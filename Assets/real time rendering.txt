




"""
    平面表 
示π：n·x +d =0并包含其数学公式，平面法线n和标量d。法线 
是描述平面面向的方向的向量。更一般地 （例如，对于弯曲表面）， 
法线描述了表面上的特定点的该方向。对于平面，同样的法线恰好 
----------------------- Page 26-----------------------
适用于其所有点。π是平面的常用数学符号。据说平面π将空间划分 
为正半空间，其中n·x +d>0，负半空间，其中n·x +d <0。所有 
其他点据说都位于平面。
    三角形可以由三个点v0，v1定义，和v2 
并用△v0v1v2表示。
    表 1.2列出了一些额外的数学运算符及其表示 
法。点，交叉，行列式和长度运算符在realtimerendering.com的 
可下载线性代数附录中进行了解释。转置运算符将列向量转换为行 
向量，反之亦然。因此，列向量可以以压缩形式写入文本块中，如 
v = （vxvyvz）T。在GraphicsGems IV[735]中引入的运算符4 
是二维向量上的一元运算符。让 1.2。符号和定义7运算符说明 1：·点 
积2：×叉积3：矢量v4的vT转置：⊥一元，perp点积运算符5： 
|·|矩阵6的行列式：|·|标量7的绝对值：参数8的k·k长度（或 
范数）：x +钳位x到09：x +夹紧x介于0和 1之间 10：n！阶 
乘 11：nk！二项式系数表1.2。一些数学运算符的表示法。这个算 
子在向量v = （vxvy）上工作，T给出一个垂直于v的向量，即v 
⊥= （.vyvx）T。我们使用|a |表示标量a的绝对值，而|A |表示 
标量a的绝对值表示矩阵A的行列式。有时，我们也使用|A | =| 
abc | =det （a，b，c），其中a，b和c是矩阵A的列向量。运 
算符8和9是钳位算子，通常用于着色计算。运算符8将负值钳位 
到0：x += （x，如果x> 0,0，否则，（1.3）和运算符9钳制0 
到 1之间的值：x +=..... 1，如果x≥1，x ，如果0 <x<1,0，否 
则。 （1.4）第十个运算符factorial定义如下，并注意0！=1：n！ 
=n （n.1） （n。2）···3·2·1. （1.5）第 11个算子，二项式因子，定 
----------------------- Page 27-----------------------
义如公式 1.6所示：是吗？=n！k！ （n。k）！。 （1.6）81.引言 
函数说明1：atan2 （y，x）双值反正切2：log （n）n的自然对数 
n表 1.3。一些专业数学函数的表示法。接下来，我们将公共平面称 
为x =0，y =0，并且z =0坐标平面或轴对齐平面。轴ex= （10 
0）T，ey = （0 10）T和ez = （00 1）T称为主轴或主方向，分 
别称为x轴，y轴和z-轴。这组轴通常称为标准基础。除非另有说 
明，否则我们将使用正交基（由相互垂直的单位向量组成）。包含 
a和b以及中间所有数字的范围的表示法是[a，b]。如果我们想要a 
和b之间的所有数字，而不是a和b本身，那么我们写（a，b）。 
也可以进行这些的组合，例如，[a，b）表示a和 b之间的所有数 
字，包括a但不包括 b。C-math函数atan2 （y，x）经常在本文 
中使用，因此值得注意。它是数学函数arctan （x）的扩展。它们 
之间的主要区别在于。2 <arctan （x）<？2，即0≤atan2 （y，x） 
<2π，并且在后一个函数中添加了一个额外的参数。arctan的一个 
常见用途是计算arctan （y/x），但是当x =0时，会得到除以零 
的结果。atan2 （y，x）的额外参数避免了这种情况。在该卷中， 
符号log （n）总是表示自然对数loge （n），而不是基数-10对数， 
log10 （n）。我们使用右手坐标系，因为这是计算机图形领域中三 
维几何的标准系统。颜色由三元素矢量表示，例如（红色，绿色， 
蓝色），其中每个元素的范围为[0,1]。1.2.2几何定义几乎所有图形 
硬件使用的基本渲染图元（也称为图形图元）是点，线和三角形.1 
在本书中，我们将几何实体的集合称为模型或对象。场景是模型的 
----------------------- Page 28-----------------------
集合，包括要渲染的环境中包含的所有内容。场景还可以包括材料 
描述，照明和查看规范。物体的例子是汽车，建筑物，甚至是线。 
在实践中，一个对象通常由一组绘图基元组成，但情况可能并非总 
是如此;一个物体可能有更高类型的几何表示，例如B'ezier曲线或 
1我们所知道的唯一例外是可以绘制球体的 Pixel-Planes [502]和 
可以绘制椭球的 NVIDIANV1芯片。1.2。符号和定义9曲面或细 
分曲面。此外，对象可以包括其他对象，例如，汽车对象包括四个 
门对象，四个轮对象等。1.2.3着色遵循完善的计算机图形使用，在 
本书中，术语 “着色”， “着色器”和相关词语用于指代两个截然 
不同但相关的概念：计算机生成的视觉外观 （例如， “着色”模型， 
 “”阴影方程，“”toon着色 “）或渲染系统的可编程组件 （例如，” 
顶点着色器 “，”着色语言 “）。在这两种情况下，从上下文中应 
该清楚预期的含义。进一步阅读和资源我们可以为您推荐的最重要 
的资源是本书的网站：realtimerendering.com。它包含指向与每 
章相关的最新信息和网站的链接。实时渲染领域正在以实时速度发 
生变化。在本书中，我们试图将重点放在基本概念和不太可能过时 
的技术上。在网站上，我们有机会提供与当今软件开发人员相关的 
信息，我们有能力使其保持最新状态。第2章图形渲染管道 “链条 
并不比它最薄弱的环节强。 “- 匿名本章介绍了实时图形的核心组 
件，即图形渲染管道，也简称为”管道 “。管道的主要功能是生成 
或渲染二维图像，给定虚拟相机，三维物体，光源等。因此，渲染 
管道是实时渲染的基础工具。使用管道的过程如图2.1所示。图像 
----------------------- Page 29-----------------------
中对象的位置和形状由其几何形状，环境特征以及相机在该环境中 
的位置决定。对象的外观受材料属性，光源，纹理（应用于曲面的 
图像）和着色方程的影响。图2.1。在左图中，虚拟相机位于金字塔 
的顶端（四条线会聚）。仅渲染视图体积内的基元。对于以透视方 
式渲染的图像（如此处的情况），视图体积是平截头体（复数：截 
头体），即具有矩形底部的截棱锥。右图显示了相机 “看到的内容”。 
请注意，左图中的红色圆环形状不在右侧渲染中，因为它位于视锥 
体外。此外，左图像中的扭曲蓝色棱镜被夹在平截头体的顶平面上。 
11122.图形渲染管道我们将解释渲染管道的不同阶段，重点是功 
能而不是实现。应用这些阶段的相关细节将在后面的章节中介绍。2。 
1建筑在物理世界中，管道概念以许多不同的形式表现出来，从工 
厂装配线到快餐厨房。它也适用于图形渲染。管道由若干阶段[715] 
组成，每个阶段执行较大任务的一部分。流水线阶段并行执行，每 
个阶段取决于前一阶段的结果。理想情况下，非流水线系统然后被 
分成n个流水线级，可以提供n倍的加速。性能的提高是使用流水 
线操作的主要原因。例如，一系列人可以快速准备大量的三明治 - 
一个准备面包，另一个添加肉，另一个添加浇头。每个都将结果传 
递给下一个人，并立即开始下一个三明治的工作。如果每个人花费 
20秒来执行他们的任务，则每20秒，每分钟三次，最大速率可以 
是一个三明治。管道阶段并行执行，但它们会停止，直到最慢的阶 
段完成其任务。例如，假设肉类添加阶段变得更加复杂，需要 30 
秒。现在，最好的速度是一分钟两个三明治。对于这种特殊的管道， 
----------------------- Page 30-----------------------
肉类阶段是瓶颈，因为它决定了整个生产的速度。据说浇头阶段在 
等待肉类阶段完成时也会被饥饿（也是顾客）。这种管道结构也可 
以在实时计算机图形学的背景下找到。将实时渲染管道粗略划分为 
四个主要阶段 - 应用程序，几何处理，光栅化和像素处理 - 如图 
2.2所示。这种结构是渲染管道的核心 - 用于实时计算机图形应用， 
因此是应用几何处理光栅化像素处理的基础图2.2。渲染管道的基本 
构造，包括四个阶段：应用程序，几何处理，光栅化和像素处理。 
这些阶段中的每一个可以是管道本身，如几何处理阶段下面所示， 
或者阶段可以（部分）并行化，如像素处理阶段下面所示。在此图 
示中，应用程序阶段是单个进程，但此阶段也可以是流水线或并行 
化的。注意，光栅化找到基元内的像素，例如三角形。2.2。后续章 
节中的应用阶段 13讨论。这些阶段中的每一个通常都是管道本身， 
这意味着它由几个子阶段组成。我们区分这里显示的功能阶段和它 
们的实现结构。功能阶段有一定的任务要执行，但没有指定任务在 
管道中执行的方式。给定的实现可以将两个功能阶段组合成一个单 
元或者使用可编程核执行，同时将另一个更耗时的功能阶段划分为 
多个硬件单元。渲染速度可以以每秒帧数（FPS）表示，即，每秒 
渲染的图像的数量。它也可以用赫兹（Hz）表示，它只是1/秒的 
符号，即更新的频率。通常只需要以毫秒 （ms）表示渲染图像所需 
的时间。生成图像的时间通常会有所不同，具体取决于每帧期间执 
行的计算的复杂程度。每秒帧数用于表示特定帧的速率，或表示某 
个使用持续时间内的平均性能。赫兹用于硬件，例如显示器，其被 
----------------------- Page 31-----------------------
设置为固定速率。顾名思义，应用程序阶段由应用程序驱动，因此 
通常在运行在通用CPU上的软件中实现。这些CPU通常包括多个 
内核，这些内核能够并行处理多个执行线程。这使CPU能够有效地 
运行应用程序阶段负责的各种任务。传统上在CPU上执行的一些任 
务包括碰撞检测，全局加速算法，动画，物理模拟以及许多其他任 
务，具体取决于应用程序的类型。下一个主要阶段是几何处理，它 
处理变换，投影和所有其他类型的几何处理。这个阶段计算要绘制 
的内容，应该如何绘制，以及绘制的位置。几何级通常在包含许多 
可编程内核以及固定操作硬件的图形处理单元（GPU）上执行。光 
栅化阶段通常将三个顶点作为输入，形成三角形，并找到在该三角 
形内部考虑的所有像素，然后将这些像素转发到下一个阶段。最后， 
像素处理级每个像素执行一个程序以确定其颜色，并且可以执行深 
度测试以查看它是否可见。它还可以执行每像素操作，例如将新计 
算的颜色与先前颜色混合。光栅化和像素处理阶段也完全在GPU上 
处理。所有这些阶段及其内部管道将在接下来的四个部分中讨论。 
有关GPU如何处理这些阶段的更多详细信息，请参阅第3章.2.2应 
用程序阶段开发人员可以完全控制应用程序阶段发生的事情，因为 
它通常在CPU上执行。因此，开发人员可以完全确定实现，并可以 
在以后修改它以提高性能。此处的更改也会影响后续阶段的性能。 
例如，应用程序 142.图形渲染管道阶段算法或设置可以减少要渲染 
的三角形的数量。所有这些说，一些应用程序工作可以由GPU执行， 
使用称为计算着色器的单独模式。此模式将GPU视为高度并行的通 
----------------------- Page 32-----------------------
用处理器，忽略了专门用于渲染图形的特殊功能。在应用阶段结束 
时，要渲染的几何体被馈送到几何处理阶段。这些是渲染基元，即 
点，线和三角形，最终可能最终出现在屏幕上（或者正在使用的任 
何输出设备）。这是应用阶段最重要的任务。基于软件的这一阶段 
实施的结果是它没有分为子阶段，几何处理，光栅化和像素处理阶 
段也是如此。但是，为了提高性能，这个阶段通常在几个处理器内 
核上并行执行。在CPU设计中，这被称为超标量结构，因为它能够 
在同一阶段同时执行多个进程。第18.5节介绍了使用多个processo 
的各种方法核心。在该阶段通常实施的一个过程是碰撞检测。在两 
个对象之间检测到碰撞之后，可以生成响应并将其发送回碰撞对象 
以及力反馈设备。应用程序阶段也是处理来自其他来源 （例如键盘， 
鼠标或头戴式显示器）的输入的地方。根据此输入，可以采取几种 
不同的操作。此处还实现了加速算法，例如特定的剔除算法 （第 19 
章），以及管道其余部分无法处理的任何其他算法。2.3几何处理 
GPU上的几何处理阶段负责大多数每三角形和每顶点操作。这个阶 
段进一步分为以下功能阶段：顶点着色，投影，剪裁和屏幕映射 （图 
2.3）。顶点投影剪切着色屏幕映射图2.3。几何处理阶段分为功能 
阶段的管道。1由于CPU本身的管道规模要小得多，你可以说应用 
程序阶段进一步细分为几个管道阶段，但这与此无关。2.3。几何处 
理 152.3.1顶点着色顶点着色有两个主要任务，即计算顶点的位置 
并评估程序员可能想要作为顶点输出数据的任何内容，例如法线和 
纹理坐标。传统上，通过将光应用于每个顶点的位置和法线并且仅 
----------------------- Page 33-----------------------
在顶点处存储所得到的颜色来计算对象的大部分阴影。然后在三角 
形上插入这些颜色。出于这个原因，这个可编程顶点处理单元被命 
名为顶点着色器[1049]。随着现代GPU的出现，以及每个像素发生 
的部分或全部阴影，这个顶点着色阶段更加通用，根据程序员的意 
图，可能根本不评估任何着色方程。顶点着色器现在是一个更通用 
的单元，专用于设置与每个顶点关联的数据。例如，顶点着色器可 
以使用第4.4节和第4.5节中的方法为对象设置动画。我们首先描 
述如何计算顶点位置，一组始终需要的坐标。在前往屏幕的途中， 
模型被转换为几个不同的空间或坐标系。最初，模型存在于自己的 
模型空间中，这只是意味着它根本没有被改变。每个模型都可以与 
模型转换相关联，以便可以定位和定向。可以将多个模型变换与单 
个模型相关联。这允许相同模型的多个副本（称为实例）在同一场 
景中具有不同的位置，方向和大小，而不需要复制基本几何。它是 
由模型变换转换的模型的顶点和法线。对象的坐标称为模型坐标， 
并且在将模型变换应用于这些坐标之后，该模型被称为位于世界坐 
标或世界空间中。世界空间是独一无二的，在模型经过各自的模型 
转换后，所有模型都存在于同一空间中。如前所述，只渲染相机 （或 
观察者）看到的模型。相机具有世界空间和方向的位置，用于放置 
和瞄准相机。为了便于投影和剪裁，使用视图变换对相机和所有模 
型进行变换。视图变换的目的是将相机放置在原点并对其进行瞄准， 
使其看向负z轴方向，y轴指向上方，x轴指向右方。我们使用.z轴 
惯例;有些文本更喜欢向下看+z轴。差异主要是语义上的，因为一 
----------------------- Page 34-----------------------
个和另一个之间的转换很简单。应用视图转换后的实际位置和方向 
取决于底层应用程序编程接口 （API）。这样描绘的空间称为相机空 
间，或更常见的是视空间或眼睛空间。视图变换影响相机和模型的 
方式示例如图2.4所示。模型变换和视图变换都可以实现为4×4矩 
阵，这是第4章的主题。但是，重要的是要认识到 162.图形渲染管 
道yx zcxc世界空间视图空间图2.4。在左图中，自上而下的视图 
显示了在+z轴向上的世界中，按照用户的需要定位和定向的摄像 
机。视图变换重新定向世界，使摄像机位于原点，沿着负Z轴观察， 
相机的+y轴向上，如右图所示。这样做是为了使剪切和投影操作 
更简单，更快速。浅蓝色区域是视图体积。这里，假设透视观察， 
因为视图体积是平截头体。类似的技术适用于任何类型的投影。可 
以用程序员喜欢的任何方式计算顶点的位置和法线。接下来，我们 
描述顶点着色的第二种输出类型。要生成逼真的场景，仅渲染对象 
的形状和位置是不够的，但也必须对其外观进行建模。此描述包括 
每个对象的材质，以及任何光源照射在对象上的效果。材料和灯光 
可以通过多种方式建模，从简单的颜色到精细的物理描述表示。确 
定光对材料的影响的这种操作称为阴影。它涉及在对象的各个点处 
计算着色方程。通常，这些计算中的一些在几何处理期间在模型的 
顶点上执行，而其他计算可以在每像素处理期间执行。可以在每个 
顶点处存储各种材料数据，例如点的位置，法线，颜色或评估着色 
方程所需的任何其他数字信息。然后将顶点着色结果 （可以是颜色， 
矢量，纹理坐标以及任何其他类型的着色数据）发送到光栅化和像 
----------------------- Page 35-----------------------
素处理阶段以进行插值并用于计算表面的阴影。本书更深入地讨论 
了GPU顶点着色器形式的顶点着色，尤其是第3章和第 5章。作 
为顶点着色的一部分，渲染系统执行投影然后剪切，将视图体积转 
换为单位立方体极值点在（.1，.1，.1）和（1,1,1）。可以使用和 
定义相同体积的不同范围，例如，0≤z≤1。单位立方体称为规范视 
图体积。首先进行投影，然后在GPU上通过顶点着色器完成投影。 
有两种常用的投影方法，即正交（也称平行）2.3。几何处理17图 
2.5。左边是正交或平行的投影;右边是透视投影。和透视投影。见 
图2.5。事实上，正字法只是一种平行投影。其他几种用途，特别是 
在建筑领域，例如倾斜和轴测投影。旧的街机游戏Zaxxon以后者 
命名。请注意，投影表示为矩阵（第4.7节），因此有时可以将其 
与几何变换的其余部分连接起来。正交观看的视图体积通常是矩形 
框，并且正投影将该视图体积变换为单位立方体。正交投影的主要 
特征是平行线在变换后保持平行。此转换是转换和缩放的组合。透 
视投影有点复杂。在这种类型的投影中，物体距离相机越远，投影 
后显得越小。此外，平行线可以会聚在地平线上。因此，透视变换 
模仿了我们感知物体大小的方式。在几何上，视图体积称为平截头 
体，是具有矩形底部的截棱锥。截锥体被转换 182.图形渲染管道也 
被转换为单位立方体。正交和透视变换都可以用4×4矩阵构建 （第 
4章），并且在任一变换之后，模型被称为剪辑坐标。这些实际上 
是齐次坐标，在第4章中讨论，因此这在w 除以之前发生。GPU 
的顶点着色器必须始终输出此类型的坐标，以便下一个功能阶段（剪 
----------------------- Page 36-----------------------
切）正常工作。虽然这些矩阵将一个卷转换为另一个卷，它们被称 
为投影，因为在显示之后，z坐标不会存储在生成的图像中，而是 
存储在z缓冲区中，如第2.5节所述。通过这种方式，模型从三维 
到二维投影。2.3.2可选的顶点处理每个管道都有刚才描述的顶点处 
理。完成此处理后，可以按顺序在GPU上执行一些可选阶段：曲面 
细分，几何体着色和流输出。它们的使用取决于硬件的能力 - 并非 
所有GPU都具有它们 - 以及程序员的期望。它们彼此独立，并且 
通常它们不常用。第3章将对每一个进行更多说明。第一个可选阶 
段是曲面细分。想象一下，你有一个弹跳球对象。如果用一组三角 
形表示它，则可能会遇到质量或性能问题。你的球可能在5米外看 
起来很好，但近距离的单个三角形，特别是沿着轮廓，变得可见。 
如果你用更多三角形制作球以提高质量，那么当球距离很远并且屏 
幕上只覆盖几个像素时，你可能会浪费大量的处理时间和记忆。通 
过曲面细分，可以生成具有适当数量的三角形的曲面。我们已经讨 
论了三角形，但到目前为止，我们刚刚处理了顶点。这些可用于表 
示点，线，三角形或其他对象。顶点可用于描述弯曲表面，例如球。 
这样的表面可以由一组贴片指定，每个补丁都是由一组顶点组成的。 
曲面细分阶段由一系列阶段本身组成 - 船体着色器，曲面细分器和 
域着色器 - 将这些贴片顶点集转换为 （通常）较大的顶点集，然后 
用于制作新的三角形集。场景的摄像机可用于确定生成三角形的数 
量：补丁关闭时很多，远处时很少。下一个可选阶段是几何着色器。 
此着色器早于曲面细分着色器，因此更常见于GPU上。它就像曲面 
----------------------- Page 37-----------------------
细分着色器一样，它采用各种各样的基元并可以生成新的顶点。这 
是一个更简单的阶段，因为这种创建的范围有限，输出原语的类型 
更加有限。几何着色器有几种用途，最受欢迎的是粒子生成之一。 
想象一下模拟烟花爆炸。2.3。几何处理 19每个火球可以由一个点， 
一个顶点表示。几何着色器可以获取每个点并将其转换为面向查看 
器并覆盖多个像素的正方形（由两个三角形组成），从而为我们提 
供更具说服力的基元。最后一个可选阶段称为流输出。这个阶段让 
我们将GPU用作几何引擎。我们可以选择将这些顶点输出到数组以 
进行进一步处理，而不是将我们处理过的顶点向下传送到管道的其 
余部分以呈现给屏幕。这些数据可以在以后的过程中由CPU或GPU 
本身使用。此阶段通常用于粒子模拟，例如我们的烟花示例。这三 
个阶段按此顺序 - 曲面细分，几何着色和流输出执行 - 每个都是 
可选的。无论使用哪个（如果有的话）选项，如果我们继续沿着管 
道继续下行，我们会有一组具有齐次坐标的顶点，将检查相机是否 
查看它们。2.3.3剪切只需要将全部或部分在视图体内的图元传递到 
光栅化阶段 （以及后续的像素处理阶段），然后在屏幕上绘制它们。 
完全位于视图卷内的基元将按原样传递到下一个阶段。完全在视图 
卷之外的基元不会被进一步传递，因为它们不会被渲染。它是部分 
位于视图体内需要剪切的基元。例如，应该在视图体积内剪切一个 
顶点外部和一个顶部视线体积的线，以便外部的顶点被位于线和视 
图体积交叉点的新顶点替换。投影矩阵的使用意味着变换的图元被 
剪切在单位立方体上。在裁剪之前执行视图变换和投影的优点是它 
----------------------- Page 38-----------------------
使裁剪问题一致;基元总是被剪切到单元立方体。剪切过程如图2.6 
所示。除了视图体积的六个剪切平面之外，用户还可以定义额外的 
剪切平面以可视地切割对象。显示此类可视化的图像称为切片，如 
图19.1在818页所示。剪切步骤使用由投影产生的4值齐次坐标 
来执行剪切。值通常不会在透视空间中的三角形上线性插值。需要 
第四个坐标，以便在使用透视投影时正确插值和剪裁数据。最后， 
执行透视分割，其将得到的三角形的位置放置到三维标准化设备坐 
标中。如前所述，此视图的范围从（.1，.1，.1）到（1,1,1）。几 
何阶段的最后一步是从此空间转换为窗口坐标。202.图形渲染管道 
图2.6。在投影变换之后，仅需要单位立方体内的基元 （对应于视锥 
体内的基元）来继续处理。因此，单元立方体外的基元被丢弃，并 
且保留了完全内部的基元。与单位立方体相交的图元将与单位立方 
体相对，因此会生成新顶点并丢弃旧顶点。2.3.4屏幕映射只有视图 
体内的（剪切的）基元传递到屏幕映射阶段，进入此阶段时坐标仍 
然是三维的。每个图元的x和y坐标被变换以形成屏幕坐标。屏幕 
坐标和z坐标也称为窗口坐标。假设场景应该被渲染成一个窗口， 
其最小角落在（x1，y1），最大角落在（x2，y2），其中x1 <x2 
和y1 <y2。然后屏幕映射是转换，然后是缩放操作。新的x和y坐 
标被称为屏幕坐标。z坐标 OpenGL（ 的[.1，+1]和 DirectX的[0,1]） 
也映射到[z1，z2]，其中z1 =0且z2 =1作为默认值。但是，这 
些可以通过API进行更改。窗口坐标以及此重新映射的z值将传递 
到光栅化器阶段。屏幕映射过程如图2.7所示。图2.7。在投影变换 
----------------------- Page 39-----------------------
之后，图元位于单位立方体中，并且屏幕映射过程负责在屏幕上找 
到坐标。2.4。光栅化21接下来，我们将描述整数和浮点值如何与 
像素（和纹理坐标）相关。给定水平像素阵列并使用笛卡尔坐标， 
最左侧像素的左边缘在浮点坐标中为0.0。OpenGL一直使用这种 
方案，DirectX10及其后继者使用它。该像素的中心为0.5。因此， 
一系列像素[0,9]覆盖[0.0,10.0]的跨度。转换只是d =floor （c）， 
 （2.1）c=d+0.5， （2.2）其中d是像素的离散 （整数）索引，c 
是像素内的连续（浮点）值。虽然所有API的像素位置值都从左向 
右增加，但在OpenGL和 DirectX.2之间的某些情况下，顶部和底 
部边缘的零位置不一致.OpenGL始终支持笛卡尔系统，将左下角视 
为最低值元素，而DirectX有时将左上角定义为此元素，具体取决 
于上下文。每个都有一个逻辑，在它们不同的地方没有正确的答案。 
举个例子， （0，0）位于OpenGL中图像的左下角，而左上角则是 
DirectX。从一个API移动到另一个API时，这种差异很重要。2.4 
光栅化给定变换和投影顶点及其相关的着色数据（全部来自几何处 
理），下一阶段的目标是找到所有像素 - 图像元素的短 - 在图元 
内部，例如三角形，被渲染。我们称这个过程为栅格化，它被分成 
两个功能子阶段：三角形设置（也称为基本组件）和三角形遍历。 
这些显示在图2.8的左侧。请注意，这些也可以处理点和线，但由 
于三角形是最常见的，因此子站的名称中包含 “三角形”。光栅化， 
也称为扫描转换，因此，从屏幕空间中的二维顶点转换 - 每个顶点 
具有z值 （深度值）和与屏幕上的每个顶点相关联的各种阴影信息。 
----------------------- Page 40-----------------------
光栅化也可以被认为是几何处理和像素处理之间的同步点，因为在 
这里三角形由三个顶点形成并最终向下发送到像素处理。是否认为 
三角形与像素重叠取决于您如何设置GPU的管道。例如，您可以使 
用点采样来确定2 “Direct3D”是 DirectX的三维图形API组件。 
DirectX包括其他API元素，例如输入和音频控件。在讨论此特定 
API 时，不是区分编写 “DirectX”和讨论此特定 API 时的 
 “Direct3D”，而是通过编写 “DirectX”来遵循常用用法。222. 
图形渲染管道三角形合并设置三角形遍历像素着色}光栅化}像素处 
理图2.8。左：光栅化分为两个功能阶段，称为三角形设置和三角形 
遍历。右：像素处理分为两个功能阶段，即像素处理和合并。 “内 
部性。”最简单的情况是在每个像素的中心使用单个点样本，因此 
如果该中心点在三角形内部，则相应的像素也被认为是在三角形内 
部。您还可以使用超级采样或多重采样抗锯齿技术在每个像素中使 
用多个样本（第 5.4.2节）。另一种方法是使用保守的光栅化，其 
定义是如果像素的至少一部分与三角形重叠，则像素在三角形 “内 
部” （第23.1.2节）。2.4.1三角形设置在此阶段，计算三角形的 
差分，边缘方程和其他数据。这些数据可用于三角形遍历 （第2.4.2 
节），也可用于插入由几何阶段产生的各种着色数据。固定功能硬 
件用于此任务。2.4.2三角形遍历这里检查三角形覆盖其中心 （或样 
本）的每个像素，并为与三角形重叠的像素部分生成一个片段。更 
详细的采样方法可以在5.4节中找到。查找三角形内的哪些样本或 
像素通常称为三角遍历。使用在三个三角形顶点之间插入的数据生 
----------------------- Page 41-----------------------
成每个三角形片段的属性（第 5章）。这些属性包括片段的深度， 
以及几何阶段的任何着色数据。麦科马克等人。[1162]提供有关三 
角形遍历的更多信息。这里也是对三角形进行透视校正插值[694] 
 （第23.1.1节）。然后将基元内的所有像素或样本发送到像素处理 
阶段，如下所述。2.5像素处理此时，由于所有先前阶段的组合，已 
经发现在三角形或其他基元内考虑的所有像素。2.5。像素处理23 
像素处理阶段分为像素着色和合并，如图2.8右侧所示。像素处理 
是对基元内的像素或样本执行每像素或每样本计算和操作的阶段。 
2.5.1像素着色此处执行任何逐像素着色计算，使用插值着色数据作 
为输入。最终结果是一个或多个颜色传递到下一个阶段。与三角设 
置和遍历阶段（通常由专用的硬连线硅执行）不同，像素着色阶段 
由可编程GPU核心执行。为此，程序员为像素着色器 （或碎片着色 
器，如OpenGL中已知）提供程序，该程序可包含任何所需的计算。 
这里可以采用多种技术，其中最重要的技术之一是纹理化。在第6 
章中更详细地处理纹理。简单地说，纹理化对象意味着将一个或多 
个图像 “粘合”到该对象上，用于各种目的。图2.9描述了这个过 
程的一个简单例子。图像可以是一维，二维或三维，其中二维图像 
是最常见的。最简单的是，最终产品是每个片段的颜色值，并将它 
们传递给下一个子阶段。图2.9。左上方显示了没有纹理的龙模型。 
图像纹理中的碎片被 “粘在”龙上，结果显示在左下角。242.图形 
渲染管道2.5.2合并每个像素的信息存储在颜色缓冲区中，颜色缓 
冲区是一个矩形颜色数组（每种颜色的红色，绿色和蓝色分量）。 
----------------------- Page 42-----------------------
合并阶段的责任是将像素着色阶段产生的碎片颜色与当前存储在缓 
冲区中的颜色相结合。此阶段也称为 ROP，代表 “光栅操作 （管道）” 
或 “渲染输出单元”，具体取决于您询问的对象。与着色阶段不同， 
执行此阶段的GPU子单元通常不是完全可编程的。但是，它具有高 
度可配置性，可实现各种效果。此阶段还负责解决可见性问题。这 
意味着当整个场景被渲染时，颜色缓冲区应包含场景中从相机视角 
可见的基元颜色。对于大多数甚至所有图形硬件，这都是通过z缓 
冲区（也称为深度缓冲区）算法[238]完成的。z缓冲区与颜色缓冲 
区的大小和形状相同，并且对于每个像素，它将z值存储到当前最 
接近的基元。这意味着当将图元渲染到某个像素时，正在计算该像 
素处的该图元上的z值，并将其与同一像素处的z缓冲区的内容进 
行比较。如果新的z值小于z缓冲区中的z值，则正在渲染的图元 
比先前在该像素处最接近相机的图元更靠近相机。因此，使用正在 
绘制的图元的z值和颜色更新该像素的z值和颜色。如果计算的z 
值大于z缓冲区中的z值，则颜色缓冲区和z缓冲区保持不变。z 
缓冲区算法很简单，具有O （n）收敛（其中n是正在渲染的图元 
的数量），并且适用于可以为每个（相关）像素计算z值的任何绘 
图基元。另请注意，此算法允许以任何顺序呈现大多数基元，这是 
其受欢迎的另一个原因。但是，z-buffer仅在屏幕上的每个点存储 
单个深度，因此不能用于部分透明的基元。这些必须在所有不透明 
基元之后呈现，并且按照从前到后的顺序呈现，或使用单独的与订 
单无关的算法（第5.5节）。透明度是基本z缓冲区的主要弱点之 
----------------------- Page 43-----------------------
一。我们已经提到颜色缓冲区用于存储颜色，z缓冲区存储每个像 
素的z值。但是，还有其他通道和缓冲区可用于过滤和捕获片段信 
息。Alpha通道与颜色缓冲区相关联，并为每个像素存储相关的不 
透明度值（第 5.5节）。在较旧的API 中，alpha通道还用于通过 
alpha测试功能选择性地丢弃像素。现在可以将丢弃操作插入到像 
素着色器程序中，并且可以使用任何类型的计算来触发丢弃。这种 
类型的测试可用于确保完全透明的片段不会影响z缓冲区（第6.6 
节）。模板缓冲区是一个屏幕外缓冲区，用于记录渲染图元的位置。 
它通常包含每像素8位。可以使用各种函数将基元渲染到模板缓冲 
区中，然后可以将缓冲区的内容用于2.6。通过 Pipeline25控制渲 
染到颜色缓冲区和z缓冲区。例如，假设已填充的圆圈已被绘制到 
模板缓冲区中。这可以与操作符组合，该操作符允许仅在存在圆的 
情况下将后续基元渲染到颜色缓冲区中。模板缓冲区可以是生成一 
些特殊效果的强大工具。管道末端的所有这些功能称为光栅操作 
 （ROP）或混合操作。可以将当前在颜色缓冲器中的颜色与在三角 
形内处理的像素的颜色混合。这可以实现诸如透明度或颜色样本的 
累积之类的效果。如上所述，混合通常可使用API​ ​ 进行配置， 
而不是完全可编程的。但是，某些API支持栅格顺序视图，也称为 
像素着色器排序，它支持可编程混合功能。帧缓冲区通常由系统上 
的所有缓冲区组成。当图元到达并通过光栅化器阶段时，从摄像机 
视角可见的图像将显示在屏幕上。屏幕显示颜色缓冲区的内容。为 
了避免允许人类观察者在被光栅化并将其发送到屏幕时看到基元， 
----------------------- Page 44-----------------------
使用双缓冲。这意味着场景的渲染在屏幕上，在后台缓冲区中进行。 
在后缓冲区中渲染场景后，后缓冲区的内容将与先前在屏幕上显示 
的前缓冲区的内容交换。交换经常发生在垂直回扫期间，这是安全 
的。有关不同缓冲区和缓冲方法的更多信息，请参见第5.4.2节， 
第23.6节和第23.7节。2.6通过管道点，线和三角形是构建模型或 
对象的渲染基元。想象一下，该应用程序是一个交互式计算机辅助 
设计 （CAD）应用程序，并且用户正在检查华夫饼机制造商的设计。 
在这里，我们将通过整个图形渲染管道遵循此模型，包括四个主要 
阶段：应用程序，几何，光栅化和像素处理。场景通过透视渲染到 
屏幕上的窗口中。在这个简单的例子中，华夫饼机模型包括两条线 
 （显示部件的边缘）和三角形（显示表面）。华夫饼机有一个可以 
打开的盖子。一些三角形由具有制造商徽标的二维图像纹理化。对 
于此示例，除了在栅格化阶段中发生的纹理应用之外，在几何阶段 
完全计算表面着色。应用程序CAD应用程序允许用户选择和移动模 
型的各个部分。例如，用户可以选择盖子，然后移动鼠标将其打开。 
应用程序阶段必须将鼠标移动转换为相应的旋转矩阵，然后查看26 
2。图形渲染管道在渲染时，此矩阵正确应用于盖子。另一个例子： 
播放动画，沿预定路径移动摄像机，以显示不同视图的华夫饼干制 
造商。然后，应用程序必须根据时间更新摄像机参数，例如位置和 
视图方向。对于要渲染的每个帧，应用程序阶段将模型的摄像机位 
置，光照和基元提供给管道中的下一个主要阶段 - 几何阶段。几何 
处理对于透视查看，我们假设应用程序提供了投影矩阵。此外，对 
----------------------- Page 45-----------------------
于每个对象，应用程序已经计算了一个矩阵，该矩阵描述了视图变 
换以及对象本身的位置和方向。在我们的例子中，华夫饼干制造商 
的基座将有一个矩阵，盖子另一个。在几何阶段，使用此矩阵转换 
对象的顶点和法线，将对象放入视图空间。然后可以使用材料和光 
源属性来计算顶点处的阴影或其他计算。然后使用单独的用户提供 
的投影矩阵执行投影，将对象转换为表示眼睛看到的单位立方体的 
空间。多维数据集外的所有基元都将被丢弃。与该单位立方体相交 
的所有图元都会相对于立方体进行剪裁，以获得完全位于单位立方 
体内的一组图元。然后将顶点映射到屏幕上的窗口中。在执行了所 
有这些pertriangle和per-vertex操作之后，结果数据将传递到光 
栅化阶段。光栅化然后在前一阶段中存在剪切的所有基元被光栅化， 
这意味着找到基元内的所有像素并在管道中进一步向像素处理发 
送。像素处理这里的目标是计算每个可见图元的每个像素的颜色。 
已经与任何纹理（图像）相关联的那些三角形被渲染，并且根据需 
要将这些图像应用于它们。可见性通过z缓冲算法以及可选的丢弃 
和模板测试来解决。依次处理每个对象，然后在屏幕上显示最终图 
像。结论这一管道源于数十年的API和图形硬件演进，其目标是实 
时渲染应用程序。值得注意的是，这不是唯一可能的渲染管道;离线 
渲染管道经历了不同的演化路径。电影制作的渲染通常是用微波管 
道[289,1734]完成的，但最近光线追踪和路径追踪已经取得了成功。 
这些2.6。通过第11.2.2节中介绍的 Pipeline27技术，也可用于 
建筑和设计预可视化。多年来，应用程序开发人员使用此处描述的 
----------------------- Page 46-----------------------
过程的唯一方法是通过使用中的图形API定义的固定功能管道。固 
定功能管道之所以如此命名是因为实现它的图形硬件包含无法以灵 
活方式编程的元素。最新的主要固定功能机器的例子是2006年推 
出的Nintendo的Wii。另一方面，可编程GPU使得可以准确地确 
定在整个流水线的各个子级中应用了哪些操作。对于本书的第四版， 
我们假设所有开发都是使用可编程GPU完成的。进一步阅读和资源 
Blinn的书 “走下图形管道”[165]是一本关于从头开始编写软件渲 
染器的旧书。它是学习实现渲染管道的一些细微之处的好资源，解 
释了剪切和透视插值等关键算法。古老的 （但经常更新的）OpenGL 
编程指南 （又名 “红皮书”）[885]提供了与其使用相关的图形管道 
和算法的全面描述。我们这本书的网站，realtimerendering.com， 
提供各种管道图的链接，渲染引擎实现等。第3章图形处理单元“显 
示器是计算机。”-Jen-HsunHuang历史上，图形加速开始于在每 
个像素扫描线上插入颜色与三角形重叠，然后显示这些值。包括访 
问图像数据的能力允许将纹理应用于表面。添加用于插值和测试z 
深度的硬件提供了内置的可见性检查。由于它们经常被使用，因此 
这些过程致力于专用硬件以提高性能。渲染管道的更多部分以及每 
个部分的更多功能都在后续世代中添加。专用图形硬件相对于CPU 
的唯一计算优势是速度，但速度至关重要。在过去的二十年中，图 
形硬件经历了令人难以置信的转变。第一款消费类图形芯片包括 
1999年推出的硬件顶点处理（NVIDIA的GeForce256）.NVIDIA 
创造了术语图形处理单元 （GPU），以区分GeForce256与之前可 
----------------------- Page 47-----------------------
用的光栅化芯片，并且它卡住了。在接下来的几年中，GPU从复杂 
的固定功能管道的可配置实现演变为高度可编程的空白板，开发人 
员可以在其中实现自己的算法。各种可编程着色器是控制GPU的主 
要手段。为了提高效率，管道的某些部分仍然是可配置的，而不是 
可编程的，但趋势是可编程性和灵活性[175]。GPU专注于一系列 
高度可并行化的任务，从而获得了极高的速度。例如，它们具有专 
用于实现z缓冲区的定制硅，快速访问纹理图像和其他缓冲区，以 
及查找哪些像素被三角形覆盖。第23章介绍了这些元素如何执行其 
功能。更早要了解的是GPU如何实现其可编程着色器的并行性。29 
303.图形处理单元第3.3节说明了着色器的功能。目前，您需要知 
道的是着色器核心是一个小型处理器，它执行一些相对孤立的任务， 
例如将顶点从其在世界中的位置转换为屏幕坐标，或计算由a覆盖 
的像素的颜色。三角形。每帧有数千或数百万个三角形被发送到屏 
幕，每秒可以有数十亿个着色器调用，即运行着色器程序的单独实 
例。首先，延迟是所有处理器都面临的问题。访问数据需要一些时 
间。考虑延迟的基本方法是信息离处理器越远，等待时间越长。第 
23.3节更详细地介绍了延迟。存储在存储器芯片中的信息访问时间 
比本地寄存器中的信息长。第18.4.1节更深入地讨论了内存访问。 
关键是等待检索数据意味着处理器停止运行，这会降低性能。3.1 
数据并行体系结构不同的处理器体系结构使用各种策略来避免停 
顿。CPU经过优化，可处理各种数据结构和大型代码库。CPU可以 
有多个处理器，但每个处理器都以大多数串行方式运行代码，有限 
----------------------- Page 48-----------------------
的SIMD向量处理是次要的例外。为了最大限度地减少延迟的影响， 
CPU的大部分芯片都包含快速本地缓存，内存中充满了接下来可能 
需要的数据。CPU还通过使用诸如分支预测，指令重新排序，寄存 
器重命名和高速缓存预取等聪明技术来避免停顿[715]GPU采用不 
同的方法。GPU的大部分芯片区域专用于大量处理器，称为着色器 
内核，通常数以千计。GPU是流处理器，其中依次处理有序的类似 
数据集。由于这种相似性 - 一组顶点或像素，例如，GPU可以以 
大规模并行方式处理这些数据。另一个重要的元素是这些调用尽可 
能独立，这样它们就不需要来自相邻调用的信息，也不需要共享可 
写存储器位置。此规则有时会被破坏以允许新的和有用的功能，但 
是这样的例外会以潜在的延迟为代价，因为一个处理器可能在另一 
个处理器上等待完成其工作。GPU针对吞吐量进行了优化，定义为 
可以处理数据的最大速率。然而，这种快速处理具有成本。由于专 
用于高速缓冲存储器和控制逻辑的芯片面积较小，每个着色器核心 
的延迟通常远高于CPU处理器遇到的延迟[462]。假设网格被栅格 
化，两千个像素有片段要处理;一个像素着色器程序将被调用两千 
次。想象一下，只有一个着色器处理器，世界上最弱的GPU。它开 
始为两千的第一个片段执行着色器程序。着色器处理器对寄存器中 
的值执行一些算术运算。寄存器是本地的，快速到3.1。数据并行架 
构31访问，因此不会发生停顿。着色器处理器然后进入诸如纹理访 
问的指令;例如，对于给定的表面位置，程序需要知道应用于网格的 
图像的像素颜色。纹理是完全独立的资源，不是像素程序的本地存 
----------------------- Page 49-----------------------
储器的一部分，并且纹理访问可能有些涉及。内存提取可能需要数 
百到数千个时钟周期，在此期间GPU处理器什么都不做。此时着色 
器处理器将停止，等待返回纹理的颜色值。为了使这个可怕的GPU 
变得更好，请为每个片段为其本地寄存器提供一点存储空间。现在， 
不是停止纹理提取，而是允许着色器处理器切换并执行另一个片段， 
即二千二。这个开关非常快，第一个或第二个片段中的任何内容都 
不会受到影响，除了注意第一个上执行的指令。现在执行第二个片 
段。与第一个相同，执行一些算术函数，然后再次遇到纹理提取。 
着色器核心现在切换到另一个片段，第三个。最终，所有两千个片 
段都以这种方式处理。此时，着色器处理器返回到第一个片段。到 
目前为止，纹理颜色已被提取并可供使用，因此着色器程序可以继 
续执行。处理器以相同的方式继续，直到遇到已知停止执行的另一 
条指令，或者程序完成。单个片段执行的时间比着色器处理器始终 
关注它的时间要长，但整个片段的整体执行时间会大大减少。在这 
种架构中，通过切换到另一个片段让GPU保持忙碌来隐藏延迟。通 
过将指令执行逻辑与数据分离，GPU进一步采用了这种设计。称为 
单指令，多数据 （SIMD），这种安排在锁定步骤中对固定数量的着 
色器程序执行相同的命令。与使用单独的逻辑和调度单元运行每个 
程序相比，SIMD的优势在于需要专门用于处理数据和切换的硅（和 
功率）相当少。将我们的两千个片段示例转换为现代GPU术语，片 
段的每个像素着色器调用称为线程。这种类型的线程与CPU线程不 
同。它包含一些用于着色器输入值的内存，以及着色器执行所需的 
----------------------- Page 50-----------------------
任何寄存器空间。使用相同着色器程序的线程被捆绑成组，由 
NVIDIA称为warp，AMD称为wavefronts。warp/ wavefront 
计划由一些GPU着色器核心执行，使用SIMD处理，从8到64位。 
每个线程都映射到 SIMD通道。假设我们有两千个线程要执行。 
NVIDIAGPU上的Warps包含32个线程。这产生2000/32=62.5 
经线，这意味着分配了63个经线，一个经线是半空的。warp的执 
行类似于我们的单GPU处理器示例。着色器程序在所有32个处理 
器上以锁定步骤执行。遇到内存提取时，所有线程同时遇到它，因 
为对所有线程执行相同的指令。获取信号表明这个线程的扭曲会停 
止，所有这些都等待它们 （不同的）结果。323.图形处理单元warp 
被替换为32个线程的不同warp，然后由32个核心执行，而不是 
停止。这种交换与我们的单处理器系统一样快，因为交换或转换 
warp时，不会触及每个线程内的数据。每个线程都有自己的寄存器， 
每个warp都会跟踪它正在执行的指令。交换一个新的warp只是 
将一组核心指向一组不同的线程来执行;没有其他开销。Warp执行 
或换出直到完成所有操作。见图3.1。在我们的简单示例中，纹理的 
内存提取延迟可能导致warp换出。实际上，由于交换成本太低， 
因此可以将warp换成较短的延迟。还有其他几种技术用于优化执 
行[945]，但是warp-swapping是所有GPU使用的主要延迟隐藏 
机制。这个过程的工作效率有几个因素。例如，如果线程很少，然 
后可以创建很少的warp，使延迟隐藏成为问题。着色器程序的结构 
是影响效率的重要特征。一个主要因素是每个线程的寄存器使用量。 
----------------------- Page 51-----------------------
在我们的示例中，我们假设一次有两千个线程都可以驻留在GPU 
上。与每个线程相关联的着色器程序所需的寄存器越多，线程越少， 
因此更少的warp可以驻留在GPU中。经线短缺可能意味着无法通 
过交换减轻摊位。居民的经线被称为 “在飞行中”，这个数字被称 
为占用率。高占用率意味着有许多可用于处理的经线，因此空闲处 
理器的可能性较小。低入住率往往会导致表现不佳。内存提取的频 
率也会影响需要隐藏的延迟量。Lauritzen[993]概述了占用者如何 
受到着色器使用的寄存器数量和共享内存的影响。Wronski 
[1911,1914]讨论了理想占用率如何根据着色器执行的操作类型而 
变化。影响整体效率的另一个因素是动态分支，由 “if”语句和循环 
引起。假设在着色器程序中遇到 “if”语句。如果所有线程都评估并 
采用相同的分支，则warp可以继续而不用担心其他分支。但是， 
如果某些线程，甚至一个线程采用备用路径，则warp必须执行两 
个分支，丢弃每个特定线程不需要的结果[530,945]。这个问题叫做 
线程分歧，其中一些线程可能需要执行循环迭代或执行warp 中其 
他线程没有的 “if”路径，在此期间让它们空闲。所有GPU都实现 
了这些架构思想，导致系统具有严格的限制，但每瓦的计算能力非 
常大。了解该系统的运行方式将有助于您作为程序员更有效地利用 
其提供的功能。在接下来的部分中，我们将讨论GPU如何实现渲染 
管道，可编程着色器如何操作以及每个GPU阶段的演变和功能。 
3.1。数据并行体系结构33狂狂狂狂 MUL MUL MUL MULTXR 
TXRTXRTXR CMPCMPCMPCMP EMTEMTEMTEMT狂狂狂 
----------------------- Page 52-----------------------
狂 MUL MUL MUL MUL TXR TXR TXR TXR CMP CMP CMP 
CMP EMT EMT EMT EMT时间着色处理器经线狂富贵逼人 MUL 
MUL MUL MUL TXR TXR TXR TXR 疯疯疯疯 MUL MUL MUL 
MULTXR TXR TXR TXR失速和交换摊位及交换摊位及交换CMP 
CMPCMPCMPEMTEMTEMTEMT处理及交换处理及交换CMP 
CMPCMPCMPEMTEMTEMTEMTCMPCMPCMPCMPEMT 
EMT EMT EMTCMP CMP CMP CMP EMT EMT EMT EMT狂狂 
狂狂 MUL MUL MUL MUL TXR TXR TXR TXR 狂狂狂狂 MUL 
MUL MUL MULTXR TXR TXR TXR 片段/线程程序：狂 multxr 
cmpemt图3.1。简化的着色器执行示例。三角形的碎片（称为线 
程）被收集到经线中。每个warp显示为四个线程，但实际上有32 
个线程。要执行的着色器程序长度为五个指令。这组四个GPU着色 
器处理器为第一个warp执行这些指令，直到在 “txr”命令上检测 
到停止条件，这需要时间来获取其数据。交换第二个warp并将着 
色器程序的前三个指令应用于它，直到再次检测到一个停顿。在交 
换第三个warp并停止后，通过交换第一个warp并继续执行继续 
执行。如果此时尚未返回其 “txr”命令的数据，则执行确实会停止， 
直到这些数据可用。每个经线依次完成。343.图形处理单元剪切顶 
点着色器屏幕映射设置＆合并三角遍历像素着色器曲面几何着色器 
图3.2。GPU实现渲染管道。根据用户对其操作的控制程度对各阶 
段进行颜色编码。绿色阶段完全可编程。虚线表示可选阶段。黄色 
阶段是可配置的但不可编程，例如，可以为合并阶段设置各种混合 
----------------------- Page 53-----------------------
模式。蓝色阶段的功能完全固定。3.2GPU流水线概述GPU实现了 
第2章中描述的概念几何处理，光栅化和像素处理流水线阶段。这 
些阶段分为几个具有不同程度可配置性或可编程性的硬件阶段。图 
3.2显示了根据可编程或可配置的颜色编码的各个阶段。请注意，这 
些物理阶段的划分方式与第2章中介绍的功能阶段略有不同。我们 
在此描述GPU的逻辑模型，即API作为程序员向您展示的模型。 
正如第 18章和第23章所讨论的那样，这个逻辑管道（物理模型） 
的实现取决于硬件供应商。可以通过向相邻可编程级添加命令在 
GPU上执行逻辑模型中固定功能的级。流水线中的单个程序可以分 
成由单独的子单元执行的元素，或者完全由单独的传递执行。逻辑 
模型可以帮助您推断影响性能的因素，但不应该误解GPU实际实现 
管道的方式。顶点着色器是完全可编程的阶段，用于实现几何处理 
阶段。几何着色器是一个完全可编程的平台，可在基元（点，线或 
三角形）的顶点上运行。它可用于执行每个基元着色操作，销毁基 
元或创建新基元。曲面细分阶段和几何着色器都是可选的，并非所 
有GPU都支持它们，尤其是在移动设备上。剪切，三角形设置和三 
角形遍历阶段由固定功能硬件实现。屏幕映射受窗口和视口设置的 
影响，内部形成简单的比例和重新定位。像素着色器阶段是完全可 
编程的。虽然合并阶段不可编程，但它具有高度可配置性，可以设 
置为执行各种操作。它实现了 “合并”功能阶段，负责修改颜色，z 
缓冲区，混合，模板和任何其他与输出相关的缓冲区。像素着色器 
与合并阶段一起执行形成了第2章中介绍的概念像素处理阶段。随 
----------------------- Page 54-----------------------
着时间的推移，GPU管道已经从硬编码操作演变为增加灵活性和控 
制。可编程着色器阶段的引入是这一发展过程中最重要的一步。下 
一节将介绍各种可编程阶段的共同特征。3.3。可编程着色器阶段 
353.3可编程着色器阶段现代着色器程序使用统一着色器设计。这 
意味着顶点，像素，几何和与曲面细分相关的着色器共享一个通用 
的编程模型。在内部，它们具有相同的指令集架构 （ISA）。实现此 
模型的处理器在 DirectX中称为公共着色器核心，具有此类核心的 
GPU据称具有统一的着色器架构。这种架构背后的想法是着色器处 
理器可用于各种角色，GPU可以根据需要分配这些角色。例如，一 
组具有小三角形的网格将需要比由两个三角形组成的大方块更多的 
顶点着色器处理。具有单独的顶点和像素着色器核心池的GPU意味 
着严格预先确定保持所有核心繁忙的理想工作分布。使用统一着色 
器核心，GPU可以决定如何平衡此负载。描述整个着色器编程模型 
超出了本书的范围，并且有很多文档，书籍和已经这样做的网站。 
着色器使用类似C的着色语言编程，例如DirectX的高级着色语言 
 （HLSL）和OpenGL着色语言（GLSL）。DirectX的HLSL可以 
编译为虚拟机字节码，也称为中间语言 （IL或 DXIL），以提供硬件 
独立性。中间表示还可以允许着色器程序被离线编译和存储。该中 
间语言由驱动程序转换为特定GPU的ISA。控制台编程通常避免使 
用中间语言步骤，因为系统只有一个ISA。基本数据类型是32位单 
精度浮点标量和向量，尽管向量只是着色器代码的一部分，并且如 
上所述在硬件中不受支持。在现代GPU上，本机也支持32位整数 
----------------------- Page 55-----------------------
和64位浮点数。浮点矢量通常包含诸如位置（xyzw），法线，矩 
阵行，颜色（rgba）或纹理坐标（uvwq）之类的数据。整数通常 
用于表示计数器，索引或位掩码。还支持聚合数据类型，例如结构， 
数组和矩阵。绘制调用调用图形API来绘制一组基元，从而使图形 
管道执行并运行其着色器。每个可编程着色器阶段都有两种类型的 
输入：均匀输入，值在整个绘制调用中保持不变（但可以在绘制调 
用之间更改），以及变化的输入，来自三角形顶点或光栅化的数据。 
例如，像素着色器可以将光源的颜色提供为均匀值，并且三角形表 
面的位置每像素改变，因此是变化的。纹理是一种特殊的均匀输入， 
曾经一直是应用于表面的彩色图像，但现在可以被认为是任何大数 
据。底层虚拟机为不同类型的输入和输出提供特殊寄存器。制服的 
可用常量寄存器数量远大于可用于不同输入或输出的寄存器数量。 
发生这种情况是因为需要为每个顶点 363单独存储变化的输入和 
输出。图形处理单元着色器虚拟机改变输入寄存器 16/16/32寄存 
器输出寄存器 16/32/8寄存器常量寄存器临时寄存器4096寄存器 
16个缓冲区4096 个寄存器纹理 128个 512纹理阵列图 3.3。 
ShaderModel4.0下的统一虚拟机架构和寄存器布局。每个资源旁 
边都会显示最大可用数量。由斜杠分隔的三个数字指的是顶点，几 
何和像素着色器的限制（从左到右）。或者像素，因此对于需要多 
少是有自然限制的。统一输入存储一次，并在绘制调用中的所有顶 
点或像素上重复使用。虚拟机还具有通用临时寄存器，用于临时空 
间。可以使用临时寄存器中的整数值对所有类型的寄存器进行数组 
----------------------- Page 56-----------------------
索引。着色器虚拟机的输入和输出如图3.3所示。在图形计算中常 
见的操作在现代GPU上有效执行。着色语言通过诸如*和+之类的 
运算符暴露这些操作中最常见的（例如加法和乘法）。其余部分通 
过内部函数公开，例如atan （），sqrt （），log （）以及针对GPU 
优化的许多其他功能。对于更复杂的操作也存在函数，例如向量归 
一化和反射，叉积，矩阵转置和行列式计算。术语流控制是指使用 
分支指令来改变代码执行的流程。与流控制相关的指令用于实现高 
级语言结构，例如 “if”和 “case”语句，以及各种类型的循环。 
着色器支持两种类型的流量控制。静态流量控制分支基于均匀输入 
的值。这意味着代码流在绘制调用上是不变的。静态流量控制的主 
要好处是允许在各种不同情况下使用相同的着色器（例如，不同数 
量的灯）。没有线程分歧，因为所有调用都采用相同的代码路径。 
动态流量控制基于不同输入的值，即每个3.4。可编程着色和API 
的演变可以不同地执行代码。这比静态流量控制更强大，但可能会 
降低成本，特别是如果代码流在着色器调用之间不规则地更改。3.4 
可编程着色和API的演变可编程着色框架的概念可以追溯到1984 
年，库克的树荫[287]。一个简单的着色器及其相应的阴影树如图 
3.4所示。RenderMan着色语言[63,1804]是在20世纪80年代后 
期从这个想法发展而来的。它现在仍然用于电影制作渲染，以及其 
他不断发展的规范，例如开放着色语言 （OSL）项目[608]。消费者 
级图形硬件于1996年10月1日由3dfxInteractive首次成功推出。 
有关今年的时间表，请参见图3.5。他们的Voodoo显卡能够以高 
----------------------- Page 57-----------------------
质量和高性能呈现Quake游戏，因此可以快速采用。该硬件实现了 
整个固定功能管道。在GPU本身支持可编程着色器之前，有几次尝 
试通过多次渲染过程实时实现可编程着色操作。Quake III：Arena 
脚本语言是第一个广泛传播** +*镜面反射分量的镜面反射分量环 
境正常视图表面粗糙度重量的环境成分铜颜色最终颜色浮动 ka = 
0.5 ，ks = 0.5; 浮点粗糙度 = 0.1; 浮动强度 ; 彩铜 = 
 （0.8,0.3,0.1）; intensity = ka * ambient （）+ ks * specular 
 （normal，view，roughness）;final_color =强度*铜; 图3.4。用 
于简单铜色着色器的树荫树及其相应的着色器语言程序。（库克之 
后[287]。）383。图形处理单元199620062018 3dfxVoodoo 
GeForce256 “GPU”DirectX8.0DX9.0SM2.0SM3.0Xbox360 
Wii，PS 3 DX 10.0 SM 4.0 DX 11.0 SM 5.0 DX 12.0 Metal 
OpenGL Vulkan ES 3.0 iPad OpenGL ES 1.0 OpenGL 1.1 
OpenGL ES 2.0 WebGL PS 4 ，Xbox One Rift，Vive Xbox 
PLAYSTATION2WebGL 2 Mantlestart图3.5。一些API和图形 
硬件版本的时间表。在本章开头提到，NVIDIA的GeForce256是 
第一款被称为GPU的硬件，但它不是可编程的。但是，它是可配置 
的。2001年初，NVIDIA的GeForce3是第一款支持可编程顶点着 
色器的GPU [1049]，通过DirectX8.0和OpenGL扩展。这些着 
色器以类似汇编的语言编程，由驱动程序在运行中转换为微码。 
DirectX8.0中还包含像素着色器，但像素着色器未达到实际可编程 
性 - 驱动程序将支持的有限 “程序”转换为纹理混合状态，而驱动 
----------------------- Page 58-----------------------
程序又将硬件 “寄存器组合器”连接在一起。这些 “程序”是不仅 
长度有限（12条指令或更少），而且缺乏重要的功能。Peercy等 
人鉴定了依赖性纹理读数和浮点数据。[1363]对于真正的可编程性 
至关重要，来自他们对 RenderMan的研究。此时着色器不允许流 
控制（分支），因此必须通过计算两个项并在结果之间选择或插值 
来模拟条件。DirectX定义了着色器模型 （SM）的概念，以区分具 
有不同着色器功能的硬件。2002年发布了DirectX9.0，包括Shader 
Model2.0，它具有真正可编程的顶点和像素着色器。在OpenGL 
下使用各种扩展也暴露了类似的功能。添加了对任意依赖纹理读取 
和 16位浮点值存储的支持，最终完成了 Peercy等人确定的一组要 
求。对着色器资源（如指令，纹理和寄存器）的限制增加了，因此 
着色器变得能够产生更复杂的效果。还增加了对流量控制的支持。 
着色器的长度和复杂性的增加使得装配编程模型变得越来越麻烦。 
幸运的是，DirectX9.0 3.4。可编程着色和API的演变39还包括 
HLSL。这种着色语言是由 Microsoft与 NVIDIA合作开发的。大约 
在同一时间，OpenGLARB （架构评审委员会）发布了GLSL，这 
是一种与OpenGL相似的语言[885]。这些语言深受C编程语言的 
语法和设计理念的影响，并包含 RenderMan着色语言中的元素。 
ShaderModel3.0于2004年推出，增加了动态流控制，使着色器 
更加强大。它还将可选功能转换为需求，进一步增加了资源限制， 
并为顶点着色器中的纹理读取添加了有限的支持。当新一代游戏机 
于2005年末 （微软的Xbox360）和2006年末 （索尼电脑娱乐的 
----------------------- Page 59-----------------------
PLAYSTATION3系统）推出时，它们配备了ShaderModel3.0级 
别的GPU。任天堂的Wii游戏机是最后一款着名的固定功能GPU 
之一，它最初于2006年底发售。纯粹的固定功能管道在这一点上 
已经很久了。着色器语言已经发展到使用各种工具来创建和管理它 
们的程度。使用Cook的树荫概念的一个这样的工具的屏幕截图如 
图3.6所示。可编程性的下一个重要步骤也接近2006年底。包含 
在 DirectX 10.0 [175]中的Shader Model4.0 引入了几个主要功 
能，例如几何着色器和流输出。ShaderModel4.0包括一个统一的 
图3.6。用于着色器设计的可视着色器图形系统。各种操作封装在功 
能框中，可在左侧选择。选中后，每个功能框都有可调参数，如右 
图所示。每个功能框的输入和输出相互链接以形成最终结果，如中 
心框架的右下方所示。（屏幕截图来自 “mentalmill”，mental 
imagesinc。）403.所有着色器 （顶点，像素和几何体）的图形处 
理单元编程模型，前面描述的统一着色器设计。资源限制进一步增 
加，并添加了对整数数据类型 （包括按位运算）的支持。在OpenGL 
3.3中引入GLSL3.30提供了类似的着色器模型。2009年，DirectX 
11和ShaderModel5.0发布，添加细分阶段着色器和计算着色器， 
也称为 DirectCompute。该版本还专注于更有效地支持CPU多处 
理，这是第 18.5节中讨论的主题。OpenGL在4.0版中添加了细分， 
在4.3 中添加了计算着色器。DirectX和OpenGL的发展方式不同。 
两者都设置了特定版本发布所需的特定级别的硬件支持。Microsoft 
控制 DirectXAPI，因此可直接与AMD，NVIDIA和 Intel等独立 
----------------------- Page 60-----------------------
硬件供应商（IHV）以及游戏开发商和计算机辅助设计软件公司合 
作，以确定要公开的功能。OpenGL由一个由非营利组织Khronos 
Group管理的硬件和软件供应商联盟开发。由于涉及的公司数量， 
在 DirectX中引入后，API功能通常会出现在OpenGL的一个版本 
中。但是，OpenGL允许扩展，特定于供应商或更通用，允许在发 
布中的官方支持之前使用最新的GPU功能。API的下一个重大变化 
是由AMD于2013年推出 MantleAPI引发的。与视频游戏开发商 
DICE合作开发，Mantle的想法是消除大部分图形驱动程序的开销， 
并直接向开发人员提供此控件。除了这种重构之外，还进一步支持 
有效的CPU多处理。这一新类别的API专注于大大减少CPU在驱 
动程序中花费的时间，以及更高效的CPU多处理器支持（第 18章）。 
在 Mantle开创的想法被 Microsof选中 OpenGL允许扩展，特定 
于供应商或更通用，允许在发布中的官方支持之前使用最新的GPU 
功能。API的下一个重大变化是由AMD于2013年推出MantleAPI 
引发的。与视频游戏开发商 DICE合作开发，Mantle的想法是消除 
大部分图形驱动程序的开销，并直接向开发人员提供此控件。除了 
这种重构之外，还进一步支持有效的CPU多处理。这一新类别的 
API专注于大大减少CPU在驱动程序中花费的时间，以及更高效的 
CPU多处理器支持（第 18章）。在 Mantle开创的想法被 Microsof 
选中OpenGL允许扩展，特定于供应商或更通用，允许在发布中的 
官方支持之前使用最新的GPU功能。API的下一个重大变化是由 
AMD于2013年推出MantleAPI引发的。与视频游戏开发商DICE 
----------------------- Page 61-----------------------
合作开发，Mantle的想法是消除大部分图形驱动程序的开销，并直 
接向开发人员提供此控件。除了这种重构之外，还进一步支持有效 
的CPU多处理。这一新类别的API专注于大大减少CPU在驱动程 
序中花费的时间，以及更高效的CPU多处理器支持（第18章）。 
在Mantle开创的想法被Microsof选中API的下一个重大变化是由 
AMD于2013年推出MantleAPI引发的。与视频游戏开发商DICE 
合作开发，Mantle的想法是消除大部分图形驱动程序的开销，并直 
接向开发人员提供此控件。除了这种重构之外，还进一步支持有效 
的CPU多处理。这一新类别的API专注于大大减少CPU在驱动程 
序中花费的时间，以及更高效的CPU多处理器支持（第18章）。 
在Mantle开创的想法被Microsof选中API的下一个重大变化是由 
AMD于2013年推出MantleAPI引发的。与视频游戏开发商DICE 
合作开发，Mantle的想法是消除大部分图形驱动程序的开销，并直 
接向开发人员提供此控件。除了这种重构之外，还进一步支持有效 
的CPU多处理。这一新类别的API专注于大大减少CPU在驱动程 
序中花费的时间，以及更高效的CPU多处理器支持（第18章）。 
在 Mantle开创的想法被 Microsof选中 除了这种重构之外，还进 
一步支持有效的CPU多处理。这一新类别的API专注于大大减少 
CPU在驱动程序中花费的时间，以及更高效的CPU多处理器支持 
 （第18章）。在 Mantle开创的想法被Microsof选中 除了这种重 
构之外，还进一步支持有效的CPU多处理。这一新类别的API专注 
于大大减少CPU在驱动程序中花费的时间，以及更高效的CPU多 
----------------------- Page 62-----------------------
处理器支持（第 18章）。在 Mantle开创的想法被 Microsof选中 
并且在2015年作为 DirectX12发布。请注意，DirectX12并不专 
注于公开新的GPU功能--DirectX11.3暴露了相同的硬件功能。这 
两种API都可用于将图形发送到虚拟现实系统，例如Oculus Rift 
和 HTCVive。但是，DirectX12是对API的彻底重新设计，可以 
更好地映射到现代GPU架构。低开销驱动程序对于CPU驱动程序 
成本导致瓶颈的应用程序非常有用，或者使用更多CPU处理器用于 
图形可以提高性能[946]。从早期的API移植可能很困难，而天真的 
实现可能会导致性能降低[249,699,1438]。Apple于2014年发布 
了自己的低开销API，名为Metal.Metal首次面向移动设备，如 
iPhone 5S和 iPadAir，一年后通过OSX ElCapitan获得更新的 
Macintoshes。超越效率，降低CPU使用率可以节省功耗，这是移 
动设备的一个重要因素。此API具有自己的着色语言，适用于图形 
和GPU计算程序。AMD 向Mronle集团捐赠了 Mantle工作，该 
集团于2016年初发布了名为Vulkan的新API。与OpenGL一样， 
Vulkan可以在多个操作系统上运行。Vulkan使用一种名为SPIRV 
的新高级中间语言，用于着色器表示和一般GPU计算。预编译着色 
器是便携式的，因此可以在任何支持3.4的GPU上使用。可编程着 
色和API的演变41所需的功能[885]。Vulkan也可用于非图形GPU 
计算，因为它不需要显示窗口[946]。Vulkan与其他低开销驱动程 
序的一个值得注意的区别在于，它适用于从工作站到移动设备的各 
种系统。在移动设备上，标准一直是使用OpenGLES。 “ES”代表 
----------------------- Page 63-----------------------
嵌入式系统，因为此API是在考虑移动设备的情况下开发的。当时 
的标准OpenGL在一些调用结构中相当庞大和缓慢，并且需要支持 
很少使用的功能。OpenGLES1.0于2003年发布，是OpenGL1.3 
的精简版本，描述了固定功能管道。虽然DirectX的版本与支持它 
们的图形硬件的版本同步，但是为移动设备开发图形支持并不是以 
同样的方式进行。例如，2010年发布的第一款iPad实现了OpenGL 
ES1.1。2007年的OpenGL ES2。0规格发布，提供可编程着色。 
它基于OpenGL2.0，但没有固定功能组件，因此与OpenGLES1.1 
不向后兼容。OpenGLES3.0于2012年发布，提供多种渲染目标， 
纹理压缩，变换反馈，实例化以及更广泛的纹理格式和模式以及着 
色器语言改进等功能。OpenGL ES3.1添加了计算着色器，3.2添 
加了几何和曲面细分着色器以及其他功能。第23章更详细地讨论了 
移动设备架构。OpenGL ES 的一个分支是基于浏览器的 API 
WebGL，通过JavaScript调用。该API于2011年发布，可在大多 
数移动设备上使用，因为它在功能上与OpenGL ES2.0相同。与 
OpenGL一样，扩展程序可以访问更高级的GPU功能。WebGL 2 
假定支持OpenGL ES3.0。WebGL特别适合在课堂上试验功能或 
使用：。它是跨平台的，适用于所有个人计算机和几乎所有移动设 
备。。驱动程序批准由浏览器处理。即使一个浏览器不支持特定的 
GPU或扩展，通常是另一个浏览器。。代码是解释的，而不是编译 
的，开发只需要文本编辑器。。大多数浏览器都内置了调试器，可 
以检查在任何网站上运行的代码。。例如，可以通过将程序上载到 
----------------------- Page 64-----------------------
网站或Github来部署程序。更高级别的场景图和效果库（如three.js 
[218]）可以轻松访问代码，以获得各种更复杂的效果，如阴影算法， 
后处理效果，基于物理的着色和延迟渲染。42 3.图形处理单元3.5 
顶点着色器顶点着色器是功能管道中的第一个阶段，如图3.2所示。 
虽然这是程序员控制下的第一个阶段，但值得注意的是，在此阶段 
之前会发生一些数据操作。在 DirectX 调用输入汇编程序 
[175,530,1208]时，可以将几个数据流编织在一起以形成沿管道发 
送的顶点和基元集。例如，对象可以由一个位置数组和一个颜色数 
组表示。输入汇编器将通过创建具有位置和颜色的顶点来创建此对 
象的三角形 （或线或点）。第二个对象可以使用相同的位置数组 （以 
及不同的模型变换矩阵）和不同的颜色数组来表示。第 16.4.5节详 
细讨论了数据表示。输入汇编程序还支持执行实例化。这允许对象 
被绘制几次，每个实例具有一些变化的数据，所有这些都具有单个 
绘制调用。第 18.4.2节介绍了实例化的使用。三角形网格由一组顶 
点表示，每个顶点与模型表面上的特定位置相关联。除了position 
之外，还有与每个顶点关联的其他可选属性，例如颜色或纹理坐标。 
曲面法线也定义在网格顶点，这似乎是一个奇怪的选择。在数学上， 
每个三角形都有明确定义的曲面法线，直接使用三角形的法线进行 
着色似乎更有意义。但是，渲染时，三角形网格通常用于表示下面 
的曲面，顶点法线用于表示此曲面的方向，而不是三角形网格本身 
的方向。第 16.3.4节将讨论计算顶点法线的方法。图3.7显示了两 
个三角形网格的侧视图，这些网格代表曲面，一个是光滑的，另一 
----------------------- Page 65-----------------------
个是具有尖锐的折痕。顶点着色器是处理三角形网格的第一个阶段。 
描述形成哪些三角形的数据对顶点着色器不可用。顾名思义，它专 
门处理传入的顶点。顶点着色器提供了图3.7的方法。三角网格的 
侧视图（黑色，顶点法线表示曲面（红色）。在左边平滑的顶点法 
线用于表示光滑的表面。在右侧，中间顶点已被复制并给出两个法 
线，表示折痕。3.5。顶点着色器43用于修改，创建或忽略与每个 
三角形顶点关联的值，例如其颜色，法线，纹理坐标和位置。通常， 
顶点着色器程序将顶点从模型空间转换为均匀剪辑空间（第4.7节）。 
顶点着色器至少必须始终输出此位置。顶点着色器与前面描述的统 
一着色器非常相似。传入的每个顶点都由顶点着色器程序处理，然 
后输出一些在三角形或直线上插值的值。顶点着色器既不能创建也 
不能破坏顶点，并且一个顶点生成的结果不能传递到另一个顶点。 
由于每个顶点都是独立处理的，因此GPU上任意数量的着色器处理 
器可以与输入的顶点流并行应用。输入程序集通常表示为在执行顶 
点着色器之前发生的过程。这是物理模型通常与逻辑模型不同的示 
例。在物理上，在顶点着色器中可能会发生用于创建顶点的数据的 
提取，并且驱动程序将使用适当的指令在每个着色器之前安静地添 
加，这对程序员是不可见的。下面的章节解释了几种顶点着色器效 
果，例如动画关节的顶点混合和轮廓渲染。顶点着色器的其他用途 
包括：。对象生成，通过仅创建一次网格并使顶点着色器变形。。 
使用蒙皮和变形技术为角色的身体和面部制作动画。。程序变形， 
例如旗帜，布料或水的移动[802,943]。。粒子创建，通过向管道发 
----------------------- Page 66-----------------------
送退化（无区域）网格并根据需要给予这些区域。。镜头扭曲，热 
雾，水波纹，页面卷曲和其他效果，通过使用整个帧缓冲区的内容 
作为纹理在屏幕对齐的网格上进行程序变形。。使用顶点纹理提取 
[40,1227]应用地形高度字段。使用顶点着色器完成的一些变形如图 
3.8所示。顶点着色器的输出可以以几种不同的方式使用。通常的路 
径是针对每个实例的基元（例如，三角形）然后生成并光栅化，并 
且生成的各个像素片段被发送到像素着色器程序以用于继续处理。 
在某些GPU上，数据也可以发送到曲面细分阶段或几何着色器或存 
储在内存中。以下各节将讨论这些可选阶段。443.图形处理单元图 
3.8。在左边，一个普通的茶壶。由顶点着色器程序执行的简单剪切 
操作产生中间图像。在右侧，噪声函数会创建一个扭曲模型的场。 
 （图片由FXComposer2制作，由NVIDIA公司提供。）3.6曲面 
细分阶段曲面细分阶段允许我们渲染曲面。GPU的任务是获取每个 
表面描述并将其转换为一组有代表性的三角形。此阶段是可选的 
GPU功能，首先在 DirectX 11中可用（并且是必需的）。它在 
OpenGL4.0和OpenGLES3.2中也受支持。使用曲面细分阶段有 
几个优点。曲面描述通常比提供相应的三角形本身更紧凑。除了节 
省内存之外，此功能还可以使CPU和GPU之间的总线不会成为动 
画角色或对象的瓶颈，其形状正在改变每一帧。通过为给定视图生 
成适当数量的三角形，可以有效地渲染表面。例如，如果球离相机 
很远，则只需要几个三角形。快了，它可能看起来最好用数千个三 
角形表示。这种控制细节水平的能力还可以允许应用程序控制其性 
----------------------- Page 67-----------------------
能，例如，在较弱的GPU上使用较低质量的网格以便保持帧速率。 
通常由平坦表面表示的模型可以被转换为三角形的精细网格，然后 
根据需要变形[1493]，或者可以对它们进行曲面细分以便较不频繁 
地执行昂贵的着色计算[225]。曲面细分阶段总是由三个元素组成。 
使用DirectX的术语，这些是船体着色器，曲面细分器和域着色器。 
在OpenGL中，外壳着色器是曲面细分控制着色器，域着色器是曲 
面细分评估着色器，虽然详细，但它们更具描述性。固定功能曲面 
细分器在OpenGL中称为原始生成器，正如将要看到的那样，它确 
实是它所做的。如何指定和镶嵌曲线和曲面将在第 17章详细讨论。 
这里我们简要总结每个曲面细分阶段的用途。首先，对外壳着色器 
的输入是一个特殊的补丁原语。这包括定义细分表面，B'ezier补丁 
或其他类型的弯曲元素的若干控制点。外壳着色器有两个功能。首 
先，它告诉曲面细分器应该生成多少个三角形，以及采用何种配置。 
其次，它对每个控制点执行处理。此外，可选地，外壳着色器可以 
修改传入的3.6。Tessellation Stage45船体着色器域着色器曲面 
细分器TF＆类型输入补丁变换补丁输出网格生成点控制点，TF和常 
数图3.9。镶嵌阶段。外壳着色器接收由控制点定义的补丁。它将曲 
面细分因子（TF）和类型发送到固定功能曲面细分器。控制点集由 
船体着色器根据需要进行变换，并与TF和相关的补丁常量一起发送 
到域着色器。曲面细分器创建顶点集以及它们的重心坐标。然后由 
域着色器处理这些，生成三角形网格（显示的控制点以供参考）。 
补丁说明，根据需要添加或删除控制点。外壳着色器将其控制点集 
----------------------- Page 68-----------------------
以及曲面细分控制数据输出到域着色器。见图3.9。曲面细分器是管 
道中的固定功能阶段，仅用于曲面细分着色器。它的任务是为域着 
色器添加几个新的顶点来处理。船体着色器向曲面细分器发送有关 
所需曲面表面类型的信息：三角形，四边形或等值线。等值线是一 
组线条，有时用于头发渲染[1954]。外壳着色器发送的其他重要值 
是曲面细分因子 （OpenGL中的曲面细分级别）。它们有两种类型： 
内边缘和外边缘。两个内部因素决定了在三角形或四边形内部发生 
了多少镶嵌。外部因素决定了每个外缘的分裂程度（第17.6节）。 
增加曲面细分因子的一个例子如图3.10所示。通过允许单独控制， 
无论内部如何细分，我们都可以在曲面细分中使相邻曲面的边缘匹 
配。匹配边缘避免了补丁遇到的裂缝或其他阴影伪影。顶点被赋予 
重心坐标 （第22.8节），这些坐标指定了所需曲面上每个点的相对 
位置。外壳着色器始终输出一个补丁，一组控制点位置。但是，它 
可以通过向曲面细分器发送零或更小（或非数字，NaN）的外部曲 
面细分级别来发信号通知要丢弃补丁。否则，曲面细分器生成网格 
并将其发送到域着色器。每次调用域着色器时，都会使用来自外壳 
着色器的曲面控制点来计算46 3.图形处理单元图3.10。改变镶嵌 
因子的效果。犹他州的茶壶由32个补丁组成。从左到右的内部和外 
部曲面细分因子是 1,2,4和8. 来（自Rideout和VanGelder[1493] 
的演示生成的图像。）每个顶点的输出值。域着色器具有类似于顶 
点着色器的数据流模式，其中来自曲面细分器的每个输入顶点被处 
理并生成相应的输出顶点。然后形成的三角形沿着管道传递。虽然 
----------------------- Page 69-----------------------
这个系统听起来很复杂，但它的结构是为了提高效率，每个着色器 
都非常简单。传递到船体着色器的补丁通常很少或根本没有修改。 
此着色器还可以使用贴片的估计距离或屏幕大小来动态计算曲面细 
分因子，如地形渲染[466]。或者，外壳着色器可以简单地为应用程 
序计算和提供的所有补丁传递一组固定的值。曲面细分器执行一个 
涉及但固定功能的过程，即生成顶点，给它们定位，并指定它们形 
成的三角形或直线。该数据放大步骤在着色器外部执行以获得计算 
效率[530]。域着色器采用为每个点生成的重心坐标，并在贴片的评 
估方程中使用这些坐标生成位置，法线，纹理坐标和所需的其他顶 
点信息。有关示例，请参见图3.11。图3.11。左边是大约6000个 
三角形的底层网格。在右侧，使用PN三角形细分对每个三角形进 
行细分和移位。（来自 NVIDIA SDK 11 [1301]样本的图片，由 
NVIDIA公司提供，来自4A Games的Metro2033型号。）3.7。 
几何着色器47图3.12。几何着色器程序的几何着色器输入具有某 
种单一类型：点，线段，三角形。最右边的两个基元包括与线和三 
角形对象相邻的顶点。更精细的补丁类型是可能的。3.7几何着色器 
几何着色器可以将基元转换为其他基元，这是曲面细分阶段无法做 
到的。例如，通过使每个三角形创建线边缘，可以将三角形网格转 
换为线框视图。或者，可以用面向观察者的四边形替换线条，从而 
使线框渲染具有更厚的边缘[1492]。随着DirectX10的发布，几何 
着色器被添加到硬件加速的图形管道中，它位于管道中的曲面细分 
着色器之后，它的使用是可选的。虽然是Shader Model4.0的必 
----------------------- Page 70-----------------------
需部分，但它并未在早期的着色器模型中使用。OpenGL 3.2和 
OpenGLES3.2也支持这种着色器。几何着色器的输入是单个对象 
及其关联的顶点。对象通常由条带中的三角形，线段或简单的点组 
成。可以通过几何着色器定义和处理扩展基元。特别地，可以传入 
三角形外部的三个附加顶点，并且可以使用折线上的两个相邻顶点。 
见图3.12。使用 DirectX11和ShaderModel5.0，您可以传递更 
精细的补丁，最多可以有32个控制点。也就是说，曲面细分阶段对 
于补丁生成更有效[175]。几何着色器处理此基元并输出零个或多个 
顶点，这些顶点被视为点，折线或三角形条带。请注意，几何着色 
器无法生成任何输出。通过这种方式，可以通过编辑顶点，添加新 
基元和删除其他基元来有选择地修改网格。几何着色器设计用于修 
改传入数据或制作有限数量的副本。例如，一种用途是生成六个转 
换的数据副本，以同时渲染立方体贴图的六个面;见 10.4.3节。它 
还可用于高效创建级联阴影贴图，以生成高质量的阴影。利用几何 
着色器的其他算法包括从点数据创建变量粒子，沿着轮廓挤出鳍以 
进行毛发渲染，并找到阴影算法的对象边缘。有关更多示例，请参 
见图3.13。本书的其余部分将讨论这些和其他用途。DirectX11增 
加了几何着色器使用实例化的能力，其中几何着色器可以在任何给 
定的基元上运行一定次数[530,1971]。48 3.图形处理单元图3.13。 
几何着色器（GS）的一些用途。在左侧，使用GS在运行中执行 
metaball等值面细分。在中间，线段的分形细分使用GS完成并流 
出，并且GS生成广告牌以显示闪电。在右侧，使用顶点和几何着 
----------------------- Page 71-----------------------
色器以及流出来执行布料模拟。 （图片来自NVIDIASDK10[1300] 
样本，由NVIDIA公司提供。）OpenGL4。0使用调用计数指定。 
几何着色器还可以输出最多四个流。可以在渲染管道上向下发送一 
个流以进行进一步处理。可以选择将所有这些流发送到流输出渲染 
目标。几何着色器保证以与输入相同的顺序输出基元的结果。这会 
影响性能，因为如果多个着色器核并行运行，则必须保存并排序结 
果。此因素和其他因素可用于在单个调用中用于复制或创建大量几 
何体的几何着色器[175,530]。在发出绘制调用之后，管道中只有三 
个位置可以在GPU上创建工作：光栅化，曲面细分阶段和几何着色 
器。这些，在考虑所需的资源和内存时，几何着色器的行为是最不 
可预测的，因为它是完全可编程的。在实践中，几何着色器通常看 
起来很少使用，因为它不能很好地映射到GPU的优势。在某些移动 
设备上，它是用软件实现的，因此在那里积极地使用它[69]。3.7.1 
流输出GPU管道的标准用途是通过顶点着色器发送数据，然后栅格 
化生成的三角形并在像素着色器中处理它们。过去，数据总是通过 
管道传递，无法访问中间结果。流输出的想法在ShaderModel4.0 
中引入。在顶点着色器（以及可选的曲面细分和几何着色器）处理 
顶点之后，可以在流中输出这些顶点，即，一个有序数组，除了被 
发送到光栅化阶段。事实上，光栅化可以完全关闭，然后管道纯粹 
用作非图形流处理器。数据3.8。以这种方式处理的像素着色器49 
可以通过流水线发回，从而允许迭代处理。这种类型的操作可用于 
模拟流动的水或其他粒子效应，如第 13.8节中所述。它也可以用于 
----------------------- Page 72-----------------------
为模型设置外观，然后让这些顶点可以重复使用（第4.4节）。流 
输出仅以浮点数的形式返回数据，因此它可能具有明显的内存成本。 
流输出适用于基元，而不是直接基于顶点。如果网格沿管道发送， 
则每个三角形都会生成自己的三个输出顶点集。原始网格中的任何 
顶点共享都将丢失。出于这个原因，更典型的用途是仅通过管道将 
顶点作为点集基元发送。在OpenGL中，流输出阶段称为变换反馈， 
因为其大部分使用的焦点是变换顶点并返回它们以进行进一步处 
理。保证基元按输入顺序发送到流输出目标，这意味着将保持顶点 
顺序[530]。3.8像素着色器在顶点，曲面细分和几何着色器执行其 
操作之后，将对基元进行剪切并设置以进行光栅化，如前一章所述。 
管道的这一部分在其处理步骤中是相对固定的，即，不可编程但可 
稍微配置。遍历每个三角形以确定它覆盖哪些像素。光栅化器还可 
以粗略计算三角形覆盖每个像素的单元区域的程度 （第 5.4.2节）。 
这部分或完全与像素重叠的三角形称为片段。三角形顶点的值（包 
括z缓冲区中使用的z值）在每个像素的三角形表面上进行插值。 
这些值将传递给像素着色器，然后像素着色器处理片段。在OpenGL 
中，像素着色器被称为片段着色器，它可能是一个更好的名称。为 
了保持一致性，我们在本书中使用 “像素着色器”。沿管道发送的 
点和线基元也为所覆盖的像素创建片段。在三角形上执行的插值类 
型由像素着色器程序指定。通常我们使用透视校正插值，使得像素 
表面位置之间的世界空间距离随着物体在距离上的后退而增加。一 
个例子是渲染铁轨延伸到地平线。铁轨越靠近轨道越远，因为每个 
----------------------- Page 73-----------------------
连续像素接近地平线的距离越大。可以使用其他插值选项，例如屏 
幕空间插值，其中不考虑透视投影。DirectX11进一步控制何时以 
及如何执行插值[530]。在编程术语中，顶点着色器程序的输出 （在 
三角形（或线）上插值）有效地成为像素着色器程序的输入。随着 
GPU的发展，其他输入已经暴露出来。例如，片段的屏幕位置可用 
于ShaderModel3.0及更高版本中的像素着色器。此外，503.图 
形处理单元图3.14。用户定义的剪裁平面。在左侧，单个水平剪裁 
平面切割对象。在中间，嵌套的球体被三个平面夹住。在右侧，球 
体的表面仅在它们位于所有三个剪裁平面之外时才会被剪裁。（来 
自three.js示例webgl剪辑和webgl剪辑交集[218]。）三角形的 
哪一侧是可见的是输入标志。这种知识对于在一次通过中在每个三 
角形的正面与背面上呈现不同的材料是重要的。通过手中的输入， 
通常像素着色器计算并输出片段的颜色。它还可能产生不透明度值 
并可选地修改其z深度。在合并期间，这些值用于修改存储在像素 
处的内容。光栅化阶段中生成的深度值也可以由像素着色器修改。 
模板缓冲区值通常不可修改，而是传递到合并阶段。DirectX11.3 
允许着色器更改此值。雾计算和alpha测试等操作已经从合并操作 
转变为SM4.0 [175]中的像素着色器计算。像素着色器还具有丢弃 
传入片段的独特能力，即不产生输出。可以使用片段丢弃的一个示 
例如图3.14所示。剪辑平面功能曾经是固定功能管道中的可配置元 
素，稍后在顶点着色器中指定。有碎片丢弃可用，然后，可以以像 
素着色器中所需的任何方式实现该功能，例如决定剪辑音量是否应 
----------------------- Page 74-----------------------
该被 “与”或 “或”在一起。最初，像素着色器可以仅输出到合并 
阶段，以便最终显示。像素着色器可以执行的指令数量随着时间的 
推移而显着增长。这种增加产生了多个渲染目标（MRT）的想法。 
不是将像素着色器程序的结果发送到颜色和z缓冲区，而是可以为 
每个片段生成多组值并保存到不同的缓冲区，每个缓冲区称为渲染 
目标。渲染目标通常具有相同的x和y维度;一些API允许不同的大 
小，但渲染区域将是这些中最小的。一些架构要求每个渲染目标具 
有相同的位深度，甚至可能是相同的数据格式。根据GPU，可用的 
渲染目标数量为四个或八个。3.8。像素着色器51即使有这些限制， 
MRT功能也可以更有效地执行渲染算法。单个渲染过程可以在一个 
目标中生成彩色图像，在另一个目标中生成对象标识符，在第三个 
目标中生成世界空间距离。此功能还产生了一种不同类型的渲染管 
道，称为延迟着色，其中可见性和着色在单独的通道中完成。第一 
遍存储有关对象位置和每个像素的材料的数据。然后，连续传球可 
以有效地应用照明和其他效果。第20.1节描述了这类渲染方法。像 
素着色器的限制是它通常只能在传递给它的片段位置写入渲染目 
标，并且无法从相邻像素读取当前结果。也就是说，当像素着色器 
程序执行时，它不能将其输出直接发送到相邻像素，也不能访问其 
他人的最近更改。相反，它计算仅影响其自身像素的结果。但是， 
这种限制并不像听起来那么严重。在一次传递中创建的输出图像可 
以在稍后的传递中由像素着色器访问其任何数据。可以使用第 12.1 
节中描述的图像处理技术处理相邻像素。像素着色器无法知道或影 
----------------------- Page 75-----------------------
响相邻像素结果的规则有例外。一个是像素着色器可以在计算梯度 
或衍生信息期间立即访问相邻片段的信息（尽管是间接的）。像素 
着色器具有沿x和y屏幕轴每个像素的任何内插值改变的量。这些 
值对于各种计算和纹理寻址是有用的。这些渐变对于纹理过滤（第 
6.2.2节）等操作尤其重要，我们想知道图像覆盖了多少像素。所有 
现代GPU都通过处理2×2组的片段来实现此功能，称为四元组。 
当像素着色器请求渐变值时，返回相邻片段之间的差异。见图3.15。 
统一内核具有访问相同warp上不同线程中保存的相邻数据的能力， 
因此可以计算在像素着色器中使用的渐变。这种实现的一个结果是， 
在受动态流控制影响的着色器的部分中，不能访问梯度信息，即， 
具有可变迭代次数的 “if”语句或循环。必须使用相同的指令集处理 
组中的所有片段，以便所有四个像素的结果对于计算梯度是有意义 
的。这是即使在离线渲染系统中也存在的基本限​ ​ 制[64]。 
DirectX11引入了一种缓冲区类型，允许对任何位置进行写访问， 
即无序访问视图（UAV）。最初仅用于像素和计算着色器，对无人 
机的访问扩展到 DirectX11.1中的所有着色器[146]。OpenGL4.3 
将其称为着色器存储缓冲区对象 （SSBO）。这两个名称都以自己的 
方式描述。像素着色器以任意顺序并行运行，并且这些存储缓冲区 
在它们之间共享。通常需要一些机制来避免数据竞争条件（也就是 
数据危险），其中两个着色器程序都 “竞争”以影响相同的值，可 
能是523.图形处理单元19176dv/dx =6-17=-11dv/ dy = 
19- 17 =28图3.15。在左侧，三角形被栅格化为四边形，2×2 
----------------------- Page 76-----------------------
像素的集合。然后在右侧显示标有黑点的像素的梯度计算。对于四 
边形中的四个像素位置中的每一个，示出了v的值。注意三角形没 
有覆盖三个像素，然而它们仍然由GPU处理，以便可以找到渐变。 
通过使用其两个四边形邻居来计算左下像素的x和y屏幕方向上的 
梯度。导致任意结果。例如，如果像素着色器的两次调用尝试在大 
约相同的时间添加到相同的检索值，则可能会发生错误。两者都将 
检索原始值，两者都会在本地修改它，但是无论哪个调用最后写入 
其结果都会消除其他调用的贡献 - 只会发生一次添加。GPU通过 
具有着色器可以访问的专用原子单元来避免这个问题[530]。但是， 
原子意味着某些着色器可能会在等待访问由另一个着色器进行读取 
/修改/写入的内存位置时停止。虽然原子能避免数据危害，许多算 
法需要特定的执行顺序。例如，您可能希望绘制一个更远的透明蓝 
色三角形，然后用红色透明三角形覆盖它，将红色混合在蓝色顶部。 
像素可以对像素进行两次像素着色器调用，每个三角形一次，以红 
色三角形着色器在蓝色之前完成的方式执行。在标准管道中，片段 
结果在处理之前在合并阶段进行排序。DirectX11.3中引入了光栅 
化器顺序视图 （ROV）以强制执行顺序。这些就像无人机;它们可以 
由着色器以相同的方式读取和写入。关键的区别在于 ROV保证以正 
确的顺序访问数据。这大大增加了这些着色器可访问缓冲区的实用 
性[327,328]。例如，ROV使像素着色器可以编写自己的混合方法， 
因为它可以直接访问和写入ROV中的任何位置，因此不需要合并阶 
段[176]。价格是，如果检测到无序访问，则像素着色器调用可能会 
----------------------- Page 77-----------------------
停止，直到处理之前绘制的三角形为止。3.9。合并阶段533.9合 
并阶段如第2.5.2节所述，合并阶段是将各个片段（在像素着色器 
中生成）的深度和颜色与帧缓冲区组合在一起。DirectX将此阶段 
称为输出合并;OpenGL将其称为每个样本操作。在大多数传统的管 
道图（包括我们自己的）上，这个阶段是模板缓冲区和z缓冲区操 
作发生的地方。如果片段可见，则此阶段中发生的另一个操作是颜 
色混合。对于不透明表面，不涉及真正的混合，因为片段的颜色只 
是替换先前存储的颜色。片段和存储颜色的实际混合通常用于透明 
度和合成操作（第 5.5节）。想象一下，光栅化生成的片段通过像 
素着色器运行，然后在应用zbuffer时被一些先前渲染的片段隐藏。 
然后，不必在像素着色器中完成所有处理。为了避免这种浪费，许 
多GPU在执行像素着色器之前执行一些合并测试[530]。片段的z 
深度（以及其他正在使用的东西，例如模板缓冲器或剪刀）用于测 
试可见性。如果隐藏，则片段被剔除。此功能称为 early-z 
[1220,1542]。像素着色器能够更改片段的z深度或完全丢弃片段。 
如果发现在像素着色器程序中存在任何类型的操作，则早期-z通常 
不能被使用并且被关闭，通常使得管道效率降低。DirectX 11和 
OpenGL4.2允许像素着色器强制早期z测试开启，但有许多限制 
[530]。有关early-z和其他z-buffer优化的更多信息，请参见第 
23.7节。有效地使用 early-z会对性能产生很大影响，这将在第 
18.4.5节中详细讨论。合并阶段占据固定功能阶段之间的中间地带， 
例如三角形设置和完全可编程着色器阶段。虽然它不可编程，但其 
----------------------- Page 78-----------------------
操作具有高度可配置性。特别是可以设置颜色混合以执行大量不同 
的操作。最常见的是涉及颜色和alpha值的乘法，加法和减法的组 
合，但是其他操作也是可能的，例如最小值和最大值，以及按位逻 
辑运算。DirectX10增加了将像素着色器中的两种颜色与帧缓冲颜 
色混合的功能。此功能称为双源颜色混合，不能与多个渲染目标一 
起使用。MRT支持混合，DirectX10.1引入了在每个单独缓冲区上 
执行不同混合操作的功能。正如上一节末尾所提到的，DirectX11.3 
提供了一种通过 ROV进行可编程混合的方法，但性价比却很高。 
ROV和合并阶段都保证了绘制顺序，即输出不变性。无论生成像素 
着色器结果的顺序如何，都是API要求，结果按照它们的输入顺序， 
逐个对象和三角形三角形排序并发送到合并阶段。543.图形处理单 
元3.10计算着色器GPU不仅可用于实现传统图形管道。在各个领 
域中存在许多非图形用途，如计算股票期权的估计值和培训用于深 
度学习的神经网络。以这种方式使用硬件称为 GPU计算。诸如 
CUDA和OpenCL之类的平台用于将GPU控制为大规模并行处理 
器，无需实际需要或访问特定于图形的功能。这些框架通常使用带 
有扩展的C或C ++等语言，以及为GPU制作的库。在 DirectX11 
中引入的计算着色器是GPU计算的一种形式，因为它是一个未锁定 
到图形管道中的位置的着色器。它与渲染过程紧密相关，因为它是 
由图形API调用的。它与顶点，像素和其他着色器一起使用。它利 
用了与管道中使用的统一着色器处理器相同的池。它与其他着色器 
一样，因为它具有一些输入数据集，并且可以访问输入和输出的缓 
----------------------- Page 79-----------------------
冲区（例如纹理）。Warp和线程在计算着色器中更明显。例如， 
每次调用都会获得一个可以访问的线程索引。还有一个线程组的概 
念，它由DirectX11中的1到 1024个线程组成。这些线程组由x， 
y和z坐标指定，主要是为了简化在着色器代码中的使用。每个线 
程组都有一些在线程之间共享的内存。在 DirectX11中，这相当于 
32kB。计算着色器由线程组执行，以便保证组中的所有线程同时运 
行[1971]。计算着色器的一个重要优点是它们可以访问GPU上生成 
的数据。将数据从GPU发送到CPU会产生延迟，因此如果处理和 
结果可以保持驻留在GPU上，则可以提高性能[1403]。后处理，以 
某种方式修改渲染图像，是计算着色器的常见用法。共享存储器意 
味着可以与相邻线程共享来自采样图像像素的中间结果。例如，使 
用计算着色器来确定图像的分布或平均亮度，其运行速度是在像素 
着色器上执行此操作的两倍[530]。计算着色器也可用于粒子系统， 
网格处理，如面部动画[134]，剔除[1883,1884]，图像滤波 
[1102,1710]，提高深度精度[991]，阴影[865]，景深[764]，以及 
可以承担一组GPU处理器的任何其他任务。Wihlidal [1884]讨论 
了计算着色器如何比镶嵌外壳着色器更有效。有关其他用途，请参 
见图3.16。这结束了我们对GPU渲染管道实现的回顾。有许多方 
法可以使用和组合GPU功能来执行各种与渲染相关的过程。调整以 
利用这些功能的相关理论和算法是本书的核心主题。我们现在的重 
点转向变换和着色。3.10。ComputeShader 55图3.16。计算着 
色器示例。在左侧，计算着色器用于模拟受风影响的头发，头发本 
----------------------- Page 80-----------------------
身使用曲面细分阶段进行渲染。在中间，计算着色器执行快速模糊 
操作。在右边，模拟了海浪。（图片来自 NVIDIASDK 11[1301] 
样本，由NVIDIACorporation提供。进一步的阅读和资源Giesen 
的图形管道之旅[530]详细讨论了GPU的许多方面，解释了为什么 
元素以他们的方式工作。Fatahalian和 Bryant[462]的课程在一系 
列详细的演讲幻灯片集中讨论了 GPU并行性。虽然专注于使用 
CUDA的GPU计算，但 Kirk和 Hwa的书[903]的介绍部分讨论了 
GPU的演变和设计理念。要了解着色器编程的正式方面需要一些工 
作。诸如OpenGL Superbible [1606]和 OpenGL编程指南[885] 
之类的书籍包括着色器编程的材料。旧书OpenGL着色语言[1512] 
未涵盖更近期的着色器阶段，例如几何和曲面细分着色器，但确实 
专注于与着色器相关的算法。看这本书的网站， 
realtimerendering.com，适用于近期和推荐的书籍。第4章转变 
 “如果愤怒的向量转向你的沉睡的头部，并形成。永远不需要害怕 
对这个贫穷世界的抽象风暴的暴力。 “- 罗伯特·佩恩·沃伦变换是 
一种采取点，矢量或颜色等实体并以某种方式转换它们的操作。对 
于计算机图形从业者来说，掌握变换是非常重要的。通过它们，您 
可以定位，重塑和动画对象，灯光和相机。您还可以确保所有计算 
都在同一坐标系中执行，并以不同方式将对象投影到平面上。这些 
只是可以使用变换执行的一些操作，但它们足以证明变换在实时图 
形中的作用的重要性，或者，就此而言，在任何一种计算机图形学 
中。线性变换是保持向量加法和标量乘法的变换。具体地，f （x）+ 
----------------------- Page 81-----------------------
f （y）=f （x +y），（4.1）kf （x）=f （kx）。（4.2）例如，f 
 （x）=5x是一个变换，它采用向量并将每个元素乘以 5。为了证 
明这是线性的，需要满足两个条件 （方程4.1和4.2）。第一个条件 
成立，因为任何两个向量乘以 5然后相加将与添加向量然后相乘相 
同。标量乘法条件 （公式4.2）显然得到了满足。此函数称为缩放变 
换，因为它会更改对象的比例（大小）。旋转变换是另一个线性变 
换，它围绕原点旋转矢量。缩放和旋转变换，事实上，三元素矢量 
的所有线性变换都可以用3×3矩阵表示。但是，这种矩阵的大小通 
常不够大。三元素向量x的函数，例如f （x）=x + （7,3,2），不 
是线性的。在两个单独的向量上执行此函数将两次 （7,3,2）的每个 
值相加以形成结果。将固定矢量添加到另一个矢量执行平移，例如， 
它将所有位置移动57584.变换相同的量。这是一种有用的变换类 
型，我们希望组合各种变换，例如，将对象缩放为一半大，然后将 
其移动到不同的位置。到目前为止，使用简单形式的函数使得很难 
轻松地将它们组合起来。可以使用仿射变换来组合线性变换和平移， 
通常存储为4×4矩阵。仿射变换是执行线性变换然后执行平移的变 
换。为了表示四元素向量，我们使用同构表示法，以相同的方式表 
示点和方向 （使用粗体小写字母）。方向矢量表示为v = （vxvyvz 
0）T，点表示为v = （vxvyvz 1）T。在本章中，我们将广泛使用 
在realtimerendering.com上可下载的线性代数附录中解释的术语 
和操作。所有平移，旋转，缩放，反射和剪切矩阵都是仿射的。仿 
射矩阵的主要特征是它保留了线的平行度，但不一定是长度和角度。 
----------------------- Page 82-----------------------
仿射变换也可以是各个仿射变换的任何级联连接。本章将从最重要 
的基本仿射变换开始。本节可以看作简单变换的 “参考手册”。然 
后描述更专业的矩阵，接着讨论和描述四元数，一个强大的变换工 
具。然后遵循顶点混合和变形，这是表达网格动画的两种简单但有 
效的方式。最后，描述了投影矩阵。大多数这些变换，它们的符号， 
功能和属性总结在表4.1 中，其中正交矩阵是反转矩阵的矩阵。变 
换是操纵几何的基本工具。大多数图形应用程序编程接口都允许用 
户设置任意矩阵，有时库可以与矩阵运算一起使用，这些运算实现 
了本章讨论的许多变换。但是，理解函数调用背后的真实矩阵及其 
相互作用仍然是值得的。知道在这样的函数调用之后矩阵的作用是 
一个开始，但理解矩阵本身的属性会带你进一步。例如，这样的理 
解使您能够辨别何时处理正交矩阵，其反转是其转置，从而实现更 
快的矩阵求逆。像这样的知识会导致加速代码。4.1基本变换本节介 
绍最基本的变换，例如平移，旋转，缩放，剪切，变换连接，刚体 
变换，正常变换（不太正常），和逆的计算。对于有经验的读者， 
这可以用作简单变换的参考手册，对于新手，它可以作为主题的介 
绍。本材料是本章其余部分和本书其他章节的必要背景。我们从最 
简单的变换开始 - 翻译。4.1。基本变换59符号名称特征T （t） 
平移矩阵移动一个点。仿射。Rx （？）旋转矩阵旋转？围绕x轴的 
弧度。y轴和z轴的相似表示法。正交和仿射。R旋转矩阵任何旋转 
矩阵。正交和仿射。S （s）缩放矩阵根据s沿所有x轴，y轴和z 
轴缩放。仿射。Hij （s）剪切矩阵相对于组分j，以因子s剪切组分 
----------------------- Page 83-----------------------
i。i，j∈{x，y，z}。仿射。E （h，p，r）欧拉变换由欧拉角头（偏 
航），俯仰，滚动给出的方位矩阵。正交和仿射。Po （s）正交投影 
平行投影到某个平面或体积上。仿射。Pp （s）透视投影在平面或 
体积上透视的项目。slerp （.q，.r，t）slerptransform根据四元 
数.q和.r以及参数t创建插值四元数。表4.1。本章讨论的大多数变 
换的摘要。4.1.1翻译从一个位置到另一个位置的变化由平移矩阵T 
表示。该矩阵通过向量t = （tx，ty，tz）来转换实体。下面通过公 
式4.3给出T：T （t）=T （tx，ty，tz）=。...100tx010ty00 
1tz0001。...... （4。3）转换变换效果的一个例子如图4.1所示。 
很容易证明点p = （px，py，pz，1）与T （t）的乘积产生一个新 
的点p'= （px+tx，py+ty，pz+tz，1），显然是一个翻译。注 
意，向量v = （vx，vy，vz，0）不受乘以T的影响，因为方向向量 
不能被转换。相反，点和矢量都受到其余仿射变换的影响。平移矩 
阵的逆是T.1 （t）=T （.t），即，向量t被否定。604.转换图4.1。 
左边的正方形用平移矩阵T （5,2,0）变换，其中正方形向右移动5 
个距离单位，向上移动2个距离单位。在这一点上我们应该提到， 
有时在计算机图形中看到的另一个有效的符号方案使用底行中具有 
平移向量的矩阵。例如，DirectX使用此表单。在该方案中，矩阵 
的顺序将被颠倒，即，应用的顺序将从左到右读取。由于矢量是行， 
所以这种表示法中的矢量和矩阵被称为行主要形式。在本书中，我 
们使用列主要形式。无论使用哪种，这纯粹是一种符号差异。当矩 
阵存储在存储器中时，十六个中的最后四个值是三个平移值，后跟 
----------------------- Page 84-----------------------
一个。4.1.2旋转旋转变换将矢量 （位置或方向）围绕通过原点的给 
定轴旋转给定角度。像翻译矩阵一样，它是一个刚体变换，即它保 
留了转换点之间的距离，并保留了手性（即，它永远不会导致左右 
交换边）。这两种类型的变换在用于定位和定向对象的计算机图形 
中显然是有用的。方向矩阵是与摄像机视图或对象相关联的旋转矩 
阵，其定义其在空间中的方向，即其向上和向前的方向。在二维中， 
旋转矩阵很容易导出。假设我们有一个向量，v = （vx，vy），我们 
将其参数化为v = （vx，vy）= （rcosθ，rsinθ）。如果我们用φ弧 
度（逆时针）旋转该矢量，那么我们将得到u = （rcos （θ+φ）， 
rsin （θ+φ））。这可以改写为u=？rcos （θ+φ）rsin （θ+φ）？ 
=？r （cosθcosφ.sinθsinφ）r （sinθcosφ+cosθsinφ）？=？cos 
φ。sinφsinφcosφ？|{z} R （？）？rcosθrsinθ？|{z}v =R （φ） 
v，（4.4）其中我们使用角度和关系来扩展cos （θ+φ）和sin （θ 
+φ）。在三维中，常用的旋转矩阵是Rx （φ），Ry （φ）和 Rz （φ）， 
其为4.1。基本变换61分别围绕x轴，y轴和z轴旋转实体φ弧度。 
它们由公式4.5-4.7给出：Rx （φ）=。...10000cosφ.sinφ00sin 
φcosφ00001。......， （4.5）Ry （φ）=。...cosφ0sinφ00100.sin 
φ0cosφ0000 1。......，（4.6）Rz （φ）=。...cosφ.sinφ00sinφ 
cosφ0000 10000 1。...... （4.7）如果从4×4矩阵中删除底行 
和最右列，则获得3×3矩阵。对于每个3×3旋转矩阵，R，围绕任 
何轴旋转φ弧度，迹线（矩阵中对角线元素的总和）与轴无关，并 
且计算为[997]：tr （R）=1+2cosφ。（4.8）旋转矩阵的效果可 
----------------------- Page 85-----------------------
以在第65页的图4.4中看到。旋转矩阵的特征是 Ri （φ），除了它 
围绕轴i旋转φ弧度的事实之外，它是离开所有点的。旋转轴，i， 
不变。注意，R也将用于表示围绕任何轴的旋转矩阵。上面给出的 
轴旋转矩阵可以用在一系列三个变换中以执行任意轴旋转。该过程 
在4.2.1节中讨论。第4.2.4节介绍了直接绕任意轴进行旋转。所有 
旋转矩阵的行列式都是 1并且是正交的。这也适用于任何数量的这 
些变换的连接。还有另一种获得逆的方法：R.1i （φ）=Ri （.φ）， 
即围绕同一轴在相反方向上旋转。示例：围绕点旋转。假设我们想 
要围绕z轴以φ弧度旋转对象，旋转中心是某个点，p。变化是什么？ 
该场景如图4.2所示。由于围绕点的旋转的特征在于点本身不受旋 
转的影响，因此变换通过平移对象开始，使得p与原点重合，这是 
用T （.p）完成的。此后跟随实际旋转：Rz （φ）。最后，必须使用 
T （p）将对象转换回其原始位置。然后，得到的变换X 由X =T （p） 
Rz （φ）T （.p）给出。（4。9）注意上面矩阵的顺序。？624.转 
换图4.2。围绕特定点旋转的示例p。4.1.3缩放缩放矩阵S （s）=S 
 （sx，sy，sz），分别沿x，y和z方向对具有因子sx，sy和sz的 
实体进行缩放。这意味着缩放矩阵可用于放大或缩小对象。si越大， 
i∈{x，y，z}，缩放实体在该方向上越大。将s的任何分量设置为1 
自然避免了该方向上的缩放变化。公式4.10显示S：S （s）=。...sx 
0000sy0000sz0000 1。...... （4.10）第65页的图4.4说 
明了缩放矩阵的效果。如果sx =sy =sz则缩放操作称为均匀，否 
则称为非均匀。有时使用术语各向同性和各向异性缩放而不是均匀 
----------------------- Page 86-----------------------
和不均匀。反向是S.1 （s）=S （1/ sx，1/ sy，1/sz）。使用齐 
次坐标，另一种创建均匀缩放矩阵的有效方法是通过操纵位置（3,3） 
处的矩阵元素，即右下角的元素。该值影响齐次坐标的w分量，因 
此缩放由矩阵变换的点（不是方向矢量）的每个坐标。例如，要均 
匀缩放5倍，缩放矩阵中 （0,0）， （1,1）和 （2,2）处的元素可以 
设置为5，或者 （3， 3）可以设置为 1/5。执行此操作的两个不同 
矩阵如下所示：S=。...5000050000500001。......，S'=。... 
10000 10000 10000 1/5。...... （4。11）与使用S进行均 
匀缩放相反，使用S'必须始终遵循均匀化。这可能是低效的，因为 
它涉及均质化4.1 中的分歧。基本变革63过程;如果右下角的元素 
 （位置（3,3））为1，则不需要分割。当然，如果系统总是在没有 
测试 1的情况下进行这种划分，那么就没有额外的成本。s的一个 
或三个分量上的负值给出一种反射矩阵，也称为镜像矩阵。如果只 
有两个比例因子是.1，那么我们将旋转π弧度。应注意，与反射矩阵 
连接的旋转矩阵也是反射矩阵。因此，以下是反射矩阵：cos （π/2） 
sin （π/ 2）.sin （π/ 2）cos （π/ 2）？|{z}轮换？100 .1？|{z} 
反射=？0.1。10？。（4.12）反射矩阵在检测到时通常需要特殊 
处理。例如，当通过反射矩阵变换时，具有逆时针顺序的顶点的三 
角形将获得顺时针顺序。此订单更改可能导致不正确的照明和背面 
剔除。为了检测给定矩阵是否以某种方式反射，计算矩阵的左上3 
×3元素的行列式。如果值为负，则矩阵是反射的。例如，公式4.12 
中矩阵的行列式为0·0。 （.1）· （。1）=。1。示例：按特定方向缩 
----------------------- Page 87-----------------------
放。缩放矩阵S仅沿x轴，y轴和z轴缩放。如果应该在其他方向 
上执行缩放，则需要复合变换。假设应该沿着标准轴的轴进行缩放， 
右向矢量fx，fy和fz。首先，构造矩阵 F，以改变基础，如下所示： 
F =？fxfyfz 0000 1？。（4.13）这个想法是让三个轴给出的坐 
标系与标准轴重合，然后使用标准的缩放矩阵，然后变换回来。第 
一步是通过乘以 F的转置（即倒数）来执行。然后进行实际缩放， 
然后进行变换。变换如公式4.14所示：X =FS （s）FT。 （4.14）？ 
4.1.4剪切另一类变换是一组剪切矩阵。例如，这些可以在游戏中用 
于扭曲整个场景以产生迷幻效果或以其他方式扭曲模型的外观。有 
六种基本的剪切矩阵，它们表示为Hxy （s），Hxz （s），Hyx （s）， 
Hyz （s），Hzx （s），和Hzy （s）。第一个下标用于表示剪切矩 
阵正在改变哪个坐标，而第二个下划线用于表示第四个坐标。转换 
图4.3。用Hxz （s）剪切单位平方的效果。y值和z值都不受变换 
的影响，而x值是旧x值和s乘以z值之和，导致平方变为倾斜。 
该变换是区域保持的，可以看出虚线区域是相同的。下标表示剪切 
的坐标。剪切矩阵Hxz （s）的一个例子如公式4.15所示。观察下 
标可用于在下面的矩阵中找到参数s的位置;x （其数字索引为0） 
标识行0，z （其数字索引为2）标识第2列，因此s位于那里：Hxz 
 （s）=。...10s0010000100001。...... （4.15）将该矩阵 
乘以点p的效果得到一个点： （px+spzpypz）T。在图形上，这 
显示在图4.3 中的单位平方。Hij （s）的倒数 （相对于第j 个坐标剪 
切第i个坐标，其中 i6 =j）是通过在相反方向上剪切产生的，即 
----------------------- Page 88-----------------------
H.1ij （s）=Hij （.s ）。您也可以使用稍微不同的剪切矩阵：H'xy 
 （s，t）=。... 10s00 1t000 10000 1。...... （4.16）然而， 
这里，两个下标都用于表示这些坐标将被第三个坐标剪切。这两种 
不同类型的描述之间的联系是 H'ij （s，t）=Hik （s）Hjk （t），其 
中k用作第三坐标的索引。使用的正确矩阵是品味问题。最后，应 
该注意的是，由于任何剪切矩阵|H|的行列式 =1，这是一个体积 
保持变换，如图4.3所示。4.1。基本变换65图4.4。这说明了乘以 
矩阵时的顺序依赖性。在顶行中，应用旋转矩阵 Rz （π/6），接着 
是缩放S （s），其中s= （2,0.5,1）。然后，复合矩阵为S （s）Rz 
 （π/ 6）。在底行中，矩阵以相反的顺序施加，产生Rz （π/ 6）S 
 （s）。结果明显不同。对于任意矩阵 M和 N，它通常认为MN6= 
NM.4.1.5变换的连接由于矩阵上的乘法运算的非交换性，矩阵发生 
的顺序很重要。因此，变换的连接被认为是依赖于顺序的。作为顺 
序依赖性的示例，考虑两个矩阵S和 R.S （2,0.5,1）将x分量缩放 
因子2，将y分量缩放0.5倍。Rz （π/6）围绕z轴逆时针旋转π/6 
弧度（在右手坐标系中从本书的页面向外指向）。这些矩阵可以以 
两种方式相乘，结果完全不同。这两种情况如图4.4所示。将一系 
列矩阵连接成一个矩阵的明显原因是为了提高效率。例如，假设您 
有一个拥有数百万个顶点的游戏场景，并且必须缩放，旋转并最终 
翻译场景中的所有对象。现在，不是将所有顶点与三个矩阵中的每 
一个相乘，而是将三个矩阵连接成单个矩阵。然后将该单个矩阵应 
用于顶点。该复合矩阵是C =TRS。请注意这里的订单。缩放矩阵 
----------------------- Page 89-----------------------
S应首先应用于顶点，因此显示在合成中的右侧。该排序意味着 
TRSp = （T （R （Sp））），其中p是要变换的点。顺便提一下， 
TRS是场景图系统常用的顺序。664.变换值得注意的是，虽然矩阵 
级联依赖于顺序，但矩阵可以根据需要进行分组。例如，假设使用 
TRSp，您想要计算一次刚体运动变换TR。将这两个矩阵组合在一 
起是有效的 （TR） （Sp），并用中间结果替换。因此，矩阵级联是 
关联的。4.1.6刚体变换当一个人抓住一个固体物体时，说一张桌子 
上的一支笔，并将其移动到另一个位置，也许是衬衫口袋，只有物 
体的方向和位置发生变化，而物体的形状一般不会受到影响。这种 
由仅仅平移和旋转的连接组成的变换称为刚体变换。它具有保持长 
度，角度和手性的特点。任何刚体矩阵X都可以写成平移矩阵T （t） 
和旋转矩阵 R的串联。因此，X具有公式4.17中矩阵的外观：X = 
T （t） R=。...r00r01r02txr10r11r12ty r20r21r22tz000 
1。...... （4.17）X的倒数计算为X.1 = （T （t）R）.1=R.1T （t）.1 
=RTT （.t）。因此，为了计算逆，R的左上3×3矩阵被转置，并 
且T的平移值改变符号。这两个新矩阵以相反的顺序相乘以获得逆 
矩阵。另一种计算X的倒数的方法是考虑R（使R表示为3×3矩阵） 
和X以​ ​ 下面的表示法 （第6页用公式 1.2描述的符号）：ˉR=.. 
r，0r，1r ，2？=。....rT0，rT1，rT2,. ....，=。X =？ˉRt0T1？， 
 （4.18）其中r，0表示旋转矩阵的第一列（即，逗号表示0到2 
之间的任何值，而第二个下标是0）和rT0，是列矩阵的第一行。注 
意，0是填充零的3×1列向量。有些计算得到公式4.19所示表达 
----------------------- Page 90-----------------------
式的倒数：X.1 =？r0，r1，r2，.ˉRTt 000 1？。（4.19）4.1。 
基本变换67clvu'ur图4.5。计算在c处定向摄像机的变换所涉及 
的几何，使用向上矢量u'，以查看点l。为此，我们需要计算r，u 
和v。示例：定位摄像机。图形中的一个常见任务是定向相机，使 
其看到某个位置。在这里，我们将介绍gluLookAt（）（来自OpenGL 
实用程序库，简称GLU）。即使这个函数调用本身现在使用不多， 
但任务仍然很常见。假设摄像机位于c，我们希望摄像机看到目标l， 
并且摄像机的给定方向是u'，如图4.5所示。我们想要计算一个由 
三个向量{r，u，v}组成的基础。我们首先将视图矢量计算为v = （cl） 
/ ||cl||，即从目标到摄像机位置的归一化矢量。然后可以将寻找 右“” 
的向量计算为r =。（v×u'）/ ||v×u'||。u'向量通常不能保证准确 
向上，因此最终向上向量是另一个叉积u =v×r，由于v和 r都被 
归一化并且垂直构造，因此保证归一化。在我们将构造的相机变换 
矩阵 M中，想法是首先翻译所有内容，使相机位置在原点 （0,0,0）， 
然后更改基础以使r与（1）对齐，0,0），u与（0,1,0）和v与（0,0,1）。 
这是通过 M =完成的。... rx ry rz0 ux uy uz0vx vy vz 0 0 0 0 
1。... 由于v和r都被归一化并且垂直于构造，因此保证归一化。在 
我们将构造的相机变换矩阵 M中，想法是首先翻译所有内容，使相 
机位置在原点 （0,0,0），然后更改基础以使 r与 （1）对齐，0,0）， 
u与 （0,1,0）和v与 （0,0,1）。这是通过 M=完成的。...rxryrz0 
uxuyuz0vxvyvz 0000 1。... 由于v和r都被归一化并且垂直 
于构造，因此保证归一化。在我们将构造的相机变换矩阵 M中，想 
----------------------- Page 91-----------------------
法是首先翻译所有内容，使相机位置在原点 （0,0,0），然后更改基 
础以使r与 （1）对齐，0,0），u与 （0,1,0）和v与 （0,0,1）。这 
是通过M=完成的。...rxryrz0uxuyuz0vxvyvz00001。...rx 
ryrz0uxuyuz0vxvyvz 0000 1。...rxryrz0uxuyuz0vx 
vyvz 0000 1。... |{z}改变基础。... 100.tx0 10.ty00 1.tz0 
001。......|{z}翻译=。...rxryrz.t·ruxuyuz.t·uvxvyvz.t·v00 
0 1。...... （4.20）注意，当将翻译矩阵与基础矩阵的变化连接时， 
翻译.t在右边，因为它应该首先应用。记住将r，u和v的组件放在 
何处的一种方法如下。我们希望 r变为（1,0,0），所以当将基础矩 
阵的变化乘以（1,0,0）时，我们可以看到矩阵中的第一行必须是r 
的元素，因为r· r =1.此外，第二行和第三行必须由垂直于 r的向 
量组成，即r·x =0.当对u和v应用相同的思想时，我们得到基矩阵 
的变化以上。？684。转换三角形xyx图4.6。左边是原始几何图 
形，一个三角形，从侧面显示其法线。中间的插图显示了如果模型 
沿x轴缩放0.5并且法线使用相同的矩阵会发生什么。右图显示正 
常的正确变换。4.1.7法线变换单个矩阵可用于一致地变换点，线， 
三角形和其他几何。相同的矩阵也可以沿着这些线或三角形的表面 
变换切线矢量。但是，此矩阵不能总是用于变换一个重要的几何属 
性，即曲面法线（和顶点光照法线）。图4.6显示了使用相同矩阵 
时会发生什么。而不是乘以矩阵本身，正确的方法是使用矩阵的伴 
随的转置[227]。我们的在线线性代数附录中描述了伴随的计算。伴 
随总是保证存在。转换后不能保证法线具有单位长度，因此通常需 
----------------------- Page 92-----------------------
要进行标准化。转换法线的传统答案是计算逆的转置[1794]。这种 
方法通常有效。但是，完全反转不是必需的，偶尔也不能创建。逆 
是伴随除以原始矩阵的行列式。如果该行列式为零，则矩阵是单数， 
并且逆不存在。即使只计算完整的4×4矩阵的伴随也可能很昂贵， 
而且通常不是必需的。由于法线是矢量，因此平移不会影响它。此 
外，大多数建模变换都是仿射变换。它们不会改变传入的齐次坐标 
的w分量，即它们不执行投影。在这些 （常见的）情况下，正常变 
换所需的全部是计算左上3×3分量的伴随。通常甚至不需要这种伴 
随计算。假设我们知道变换矩阵完全由翻译，旋转和均匀缩放操作 
 （无拉伸或挤压）的串联组成。翻译不会影响正常。均匀缩放因子 
只是改变法线的长度。剩下的是一系列旋转，它总是产生某种净旋 
转，仅此而已。4.1。基本变换69逆的转置可用于变换法线。旋转 
矩阵由其转置为反转的事实定义。替换以获得正常变换，两个转置 
 （或两个反转）给出原始旋转矩阵。综合起来，原始变换本身也可 
以直接用于在这些情况下转换法线。最后，并非总是需要完全重新 
正规化所产生的法线。如果仅将平移和旋转连接在一起，则当由矩 
阵变换时，法线不会改变长度，因此不需要重新归一化。如果连续 
统一缩放，则可以使用总体比例因子（如果已知或提取 - 第4.2.3 
节）直接标准化所产生的法线。例如，如果我们知道应用了一系列 
缩放，使对​ ​ 象大 5.2倍，那么直接由该矩阵变换的法线通过将 
它们除以5.2来重新归一化。或者，为了创建一个可以产生归一化 
结果的法线变换矩阵，原始矩阵的3×3左上角可以除以该比例因子 
----------------------- Page 93-----------------------
一次。注意，正常变换在系统中不是问题，在变换之后，表面法线 
是从三角形导出的（例如，使用三角形边的叉积）。切线向量在本 
质上与法线不同，并且总是由原始矩阵直接变换。4.1.8反转的计算 
在许多情况下需要反转，例如，在坐标系之间来回切换时。根据有 
关变换的可用信息，可以使用以下三种计算矩阵逆的方法之一：。 
如果矩阵是单个变换或具有给定参数的简单变换序列，则可以通过 
 “反转参数”和矩阵顺序来容易地计算矩阵。例如，如果 M=T （t） 
R （φ），则 M.1=R （.φ）T （.t）。这很简单并且保留了变换的准 
确性，这在渲染巨大的世界时很重要[1381]。。如果已知矩阵是正 
交的，则 M.1=MT，即，转置是反向的。任何旋转序列都是旋转， 
因此是正交的。。如果什么都不知道，则可以使用伴随方法，Cramer 
规则，LU分解或高斯消元来计算逆。Cramer的规则和伴随方法通 
常是优选的，因为它们具有较少的分支操作; “如果”测试在现代体 
系结构上是可以避免的。见4.1节。7关于如何使用伴随来反转变 
换法线。在优化时也可以考虑逆计算的目的。例如，如果逆用于变 
换向量，则通常只需要反转矩阵的3×3左上部分（参见前一节）。 
704.变换4.2特殊矩阵变换和操作在本节中，将介绍和导出几个对 
实时图形至关重要的矩阵变换和操作。首先，我们提出欧拉变换 （及 
其参数的提取），这是一种描述方向的直观方式。然后我们讨论从 
单个矩阵中检索一组基本变换。最后，导出一种围绕任意轴旋转实 
体的方法。4.2。1欧拉变换这种变换是一种直观的方法，可以构建 
一个矩阵来定位自己（即相机）或某个方向上的任何其他实体。它 
----------------------- Page 94-----------------------
的名字来自伟大的瑞士数学家LeonhardEuler （1707-1783）。首 
先，必须建立某种默认的视图方向。大多数情况下，它位于负z轴， 
头部沿y轴定向，如图4.7所示。欧拉变换是三个矩阵的乘法，即 
图中所示的旋转。更正式地，表示为E的变换由等式4.21给出：E 
 （h，p，r）=Rz （r）Rx （p）Ry （h）。（4.21）矩阵的顺序可 
以用24种不同的方式选择[1636];我们提出这个是因为它是常用 
的。由于E是旋转的串联，因此它也明显正交。因此，它的倒数可 
以表示为E.1=ET = （RzRxRy）T =RTyRTxRTz，当然，更容易 
直接使用E的转置。欧拉角h，p和r表示头部，俯仰和滚动应绕其 
各自的轴旋转的顺序和程度。有时角度都被称为 “滚动”，例如， 
我们的 “头部”是 “y-roll”而我们的 “俯仰”是 “x-roll”。此外， 
 “头部”有时被称为 “偏航”，例如在飞行模拟中。这种转换很直 
观，因此很容易用外行语言进行讨论。例如，改变头部角度使观察 
者摇头 “不”，改变音高使他们点头，并且滚动使他们将头部侧向 
倾斜。我们谈论的是改变头部，俯仰和滚动，而不是谈论围绕x轴， 
y轴和z轴的旋转。请注意，此变换不仅可以定向摄像机，还可以 
定向任何对象或实体。可以使用世界空间的全局轴或相对于本地参 
考帧来执行这些变换。重要的是要注意，欧拉角的一些表示给出了 
z轴作为初始向上方向。这种差异纯粹是一种符号变化，尽管可能 
令人困惑。在计算机图形学中，存在如何看待世界以及如何形成内 
容的区分：y-up或z-up。大多数制造工艺，包括3D打印，都认 
为z方向在世界空间中是朝上的;航空和海上交通工具认为.z要上 
----------------------- Page 95-----------------------
升。建筑和GIS通常使用z-up，因为建筑平面图或地图是二维的， 
x和y。与媒体相关的建模系统通常将y方向视为世界坐标中的向上， 
与我们总是在计算机图形中描述相机的屏幕向上方向相匹配。4.2 
之间的区别。特殊矩阵变换和操作71图4.7。欧拉变换及其与改变 
头部，俯仰和滚转角度的方式有关。显示默认视图方向，沿负z轴 
观察，沿y轴向上。这两个世界向上的向量选择只是90.旋转 （可能 
是一个反射），但不知道假设哪个会导致问题。除非另有说明，否 
则在本卷中我们使用y-up的世界方向。我们还想指出，相机在其 
视野中的向上方向与世界的向上方向没有任何关系。滚动你的头部， 
视野倾斜，其世界空间向上方向与世界不同。另一个例子，假设世 
界使用y-up，我们的相机直视下方的地形，鸟瞰。这个方向意味着 
摄像机向前倾斜90°，因此它在世界空间中的向上方向是（0,0，.1）。 
在这个方向上，相机没有y分量，而是将.z视为在世界空间中，但 
根据定义， “y isup”在视图空间中保持为真。虽然欧拉角在小角 
度变化或观察者方向上有用，但还有其他一些严重的局限性。在组 
合72中很难使用两组欧拉角.4。改变民族。例如，一组与另一组之 
间的插值不是插值每个角度的简单问题。事实上，两组不同的欧拉 
角可以给出相同的方向，因此任何插值都不应该旋转对象。这些是 
使用替代方向表示（如本章后面讨论的四元数）值得追求的一些原 
因。使用欧拉角，你也可以得到一种叫做万向节锁的东西，这将在 
4.2.2节中解释。4.2.2从 Euler变换中提取参数在某些情况下，有 
一个从正交矩阵中提取 Euler参数h，p和r的过程很有用。该过程 
----------------------- Page 96-----------------------
如公式4.22所示：E （h，p，r）=。。e00e01e02e10e11e12 
e20e21e22。。=Rz （r）Rx （p）Ry （h）。（4.22）这里我们 
放弃了3×3矩阵的4×4矩阵，因为后者为旋转矩阵提供了所有必 
要的信息。那是，等效4×4矩阵的其余部分始终包含零和右下角的 
一个。连接公式4.22 中的三个旋转矩阵得到E=cos rcos h.sinr 
sinpsin h.sinrcos pcos rsinh +sinrsinpcos hsin rcos h 
+cosrsinpsinhcosrcospsinrsinh.cosrsinpcosh.cosp 
sinhsinpcospcosh！。 （4.23）由此可见，俯仰参数由sinp= 
e21给出。另外，将e01除以e11，并且类似地将e20除以e22， 
得到以下头部和滚动参数的提取方程式：e01 e11 =.sin rcos r 
=.tanr和e20e22 =.sinhcosh=.tanh。（4.24）因此，使用 
函数atan2 （y，x）从矩阵 E中提取欧拉参数h （head），p （pitch） 
和r （roll），如公式4.25所示 （参见第 1章第8页） ：h=atan2 
 （。e20，e22），p=arcsin （e21），r=atan2 （.e01，e11）。 
 （4.25）但是，我们需要处理一个特例。如果cosp=0，我们有万 
向节锁定（第4.2.2节），旋转角度 r和 h将围绕同一轴旋转（尽 
管可能在不同方向，取决于p旋转角度是.π/2还是π/2），因此只 
需要导出一个角度。如果我们任意设置h =0 [1769]，我们得到E 
=。。cosrsinrcospsinrsinpsinrcosrcosp.cosrsinp0sin 
pcos p。.. （4.26）4.2。特殊矩阵变换和运算73由于p不影响第 
一列中的值，因此当cosp=0时，我们可以使用sinr/cosr=tan 
r=e10/e00，它给出r=atan2 （e10，e00）。注意，从arcsin 
----------------------- Page 97-----------------------
的定义来看，.π/2≤p≤π/ 2，这意味着如果在该区间之外创建了一 
个具有p值的 E，原始参数无法提取。h，p和r不是唯一的意味着 
可以使用多于一组的 Euler参数来产生相同的变换。关于欧拉角转 
换的更多信息可以在Shoemake的1994年文章[1636]中找到。上 
面概述的简单方法可能导致数值不稳定性的问题，这可以在速度上 
以某种代价避免[1362]。当你使用欧拉变换时，可能会发生一种称 
为万向节锁定的东西[499,1633]。这种情况发生在进行旋转时会失 
去一个自由度。例如，假设变换的顺序是x/ y/ z。考虑仅围绕y 
轴旋转π/ 2，执行第二次旋转。这样做会使局部z轴旋转以与原始 
x轴对齐，因此围绕z的最终旋转是多余的。在数学上，我们已经 
在公式4.26中看到了万向节锁定，其中我们假设cosp=0，即p= 
±π/ 2 +2πk，其中k是整数。利用 p的这个值，我们失去了一个 
自由度，因为矩阵仅取决于一个角度r +h或r。h （但不是两个同 
时）。虽然欧拉角通常在建模系统中呈现为x/y/ z顺序，但是围 
绕每个局部轴旋转，其他排序是可行的。例如，z/ x/ y用于动画 
和z/ x/ z中的动画和物理。所有这些都是指定三个单独旋转的有 
效方法。最后的排序z/x/ z对于某些应用来说可能是优越的，因 
为只有当围绕x旋转π弧度 （半旋转）时才会发生万向节锁定。没有 
完美的序列可以避免万向节锁定。尽管如此，欧拉角是常用的，因 
为动画师更喜欢曲线编辑器来指定角度随时间的变化[499]。示例： 
约束变换。想象一下，你正拿着一把握住螺栓的（虚拟）扳手。要 
将螺栓固定到位，必须围绕x轴旋转扳手。现在假设您的输入设备 
----------------------- Page 98-----------------------
 （鼠标，VR手套，太空球等）为您提供了一个旋转矩阵，即旋转， 
用于扳手的移动。问题是将此变换应用于扳手可能是错误的，扳手 
应仅围绕x轴旋转。要将输入变换 （称为 P）限制为围绕x轴旋转， 
只需使用本节中描述的方法提取欧拉角度h，p和r，然后创建新矩 
阵Rx（p）。然后，这将是围绕x轴旋转扳手的广受欢迎的变换 （如 
果 P现在包含这样的运动）。？4.2.3矩阵分解到目前为止，我们一 
直在假设我们知道我们正在使用的变换矩阵的起源和历史。通常情 
况并非如此。744.变换例如，只有连接矩阵可能与某些变换对象相 
关联。从级联矩阵中检索各种变换的任务称为矩阵分解。检索一组 
转换的原因有很多。用途包括：。仅提取对象的缩放因子。。查找 
特定系统所需的变换。（例如，某些系统可能不允许使用任意4×4 
矩阵。）。确定模型是否仅经历了刚体变换。。在动画中的关键帧 
之间进行插值，其中只有对象的矩阵可用。。从旋转矩阵中移除剪 
刀。我们已经提出了两种分解，即导出刚体变换的平移和旋转矩阵 
 （第4.1.6节）和从正交矩阵导出欧拉角 （第4.2.2节）。正如我们 
所看到的，检索平移矩阵是微不足道的，因为我们只需要4×4矩阵 
的最后一列中的元素。我们还可以通过检查矩阵的行列式是否为负 
来确定是否发生了反射。分离旋转，缩放和剪切需要更多的努力。 
幸运的是，有几篇关于这个主题的文章，以及在线提供的代码。 
Thomas [1769]和 Goldman [552,553]各自提出了各种不同类型 
的转换方法。Shoemake [1635]对其仿射矩阵的技术进行了改进， 
因为他的算法独立于参照系并试图分解矩阵以获得刚体变换。4.2.4 
----------------------- Page 99-----------------------
关于任意轴的旋转有时，使用围绕任意轴旋转实体一定角度的过程 
是很方便的。假设旋转轴 r被标准化，并且应该创建一个围绕 r旋 
转α弧度的变换。为此，我们首先转换到我们想要旋转的轴是x轴的 
空间。这是通过一个名为 M的旋转矩阵完成的。然后执行实际旋转， 
然后使用 M.1[314]进行变换。该过程如图4.8所示。为了计算M， 
我们需要找到两个与r和彼此正交的轴。我们专注于找到第二轴s， 
知道第三轴t将是第一轴和第二轴的叉积，t =r×s。一种数值稳定 
的方法是找到r的最小分量（绝对值），并将其设置为0.交换剩余 
的两个分量，然后取消它们中的第一个4.2。特殊矩阵变换和操作 
75图4.8。围绕任意轴r的旋转是通过找到由r，s和t形成的标准 
正交基来完成的。然后，我们将此基础与标准基准对齐，以使r与x 
轴对齐。围绕x轴的旋转在那里进行，最后我们变换回来。（事实 
上​ ​ ，任何非零组件都可以否定）。在数学上，这表示为[784]：ˉ 
s=.. （0，.rz，ry），如果|rx|≤|ry|和|rx|≤|rz|，（。rz，0， 
rx），如果|ry|≤|rx|和|ry|≤|rz|，（。。，rx，0），如果|rz 
|≤|rx|和|rz|≤|ry|，s =ˉs/||ˉs||，t =r×s。（4.27）这保证了ˉ 
s与r正交 （垂直），并且 （r，s，t）是标准正交基。Frisvad[496] 
提出了一种在代码中没有任何分支的方法，它更快但准确度更低。 
Max[1147]和 Duff等人。[388]提高 Frisvad方法的准确性。无论 
采用哪种技术，这三个矢量用于创建旋转矩阵：M=。。rTsTtT。.. 
 （4.28）该矩阵将矢量r变换为x轴，s变换为y轴，t变换为z轴。 
所以，然后，在归一化矢量r周围旋转α弧度的最终变换是X =MTRx 
----------------------- Page 100-----------------------
 （α）M。 （4.29）在单词中，这意味着首先我们变换使得r是x轴 
 （使用M），然后我们围绕这个x轴旋转α弧度 （使用Rx （α））， 
然后我们使用 M的倒数，在这种情况下是 MT，因为M是正交的。 
Goldman [550]提出了另一种围绕任意归一化轴 r旋转φ弧度的方 
法。在这里，我们简单介绍他的变换：R=。。cos？+ （1.cos？） 
r2x （1.cos？）rxry.rzsin？ （1.cos？）rxrz+rysin？ （1.cos？） 
rxry +rz罪？cos？+ （1.cos？）r2y （1.cos？）ryrz.rx sin？ 
 （1.cos？）rxrz.ry罪？ （1.cos？）ryrz+rx罪？cos？+（1.cos？） 
r2z。.. （4.30）764.变换在4.3.2节中，我们提出了另一种使用四 
元数来解决这个问题的方法。同样在该部分中，对于相关问题也是 
更有效的算法，例如从一个向量到另一个向量的旋转。4.3 四元数虽 
然四元数是由威廉·罗恩·汉密尔顿爵士于 1843年发明的，作为复数 
的扩展，但直到1985年，Shoemake [1633]才将它们引入计算机 
图形学领域.1四元数用于表示旋转和方向。它们在几个方面优于欧 
拉角和矩阵。任何三维取向可以表示为围绕特定轴的单个旋转。给 
定此轴和角度表示，转换为四元数或从四元数转换是直截了当的， 
而在任一方向上的欧拉角转换都具有挑战性。四元数可用于稳定和 
恒定的方向插值，欧拉角度无法做到的事情。复数具有实部和虚部。 
每个都由两个实数表示，第二个实数乘以√.1。同样，四元数有四个 
部分。前三个值与旋转轴密切相关，旋转角度影响所有四个部分 （更 
多关于第4.3.2节中的内容）。每个四元数由四个实数表示，每个 
实数与不同的部分相关联。由于四元数有四个组成部分，我们选择 
----------------------- Page 101-----------------------
将它们表示为向量，但为了区分它们，我们在它们上面加上一个帽 
子：.q。我们从四元数的一些数学背景开始，然后用它来构造各种 
有用的变换。4.3.1数学背景我们从四元数的定义开始。定义。四元 
数。q可以通过以下方式定义，全部等效。.q= （qv，qw）=iqx+ 
jqy +kqz +qw =qv +qw，qv =iqx +jqy +kqz = （qx，qy， 
qz）， （4.31）i2=j2 =k2=.1，jk =.kj=i，ki=.ik=j，ij=.ji 
=k。变量qw被称为四元数的实部，.q。虚部是qv，i，j 和k被称 
为虚部。？对于虚部qv，我们可以使用所有常规向量运算，例如加 
法，缩放，点积，叉积等。使用四元数的定义，导出两个四元数，.q 
和.r之间的乘法运算 1在公平性中，Robinson[1502]在 1958年使 
用四元数进行刚体模拟。4.3。四元数77如下图所示。注意，虚部 
的乘法是非交换的。乘法：.q。r= （iqx+jqy +kqz+qw）（irx 
+jry +krz+rw）=i （qyrz.qzry +rwqx+qwrx）+j （qzrx.qxrz 
+rwqy+qwry）（4.32）+k （qxry。 qyrx +rwqz+qwrz）+ 
qwrw。qxrx。qyry。qzrz = （qv×rv+rwqv+qwrv，qwrw.qv·rv）。 
从这个等式可以看出，我们使用叉积和点积来计算两个四元数的乘 
积。随着四元数的定义，需要加法，共轭，范数和同一性的定义： 
加法：.q+.r= （qv，qw）+ （rv，rw）= （qv +rv，qw+RW）。 
共轭：.q。= （qv，qw）。= （。qv，qw）。范数：n （.q）=p.qq 
=p.q..q=pqv·qv +q2w （4.33）=qq2x+q2y +q2z +q2w。 
身份：.i= （0,1）。当n （.q）=√.qq被简化时 （上面显示的结果）， 
虚部抵消并且仅剩下实部。规范有时表示为||。q||=n （.q）[1105]。 
----------------------- Page 102-----------------------
上述结果是可以导出乘法逆，用.q.1表示。等式.q.1.q =.qq1 =1 
必须保持逆（对于乘法逆是常见的）。我们从范数的定义推导出一 
个公式：n （.q）2=.qq..qqn （.q）2=1. （4.34）这给出了乘法 
逆，如下所示：逆：.q。 1=1n （.q）2.q.. （4.35）逆的公式使 
用标量乘法，这是从公式4.3.1中得到的乘法导出的运算：sq= （0， 
s）（qv， qw）= （sqv，sqw）和.qs = （qv，qw）（0，s）= 
 （sqv，sqw），这意味着标量乘法是可交换的：sq=.qs= （sqv， 
sqw）。784.变换以下规则集很容易从定义中得出：共轭规则： （。 
q。）。=.q， （。q +.r）。=.q。+.r。， （4.36） （。qr）。=.r..q.. 
范数规则：n （.q。）=n （.q）， （4.37）n （.qr）=n （.q）n （.r）。 
乘法定律：线性：.p （sq+tr）=spq+tpr， （4.38） （sp+tq）.r 
=spr+tqr相关性：.p （.qr）= （。pq）.r。单位四元数，.q= （qv， 
qw），使得n （.q）=1.由此得出.q可以写成.q = （sinφuq，cos 
φ）=sinφuq+cos φ， （4.39）对于某些三维向量uq，使得||uq 
|| =1，因为n （.q）=n （sinφuq，cosφ）=qsin2φ （uq·uq） 
+cos2φ=qsin2φ+cos2φ=1 （4.40）当且仅当uq·uq=1=||uq 
||2。如下一节所示，单位四元数非常适合以最有效的方式创建旋转 
和方向。但在此之前，将为单位四元数引入一些额外的操作。对于 
复数，二维单位矢量可以写成cosφ+isinφ=ei？。四元数的等价 
物是.q =sinφuq+cosφ=e？uq。（4.41）单位四元数的对数和幂 
函数遵循公式4.41：对数：log （.q）=log （e？uq）=φuq，（4.42） 
功率：.qt = （sinφuq+cosφ）t =e？tuq =sin （φt）uq +cos 
----------------------- Page 103-----------------------
 （φt）。4.3。四元数79图4.9。由单位四元数表示的旋转变换的 
图示，.q= （sinφuq，cosφ）。变换围绕轴uq旋转2φ弧度。4.3.2 
四元数变换我们现在将研究四元数集的子类，即单位长度的子类， 
称为单位四元数。关于单位四元数的最重要的事实是它们可以表示 
任何三维旋转，并且这种表示非常紧凑和简单。现在我们将描述使 
单位四元数对旋转和方向如此有用的原因。首先，将点或向量的四 
个坐标p= （pxpypzpw）T放入四元数.p的分量中，并假设我们 
有一个单位四元数.q= （sinφuq，cosφ）。可以证明.qpq1 （4.43） 
围绕轴uq以角度2φ旋转.p （以及因此点p）。请注意，由于.q是 
单位四元数，.q.1=.q..请参见图4.9。.q的任何非零实数倍也表示 
相同的变换，这意味着.q和..q表示相同的旋转。也就是说，否定轴， 
uq和实部qw会创建一个四元数，它与原始四元数完全一样旋转。 
它还意味着从矩阵中提取四元数可以返回.q或..q。给定两个单位四 
元数，.q和.r，首先将.q和.r连接到四元数，.p （可以解释为点p） 
的串联由公式4.44给出：.r （.qpq）.r。= （。rq）.p （.rq）。=.cpc。 
 （4.44）这里，.c=.rq是表示单位四元数.q和.r的串联的单位四元 
数。矩阵转换由于人们经常需要组合几种不同的变换，并且大多数 
都是矩阵形式，因此需要一种方法将公式4.43转换为矩阵。四元数， 
804.变换.q，可以转换成矩阵 Mq，如公式4.45 [1633,1634]所示： 
Mq=。......1。s （q2y +q2z）s （qxqy。qwqz）s （qxqz+qwqy） 
0 s （qxqy +qwqz）1。s （q2x +q2z）s （qyqz。qwqx）0 s 
 （qxqz .qwqy）s （qyqz +qwqx）1。s （q2x +q2y）00 0 0 
----------------------- Page 104-----------------------
1。...... （4.45）这里，标量是s =2/ （n （.q））2。对于单位四 
元数，这简化为 Mq=。......1。2 （q2y +q2z）2 （qxqy.qwqz） 
2 （qxqz +qwqy）0 2 （qxqy +qwqz）1。2 （q2x +q2z）2 
 （qyqz.qwqx）02 （qxqz.qwqy）2 （qyqz+qwqx）1。2 （q2x 
+q2y）0000 1。...... （4.46）构造四元数后，不需要计算三角 
函数，因此转换过程在实践中是有效的。从正交矩阵Mq到单位四 
元数.q的反向转换更复杂。这个过程的关键是从公式4.46中的矩阵 
得到的以下差异：mq21。mq 12 =4qwqx，mq02。mq20 = 
4qwqy，mq10。mq01 =4qwqz。（4.47）这些方程的含义是， 
如果qw已知，则可以计算向量vq的值，从而导出.q。Mq的轨迹 
由tr （Mq）=4计算。2s （q2x +q2y +q2z）=4 1。q2x +q2 
y +q2zq2x +q2y +q2z +q2w！=4q2w q2x +q2y +q2z 
+q2w =4q2w （n （.q））2。（4.48）该结果产生单位四元数的 
以下转换：qw =12 ptr （Mq），qx =mq21。mq 124qw， 
qy =mq02。mq204qw，qz =mq10。mq014qw。（4.49） 
为了具有数值稳定的程序[1634]，应避免使用小数除法。因此，首 
先设置t =q2w。q2x。q2y。q2z，由此得出m00 =t +2q2x， 
m11=t +2q2y，m22 =t +2q2z，u=m00 +m11+m22= 
t +2q2w， （4.50）4.3。四元数81反过来暗示 m00，m11，m22 
和u中的最大值确定qx，qy，qz和qw中的哪一个是最大的。如 
果qw最大，则使用公式4.49导出四元数。否则，我们注意到以下 
情况：4q2x =+m00。m11。m22+m33,4q2y =。m00+m11。 
----------------------- Page 105-----------------------
m22+m33,4q2z =.m00。m11+m22+m33,4q2w=tr Mq（ ）。 
 （4.51）然后使用上述那些的适当等式来计算qx，qy和qz的最大 
值，之后使用等式4.47来计算.q的剩余分量。Sch¨uler[1588]提出 
了一种无分支但使用四个平方根的变体。球面线性插值球面线性插 
值是一种操作，给定两个单位四元数，.q和.r，以及参数t∈[0,1]， 
计算插值四元数。例如，这对于动画对象很有用。它对插值摄像机 
方向没有用，因为摄像机的 “向上”矢量在插值过程中会变得倾斜， 
通常是一种令人不安的效果。这个操作的代数形式由复合四元数表 
示，.s，下面：.s （.q，.r，t）= （。rq1）tq （4.52）然而，对于软 
件实现，以下形式，其中slerp代表球面线性插值，更合适：.s （。 
q，.r，t）=slerp （.q ，.r，t）=sin （φ （1。t））sinφ.q +sin 
 （φt）sinφ.r。 （4.53）为了计算该等式中所需的φ，可以使用以下 
事实：cosφ=qxrx +qyry +qzrz +qwrw [325]。对于t∈[0,1]， 
slerp函数计算 （unique2）内插四元数，它们一起构成从.q （t =0） 
到.r （t =1）的四维单位球上的最短弧。弧位于由.q，.r和原点给出 
的平面与四维单位球体之间的交点形成的圆上。如图4.10所示。计 
算出的旋转四元数以恒定速度绕固定轴旋转。诸如此类的曲线具有 
恒定的速度并因此具有零加速度，被称为测地曲线[229]。球体上的 
一个大圆被生成为通过原点和球体的平面的交点，并且这种圆的一 
部分被称为大弧。slerp功能非常适合在两个方向之间进行插值，并 
且表现良好 （固定轴，恒定速度）。当2If和仅当.q和.r不相反时， 
情况并非如此。824.转换图4.10。单位四元数表示为单位球面上的 
----------------------- Page 106-----------------------
点。函数slerp用于在四元数之间进行插值，插值路径是球体上的 
一个很大的弧。请注意，从.q1到.q2的插值以及从.q1到.q3到.q2 
的插值都不是一回事，即使它们到达相同的方向。使用几个欧拉角 
进行插值。实际上，直接计算slerp是一项涉及调用三角函数的昂 
贵操作。Malyshau[1114]讨论了将四元数集成到渲染管道中。他 
指出，对于90度角，三角形方向的误差最大为4度，而不是使用 
slerp，只是简单地对像素着色器中的四元数进行归一化。栅格化三 
角形时，此错误率是可以接受的。Li[1039,1040]提供了更快的增量 
方法来计算不牺牲任何精度的slerps。Eberly[406]提出了一种使用 
加法和乘法计算 slerps的快速技术。当两个以上的方向时，比 
如.q0，.q1,. 。。，.qn.1，可用，我们想要从.q0到.q1到.q2进行 
插值，依此类推，直到.qn.1，slerp可以直接使用。现在，当我们 
接近.qi时，我们会使用.qi.1和.qi作为slerp的参数。通过.qi之后， 
我们将使用.qi和.qi+1作为slerp的参数。这将导致在方向插值中 
出现突然的抖动，如图4.10所示。这类似于线性插值点时发生的情 
况;请参阅第 17页的图 17.3的右上角部分。有些读者可能希望在 
阅读第17章中的样条曲线后重新阅读以下段落。更好的插值方法是 
使用某种样条曲线。我们在.qi和.qi +1之间引入四元数.ai和.ai + 
1。球面三次插值可以在四元数组中定义.qi，.ai，.ai+1和.qi+1。 
令人惊讶的是，这些额外的四元数的计算如下所示[404]3:.ai =.qi 
exp？。log （.q.1 i.qi.1）+log （.q.1 i.qi +1）4？。（4.54） 
3Shoemake [1633]给出了另一种推导。4.3。四元数83 .qi和.ai 
----------------------- Page 107-----------------------
将用于使用平滑三次样条曲面插值四元数，如公式4.55所示：小队 
 （.qi，.qi+1，.ai，.ai+1，t）=slerp （slerp （.qi，.qi+1，t）， 
slerp （.ai，.ai+1，t），2t （1。t））。 （4.55）如上所示，小队 
功能是由使用slerp的重复球面插值构成的（第17.1.1节有关点的 
重复线性插值的信息）。插值将通过初始方向.qi，i∈[0,. 。。，n。 
1]，但不是通过.ai-这些用于表示初始方向的切线方向。从一个向量 
到另一个向量的旋转通常的操作是通过可能的最短路径从一个方向 
s转换到另一个方向。四元数的数学大大简化了这个过程，并显示 
了四元数与这种表示的紧密关系。首先，规范化s和t。然后计算单 
位旋转轴，称为u，计算为u= （s×t）/ ||s×t ||。接下来，e =s·t 
=cos （2φ）和||s×t||=sin （2φ），其中2φ是s和t之间的角度。 
表示从s到t的旋转的四元数则为.q= （sinφu，cosφ）。事实上， 
使用半角关系和三角恒等式简化.q= （sin？sin2？ （s×t），cosφ） 
给出[1197].q= （qv，qw）=1p2 （1+e） （s×t），p2 （1+ 
e）2！。 （4。56）以这种方式直接生成四元数 （相对于对乘积s× 
t进行归一化）避免了当s和t指向几乎相同的方向时的数值不稳定 
性[1197]。当s和t指向相反方向时，两种方法都出现稳定性问题， 
因为除以零。当检测到这种特殊情况时，任何垂直于s的旋转轴都 
可以用于旋转到t。有时我们需要从s到t的旋转矩阵表示。在公式 
4.46的一些代数和三角函数简化之后，旋转矩阵变为[1233]R （s， 
t）=。...e +hv2xhvxvy。vz hvxvz+vy0hvxvy+vze +hv2y 
hvyvz。vx0hvxvz。vy hvyvz+vxe+hv2z00001。...... 4.57（ ） 
----------------------- Page 108-----------------------
在这个等式中，我们使用了以下中间计算：v =s×t，e=cos （2φ） 
=s·t，h=1。cos （2φ）sin2 （2φ）=1。ev·v =11+e。 （4.58） 
844.变换可以看出，由于简化，所有平方根和三角函数都消失了， 
因此这是创建矩阵的有效方法。注意，公式4.57的结构类似于公式 
4.30的结构，并注意后一种形式如何不需要三角函数。注意，当s 
和t平行或接近平行时必须小心，因为那样||s×t||≈0。如果φ≈0， 
那么我们可以返回单位矩阵。但是，如果2φ≈π，那么我们可以围 
绕任何轴旋转π弧度。该轴可以作为s与任何其他与s不平行的向量 
之间的交叉积（第 4.2.4 节）。M？oller 和 Hughes 使用 
Householder矩阵以不同的方式处理这种特殊情况[1233]。4。4 
顶点混合想象一下，数字角色的手臂使用前臂和上臂两部分进行动 
画处理，如图4.11左侧所示。可以使用刚体变换对该模型进行动画 
处理（第4.1.6节）。然而，这两个部分之间的关​ ​ 节将不会像 
真正的肘部。这是因为使用了两个单独的对象，因此，关节由来自 
这两个单独对象的重叠部分组成。显然，最好只使用一个对象。然 
而，静态模型部件没有解决使关节灵活的问题。顶点混合是这个问 
题的一种流行的解决方案[1037,1903]。此技术还有其他几个名称， 
例如线性混合蒙皮，包络或骨架子空间图4.11。由前臂和上臂组成 
的手臂使用左侧两个单独物体的刚体变换来动画。肘部看起来不太 
现实。在右侧，顶点混合用于单个对象。下一个最右边的手臂说明 
当一个简单的皮肤直接连接两个部分以覆盖肘部时会发生什么。最 
右边的臂说明了使用顶点混合时会发生什么，并且一些顶点与不同 
----------------------- Page 109-----------------------
的权重混合：（2/ 3,1/ 3）意味着顶点称重上臂的变换2/3和前 
臂的变换 1/3。该图还显示了最右边插图中顶点混合的缺点。在这 
里，可以看到肘部内侧的折叠。使用更多骨骼和更精心选择的重量 
可以获得更好的结果。4.4。顶点混合85变形。虽然这里提出的算 
法的确切起源尚不清楚，但定义骨骼并让皮肤对变化做出反应是计 
算机动画中的一个古老概念[1100]。在最简单的形式中，前臂和上 
臂像以前一样单独动画，但在关节处，两个部分通过弹性 “皮肤” 
连接。因此，这个弹性部分将有一组顶点由前臂矩阵和另一组由上 
臂矩阵变换的组。这导致三角形的顶点可以由不同的矩阵变换，与 
每个三角形使用单个矩阵相反。见图4.11。通过更进一步，可以允 
许单个顶点被几个不同的矩阵变换，所得到的位置被加权并混合在 
一起。这是通过为动画对象设置骨骼骨架来完成的，其中每个骨骼 
的变换可以通过用户定义的权重影响每个顶点。由于整个臂可以是 
 “弹性的”，即，所有顶点可能受多于一个矩阵的影响，因此整个 
网格通常被称为皮肤 （在骨骼上）。见图4.12。许多商业建模系统 
具有相同类型的骨架 - 骨骼建模功能。尽管他们的名字，骨头不一 
定是僵硬的。例如，Mohr和Gleicher[1230]提出了添加额外关节 
以实现肌肉膨胀等效果的想法。James和Twigg [813]讨论了使用 
可以挤压和拉伸的骨骼进行动画蒙皮。在数学上，这在公式4.59中 
表示，其中p是原始顶点，u （t）是位置取决于时间t的变换顶点： 
u （t）=nX.1i =0wiBi （t）M.1ip，其中nX.1i=0wi =1，wi 
≥0。 （4.59）有n个骨头影响p的位置，这是以世界坐标表示。值 
----------------------- Page 110-----------------------
wi是顶点 p的骨骼i的权重。矩阵Mi从初始骨骼坐标系转换为世 
界坐标。通常，骨骼在其坐标系的原点处具有控制关节。例如，前 
臂骨骼将其肘关节移动到原点，动画旋转矩阵将手臂的这部分移动 
到关节周围。Bi （t）矩阵是第i个骨骼的世界变换，其随时间变化 
以使对象动画化，并且通常是若干矩阵的串联，例如先前骨骼变换 
的层次结构和局部动画矩阵。Woodland [1903]深入讨论了维持和 
更新Bi （t）矩阵动画函数的一种方法。每个骨骼相对于其自己的参 
照系将顶点变换到一个位置，并且从该组计算点插入最终位置。在 
一些皮肤讨论中没有明确地显示matrixMi，而是被认为是Bi （t） 
的一部分。我们在这里提出它，因为它是一个有用的矩阵，几乎总 
是矩阵连接过程的一部分。在实践中，对于每个动画帧，矩阵 Bi （t） 
和 M.1i被连接用于每个骨骼，并且每个得到的矩阵用于变换顶点。 
顶点p由不同的骨骼连接矩阵转换，然后864.转换图4.12。顶点 
混合的一个真实例子。左上角的图像显示了手臂的两个骨骼，处于 
伸展位置。在右上角，显示网格，颜色表示每个顶点拥有哪个骨骼。 
底部：手臂的阴影网格处于略微不同的位置。 （图片由Jeff Lander 
提供[968]。）混合使用权重wi-因此名称顶点混合。权重是非负的 
并且总和为 1，所以发生的是顶点被转换到几个位置然后在它们之 
间进行插值。因此，对于所有i =0，变换点u将位于点集 Bi （t） 
M.1ip的凸包中。。。n。1 （固定t）。通常也可以使用公式4.59 
转换法线。取决于所使用的变形（例如，如果骨骼被拉伸或压扁相 
当大的量），4.5。将Bi （t）M的倒数转置为87。可能需要1i， 
----------------------- Page 111-----------------------
如4.1.7节所述。顶点混合非常适合在GPU上使用。网格中的顶点 
集可以放置在静态缓冲区中，该缓冲区一次发送到GPU并重复使 
用。在每个帧中，只有骨骼矩阵发生变化，顶点着色器计算它们对 
存储网格的影响。以这种方式，在CPU上处理和从CPU传输的数 
据量被最小化，允许GPU有效地渲染网格。如果模型的整个骨矩阵 
可以一起使用，这是最简单的;否则必须拆分模型并复制一些骨骼。 
或者，骨骼变换可以存储在顶点访问的纹理中，这可以避免达到寄 
存器存储限制。通过使用四元数来表示旋转，每个变换可以存储在 
两个纹理中[1639]。如果可用，无序访问视图存储允许重用皮肤结 
果[146]。可以指定超出范围[0,1]的权重集或不总和为1的权重集。 
但是，只有在使用某些其他混合算法 （例如变形目标 （第4.5节）） 
时才有意义。基本顶点混合的一个缺点是可能发生不希望的折叠， 
扭曲和自交叉[1037]。见图4.13。更好的解决方案是使用双四元数 
[872,873]。这种进行蒙皮的技术有助于保持原始变形的刚性，从而 
避免四肢中的 “糖果包装”扭曲。计算小于线性皮肤混合成本的 1.5 
倍，结果良好，这导致了该技术的迅速采用。但是，双四元数蒙皮 
会导致膨胀效应，和 Le和 Hodgins[1001]提出了旋转中心剥皮作 
为更好的选择。它们依赖于局部变换应该是刚体的假设，并且具有 
相似权重的顶点wi应该具有相似的变换。对每个顶点预先计算旋转 
中心，同时施加正交（刚体）约束以防止肘部塌陷和糖果包裹物扭 
曲伪影。在运行时，该算法类似于线性混合蒙皮，因为GPU实现在 
旋转中心执行线性混合蒙皮，然后是四元数混合步骤。4.5变形在执 
----------------------- Page 112-----------------------
行动画[28,883,1000,1005]时，从一个三维模型到另一个模型的变 
形可能很有用。想象一下，在时间t0显示一个模型，我们希望它在 
时间t1变成另一个模型。对于t0和t1之间的所有时间，使用某种 
插值获得连续的 “混合”模型。变形的一个例子如图4.14所示。变 
形涉及解决两个主要问题，即顶点对应问题和插值问题。给定两个 
可能具有不同拓扑，不同顶点数和不同网格连通性的任意模型，通 
常必须首先设置这些顶点对应关系。这是一个困难的884.转换图 
4.13。左侧显示使用线性混合蒙皮时关节处的问题。在右侧，使用 
双四元数进行混合可改善外观。（图片由LadislavKavan等人提供， 
模型由 PaulSteed[1693]提出。）问题，并且在该领域进行了大量 
研究。我们将感兴趣的读者引用到Alexa的调查[28]。但是，如果 
两个模型之间已存在一对一的顶点对应关系，则可以在每个顶点的 
基础上进行插值。也就是说，对于第一个模型中的每个顶点，第二 
个模型中必须只存在一个顶点，反之亦然。这使得插值变得容易。 
例如，线性插值可以直接用在顶点上（第 17.1节用于其他插值方 
法）。至4.5。变形89图4.14。顶点变形。为每个顶点定义两个位 
置和法线。在每个帧中，中间位置和法线由顶点着色器线性插值。 
 （图片由NVIDIA公司提供。）计算时间t∈[t0，t1]的变形顶点， 
我们首先计算s= （t.t0）/ （t1.t0），然后计算线性顶点混合，m= 
 （1.s）p0 +sp1，（4.60）其中p0和 p1对应于相同的顶点但在 
不同的时间t0和t1。用户具有更直观控制的变形变体被称为变形目 
标或混合形状[907]。可以使用图4.15解释基本思想。我们从一个 
----------------------- Page 113-----------------------
中性模型开始，在这种情况下是一个面孔。让我们用 N来表示这个 
模型。此外，我们还有一组不同的面部姿势。在示例插图中，只有 
一个姿势，这是一个笑脸。一般来说，我们可以允许k≥1个不同的 
姿势，表示为 Pi，i∈[1,. 。。，k]。作为预处理，904.转换中性微 
笑差异向量图4.15。给定两个嘴姿势，计算一组差矢量以控制内插 
或甚至外推。在变形目标中，差异向量用于将运动 “添加”到中性 
面上。对于差异向量的正权重，我们得到一个微笑的嘴，而负权重 
可以产生相反的效果。 “差异面”被计算为：Di=Pi.N，即，从每 
个姿势中减去中性模型。在这一点上，我们有一个中性模型，N和 
一组差异姿势，Di。然后可以使用以下公式获得变形模型 M：M= 
N+Xk i =1wiDi。（4.61）这是中性模型，最重要的是我们使用 
权重wi根据需要添加不同姿势的特征。对于图4.15，设置w1 =1 
可以准确地给出我们在插图中间的笑脸。使用w1 =0.5给我们一个 
半笑脸，依此类推。人们也可以使用负重和大于 1的权重。对于这 
个简单的脸部模型，我们可以添加另一张脸上有 “悲伤”的眉毛。 
使用负重量的眉毛可以创造 “快乐”的眉毛。由于位移是附加的， 
因此这种眉毛姿势可以与姿势一起用于微笑的嘴巴。变形目标是一 
种强大的技术，可以为动画师提供很多控制，因为模型的不同特征 
可以独立于其他特征进行操作。刘易斯等人。[1037]引入姿势空间 
变形，其组合顶点混合和变形目标。Senior[1608]使用预先计算的 
顶点纹理来存储和检索目标姿势之间的位移。支持流出的硬件和每 
个顶点的 ID允许在单个模型中使用更多目标，并且仅在GPU上计 
----------------------- Page 114-----------------------
算效果[841,1074]。使用低分辨率网格，然后通过曲面细分阶段和 
位移映射生成高分辨率网格，避免了在高度详细的模型中对每个顶 
点进行蒙皮的成本[1971]。4.5。变形91图4.16。DAMIN角色的 
脸在inFAMOUSSecondSon中，使用混合形状进行动画制作。所 
有这些镜头使用相同的静止姿势面，然后修改不同的权重以使面部 
看起来不同。 （图片由NaughtyDogLLC。提供，参见第二代儿歌， 
2014 年 Sony Interactive Entertainment LLC。 inFAMOUS 
Second Son是索尼互动娱乐有限责任公司的商标。由 Sucker 
PunchProductionsLLC开发。）显示了同时使用蒙皮和变形的真 
实示例在图4.16中。Weronko和Andreason [1872]在TheOrder： 
1886中使用了剥皮和变形.924。变换4.6几何缓存回放在剪切场 
景中，可能需要使用极高质量的动画，例如，对于无法使用上述任 
何方法表示的运动。一种天真的方法是存储所有帧的所有顶点，从 
磁盘读取它们并更新网格。但是，对于短动画中使用的30,000个顶 
点的简单模型，这可以达到50MB/s。Gneiting[545]提出了几种 
将内存成本降低到 10％左右的方法。首先，使用量化。例如，对于 
每个坐标，使用 16位整数存储位置和纹理坐标。在执行压缩之后无 
法恢复原始数据的意义上，该步骤是有损的。为了进一步减少数据， 
进行空间和时间预测并编码差异。对于空间压缩，可以使用平行四 
边形预测[800]。对于三角形条带，下一个顶点的预测位置只是在当 
前三角形边缘周围的三角形平面中反射的当前三角形，形成平行四 
边形。然后编码与该新位置的差异。通过良好的预测，大多数值将 
----------------------- Page 115-----------------------
接近零，这是许多常用压缩方案的理想选择。与MPEG压缩类似， 
也在时间维度上进行预测。也就是说，每n帧执行空间压缩。在两 
者之间，预测在时间维度中完成，例如，如果某个顶点移动来自帧 
n的增量矢量。如图 1中的帧n，则它可能移动相似的量到帧n+1. 
这些技术充分地减少了存储，因此该系统可以用于实时地流式传输 
数据。4.7投影在实际渲染场景之前，必须将场景中的所有相关对象 
投影到某种平面或某种类型的简单体积中。之后，执行裁剪和渲染 
 （第2.3节）。到目前为止在本章中看到的变换使第四个坐标w分 
量不受影响。也就是说，点和向量在变换后保留了它们的类型。此 
外，4×4矩阵中的底行始终为 （0001）。透视投影矩阵是这两个 
属性的例外：底行包含向量和点操纵数字，并且通常需要均匀化过 
程。也就是说，w通常不是 1，因此需要除以w来获得非均匀点。 
正投影，本节首先讨论，是一种更简单的投影，也是常用的投影。 
它不会影响w分量。在本节中，假设观察者沿着摄像机的负z轴观 
察，y轴朝上，x轴朝右。这是一个右手坐标系。一些文本和软件， 
例如 DirectX，使用左手系统，其中观看者沿着相机的正z轴看。 
两种系统都同样有效，最终实现了相同的效果。4.7。预测93图4.17。 
公式4.62生成的简单正交投影的三种不同视图。当观察者沿着负z 
轴观察时，可以看到该投影，这意味着投影在保持x坐标和y坐标 
的同时简单地跳过 （或设置为零）z坐标。注意，z =0两侧的物体 
被投影到投影平面上。4.7.1正交投影正投影的一个特征是平行线在 
投影后保持平行。当使用正交投影观看场景时，无论与相机的距离 
----------------------- Page 116-----------------------
如何，对象都保持相同的大小。如下所示，矩阵 Po是简单的正交投 
影矩阵，其使得点的x分量和y分量保持不变，同时将z分量设置 
为零，即，它正交投影到平面z =0：Po=。...10000 10000 
00000 1。...... （4.62）这种预测的效果如图4.17所示。显然， 
Po是不可逆的，因为它的行列式是|Po|换句话说，变换从三维变 
为二维，并且无法检索已删除的维度。使用这种正投影进行观察的 
一个问题是它将具有正值的点和具有负z值的点投影到投影平面 
上。将z值（以及x值和y值）限制为某个间隔通常很有用，例如 
从n （近平面）到f （远平面）.4这是下一次变换的目的。用于执行 
正交投影的更常见的矩阵由六元组 （l，r，b，t，n，f）表示，表示 
左，右，底，顶，近和远平面。该矩阵将由这些平面形成的轴对齐 
边界框 （AABB;参见第22.2节中的定义）缩放并转换为以4为中心 
的轴对齐立方体。近平面也称为前平面或前平面;远飞机也是背板或 
飞机。944.转换图4.18。转换规范视图卷上的轴对齐框。首先翻译 
左侧的框，使其中心与原点重合。然后缩放以获得规范视图卷的大 
小，如右图所示。起源。AABB的最小角是 （l，b，n），最大角是 
 （r，t，f）。重要的是要认识到n>f，因为我们在这个空间体积下 
俯视负z轴。我们的常识说，近似值应该是一个比far更低的数字， 
因此可以让用户提供它们，然后在内部否定它们。在OpenGL中， 
轴对齐的立方体的最小角为 （.1，.1，.1），最大角为 （1,1,1）;在 
DirectX中，边界是（。1，.1,0）到（1,1,1）。此立方体称为规范 
视图体积，此体积中的坐标称为标准化设备坐标。转换过程如图4.18 
----------------------- Page 117-----------------------
所示。转换为规范视图卷的原因是在那里更有效地执行裁剪。在转 
换为规范视图体积后，要渲染的几何体的顶点将被剪裁在此立方体 
上。最终通过将剩余的单位正方形映射到屏幕来渲染不在立方体外 
部的几何体。这里示出了这种正交变换：Po=S （s）T （t）=。....... 
2r。l00002t。b00002f。n00001。..............100。l+ 
r2010。t +b2001。f +n20001。.......=。........2r。l00。 
r+lr。l02t。b0。t +bt。b002f。n。f +nf。n0001。........ 4.63（ ） 
4.7。预测95如此等式所示，Po可以写为平移的串联T （t），后 
跟缩放矩阵S （s），其中s= （2/ （r.l），2/ （t.b），2/ （f.n））， 
和t = （。（r+1）/ 2，。（t +b）/ 2，。（f +n）/2）。该矩 
阵是可逆的，即P≤0=T （.t）S （（r.1）/2， （t.b）/2， （f.n）/ 
2）。在计算机图形学中，最经常在投影后使用左手坐标系 - 即， 
对于视口，x轴向右移动，y轴向上，z轴进入视口。因为远值小于 
我们定义AABB的方式的近似值，所以正交变换将始终包括镜像变 
换。要看到这一点，请说原始AABB与目标大小相同，即规范视图 
卷。那么AABB的坐标是（.1，.1,1）（l，b，n）和（1,1，f）为 
 （r，t，f）。将其应用于公式4.63给出了 Po=。...10000100 
00.100001。......，（4.64）是一个镜像矩阵。正是这种镜像从 
右手观察坐标系（俯视负z轴）转换为左手归一化设备坐标。DirectX 
将z深度映射到范围[0,1]而不是OpenGL的[.1,1]。这可以通过应 
用在正交矩阵之后应用的简单缩放和平移矩阵来实现，即Mst=。... 
10000 100000.50.5000 1。...... （4.65）因此，DirectX 
----------------------- Page 118-----------------------
中使用的正交矩阵是Po[0,1]=。.......2r。l00。r +lr。l02t。 
b0。t +bt。b001f。n。nf。n0001。....... （4。66）通常以 
转置形式呈现，因为 DirectX使用行主要形式来编写矩阵。5如果 
且仅当n6=f，l6=r，并且t6=b;否则，不存在逆。964.转换 
投影平面，z =-dz =-d图4.19。用于导出透视投影矩阵的符号。 
点p投影到平面z =.d，d>0，这产生投影点q。从相机位置的角 
度执行投影，在这种情况下是原点。在右侧的x分量中示出了在推 
导中使用的类似三角形。4.7.2透视投影比正投影更复杂的变换是透 
视投影，它通常用于大多数计算机图形应用程序。这里，平行线在 
投影后通常不平行;相反，他们可能会在极端情况下收敛到一个点。 
透视更接近我们对世界的感知，即更远的物体更小。首先，我们将 
为投影到平面z =.d，d>0的透视投影矩阵提供一个指导性的推导。 
我们从世界空间推导出来，以简化对世界到视图转换如何进行的理 
解。这种推导之后是更常规的矩阵，例如OpenGL [885]。假设相 
机 （视点）位于原点，并且我们想要将一个点p投影到平面z =.d， 
d>0上，产生一个新的点q = （qx，qy，.d） 。该场景如图4.19 
所示。从该图中所示的类似三角形，得到q的x分量的以下推导： 
qxpx=.dpz..qx =.dpxpz。（4.67）q的其他分量的表达式是 
qy =.dpy/ pz （与qx类似地获得），并且qz =.d。与上面的公 
式一起，这些给出了透视投影矩阵 Pp，如下所示：Pp=。...1000 
0 10000 1000.1/ d0。...... （4.68）4.7。预测97图4.20。 
矩阵 Pp将视锥体转换为单位立方体，称为规范视图体积。通过q= 
----------------------- Page 119-----------------------
Ppp=确认该矩阵产生正确的透视投影。... 10000 10000 10 
0 0 .1 / d 0。...... ... px py pz 1。...... =。... px py pz .pz / 
d。......。....dpx/ pz.dpy/ pz.d 1。...... （4.69）最后一步来自 
于整个向量除以w分量 （在这种情况下为.pz/d），以在最后位置 
得到 1。结果z值始终为。因为我们正投射到这架飞机上。直觉上， 
很容易理解为什么齐次坐标允许投影。均匀化过程的一个几何解释 
是它将点（px，py，pz）投影到平面w =1上。与正交变换一样， 
还有一个透视变换，而不是实际投影到一个平面上 （是不可逆的）， 
将视锥体转换为前面描述的规范视图体积。这里视锥体假设从z =n 
开始并在z =f结束，0>n>f。z =n处的矩形在 （l，b，n）处具 
有最小角，在 （r，t，n）处具有最大角。如图4.20所示。参数 （l， 
r，b，t，n，f）确定摄像机的视锥体。水平视场由平截头体的左平 
面和右平面 （由l和r确定）之间的角度确定。以相同的方式，垂直 
视场由顶平面和底平面之间的角度确定（由t和b确定）。视野越 
大，相机 “看到”越多。不对称的截头可以通过r6 =.l或t6 =.b 
来创建。例如，非对称截头体用于立体观看和虚拟现实（第21.2.3 
节）。视野是提供场景感的重要因素。与计算机屏幕相比，眼睛本 
身具有物理视野。这种关系是φ=2arctan （w/ （2d））， （4.70） 
984.变换其中φ是视场，w是垂直于视线的物体宽度，d是到视线 
的距离物体。例如，25英寸的显示器宽约22英寸。距离 12英寸， 
水平视野为85度;在20英寸处，它是58度;在30英寸，40度。 
这个相同的公式可以用于从相机镜头尺寸转换到视野，例如，用于 
----------------------- Page 120-----------------------
35mm相机的标准50mm镜头 （具有36mm宽的框架尺寸）给出 
φ=2arctan （36/ （2·50）） =39.6度。与物理设置相比，使用 
更窄的视野将减少透视效果，因为观看者将在场景中放大。设置更 
宽的视野会使对象显得扭曲（例如使用广角相机镜头）这个相同的 
公式可以用于从相机镜头尺寸转换到视野，例如，用于35mm相机 
的标准50mm镜头 （具有36mm宽的框架尺寸）给出φ=2arctan 
 （36/ （2·50）） =39.6度。与物理设置相比，使用更窄的视野将 
减少透视效果，因为观看者将在场景中放大。设置更宽的视野会使 
对象显得扭曲（例如使用广角相机镜头）这个相同的公式可以用于 
从相机镜头尺寸转换到视野，例如，用于35mm相机的标准50mm 
镜头 （具有36mm宽的框架尺寸）给出φ=2arctan （36/ （2·50）） 
=39.6度。与物理设置相比，使用更窄的视野将减少透视效果，因 
为观看者将在场景中放大。设置更宽的视野会使对象显得扭曲（例 
如使用广角相机镜头）靠近屏幕的边缘，会夸大附近物体的比例。 
然而，更宽的视野使观察者感觉到物体更大且更令人印象深刻，并 
且具有向用户提供关于周围环境的更多信息的优点。将平截头体转 
换为单位立方体的透视变换矩阵由公式4.71给出：Pp=。........2n 
r。l0。r +lr。l002nt。b。t +bt。b000f +nf。n。2fnf。 
n0010。........ （4.71）将这个变换应用到一个点后，我们将获得 
另一个点q = （qx，qy，qz，qw）T。此点的w分量qw （通常） 
非零且不等于 1。为了得到投影点p，我们需要除以qw，即p= （qx 
/ qw，qy/ qw，qz/ qw，1）。（4。72）矩阵Pp总是看到z = 
----------------------- Page 121-----------------------
f映射到+1并且z =n映射到.1。远处平面之外的物体将被剪裁， 
因此不会出现在场景中。透视投影可以处理取无穷大的远平面，这 
使得等式4.71变为 Pp=。......2nr。l0。r+lr。l002nt。b。t 
+bt。b0001.2n0010。....... （4.73）总之，应用透视变换 （以 
任何形式）Pp，然后进行剪切和均匀化 （除以w），这导致归一化 
的设备坐标。4.7。投影99要获得OpenGL中使用的透视变换，首 
先乘以S （1,1，.1,1），原因与正交变换相同。这简单地否定了公 
式4.71第三列中的值。应用此镜像转换后，near和far值作为正值 
输入，0 <n'<f'，因为传统上它们将呈现给用户。然而，它们仍然 
表示沿着世界负z轴的距离，这是视线的方向。出于参考目的，这 
是OpenGL等式：POpenGL=。........2n'r。l0r+lr。l002n't。 
bt +bt。b000。f'+ n'f'。n'。2f'n'f'。n'00.10。........ （4.74） 
更简单的设置是仅提供垂直视场，φ，纵横比a =w/ h （其中w× 
h是屏幕分辨率），n'和f'。这导致POpenGL=。.....c/ a0000 
c0000。f'+n'f'。n'。2f'n'f'。n'00.10。.....， （4.75）其中c= 
1.0/tan （φ/2）。这个矩阵正是旧的gluPerspective （）所做的， 
这是OpenGL实用程序库（GLU）的一部分。一些API （例如， 
DirectX）将近平面映射到z =0 （而不是z =.1）并且将远平面映 
射到z =1.此外，DirectX使用左手坐标系来定义其投影矩阵。这意 
味着 DirectX沿正z轴看，并将近端和远端值显示为正数。这是 
DirectX方程：Pp[0,1]=。........2n'r。l0。r +lr。l002n't。b。 
t +bt。b000f'f'。n'。f'n'f'。n'00 10。........ （4.76）DirectX 
----------------------- Page 122-----------------------
在其文档中使用行主格式，因此该矩阵通常以转置形式呈现。使用 
透视变换的一个效果是计算的深度值不随输入pz值线性变化。使用 
公式4.74-4.76至 100中的任何一个4.变换ZNDC-0.2-0。4-0.6 
-0.8-1图4.21。改变近平面距原点的距离的效果。距离f'.n'保持恒 
定为 100.随着近平面变得更接近原点，更靠近远平面的点使用更小 
范围的归一化设备坐标 （NDC）深度空间。这具有使z缓冲区在更 
远距离处更不准确的效果。乘以点 p，我们可以看出v = Pp 
=。......。。。。。dpz+e±pz。...， （4.77）其中省略了vx和vy 
的细节，并且常数d和f取决于所选择的矩阵。例如，如果我们使 
用公式4.74，那么d =。 （f'+n'）/ （f'.n'），e =.2f'n'/ （f'.n'）， 
并且vx =.pz 。为了获得归一化设备坐标（NDC）中的深度，我 
们需要除以w分量，这导致zNDC =dpz+e.pz=d。epz， （4。 
78）其中zNDC∈[。1，+1]用于OpenGL投影。可以看出，输出 
深度zNDC与输入深度 pz成反比。例如，如果 n'=10且f'= 110 
 （使用OpenGL术语），当pz是负z轴下方60个单位（即中间点） 
时，归一化设备坐标深度值是0.833，而不是0。图4.21显示了改 
变近平面距原点的距离的效果。近平面和远平面的放置会影响z缓 
冲区的精度。第23.7节将进一步讨论这种影响。有几种方法可以提 
高深度精度。一种常见的方法，我们称之为反向z，是用浮点深度 
或整数存储 1.0.zNDC[978]。比较如图4.22所示。里德[1472]用 
模拟4.7表示。投影 10101ZNDC靠近pz远近pz远=01ZNDC 
0 1ZNDC 靠近 pz远远靠近 pz远 0 1 1-ZNDC图4.22。使用 
----------------------- Page 123-----------------------
DirectX变换设置深度缓冲区的不同方法，即zNDC∈[0，+1]。左 
上角：标准整数深度缓冲区，此处显示4位精度 （因此y轴上有 16 
个标记）。右上角：远平面设置为∞，两个轴上的小偏移表明这样 
做不会损失很多精度。左下：带有3个指数位和3个浮点深度的尾 
数位。注意分布在y轴上是如何非线性的，这使得它在x轴上更加 
糟糕。右下：反向浮点深度，即 1。zNDC，因此具有更好的分布。 
 （插图由NathanReed提供。）使用具有反向z的浮点缓冲区提供 
了最佳精度，这也是整数深度缓冲区 （每个深度通常具有24位）的 
首选方法。对于标准映射（即，非反转z），在变换中分离投影矩 
阵会降低误差率，如Upchurch和 Desbrun[1803]所建议的。例如， 
使用P （Mp）比Tp更好，其中T =PM。此外，在[0.5,1.0]的范围 
内，fp32和int24的精度非常相似，因为fp32具有23位尾数。使 
zNDC与 1/ pz成比例的原因是它使硬件更简单并且深度压缩更成 
功，这将在第23.7节中进行更多讨论。Lloyd[1063]提出使用深度 
值的对数来提高阴影贴图的精度。Lauritzen等。[991]使用前一帧 
的z缓冲区来确定最大近平面和最小远平面。对于屏幕空间深度， 
Kemen[881]建议每个顶点使用以下重新映射：z =w..log2..max 
 （10.6,1+w）？fc。1？，[OpenGL]z =wlog2..max （10.6,1+ 
w）？fc/2，[DirectX] （4.79）其中w是投影矩阵之后的顶点的w 
值，z是来自顶点着色器的输出z。常数fc是fc =2/ log2 （f +1）， 
其中f是远平面。当仅在顶点着色器中应用此变换时，GPU将在顶 
点处的非线性变换深度之间在三角形上线性地插入深度（公式 
----------------------- Page 124-----------------------
4.79）。由于对数是单调的1024.变换函数，只要分段线性插值和 
精确的非线性变换深度值之间的差异很小，遮挡剔除硬件和深度压 
缩技术仍然可以工作。对于具有足够几何曲面细分的大多数情况来 
说，情况确实如此。但是，也可以应用每个片段的变换。这是通过 
输出e =1 +w的每顶点值来完成的，然后由GPU在三角形上进 
行插值。然后，像素着色器将片段深度修改为log2 （ei）fc/2，其 
中ei是e的内插值。当GPU中没有浮点深度并且使用深度较大的 
距离渲染时，此方法是一个很好的选择。Cozzi [1605]建议使用多 
个截头，这可以提高准确度以有效地达到任何所需的速率。视锥体 
在深度方向上被分成几个不重叠的较小的子截头体，它们的结合正 
好是截锥体。子截头体按照从前到后的顺序呈现。首先，清除颜色 
和深度缓冲区，并将要渲染的所有对象分类到它们重叠的每个子截 
头中。对于每个子截头体，设置其投影矩阵，清除深度缓冲器，然 
后渲染与子截头体重叠的对象。进一步阅读和资源沉浸式线性代数 
网站[1718]提供了一本关于该主题基础知识的交互式书籍，通过鼓 
励你操纵数字来帮助建立直觉。其他交互式学习工具和转换代码库 
从 realtimerendering.com链接。Farin和 Hansford的几何工具 
箱[461]是以无痛方式建立一个关于矩阵的直觉的最佳书之一。另一 
个有用的工作是 Lengyel的 3D游戏编程和计算机图形学数学 
[1025]。对于不同的视角，许多计算机图形文本，例如Hearn和 
Baker[689]，Marschner和Shirley[1129]以及Hughes等人。[785] 
也涵盖了矩阵基础知识。Ochiai等人的课程。[1310]介绍矩阵基础 
----------------------- Page 125-----------------------
以及矩阵的指数和对数，以及计算机图形的用途。GraphicsGems 
系列[72,540,695,902,1344]提供了各种与变换相关的算法，并且具 
有许多这些在线可用的代码。Golub 和 Van Loan 的 Matrix 
Computations[556]是开始认真研究矩阵技术的地方。关于骨架子 
空间变形/顶点混合和形状插值的更多信息可以在 Lewis等人的 
SIGGRAPH论文[1037]中阅读。哈特等人。[674]和汉森[663]提供 
了四元数的可视化。Pletinckx[1421]和Schlag[1566]提出了在一 
组四元数之间平滑插值的不同方法。Vlachos和 Isidoro[1820]推 
导出四元数C2插值的公式。与四元数插值相关的是沿曲线计算一 
致坐标系的问题。这由 Dougan治疗[374]。Alexa [28]和 Lazarus 
和Verroust [1000]提出了许多不同变形技术的调查。家长的书 
[1354]是计算机动画技术的绝佳来源。第五章阴影基础知识 “一张 
好照片相当于一件好事。 “-VincentVanGogh当您渲染三维物体 
的图像时，模型不仅应具有适当的几何形状，还应具有所需的视觉 
外观。取决于应用，这可以从照片写实 - 与真实物体的照片几乎相 
同的外观 - 到出于创造性原因选择的各种类型的风格化外观。有关 
两者的示例，请参见图5.1。本章将讨论阴影的那些方面，这些方面 
同样适用于照片级逼真和风格化渲染。第15章专门用于程式化渲 
染，本书的第9章到第 14章重点介绍了常用于照片级渲染的基于 
物理的方法。5。1着色模型确定渲染对象外观的第一步是选择着色 
模型来描述对象的颜色应如何根据表面方向，视图方向和光照等因 
素而变化。作为一个例子，我们将使用 Gooch着色模型的变体 
----------------------- Page 126-----------------------
[561]。这是非真实感渲染的一种形式，是第15章的主题。古奇着 
色模型旨在提高技术插图中细节的易读性。Gooch着色背后的基本 
思想是将表面法线与光线的位置进行比较。如果法线指向光线，则 
使用较暖的色调为表面着色;如果它指向远处，则使用较冷的音调。 
两者之间的角度在这些色调之间进行插值，这些色调基于用户提供 
的表面颜色。在这个例子中，我们为模型添加了一个风格化的 “高 
光”效果，使表面具有闪亮的外观。图 5.2显示了正在运行的着色 
模型。着色模型通常具有用于控制外观变化的属性。设置这些属性 
的值是确定对象外观的下一步。我们的示例模型只有一个属性，表 
面颜色，如图5.2的底部图所示。1031045.阴影基础图5.1。顶部 
图像来自使用虚幻引擎渲染的逼真景观场景。底部图片来自Campo 
Santo的Firewatch游戏，其设计采用了艺术风格。（上图由G¨ 
okhanKaradayi提供，下图由CampoSanto提供。）与大多数着 
色模型一样，此示例受到相对于视图和照明方向的表面方向的影响。 
对于着色目的，这些方向通常表示为标准化（单位长度）向量，如 
图5.3所示。现在我们已经定义了阴影模型的所有输入，我们可以 
看一下模型本身的数学定义：cshaded =schighlight + （1.s）..t 
cwarm+ （1.t）ccool？。 （5.1）5.1。着色模型 105图5.2。一个 
风格化的着色模型，结合了Gooch着色和高光效果。顶部图像显示 
具有中性表面颜色的复杂对象。底部图像显示了具有各种不同表面 
颜色的球体。 （来自ComputerGraphicsArchive [1172]的中国龙 
网，来自斯坦福3D扫描库的原始模型。）图5.3。单位长度矢量输 
----------------------- Page 127-----------------------
入到示例着色模型​ ​  （以及大多数其他模型）：表面法线n，视 
图矢量v和光线方向l。1065。着色基础在这个等式中，我们使用 
了以下中间计算：ccool = （0,0,0.55）+0.25csurface，cwarm= 
 （0.3,0.3,0）+0.25csurface，chighlight = （1,1,1），t = （n·l） 
+12，r =2 （n·1）n。l，s =.. 100 （r·v）。97？+。（5.2）该 
定义中的几个数学表达式也常见于其他着色模型中。钳位操作（通 
常钳位到0或钳位在0和 1之间）在阴影中很常见。这里我们使用 
第 1.2节中介绍的x +表示法，用于计算高亮混合因子s时0到 1 
之间的钳位。点积运算符出现三次，在每种情况下出现在两个单位 
长度矢量之间;这是一种非常常见的模式。两个向量的点积是它们的 
长度和它们之间角度的余弦的乘积。因此，两个单位长度矢量的点 
积只是余弦，它是两个矢量彼此对齐程度的有用量度。由余弦组成 
的简单函数通常是最令人愉悦和准确的数学表达式，以考虑阴影模 
型中两个方向（例如，光方向和表面法线）之间的关系。另一种常 
见的着色操作是基于0和1之间的标量值在两种颜色之间线性插值。 
此操作采用tca + （.t）cb形式，在ca和cb之间进行插值，因为t 
的值在1和0之间移动， 分别。此模板在此着色模型中出现两次， 
首先在cwarm和ccool之间插值，然后在前一个插值和chighlight 
的结果之间插值。线性插值在着色器中经常出现，它是我们看到的 
每种着色语言中的内置函数，称为lerp或mix。线 “r=2 （n·l）n。 
l “计算反射光矢量，反映l约n。虽然不像前两个操作那么常见， 
但这对于大多数着色语言来说也足够普遍，它也具有内置的反射功 
----------------------- Page 128-----------------------
能。通过以不同方式将这些操作与各种数学表达式和着色参数组合， 
可以为各种风格化和逼真的外观定义着色模型。5.2光源照明对我们 
的示例着色模型​ ​ 的影响非常简单; 它为阴影提供了主导方向。当 
然，现实世界中的照明可能非常复杂。可以有多个光源，每个光源 
都有自己的尺寸，形状，颜色，5.2。光源107和强度; 间接照明增 
加了更多变化。正如我们将在第9章中看到的那样，基于物理的照 
片级真实着色模型需要考虑所有这些参数。相比之下，风格化的着 
色模型可以以许多不同的方式使用照明，这取决于应用程序的需求 
和视觉风格。一些高度风格化的模型可能根本没有光照概念，或者 
 （像我们的Gooch着色示例）可能只使用它来提供一些简单的方向 
性。照明复杂性的下一步是使着色模型以二进制方式对光的存在与 
否作出反应。用这种模型着色的表面在点亮时具有一种外观，在不 
受光影响时具有不同的外观。这意味着区分这两种情况的一些标准： 
光源距离，阴影（将在第7章中讨论），表面是否背离光源（即表 
面法线n和光矢量之间的角度） l大于90.），或这些因素的某种 
组合。从二元存在或不存在光到连续光强度是一小步。这可以表示 
为缺席和完全存在之间的简单插值，这意味着强度的有界范围，可 
能是0到 1，或者是以某种其他方式影响着色的无界数量。后者的 
一个常见选项是将着色模型分解为亮起和不亮的部分，光强度 
klight线性缩放亮起的部分：cshaded =funlit （n，v）+klightflit 
 （l，n，v）。 （5.3）这很容易扩展到 RGB浅色，cshaded=funlit 
 （n，v）+clightflit （l，n，v）， （5.4）和多个光源，cshaded = 
----------------------- Page 129-----------------------
funlit （n，v）+Xn i =1clightiflit （li，n，v）。（5.5）未点亮 
部分funlit （n，v）对应于将光作为二进制处理的着色模型的 “不 
受光影响的外观”。它可以有各种形式，具体取决于所需的视觉风 
格和应用程序的需求。例如，funlit （）= （0,0,0）将导致任何不受 
光源影响的表面被着色为纯黑色。或者，未点亮的部分可以为未点 
亮的物体表现出某种形式的程式化外观，类似于Gooch模型的远离 
光线的表面的冷色。通常，阴影模型的这一部分表示某种形式的照 
明，其不直接来自明确放置的光源，例如来自天空的光或来自周围 
物体的光。这些其他形式的照明将在第 10章和第 11章中讨论。我 
们前面提到过，如果光的方向l大于90，光源不会影响表面点，从 
表面法线n开始，实际上来自 1085。着色基础图 5.4。上排图示出 
了表面上的光的横截面视图。在左边，光线直接撞击表面，在中心， 
它们以一定角度撞击表面，在右边，我们看到使用矢量点积来计算 
角度余弦。底部图显示了与整个表面相关的横截面平面（包括光矢 
和视图矢量）。在表面下面。这可以被认为是光的方向，相对于表 
面和它对阴影的影响之间更一般关系的特殊情况。虽然基于物理， 
但这种关系可以从简单的几何原理导出，并且对于许多类型的非基 
于物理的风格化着色模型也是有用的。光在表面上的影响可以看作 
一组光线，其中光线的密度击中表面对应于光强度以用于表面阴影 
目的。请参见图5.4，其中显示了亮面的横截面。沿着该横截面撞击 
表面的光线之间的间隔与 l和 n之间的角度的余弦成反比。因此， 
撞击表面的光线的总密度与 l和 n之间的角度的余弦成比例，正如 
----------------------- Page 130-----------------------
我们之前所见，这等于这两个单位长度矢量之间的点积。在这里， 
我们看到为什么定义与光的行进方向相反的光矢量 l是方便的。否 
则我们必须在执行点积之前否定它。更准确地说，光线密度（以及 
因此光对阴影的贡献）与点积相比是正的。负值对应于来自表面后 
面的光线，这些光线没有任何影响。因此，在将灯光阴影乘以照明 
点积之前，我们需要首先夹住点积 5.2。光源109到0.使用第 1.2 
节中介绍的x +表示法，这意味着将负值钳位为零，我们有cshaded 
=funlit （n，v）+Xni=1 （li·n）+clightiflit （li，n，v）。 （5.6） 
支持多个光源的着色模型通常使用公式5.5中的一个结构，这是更 
通用的，或公式5.6，这是物理模型所需的。对于风格化的模型也是 
有利的，因为它有助于确保照明的整体一致性，尤其是对于背离光 
线或被遮蔽的表面。但是，有些模型并不适合这种结构;这些模型将 
使用公式5.5中的结构。函数flit （）最简单的选择是使它成为一个 
恒定的颜色，flit ）（=csurface，（5.7）得到以下着色模型：cshaded 
=funlit （n，v）+Xn i =1 （li·n）+clighticsurface。（5.8）在 
1760年出版的Johann HeinrichLambert[967]之后，这个模型的 
被点亮的部分对应于 Lambertian着色模型！该模型适用于理想的 
漫反射表面，即完全无光泽的表面。我们在这里给出 Lambert模型 
的一些简化解释，第9章将更加严格地介绍 Lambertian模型可以 
单独用于简单着色，它是许多着色模型中的关键构建块。从方程 
5.3-5.6可以看出，光源通过两个参数与阴影模型相互作用：矢量l 
指向光和光色。存在各种不同类型的光源，其主要区别在于这两个 
----------------------- Page 131-----------------------
参数在场景中如何变化。接下来我们将讨论几种常见类型的光源， 
它们有一个共同点：在给定的表面位置，每个光源仅从一个方向l 
照亮表面。换句话说，从阴影表面位置看，光源是无限小的点。对 
于真实世界的灯来说，这并不严格，但是大多数光源相对于它们与 
照明表面的距离都很小，这使得这是一个合理的近似值。在7.1.2 
和 10.1节中，我们将讨论从一系列方向照亮表面位置的光源，即“区 
域光”.5.2.1定向光定向光是最简单的光源模型。l和clight在场景 
中都是恒定的，除了可以通过阴影衰减clight。定向灯1105.阴影 
基础没有位置。当然，实际光源确实在空间中具有特定位置。定向 
灯是抽象，当相对于场景大小的距离较大时，它可以很好地工作。 
例如，20英尺远的泛光灯照亮小桌面立体模型可以表示为定向光。 
另一个例子几乎是任何被太阳照射的场景，除非所讨论的场景是诸 
如太阳系内行星的东西。定向光的概念可以稍微扩展以允许在光方 
向l保持恒定的同时改变光线的值。出于性能或创造性的原因，这 
通常用于将光的效果限制到场景的特定部分。例如，一个区域可以 
定义为两个嵌套（一个在另一个内）的盒形体积，其中clight等于 
外部框外的 （0,0,0） （纯黑），等于内部的某个常数值内盒，并在 
两个盒子之间的区域中的那些极端之间平滑插值。5.2.2准时灯准时 
灯不是按时约会的灯，而是一个有定位灯的灯，与定向灯不同。与 
现实世界的光源不同，这种灯也没有尺寸，没有形状或尺寸。我们 
使用术语 “准时”，来自拉丁语punctus，意思是 “点”，用于由 
来自单个的所有光源组成的类，当地的位置。我们使用术语 “点光” 
----------------------- Page 132-----------------------
来表示一种特定类型的发射器，一种在所有方向上均匀照射光的发 
射器。因此，点和聚光灯是两种不同形式的准时光。光方向矢量 l 
根据当前阴影表面点p0相对于准点光的位置plight的位置而变化： 
l=plight。p0kplight。p0k。 （5.9）该等式是矢量归一化的示例： 
将矢量除以其长度以产生指向相同方向的单位长度矢量。这是另一 
种常见的着色操作，就像我们在上一节中看到的着色操作一样，它 
是大多数着色语言中的内置函数。但是，有时需要此操作的中间结 
果，这需要显式执行规范化，在多个步骤中，使用更多基本操作。 
将其应用于准时光方向计算给出了以下内容：d =困境。p0，r =√ 
d·d，l=dr。 （5.10）由于两个向量的点积等于两个向量长度与它 
们之间角度的余弦的乘积，并且余弦值为 1.0，因此点积为5.2。具 
有自身的矢量的光源 111是其长度的平方。因此，为了找到任何向 
量的长度，我们只需将其与自身对齐并取结果的平方根。我们需要 
的中间值是r，即准时光源和当前阴影点之间的距离。除了用于归一 
化光矢量之外，还需要 r的值来计算作为距离函数的光色度的衰减 
 （变暗）。这将在下一节中进一步讨论。点/全向灯在所有方向均匀 
发光的点光源称为点光源或全向灯。对于点光源，clight随距离r 
的变化而变化，唯一的变化源是上面提到的距离衰减。图5.5显示 
了为什么会出现这种变暗，使用类似的几何推理来证明图5.4中的 
余弦因子。在给定表面处，来自点光源的光线之间的间隔与从表面 
到光的距离成比例。与图5.4中的余弦因子不同，这种间距增加沿 
着表面的两个维度发生，因此光线密度（因此光色度）与反平方距 
----------------------- Page 133-----------------------
离1/ r2成比例。这使我们能够使用单个光属性clight0指定clight 
中的空间变化，clight0定义为固定参考距离r0处的clight值：clight 
 （r）=clight0？r0r？2。 （5.11）公式5.11通常被称为反方光衰 
减。虽然从技术上讲，点光源的距离衰减是正确的，但是有一些问 
题使得这个方程不太适合实际的阴影使用。第一个问题发生在相对 
较小的距离。当r的值趋于0时，clight的值将以无限的方式增加。 
当r达到0时，我们将得到一个被零除的奇点。为了解决这个问题， 
一个常见的修改是添加一个小值。到分母[861]：clight （r）=clight0 
r20r2+。。 （5.12）用于的确切值。取决于应用;例如，虚幻游戏 
引擎使用。=1厘米[861]。在CryEngine[1591]和 Frostbite[960] 
游戏引擎中使用的另一种修改是将 r钳制到最小值rmin：clight（r） 
=clight0？r0max （r，rmin）？2。（5.13）不像有点武断。在 
前一种方法中使用的值，rmin的值具有物理解释：发射光的物理对 
象的半径。r小于rmin的值对应于穿透物理光源内部的阴影表面， 
这是不可能的。1125.阴影基础图5.5。来自点光的光线之间的间隔 
与距离 r成比例地增加。由于间距增加发生在两个维度上，因此光 
线密度（以及因此光强度）与 1/ r2成比例地减小。相反，反方形 
衰减的第二个问题发生在相对较大的距离。问题不在于视觉效果， 
而在于性能。虽然光强度随着距离的增加而不断下降，但它永远不 
会变为0.为了有效渲染，希望光在某个有限距离内达到0强度（第 
20章）。有许多不同的方法可以修改反平方方程来实现这一点。理 
想情况下，修改应尽可能少地引入。为了避免在光影响的边界处的 
----------------------- Page 134-----------------------
急剧截止，还优选的是，修正函数的导数和值在相同距离处达到0。 
一种解决方案是将反平方方程乘以窗口函数乘以5.2。光源 11301 
234 5距离r0.00.20.40.60.8 1。0 r20/ （r2 +？）fwin （r） 
fwin （r）r20/ （r2+？）图5.6。该图显示了一个反平方曲线 （使 
用。方法避免奇点，其值为 1），公式5.14中描述的窗函数 （rmax 
设置为3）和窗口曲线。期望的属性。虚幻引擎[861]和 Frostbite 
[960]游戏引擎使用一个这样的函数[860]：fwin （r）=1。？rrmax？ 
4！+2。 （5.14）+2表示在将其平方后将该值 （如果为负）钳位为 
0。图5.6显示了一个反方形曲线示例，公式5.14中的加窗函数， 
以及两者相乘的结果。应用要求将影响所用方法的选择。例如，当 
在相对低的空间频率（例如，在光图或每顶点）中采样距离衰减函 
数时，在 rmax处具有等于0的导数是特别重要的。CryEngine不 
使用光照贴图或顶点照明，因此它采用更简单的调整，切换到 
0.8rmax和 rmax之间的线性衰减[1591]。1145.着色基础对于某 
些应用，匹配反平方曲线不是优先级，因此完全使用其他一些函数。 
这有效地将方程5.11-5.14推广到以下：clight （r）=clight0fdist 
 （r），（5.15）其中fdist （r）是距离的某个函数。这些功能称为 
距离衰减功能。在某些情况下，非逆平方衰减函数的使用受性能约 
束的驱动。例如，游戏JustCause2需要非常便宜的计算灯。这决 
定了一个易于计算的衰减函数，同时也足够平滑以避免每顶点光照 
伪影[1379]：fdist （r）=1。？rrmax？2！+2。（5.16）在其他 
情况下，可以通过创造性考虑来选择衰减函数。例如，用于逼真和 
----------------------- Page 135-----------------------
程式化游戏的虚幻引擎有两种光衰减模式：反方形模式，如公式5.12 
所述，以及指数衰减模式，可以调整以创建各种衰减曲线[1802]。 
游戏 “古墓丽影” （2013）的开发者使用样条编辑工具来创作衰减 
曲线[953]，从而可以更好地控制曲线形状。聚光灯与点光源不同， 
来自几乎所有现实世界光源的照明随方向和距离而变化。该变化可 
以表示为方向衰减函数fdir （1），其与距离衰减函数组合以定义光 
强度的整体空间变化：clight =clight0fdist （r）fdir （l）。 （5.17） 
fdir （l）的不同选择可以产生各种照明效果。一种重要的效果是聚 
光灯，它将光投射到圆锥体中。聚光灯的方向衰减函数具有围绕聚 
光灯方向矢量s的旋转对称性，因此可以表示为s与反转光矢量.1 
之间的角度θs到表面的函数。光矢量需要反转，因为我们在表面定 
义 l指向光，在这里我们需要指向远离光线的矢量。大多数聚光灯 
函数使用由θs的余弦组成的表达式， （如前所述）是阴影中角度最 
常见的形式。聚光灯通常具有本影角θu，其限制光，使得对于所有 
θs≥θu，fdir （l）=0。该角度可用于以与先前所见的最大衰减距离 
rmax类似的方式进行剔除。聚光灯通常具有半影角θp，其限定了 
光锥处于其全强度的内锥。见图5.7。5.2。光源115s-lquqpqs 
图5.7。聚光灯：θs是从光的定义方向s到矢量.1的角度，即到表 
面的方向;θp表示半影;θu表示为光定义的本影角。各种方向衰减 
函数用于聚光灯，但它们往往大致相似。例如，函数fdirF （l）用于 
Frostbite游戏引擎[960]，函数fdirT （l）用于three.js浏览器图形 
库[218]：t =？cosθs。cosθucosθp。cosθu？+，fdirF （l）=t2， 
----------------------- Page 136-----------------------
fdirT （l）=smoothstep （t）=t2 （3.2t）。 （5.18）回想一下x + 
是我们将x钳位在0和 1之间的符号，如 1.2节所述。smoothstep 
函数是一个三次多项式，通常用于着色中的平滑插值。它是大多数 
着色语言中的内置函数。图 5.8显示了我们到目前为止讨论过的一 
些灯光类型。图5.8。某些类型的灯。从左到右：方向，点光源没有 
衰减，聚光灯平滑过渡。请注意，由于光线与表面之间的角度变化， 
点光源会朝向边缘变暗。1165.阴影基础其他准时灯还有许多其他 
方法可以使准时光的亮度值发生变化。fdir （l）函数不限于上面讨 
论的简单聚光灯衰减函数; 它可以表示任何类型的方向变化，包括从 
真实世界光源测量的复杂表格模式。照明工程学会 （IES）为此类测 
量定义了标准文件格式。IES配置文件可从许多照明制造商处获得， 
并已用于游戏Killzone：ShadowFall[379,380]，以及Unreal[861] 
和 Frostbite[960]游戏引擎等。Lagarde给出了与解析和使用此文 
件格式相关的问题的总结[961]。游戏古墓丽影（2013）[953]有一 
种准点光，它对沿x，y和z世界轴的距离应用独立的衰减函数。在 
古墓丽影中，还可以应用曲线随时间改变光强度，例如，以产生闪 
烁的火炬。在6.9节中，我们将讨论如何通过使用纹理来改变光强 
度和颜色。5.2.3其他光类型方向光和准时光的主要特征在于如何计 
算光方向l。通过使用其他方法来计算光方向，可以定义不同类型的 
灯。例如，除了前面提到的灯光类型之外，古墓丽影也有胶囊灯， 
它使用线段作为源而不是点[953]。对于每个阴影像素，线段上最近 
点的方向用作光方向 l。只要着色器具有用于评估着色方程的l和 
----------------------- Page 137-----------------------
clight值，就可以使用任何方法来计算这些值。到目前为止讨论的 
光的类型是抽象。实际上，光源具有尺寸和形状，并且它们从多个 
方向照射表面点。在渲染中，这种灯被称为区域灯，并且它们在实 
时应用中的使用正在稳步增加。区域光渲染技术分为两类：模拟由 
区域光部分遮挡产生的阴影边缘软化（第7.1.2节）和模拟区域光 
对表面阴影的影响（第 10.1节） 。第二类照明对于光滑的镜面表 
面最为明显，其中光的形状和大小可以在其反射中清晰地辨别。定 
向和准时灯不太可能被废弃，尽管它们不再像过去那样普遍存在。 
已经开发了考虑光区域的近似值，其实现起来相对便宜，因此可以 
看到更广泛的用途。GPU性能的提高还允许比过去更精细的技术。 
5.3。实现着色模型 1175.3实现着色模型为了有用，这些着色和光 
照方程当然必须在代码中实现。在本节中，我们将讨论设计和编写 
此类实现的一些关键注意事项。我们还将介绍一个简单的实现示例。 
5.3。1评估频率在设计着色实现时，需要根据评估频率对计算进行 
划分。首先，确定给定计算的结果在整个绘制调用中是否总是恒定 
的。在这种情况下，计算可以由应用程序执行，通常在CPU上执行， 
尽管GPU计算着色器可以用于特别昂贵的计算。结果通过统一着色 
器输入传递给图形API。即使在这一类别中，也有很多可能的评估 
频率，从 “曾经”开始。最简单的情况是阴影方程中的常数子表达 
式，但这可以适用于基于很少变化因素的任何计算。作为硬件配置 
和安装选项。在编译着色器时可以解决这种着色计算，在这种情况 
下，甚至不需要设置均匀的着色器输入。或者，可以在离线预计算 
----------------------- Page 138-----------------------
过程中，在安装时或在加载应用程序时执行计算。另一种情况是着 
色计算的结果在应用程序运行时发生变化，但是如此缓慢以至于不 
需要每帧更新它。例如，取决于虚拟游戏世界中的时间的照明因素。 
如果计算成本很高，则可能需要在多个帧上分摊它。其他情况包括 
每帧执行一次的计算，例如连接视图和透视矩阵;或每个模型一次， 
例如更新依赖于位置的模型照明参数;或每次抽奖一次，例如，更新 
模型中每种材料的参数。按评估频率对统一着色器输入进行分组对 
于应用效率很有用，并且还可以通过最小化不断更新来帮助GPU性 
能[1165]。如果着色计算的结果在绘制调用中发生更改，则无法通 
过统一着色器输入将其传递给着色器。相反，它必须由第3章中描 
述的一个可编程着色器阶段计算，如果需要，可以通过不同的着色 
器输入传递到其他阶段。理论上，阴影计算可以在任何可编程级上 
执行，每个可编程级对应于不同的评估频率：。顶点着色器 - 每个 
预镶嵌顶点的评估。。船体着色器 - 每个表面贴片的评估。。域着 
色器 - 每个后镶嵌顶点的评估。1185。着色基础图5.9。对于来 
自公式5.19的示例着色模型​ ​ 的每像素和每顶点评估的比较，在 
三种不同顶点密度模型上显示。左列显示每像素评估的结果，中间 
列显示每顶点评估，右列显示每个模型的线框渲染以显示顶点密度。 
 （来自ComputerGraphicsArchive [1172]的中国龙网，来自斯坦 
福3D扫描库的原始模型。）。几何着色器 - 每个基元的评估。。 
像素着色器 - 每像素评估。实际上，每个像素执行大多数着色计算。 
虽然这些通常在像素着色器中实现，但计算着色器实现越来越常 
----------------------- Page 139-----------------------
见;几个例子将在第20章中讨论。其他阶段主要用于几何操作，例 
如变形和变形。为了理解这种情况的原因，我们将比较每顶点和每 
像素着色评估的结果。在较早的文本中，这些有时分别被称为 
Gouraud阴影[578]和 Phong阴影[1414]，尽管这些术语今天不常 
使用。此比较使用的阴影模型与公式 5.1中的阴影模型有些相似， 
但经过修改后可与多个光源配合使用。稍后我们将详细介绍示例实 
现，稍后将给出完整模型。图 5.9显示了具有多种顶点密度的模型 
上的每像素和每顶点着色的结果。对于龙，一个非常密集的网格， 
两者之间的差异很小。但是在茶壶上，顶点着色评估会导致可见错 
误，例如角度形状的高光，而在双三角平面上，顶点阴影版本显然 
不正确。这些误差的原因是阴影方程的一部分，特别是突出显示， 
具有在5.3上非线性变化的值。实施着色模型 119图5.10。在左侧， 
我们看到表面上单位法线的线性插值导致长度小于 1的插值向量。 
在右侧，我们看到具有显着不同长度的法线的线性插值导致内插方 
向偏向两个法线中的较长者。网格表面。这使得它们不适合顶点着 
色器，其结果在被馈送到像素着色器之前在三角形上线性插值。原 
则上，可以仅在像素着色器中计算着色模型的镜面高光部分，并在 
顶点着色器中计算其余部分。这可能不会导致视觉伪像，理论上可 
以节省一些计算。实际上，这种混合实现通常不是最佳的。着色模 
型的线性变化部分往往计算成本最低，并且以这种方式分割着色计 
算往往会增加足够的开销，例如重复计算和额外变化的输入，以超 
过任何好处。正如我们前面提到的，在大多数实现中，顶点着色器 
----------------------- Page 140-----------------------
负责非着色操作，例如几何变换和变形。得到的几何表面属性，转 
换为适当的坐标系，由顶点着色器写出，在三角形上线性插值，并 
作为变化的着色器输入传递到像素着色器。如果需要进行法线贴图， 
这些属性通常包括曲面的位置，曲面法线和可选的曲面切线矢量。 
请注意，即使顶点着色器始终生成单位长度曲面法线，插值也可以 
更改其长度。见图5.10的左侧。因此，需要在像素着色器中将法线 
重新规范化（缩放为长度为 1）。但是，顶点着色器生成的法线长 
度仍然很重要。如果正常长度在顶点之间显着变化，例如，作为顶 
点混合的副作用，则这将使插值偏斜。这可以在图5.10的右侧看到。 
由于这两种影响，实现通常在插值之前和之后归一化插值矢量，即， 
在顶点和像素着色器中。与表面法线不同，指向特定位置的矢量 （例 
如视图矢量和准时光的光矢量）通常不进行插值。相反，插值表面 
位置用于在像素着色器中计算这些矢量。除了标准化之外，正如我 
们所见，在任何情况下都需要在像素着色器中执行，这些向量中的 
每一个都是用向量减法计算的，这是快速的。如果由于某种原因需 
要插入这些 1205.阴影基础图5.11。两个光矢量之间的插值。在左 
侧，插值前对它们进行标准化会导致插值后方向不正确。在右边， 
内插非标准化向量产生正确的结果。向量，不要事先规范化它们。 
这将产生不正确的结果，如图5.11所示。之前我们提到过顶点着色 
器将表面几何体转换为 “适当的坐标系”。通过均匀变量传递给像 
素着色器的相机和光源位置通常由应用程序转换到相同的坐标系 
中。这最大限度地减少了像素着色器完成的工作，使所有着色模型 
----------------------- Page 141-----------------------
向量进入相同的坐标空间。但哪个坐标系是 “合适的”呢？可能性 
包括全球世界空间以及相机的局部坐标系，或者更少见的是当前渲 
染模型的坐标系。通常选择渲染系统作为整体，基于系统考虑因素， 
如性能，灵活性和简单性。例如，如果渲染场景预计包含大量灯光， 
则可以选择世界空间以避免变换灯光位置。或者，相机空间可能是 
首选，以更好地优化与视图矢量相关的像素着色器操作，并可能提 
高精度 （第 16.6节）。虽然大多数着色器实现，包括我们即将讨论 
的示例实现，但遵循上述大纲，但肯定有例外。例如，某些应用程 
序出于风格原因选择了perprimitive阴影评估的多面外观。这种风 
格通常被称为平面阴影。两个例子如图5.12所示。原则上，可以在 
几何着色器中执行平面着色，但最近的实现通常使用顶点着色器。 
这是通过将每个图元的属性与其第一个顶点相关联并禁用顶点值插 
值来完成的。禁用插值（可以分别对每个顶点值进行插值）会使第 
一个顶点的值传递给基元中的所有像素。5.3.2实现示例现在我们将 
介绍一个示例着色模型​ ​ 实现。如前所述，我们实现的着色模型 
类似于5.3中的扩展Gooch模型。实施着色模型 121图5.12。两 
款使用平面阴影作为风格选择的游戏：肯塔基零号线，顶级和那个 
龙，巨蟹座，底部。 （上图由CardboardComputer提供，较低的 
NuminousGames礼貌。）公式5。1，但修改为与多个光源一起 
工作。它由cshaded =12ccool +Xn i =1 （li·n）+clighti...si 
chighlight + （1.si）cwarm描述？， （5.19）1225.使用以下中间 
计算着色基础：ccool = （0,0,0.55）+0.25 csurface，cwarm = 
----------------------- Page 142-----------------------
 （0.3,0.3,0）+0.25csurface，chighlight = （2,2,2），ri=2 （n·li） 
n。li，si =.. 100 （ri·v）。97？+。（5.20）该公式适合公式5.6 
中的多光结构，为方便起见，这里重复：cshaded =funlit （n，v） 
+Xn i =1 （li·n）+clightiflit （li，n，v）。在这种情况下，点亮 
和不亮的术语是funlit （n，v）=12ccool，flit （li，n，v）=si 
chighlight + （1.si）cwarm， （5.21），冷色调的未点亮贡献调整 
为使结果看起来更像原始方程式。在大多数典型的渲染应用中材料 
属性（如csurface）的变化值将存储在顶点数据中，或者更常见地 
存储在纹理中（第6章）。但是，为了使这个示例实现简单，我们 
假设csurface在整个模型中是恒定的。此实现将使用着色器的动态 
分支功能来遍历所有光源。虽然这种简单的方法可以很好地适用于 
相当简单的场景，但它不能很好地适应具有许多光源的大型和几何 
复杂场景。第20章将介绍有效处理大光数的渲染技术。另外，为简 
单起见，我们只支持一种光源：点光源。虽然实现非常简单，但它 
遵循前面介绍的最佳实践。着色模型不是孤立实现的，而是在较大 
的渲染框架的上下文中实现的。此示例在一个简单的WebGL 2应 
用程序中实现，该应用程序由 Tarek Sherif [1623] 的 
 “Phong-shadedCube”WebGL2样本修改，但同样的原则也适 
用于更复杂的框架。我们将从应用程序中讨论一些GLSL着色器代 
码和JavaScript WebGL调用的示例。目的不是教授WebGL API 
的细节，而是展示一般实现原则。我们将以 “由内向外”的顺序进 
行实现，从像素着色器开始，然后是顶点着色器，最后是应用程序 
----------------------- Page 143-----------------------
端图形API调用。在着色器代码正确之前，着色器源包括着色器输 
入和输出的定义。如前面第3.3节所述，使用GLSL术语，5.3。实 
现着色模型 123着色器输入分为两类。一个是一组统一输入，它们 
具有由应用程序设置的值，并且在绘制调用中保持不变。第二种类 
型由不同的输入组成，这些输入具有可在着色器调用 （像素或顶点） 
之间更改的值。在这里，我们看到像素着色器的变化输入的定义， 
它们在GLSL中被标记，以及它的输出：在vec3vPos 中;在vec3 
vNormal; outvec4 outColor;此像素着色器具有单个输出，这是 
最终的阴影颜色。像素着色器输入匹配顶点着色器输出，这些输出 
在馈入像素着色器之前在三角形上进行插值。这个像素着色器有两 
个不同的输入：表面位置和表面法线，两者都在应用程序的世界空 
间坐标系中。均匀输入的数量要大得多，因此为简洁起见，我们只 
显示两个与光源相关的定义：structLight{vec4position;vec4颜 
色;};统一LightUBlock{LightuLights[MAXLIGHTS];};统一uint 
uLightCount;由于这些是点光源，因此每个点的定义包括位置和颜 
色。这些被定义为vec4而不是vec3，以符合GLSLstd140数据布 
局标准的限制。虽然，在这种情况下，std140布局可能会导致一些 
浪费的空间，但它简化了确保CPU和GPU之间一致数据布局的任 
务，这就是我们在此示例中使用它的原因。Light结构数组在命名的 
统一块内定义，这是一个GLSL功能，用于将一组统一变量绑定到 
缓冲区对象，以实现更快的数据传输。数组长度定义为等于应用程 
序在单次绘制调用中允许的最大灯数。正如我们稍后将看到的，应 
----------------------- Page 144-----------------------
用程序在着色器编译之前用正确的值 （在本例中为 10）替换着色器 
源中的 MAXLIGHTS字符串。统一整数uLightCount是绘制调用 
中的实际活动灯数。接下来，我们将看一下像素着色器代码：vec3lit 
 （vec3l，vec3n，vec3v）{vec3r_l=reflect （-l，n）;floats= 
clamp （100.0*dot （r_l，v）-97.0,0.0,1.0）;vec3highlightColor 
=vec3 （2,2,2）; returnmix（uWarmColor，highlightColor，s）;} 
void main （）{vec3 n = normalize （vNormal）; vec3 v = 
normalize uEyePosition（ .xyz-vPos）; 1245。着色基础outColor 
=vec4 （uFUnlit，1.0）;for （uinti=0u;i<uLightCount;i++） 
{vec3l=normalize uLights（ [i].position。xyz -vPos）;floatNdL 
=clamp （dot （n，l），0.0,1.0）;outColor。rgb+=NdL*uLights 
[i]。颜色。rgb* lit （l，n，v）;我们有一个点亮术语的函数定义， 
由main （）函数调用。总的来说，这是方程5.20和 5.21的简单 
GLSL实现。请注意，funlit （）和cwarm的值作为统一变量传递。 
由于这些在整个绘制调用中是恒定的，因此应用程序可以计算这些 
值，从而节省一些GPU周期。此像素着色器使用多个内置GLSL函 
数。reflect （）函数在由第二矢量定义的平面中反射一个矢量，在 
这种情况下是光矢量，在这种情况下是表面法线。由于我们希望光 
矢量和反射矢量都指向远离表面，我们需要在将它传递给reflect（） 
之前否定前者。clamp （）函数有三个输入。其中两个定义了第三 
个输入被钳位的范围。在大多数GPU上，钳位到0到 1之间的范 
围 （对应于 HLSL饱和 （）函数）的特殊情况很快，通常是有效的。 
----------------------- Page 145-----------------------
这就是为什么我们在这里使用它，虽然我们只需要将值钳位到0， 
因为我们知道它不会超过1.函数mix （）也有三个输入并在两个输 
入之间进行线性插值，暖色和在这种情况下，基于第三个值，在0 
和 1之间的混合参数突出显示颜色。在 HLSL中，此函数称为lerp 
 （），用于“线性插值”。最后，normalize （）将矢量除以其长 
度，将其缩放为长度 1.现在让我们看一下顶点着色器。我们不会显 
示任何统一定义，因为我们已经看到了像素着色器的一些示例统一 
定义，但是变化的输入和输出定义值得检查：vec4位置的布局 （位 
置=0）;vec4normal中的layout （location=1）;vec3vPos; out 
vec3vNormal;请注意，如前所述，顶点着色器输出与像素着色器 
变化输入相匹配。输入包括指定如何在顶点数组中布置数据的指令。 
接下来是顶点着色器代码：void main （）{vec4worldPosition = 
uModel * position; vPos = worldPosition。XYZ; vNormal = 
 （uModel * normal ） .xyz; gl_Position = viewProj * 
worldPosition;这些是顶点着色器的常见操作。着色器将表面位置 
和法线转换为世界空间，并将它们传递给像素着色器5.3。实现着色 
模型 125以用于着色。最后，曲面位置被转换为剪辑空间并传递到 
gl Position，这是一个由光栅化器使用的特殊系统定义变量。gl 
Position变量是任何顶点着色器所需的输出。请注意，法线向量在 
顶点着色器中未标准化。它们不需要标准化，因为它们在原始网格 
数据中的长度为 1，并且此应用程序不执行任何操作，例如顶点混 
合或非均匀缩放，这可能会不均匀地改变它们的长度。模型矩阵可 
----------------------- Page 146-----------------------
以具有统一的比例因子，但这会按比例改变所有法线的长度，因此 
不会导致图5.10右侧所示的问题。该应用程序使用WebGLAPI进 
行各种渲染和着色器设置。每个可编程着色器阶段都是单独设置的， 
然后它们都绑定到程序对象。这是像素着色器设置代码：var 
fSource =document。getElementById （“fragment”）。文 
字。trim （）;var maxLights =10;fSource =fSource。replace 
 （/ MAXLIGHTS / g ，maxLights。toString （））; var 
fragmentShader  =     gl   。     createShader 
 （ gl.FRAGMENT_SHADER ） ; 冰 川    shaderSource 
 （fragmentShader ， fSource ） ; 冰 川 compileShader 
 （fragmentShader）;请注意“片段着色器”引用。该术语由WebGL 
 （以及它所基于的OpenGL）使用。正如本书前面所述，虽然 “像 
素着色器”在某些方面不太精确，但它是我们在本书中遵循的更常 
见的用法。此代码也是用适当的数值替换 MAXLIGHTS字符串的地 
方。大多数渲染框架执行类似的预编译着色器操作。有更多应用程 
序端代码用于设置制服，初始化顶点数组，清除，绘图等，您可以 
在程序[1623]中查看这些代码，并由许多API指南解释。我们的目 
标是通过自己的编程环境，了解着色器如何被视为独立的处理器。 
因此，我们在此时结束了我们的演练。5.3.3材质系统渲染框架很少 
只实现一个着色器，就像我们的简单示例一样。通常，需要专用系 
统来处理各种材料，着色模型和应用程序使用的着色器。如前面章 
节中所述，着色器是GPU的可编程着色器阶段之一的程序。因此， 
----------------------- Page 147-----------------------
它是一种低级图形API资源，而不是艺术家直接交互的东西。相比 
之下，材料是面向艺术家的表面视觉外观的封装。材料有时也描述 
非视觉方面，例如碰撞属性，我们不会进一步讨论，因为它们超出 
了本书的范围。1265.着色基础虽然材质是通过着色器实现的，但 
这并不是简单的一对一对应。在不同的渲染情况下，相同的材质可 
能使用不同的着色器。着色器也可以由多种材质共享。最常见的情 
况是参数化材料。在最简单的形式中，材料参数化需要两种类型的 
材料实体：材料模板和材料实例。每个材质模板都描述了一类材质， 
并且具有一组参数，可以根据参数类型为其分配数值，颜色或纹理 
值。每个材质实例对应于材质模板以及其所有参数的特定值集。一 
些渲染框架（例如虚幻引擎[1802]）允许更复杂的分层结构，其中 
材料模板来自多个级别的其他模板。参数可以在运行时通过将统一 
输入传递到着色器程序来解析，或者在编译时通过在编译着色器之 
前替换值来解析。常见类型的编译时参数是一个布尔开关，用于控 
制给定材料特征的激活。这可以由艺术家通过材料用户界面中的复 
选框或材料系统的程序设置，例如，以降低特征的视觉效果可忽略 
的远距离物体的着色器成本。虽然材料参数可以与着色模型的参数 
一一对应，但情况并非总是如此。材质可以将给定着色模型参数 （例 
如表面颜色）的值固定为常数值。或者，可以计算着色模型参数作 
为复杂系列操作的结果，其中多个材料参数以及内插顶点或纹理值 
作为输入。在某些情况下，参数如表面位置，表面方向，甚至时间 
也可能影响计算。基于表面位置和方向的阴影在地形材料中尤为常 
----------------------- Page 148-----------------------
见。例如，高度和表面法线可用于控制雪效果，在高海拔水平和几 
乎水平的表面上以白色表面颜色混合。基于时间的着色在动画材质 
中很常见，例如闪烁的霓虹灯。材料系统最重要的任务之一是将各 
种着色器功能划分为单独的元素并控制它们的组合方式。在许多情 
况下，这种类型的组合物是有用的，包括以下内容：。使用几何处 
理组合表面着色，例如刚性变换，顶点混合，变形，镶嵌，实例化 
和裁剪。这些功能位置各不相同：表面着色取决于材质，几何处理 
取决于网格。因此，可以方便地单独创作它们，并根据需要将材料 
系统组合起来。。使用像素丢弃和混合等合成操作组合表面着色。 
这与移动GPU尤其相关，其中混合通常在像素着色器中执行。通常 
希望独立于用于表面着色的材料来选择这些操作。5.3。实施着色模 
型 127。通过计算着色模型本身来计算用于计算着色模型参数的操 
作。这允许一次创作着色模型实现并且将其与用于计算着色模型参 
数的各种不同方法结合使用。。相互独立地选择材料特征，选择逻 
辑和着色器的其余部分。这使得能够单独编写每个功能的实现。。 
通过光源评估来组成着色模型并计算其参数：计算每个光源的阴影 
点处的clight和l的值。诸如延迟渲染 （在第20章中讨论）之类的 
技术改变了这种组合的结构。在渲染支持多种此类技术的框架中， 
这会增加额外的复杂性。如果图形API提供这种类型的着色器代码 
模块化作为核心特征将是方便的。遗憾的是，与CPU代码不同， 
GPU着色器不允许代码片段的后编译链接。每个着色器阶段的程序 
编译为一个单元。着色器阶段之间的分离确实提供了一些有限的模 
----------------------- Page 149-----------------------
块化，这有点适合我们列表中的第一项：使用几何处理（通常在其 
他着色器阶段中执行）组合表面着色 （通常在像素着色器中执行）。 
但是拟合并不完美，因为每个着色器也执行其他操作，并且仍然需 
要处理其他类型的合成。鉴于这些限制，材料系统实现所有这些类 
型组合的唯一方法是在源代码级别。这主要涉及字符串操作，例如 
连接和替换，通常通过C风格的预处理指令执行，例如＃include， 
＃if和#define。早期的渲染系统具有相对较少的着色器变体，并 
且这有点适合我们列表中的第一项：使用几何处理 （通常在其他着 
色器阶段中执行）组合表面着色（通常在像素着色器中执行）。但 
是拟合并不完美，因为每个着色器也执行其他操作，并且仍然需要 
处理其他类型的合成。鉴于这些限制，材料系统实现所有这些类型 
组合的唯一方法是在源代码级别。这主要涉及字符串操作，例如连 
接和替换，通常通过C风格的预处理指令执行，例如＃include，＃ 
if和#define。早期的渲染系统具有相对较少的着色器变体，并且这 
有点适合我们列表中的第一项：使用几何处理（通常在其他着色器 
阶段中执行）组合表面着色（通常在像素着色器中执行）。但是拟 
合并不完美，因为每个着色器也执行其他操作，并且仍然需要处理 
其他类型的合成。鉴于这些限制，材料系统实现所有这些类型组合 
的唯一方法是在源代码级别。这主要涉及字符串操作，例如连接和 
替换，通常通过C风格的预处理指令执行，例如＃include，＃if和 
#define。早期的渲染系统具有相对较少的着色器变体，并且使用 
几何处理（通常在其他着色器阶段中执行）组合表面着色（通常在 
----------------------- Page 150-----------------------
像素着色器中执行）。但是拟合并不完美，因为每个着色器也执行 
其他操作，并且仍然需要处理其他类型的合成。鉴于这些限制，材 
料系统实现所有这些类型组合的唯一方法是在源代码级别。这主要 
涉及字符串操作，例如连接和替换，通常通过C风格的预处理指令 
执行，例如＃include，＃if和#define。早期的渲染系统具有相对 
较少的着色器变体，并且使用几何处理 （通常在其他着色器阶段中 
执行）组合表面着色（通常在像素着色器中执行）。但是拟合并不 
完美，因为每个着色器也执行其他操作，并且仍然需要处理其他类 
型的合成。鉴于这些限制，材料系统实现所有这些类型组合的唯一 
方法是在源代码级别。这主要涉及字符串操作，例如连接和替换， 
通常通过 C 风格的预处理指令执行，例如＃include，＃if和 
#define。早期的渲染系统具有相对较少的着色器变体，并且其他 
类型的成分仍然需要处理。鉴于这些限制，材料系统实现所有这些 
类型组合的唯一方法是在源代码级别。这主要涉及字符串操作，例 
如连接和替换，通常通过C风格的预处理指令执行，例如＃include， 
＃if和#define。早期的渲染系统具有相对较少的着色器变体，并 
且其他类型的成分仍然需要处理。鉴于这些限制，材料系统实现所 
有这些类型组合的唯一方法是在源代码级别。这主要涉及字符串操 
作，例如连接和替换，通常通过C风格的预处理指令执行，例如＃ 
include，＃if和#define。早期的渲染系统具有相对较少的着色器 
变体，并且通常每个都是手动编写的。这有一些好处。例如，可以 
在完全了解最终着色器程序的情况下优化每个变体。然而，随着变 
----------------------- Page 151-----------------------
体数量的增加，这种方法很快变得不切实际。在考虑所有不同的部 
件和选项时，可能的不同着色器变体的数量是巨大的。这就是模块 
化和可组合性如此重要的原因。设计用于处理着色器变体的系统时 
要解决的第一个问题是，是否在运行时通过动态分支执行选择，或 
者在编译时通过条件预处理执行。在较旧的硬件上，动态分支通常 
是不可能的或非常慢，因此运行时选择不是一种选择。然后在编译 
时处理变体，包括不同光类型的计数的所有可能组合[1193]。相比 
之下，当前的GPU可以很好地处理动态分支，尤其是当绘制调用中 
的所有像素的分支行为相同时。今天，许多功能变化，例如灯的数 
量，都是在运行时处理的。然而，向着色器添加大量功能变化会产 
生不同的成本：寄存器数量的增加和占用率的相应降低，从而性能 
降低。1285.着色基础有关更多详细信息，请参见第 18.4.5节。因 
此，编译时变化仍然很有价值。它避免包含永远不会执行的复杂逻 
辑。举个例子，让我们设想一个支持三种不同类型灯光的应用程序。 
两种灯类型很简单：点和方向。第三种类型是广义聚光灯，支持列 
表照明模式和其他复杂功能，需要大量的着色器代码才能实现。然 
而，假设普遍的聚光灯使用相对较少，应用中不到5％的灯是这种 
类型。在过去，将针对三种光类型的每种可能的计数组合编译单独 
的着色器变体，以避免动态分支。虽然今天不需要这样，但是编译 
两个单独的变体仍然是有益的，一个用于广义聚光灯的计数等于或 
大于 1的情况，一个用于这种光的计数正是如此的情况。 0.由于代 
码更简单，第二种变体（最常用）可能具有较低的寄存器占用率， 
----------------------- Page 152-----------------------
从而具有较高的性能。现代材料系统采用运行时和编译时着色器变 
体。尽管仅在编译时不再处理完全负担，但总体复杂性和变体数量 
仍在增加，因此仍需要编译大量着色器变体。例如，在 Destiny： 
TheTaken King游戏的某些区域中，在单个帧中使用了超过9000 
个编译的着色器变体[1750]。可能的变化的数量可以更大，例如， 
Unity渲染系统具有具有接近 1000亿可能变体的着色器。仅编译实 
际使用的变体，但必须重新设计着色器编译系统以处理大量可能的 
变体[1439]。材料系统设计人员采用不同的策略来解决这些设计目 
标。虽然这些有时被呈现为互斥的系统架构[342]，但这些策略可以 
- 并且通常在同一系统中组合。这些策略包括以下内容：。代码重 
用 - 在共享文件中实现函数，使用#include预处理程序指令从任 
何需要它们的着色器访问这些函数。。Subtractive-A着色器，通 
常称为 “整形器”或 “超级变形器”[1170,1784]，它聚合了大量功 
能，使用编译时预处理器条件和动态分支的组合来删除未使用的部 
件并在互斥的备选之间切换。。添加剂 - 各种功能位被定义为具有 
输入和输出连接器的节点，这些是一起组成的。这类似于代码重用 
策略，但更具结构性。节点的组成可以通过文本[342]或可视化图形 
编辑器完成。后者旨在使非工程师（如技术艺术家）更容易创作新 
的材料模板[1750,1802]。通常，只有部分着色器可供可视图形创作 
使用。例如，在虚幻引擎中，图形编辑器只能影响着色模型输入的 
计算[1802]。见图5.13。5.3。实施着色模型129图5.13。虚幻引 
擎材质编辑器。请注意节点图右侧的高节点。此节点的输入连接器 
----------------------- Page 153-----------------------
对应于渲染引擎使用的各种着色输入，包括所有着色模型参数。（材 
料样本由 EpicGames提供。）。基于模板 - 定义了一个接口，只 
要它们符合该接口，就可以插入不同的实现。这比添加策略更正式， 
通常用于更大的功能块。这种界面的一个常见例子是着色模型参数 
的计算与着色模型本身的计算之间的分离。虚幻引擎[1802]具有不 
同的 “材料域”，包括用于计算着色模型参数的Surface域和用于 
计算调制给定光源的clight的标量值的LightFunction域。Unity 
[1437]中也存在类似的 “表面着色器”结构。请注意，延迟着色技 
术（在第20章中讨论）强制执行类似的结构，G缓冲区用作接口。 
对于更具体的示例，（现在免费）的书籍WebGL Insights [301] 
中的几个章节讨论了各种引擎如何控制着色器管道。除了组合之外， 
现代材料系统还有其他几个重要的设计考虑因素，例如需要支持多 
个平台，并且着色器代码重复最少。这包括功能的变化，以考虑平 
台，着色语言和API之间的性能和功能差异。命运着色器系统[1750] 
是这类问题的代表性解决方案。它使用专有的预处理器层，该层使 
用自定义着色语言方言编写着色器。这允许编写与平台无关的材料， 
并自动转换为不同的着色语言和实现。虚幻引擎[1802]和 Unity 
[1436]具有类似的系统。1305.底纹基础材料系统还需要确保良好 
的性能。除了专门编辑着色变体外，还有一些其他常见的优化材料 
系统可以执行。Destiny着色器系统和虚幻引擎自动检测绘制调用 
中的常量计算（例如早期实现示例中的暖色和冷色计算），并将其 
移出着色器。另一个例子是 Destiny中使用的范围系统，用于区分 
----------------------- Page 154-----------------------
以不同频率更新的常数（例如，每帧一次，每次一次，每个对象一 
次），并在适当的时间更新每组常量以减少API开销。正如我们所 
看到的，实现着色方程是决定哪些部分可以简化，计算各种表达的 
频率，以及用户如何修改和控制外观的问题。渲染管道的最终输出 
是颜色和混合值。抗锯齿，透明度和图像显示的其余部分详细说明 
了如何组合和修改这些值以供显示。5.4混叠和抗锯齿想象一个大的 
黑色三角形在白色背景中缓慢移动。当屏幕网格单元被三角形覆盖 
时，表示该单元的像素值应该在强度上平滑地下降。在各种基本渲 
染器中经常发生的事情是，在网格单元的中心被覆盖的那一刻，像 
素颜色立即从白色变为黑色。标准GPU渲染也不例外。请参见图 
5.14的最左侧一栏。三角形以像素显示为存在或不存在。绘制的线 
条有类似的问题。由于这个原因，边缘有锯齿状的外观，所以这种 
视觉神器被称为 “锯齿”，在动画时会变成 “爬行动物”。更正式 
地说，这个问题被称为别名，而避免它的努力被称为抗锯齿技术。 
抽样理论和数字滤波的主题足以填补自己的书[559,1447,1729]。由 
于这是渲染的关键领域，因此将提出采样和滤波的基本理论。然后， 
我们将关注当前可以实时完成的工作以减轻混叠伪像。5.4.1采样和 
滤波理论渲染图像的过程本质上是一个采样任务。这是因为图像的 
生成是对三维场景进行采样以便获得图像中的每个像素（离散像素 
阵列）的颜色值的过程。要使用纹理映射（第6章），必须对纹素 
进行重新采样，以便在不同条件下获得良好的结果。为了在动画中 
生成图像序列，通常以均匀的时间间隔对动画进行采样。本节介绍 
----------------------- Page 155-----------------------
了采样，重建和过滤的主题。为简单起见，大多数材料为5.4。别名 
和抗锯齿 131图5.14。上排显示三个图像，其具有三角形，线条和 
一些点的不同抗锯齿水平。下排图像是上排的放大倍数。最左边的 
列每个像素只使用一个样本，这意味着不使用抗锯齿。中间列图像 
用每个像素四个样本（以网格图案）渲染，右列每个像素使用八个 
样本 （在4×4棋盘中，一半采样的样本）。以一个维度呈现。这些 
概念也自然地扩展到两个维度，因此可以在处理二维图像时使用。 
图5.15显示了如何以均匀间隔的间隔对连续信号进行采样，即离散 
化。此抽样过程的目标是以数字方式表示信息。这样做可以减少信 
息量。但是，需要重建采样信号以恢复原始信号。这是通过对采样 
信号进行滤波来完成的。无论何时完成采样，都可能出现混叠。这 
是一个不需要的工件，我们需要对抗锯齿以产生令人愉悦的图像。 
在旧西部片中看到的一个典型的混叠示例是由电影摄影机拍摄的旋 
转马车车轮。因为图5.15。对连续信号 （左）进行采样 （中），然 
后通过重建（右）恢复原始信号。1325.着色基础图5.16。顶行显 
示旋转轮（原始信号）。这在第二行中未充分采样，使其看起来向 
相反方向移动。这是由于采样率太低而产生混叠的示例。在第三行 
中，采样率恰好是每转两个样本，我们无法确定车轮在哪个方向旋 
转。这是奈奎斯特极限。在第四行中，采样率高于每转两个样本， 
我们突然可以看到车轮在正确的方向上旋转。辐条的移动速度比摄 
像机记录图像的速度快得多，滚轮可能看起来很慢（向后或向前） 
旋转，或者甚至可能看起来根本不旋转。这可以在图 5.16中看到。 
----------------------- Page 156-----------------------
之所以会出现这种效果，是因为轮子的图像是在一系列时间步长中 
拍摄的，因此被称为时间混叠。计算机图形中混叠的常见例子是光 
栅化线条或三角形边缘的 “锯齿”，闪烁的高光被称为 “萤火虫”， 
以及带有格子图案的纹理缩小时（第6.2.2节）。当以太低的频率 
对信号进行采样时发生混叠。然后，采样信号看起来是频率低于原 
始信号的信号。如图5.17所示。对于要正确采样的信号 （即，因此 
可以从样本中重建原始信号），采样频率如图5.17所示。实线蓝色 
是原始信号，红色圆圈表示均匀间隔的采样点，绿色虚线是重建信 
号。上图显示了太低的采样率。因此，重建的信号看起来具有较低 
的频率，即原始信号的别名。底部显示的采样率恰好是原始信号频 
率的两倍，重建信号在这里是水平线。可以证明，如果采样率略微 
增加，则可以进行完美的重建。5.4。混叠和抗锯齿 133必须是要采 
样的信号的最大频率的两倍以上。这通常被称为采样定理，采样频 
率被称为奈奎斯特率[1447]或奈奎斯特极限，在瑞尼科学家哈里奈 
奎斯特（1889-1976）之后，他于1928年发现了这一点。奈奎斯 
特极限也在图5.16中说明。定理使用术语 “最大频率”的事实意味 
着信号必须是带限的，这意味着没有任何频率超过某个限制。换句 
话说，信号必须相对于相邻样本之间的间隔足够平滑。当使用点样 
本渲染时，三维场景通常从不受​ ​ 带限制。三角形，阴影边界和 
其他现象的边缘产生不连续变化的信号，因此产生无限的频率 
[252]。此外，无论样品包装多么紧密，对象仍然可以很小，根本不 
会被采样。因此，当使用点样本渲染场景时，不可能完全避免混叠 
----------------------- Page 157-----------------------
问题，并且我们几乎总是使用点采样。然而，有时可以知道信号何 
时是带限的。一个例子是将纹理应用于表面。与像素的采样率相比， 
可以计算纹理样本的频率。如果此频率低于奈奎斯特极限，则无需 
特殊操作即可正确采样纹理。如果频率太高，则使用各种算法来限 
制纹理（第6.2.2节）。重建给定带限采样信号，我们现在将讨论 
如何从采样信号重建原始信号。去做这个，必须使用过滤器。三种 
常用的滤波器如图5.18所示。请注意，滤波器的面积应始终为 1， 
否则重建信号可能会增大或缩小。图5.18。左上角显示盒式过滤器， 
右上角显示帐篷过滤器。底部显示sinc过滤器 （此处已夹紧在x轴 
上）。1345.着色基础图 5.19。使用盒式滤波器重建采样信号 （左）。 
这是通过将盒式过滤器放在每个样品点上，并在y方向上缩放，以 
使过滤器的高度与样品点相同来完成的。总和是重建信号（右）。 
在图5.19中，盒式滤波器 （最近邻居）用于重建采样信号。这是使 
用最差的滤波器，因为结果信号是非连续的阶梯情况。尽管如此， 
由于其简单性，它经常用于计算机图形学。从图中可以看出，箱式 
滤波器放置在每个采样点上，然后进行缩放，使滤波器的最高点与 
采样点重合。所有这些缩放和翻译的框功能的总和是右侧所示的重 
建信号。盒式过滤器可以用任何其他过滤器替换。在图5.20中，帐 
篷滤波器（也称为三角滤波器）用于重建采样信号。注意这个图5.20。 
使用帐篷滤波器重建采样信号 （左）。重建的信号显示在右侧。5.4。 
别名和抗锯齿 135图5.21。这里，sinc滤波器用于重建信号。sinc 
滤波器是理想的低通滤波器。滤波器实现相邻采样点之间的线性插 
----------------------- Page 158-----------------------
值，因此它优于盒式滤波器，因为重建信号现在是连续的。然而， 
使用帐篷滤波器的重建信号的平滑度很差;样本点有突然的斜率变 
化。这与帐篷过滤器不是完美的重建过滤器这一事实有关。为了获 
得完美的重建，必须使用理想的低通滤波器。信号的频率分量是正 
弦波：sin （2πf），其中f是该分量的频率。鉴于此，低通滤波器 
会移除频率高于滤波器定义的特定频率的所有频率分量。直观地说， 
低通滤波器去除了信号的尖锐特征，即滤波器模糊了它。理想的低 
通滤波器是正弦滤波器（图5.18底部）：sinc （x）=sin （πx）π 
x。 （5.22）傅里叶分析理论[1447]解释了为什么正弦滤波器是理想 
的低通滤波器。简而言之，推理如下。理想的低通滤波器是频域中 
的盒式滤波器，当它与信号相乘时，它会去除滤波器宽度以上的所 
有频率。将盒式滤波器从频域转换为空间域会产生sinc函数。同时， 
乘法运算被转换为卷积函数，这是我们在本节中使用的，而没有实 
际描述该术语。使用sinc滤波器重建信号可以得到更平滑的结果， 
如图5.21所示。采样过程在信号中引入高频分量 （突然变化），低 
通滤波器的任务是去除这些。事实上，正弦滤波器消除了频率高于 
采样率 1/2的所有正弦波。如公式 5.22所示，sinc函数是采样频率 
为1.0时的完美重建滤波器（即采样的最大频率1365.阴影基础信 
号必须小于 1/2）。更一般地，假设采样频率是fs，即相邻样本之 
间的间隔是1/fs。对于这种情况，完美的重建滤波器是sinc （fsx）， 
它消除了高于fs/2的所有频率。这在重新采样信号时非常有用 （下 
一节）。但是，sinc的滤波器宽度是无限的，在某些区域是负的， 
----------------------- Page 159-----------------------
所以它在实践中很少有用。一方面低质量的箱子和帐篷过滤器之间 
有一个有用的中间地带，另一方面是不切实际的sinc过滤器。最广 
泛使用的滤波函数[1214,1289,1413,1793]介于这些极端之间。所 
有这些滤波器函数都与sinc函数有一些近似，但是它们影响的像素 
数量有限。最接近sinc函数的滤波器在其域的一部分上具有负值。 
对于负滤波器值不合需要或不实用的应用，通常使用没有负波瓣的 
滤波器（通常一般称为高斯滤波器，因为它们或者从高斯曲线导出 
或类似于高斯曲线）[1402]。第 12.1节更详细地讨论了过滤器功能 
及其用法。使用任何过滤器后，获得连续信号。然而，在计算机图 
形学中，我们不能直接显示连续信号，但我们可以使用它们将连续 
信号重新采样到另一个大小，即放大信号或减小信号。接下来讨论 
该主题。重采样重采样用于放大或缩小采样信号。假设原始样本点 
位于整数坐标（0,1,2，...），即样本之间的单位间隔。此外，假设 
在重新采样之后，我们希望新样本点均匀地定位，样本之间的间隔 
为a。对于a>1，进行缩小 （下采样），对于<1，进行放大 （上采 
样）。放大是两者的简单情况，所以让我们从这开始。假设重建采 
样信号，如上一节所示。直观地，由于现在信号被完美地重建和连 
续，所需要的只是以期望的间隔重新采样重建的信号。这个过程如 
图5.22所示。但是，当缩小发生时，此技术不起作用。原始信号的 
频率对于采样率来说太高以避免混叠。相反，已经证明使用sinc （x 
/a）的滤波器应该用于从采样的[1447,1661]创建连续信号。之后， 
可以进行所需间隔的重采样。这可以在图5.23中看到。换句话说， 
----------------------- Page 160-----------------------
通过在此使用sinc （x/a）作为滤波器，增加了低通滤波器的宽度， 
从而消除了更多信号的更高频率内容。如图所示，滤波器宽度（单 
个sinc的）加倍，以将重采样率降低到原始采样率的一半。将其与 
数字图像相关联，这类似于首先模糊它（去除高频）然后以较低分 
辨率重新采样图像。5.4。别名和抗锯齿137图5.22。左边是采样 
信号和重建信号。在右侧，重建的信号已经以两倍的采样率重新采 
样，即放大已经发生。图5.23。左边是采样信号和重建信号。在右 
侧，过滤器宽度加倍，以使样本之间的间隔加倍，即缩小已经发生。 
以抽样和过滤理论为框架，现在讨论用于实时渲染以减少混叠的各 
种算法。5.4.2基于屏幕的抗锯齿如果没有采样和过滤，三角形边缘 
会产生明显的伪影。阴影边界，镜面高光以及颜色快速变化的其他 
现象可能会导致类似的问题。本节中讨论的算法有助于提高这些情 
况的渲染质量。它们具有基于屏幕的共同线程，即它们仅在管道的 
输出样本上操作。没有一种最好的抗锯齿技术，因为每种技术在质 
量，捕获尖锐细节或其他现象的能力，移动期间的外观，存储器成 
本，GPU要求和速度方面具有不同的优势。在图5.14的黑色三角 
形示例中，一个问题是低采样率。在每个像素的网格单元的中心拍 
摄单个样本，因此最多的是1385.阴影基础图5.24。在左侧，呈现 
红色三角形，其中一个样本位于像素的中心。由于三角形不覆盖样 
本，因此像素将是白色的，即使像素的大部分被红色三角形覆盖。 
在右侧，每个像素使用四个样本，并且可以看出，其中两个被红色 
三角形覆盖，这导致粉红色像素颜色。关于细胞的已知是中心是否 
----------------------- Page 161-----------------------
被三角形覆盖。通过每个屏幕网格单元使用更多样本并以某种方式 
混合这些样本，可以计算出更好的像素颜色。如图5.24所示。基于 
屏幕的抗锯齿方案的一般策略是对屏幕使用采样模式，然后对样本 
进行加权和求和以产生像素颜色，p：p （x，y）=Xni=1wic （i， 
x，y）， （5.23）其中n是像素的采样数。函数c （i，x，y）是样 
本颜色，wi是在[0,1]范围内的权重，样本将对整个像素颜色有贡献。 
样品位置取决于系列 1中的样品。。。，n和该函数可选地也使用 
像素位置（x，y）的整数部分。换句话说，在屏幕上拍摄样本的网 
格对于每个样本是不同的，并且可选地，采样图案可以在像素之间 
变化。样本通常是实时渲染系统（以及大多数其他渲染系统）中的 
点样本。因此，函数c可以被认为是两个函数。首先，函数f （i，n） 
检索需要样本的屏幕上的浮点（xf，yf）位置。然后对屏幕上的该 
位置进行采样，即，检索该精确点处的颜色。选择采样方案并且渲 
染管线被配置为计算特定子像素位置处的样本，通常基于每帧（或 
每应用）设置。抗锯齿中的另一个变量是wi，即每个样本的权重。 
这些权重总和为 1。实时渲染系统中使用的大多数方法为其样本提 
供了均匀的权重，即wi =1n。图形硬件的默认模式，即像素中心 
的单个样本，是上述抗混叠方程的最简单情况。只有一个术语，该 
项的权重为 1，采样函数f总是返回被采样像素的中心。计算每个像 
素多个完整样本的抗锯齿算法称为超级采样（或过采样）方法。概 
念上最简单的全场景抗锯齿（FSAA），也称为 “超级采样抗锯齿” 
 （SSAA），呈现5.4。以更高分辨率对场景进行混叠和抗锯齿处理 
----------------------- Page 162-----------------------
139然后过滤相邻样本以创建图像。例如，假设需要 1280×1024 
像素的图像。如果在屏幕外渲染2560×2048的图像，然后在屏幕 
上平均每个2×2像素区域，则生成所需图像，每个像素有四个样本， 
使用盒式过滤器进行过滤。请注意，这对应于图5.25中的2×2网 
格采样。这种方法很昂贵，因为所有子样本必须完全着色并填充， 
每个样本的z缓冲深度。FSAA的主要优势是简洁。此方法的其他 
低质量版本仅在一个屏幕轴上以两倍的速率采样，因此称为1×2或 
2×1超级采样。通常，为简单起见，使用二次幂分辨率和盒式滤波 
器。NVIDIA的动态超分辨率功能是一种更精细的超级采样形式， 
其中场景以更高的分辨率渲染，13样本高斯滤波器用于生成显示的 
图像[1848]。与超级采样相关的采样方法基于累积缓冲器的想法 
[637,1115]。此方法使用的缓冲区与所需图像具有相同的分辨率， 
但每个通道具有更多的颜色位，而不是一个大的屏幕外缓冲区。为 
了获得场景的2×2采样，生成四个图像，其中视图根据需要在屏幕 
x或y方向上移动半个像素。生成的每个图像基于网格单元内的不 
同样本位置。每帧必须重新渲染场景几次并将结果复制到屏幕的额 
外成本使得该算法对于实时渲染系统而言成本高昂。当性能不重要 
时，它可用于生成更高质量的图像，因为每个像素可以使用放置在 
任何地方的任意数量的样本[1679]。累积缓冲区曾经是一个独立的 
硬件。它直接在OpenGLAPI中受支持，但在3.0版中已弃用。在 
现代GPU上，通过使用输出缓冲器的更高精度颜色格式，可以在像 
素着色器中实现累积缓冲器概念。当物体边缘，镜面高光和锐利阴 
----------------------- Page 163-----------------------
影等现象导致颜色突然变化时，需要额外的样本。阴影通常可以变 
得更柔和，并且更加平滑以避免混叠。特定物体类型的尺寸可以增 
加，例如电线，从而保证它们沿着它们的长度覆盖每个位置处的至 
少一个像素[1384]。物体边缘的混叠仍然是主要的采样问题。可以 
使用分析方法，其中在渲染期间检测对象边缘并且考虑它们的影响， 
但是这些通常比仅采集更多样本更昂贵且更不稳健。但是，保守的 
光栅化和光栅化器顺序视图等GPU功能开辟了新的可能性[327]。 
诸如超级采样和累积缓冲之类的技术通过生成完全由单独计算的阴 
影和深度指定的样本来工作。总体增益相对较低且成本较高，因为 
每个样本都必须通过像素着色器。多重采样抗锯齿（MSAA）通过 
计算每个像素一次的表面阴影并在样本之间共享此结果来降低高计 
算成本。例如，像素可以具有每个片段的四个（x，y）样本位置， 
每个具有它们自己的 1405.阴影基础1×22×12×22×24×44×4 
8×88×8图5.25。一些像素采样方案的比较，范围从每像素的最少 
到大多数采样。Quincunx共享角落样本并对其中心样本进行加权， 
使其值为像素最终颜色的一半。2×2旋转网格捕获比近直2×2网格 
更接近水平边缘的灰度级。类似地，尽管使用较少的样本，8车模 
式捕获的这些线路的灰度级别比4×4 网格更多。5.4。别名和抗锯 
齿 1410231MSAA：0123＃color＆zA BIDcolor＆z EQAA： 
BA0123＃IDBB图5.26。在中间，有两个对象重叠的像素。红 
色物体包括三个样品，蓝色只有一个。像素着色器评估位置以绿色 
显示。由于红色三角形覆盖像素的中心，因此该位置用于着色器评 
----------------------- Page 164-----------------------
估。在样本的位置评估蓝色对象的像素着色器。对于 MSAA，在所 
有四个位置都存储单独的颜色和深度。在右侧显示 EQAA的2f4x 
模式。这四个样本现在有四个 ID值，它们索引存储的两种颜色和深 
度的表格。颜色和z深度，但像素着色器仅针对应用于像素的每个 
对象片段计算一次。如果片段覆盖了所有 MSAA位置样本，则在像 
素的中心处评估着色样本。相反，如果片段覆盖的位置样本较少， 
则可以移动着色样本的位置以更好地表示所覆盖的位置。例如，这 
样做可以避免从纹理边缘进行阴影采样。此位置调整称为质心采样 
或质心插值，如果启用，则由GPU 自动完成。质心采样避免了三角 
形外的问题，但可能导致微分计算返回不正确的值[530,1041]。见 
图5.26。MSAA比纯超级采样方案更快，因为片段只有一次阴影。 
它着重于以更高的速率对片段的像素覆盖率进行采样并共享计算的 
阴影。通过进一步解耦采样和覆盖可以节省更多内存，这反过来又 
可以使抗锯齿更快 - 触摸的内存越少，渲染速度越快。NVIDIA于 
2006年推出了覆盖采样抗锯齿（CSAA），AMD也采用了增强型 
抗锯齿（EQAA）。这些技术通过以较高的采样率仅存储片段的覆 
盖范围来工作。例如，EQAA的 “2f4x”模式存储两个颜色和深度 
值，在四个样本位置之间共享。颜色和深度不再存储在特定位置， 
而是保存在表格中。然后，四个样本中的每一个只需要一位来指定 
两个存储值中的哪一个与其位置相关联。见图5.26。覆盖样本指定 
每个片段对最终像素颜色的贡献。如果超过存储的颜色数，则存储 
的颜色被逐出，其样本被标记为未知。这些样本对最终颜色没有贡 
----------------------- Page 165-----------------------
献[382,383]。对于大多数场景，相对较少的像素包含三个或更多可 
见的不透明片段，这些片段在阴影上完全不同，因此该方案在实践 
中表现良好[1405]。然而，为了获得最高质量，ForzaHorizo​ ​ 
n2游戏采用了4×MSAA，尽管 EQAA具有性能优势[1002]。142 
5.着色基础知识将所有几何体渲染到多样本缓冲区后，将执行解析 
操作。此过程将样本颜色平均在一起以确定像素的颜色。值得注意 
的是，当使用具有高动态范围颜色值的多重采样时会出现问题。在 
这种情况下，为了避免伪像，您通常需要在解析之前对值进行色调 
映射[1375]。这可能是昂贵的，因此可以使用更简单的近似色调映 
射函数或其他方法[862,1405]。默认情况下，使用框过滤器解析 
MSAA。2007年，ATI推出了定制滤波器抗锯齿 （CFAA）[1625]， 
具有使用窄和宽帐篷滤波器的功能，这些滤波器稍微延伸到其他像 
素单元中。此模式已被 EQAA支持取代。在现代GPU上，像素或 
计算着色器可以访问MSAA样本并使用所需的任何重建滤波器，包 
括从周围像素的样本中采样的一个。较宽的滤波器可以减少混叠， 
但会丢失清晰的细节。Pettineo[1402,1405]发现，滤波器宽度为2 
或 3像素的立方平滑步进和 B样条滤波器总体上得到了最好的结 
果。还有性能成本，因为即使使用自定义着色器模拟默认的盒式过 
滤器解析也需要更长时间，而更宽的过滤器内核意味着增加了样本 
访问成本。NVIDIA内置的TXAA支持同样在比单个像素更宽的区 
域使用更好的重建滤波器，以提供更好的结果。它和更新的 MFAA 
 （多帧抗锯齿）方案都使用时间抗锯齿（TAA），这是一种使用先 
----------------------- Page 166-----------------------
前帧的结果来改善图像的一般技术。部分地，由于允许程序员每帧 
设置MSAA采样模式的功能，使得这种技术成为可能[1406]。这些 
技术可以解决诸如旋转车轮之类的混叠问题，并且还可以改善边缘 
渲染质量。想象一下，通过生成一系列图像来 “手动”执行采样模 
式，其中每个渲染使用像素内的不同位置来获取样本。这种偏移是 
通过在投影矩阵上附加微小的平移来完成的[1938]。生成和平均的 
图像越多，结果越好。在时间抗混叠算法中使用这种使用多个偏移 
图像的概念。生成单个图像，可能使用MSAA或其他方法，并混合 
先前的图像。通常只使用两到四帧[382,836,1405]。较旧的图像可 
以以指数减少的权重给出[862]，尽管如果观看者和场景不移动，这 
可以具有帧闪烁的效果，因此通常仅对最后和当前帧进行相等的加 
权。对于每个帧的样本在不同的子像素位置，这些样本的加权和提 
供了比单个帧更好的边缘覆盖估计。因此，使用最近两帧平均的系 
统可以提供更好的结果。每个帧都不需要额外的样本，这使得这种 
方法非常吸引人。甚至可以使用时间采样来生成较低分辨率的图像， 
该图像被放大到显示器的分辨率[1110]。此外，为了获得良好结果， 
需要许多样本的照明方法或其他技术可以改为每帧使用更少的样 
本，因为结果将在几个帧上混合[1938]。5.4。别名和抗锯齿 143 
虽然在没有额外采样成本的情况下为静态场景提供抗锯齿，但这种 
算法在用于时间抗锯齿时存在一些问题。如果帧的权重不相等，则 
静态场景中的对象可以呈现出微光。快速移动的物体或快速的相机 
移动可能导致重影，即由于先前帧的贡献而留在物体后面的痕迹。 
----------------------- Page 167-----------------------
重影的一种解决方案是仅对缓慢移动的对象执行这种抗锯齿 
[1110]。另一个重要的方法是使用重投影 （第 12.2节）来更好地关 
联先前帧和当前帧的对象。在这样的方案中，对象生成存储在单独 
的 “速度缓冲器”中的运动矢量 （第 12.5节）。这些向量用于将先 
前帧与当前帧相关联，即，从当前像素位置减去向量以找到该对象 
的表面位置的前一帧的颜色像素。不太可能是当前帧中表面的一部 
分的样本被丢弃[1912]。由于时间抗锯齿不需要额外的样本，因此 
需要相对较少的额外工作，因此近年来人们对这种类型的算法产生 
了浓厚的兴趣和广泛的采用。其中一些注意力是因为延迟着色技术 
 （第20.1节）与 MSAA和其他多重采样支持[1486]不兼容。方法 
各不相同，取决​ ​ 于应用程序的内容和目标，已经开发了一系列 
用于避免伪影和改善质量的技术[836,1154,1405,1533,1938]。例 
如，Wihlidal 的演示文稿[1885]显示了应用于棋盘格采样模式的 
EQAA，时间抗锯齿和各种滤波技术如何结合起来以保持质量，同 
时降低像素着色器调用的数量。Iglesias-Guitian等。[796]总结了 
先前的工作并呈现了他们使用像素历史和预测来最小化过滤伪像的 
方案。Patney等人。[1357]扩展了 Karis和 Lottes关于虚幻现实应 
用[862]的TAA工作，用于虚拟现实应用，增加了可变大小的采样 
以及眼动的补偿 （第21.3.2节）。采样模式有效的采样模式是减少 
混叠的关键因素，时间和其他方面。Naiman[1257]表明人类对近 
水平和近垂直边缘的混叠最为不安。接近45度坡度的边缘是最令人 
不安的。旋转网格超级采样 （RGSS）使用旋转的方形图案在像素内 
----------------------- Page 168-----------------------
提供更多的垂直和水平分辨率。图5.25显示了此模式的一个示例。 
RGSS模式是拉丁超立方或 N-rooks采样的一种形式，其中n个样 
本放置在n×n网格中，每行和每列一个样本[1626]。利用RGSS， 
四个样本分别位于4×4子像素网格的单独行和列中。与常规的2×2 
采样模式相比，这种模式对于捕获几乎水平和垂直的边缘特别好， 
其中这样的边缘可能覆盖偶数个样本，因此给出较少的有效水平。 
N-rooks是创造良好采样模式的开始，但这还不够。例如，样本都 
可以是沿子像素网格的对角线的位置，因此对于几乎平行于该对角 
线的边缘给出差的结果。见图 5.27。144 5.着色基础图 5.27。 
N-rooks抽样。在左边是一个合法的 N-rooks模式，但它在捕获沿 
其对角线的三角形边缘时表现不佳，因为当三角形移动时，所有样 
本位置将在三角形内部或外部。在右边是一个模式，可以更有效地 
捕获这个和其他边缘。为了更好的采样，我们希望避免将两个样本 
放在彼此附近。我们还希望均匀分布，在整个区域均匀分布样品。 
要形成这样的模式，拉丁超立方采样等分层抽样技术与其他方法相 
结合，如抖动，哈尔顿序列和泊松盘采样[1413,1758]。实际上， 
GPU制造商通常会将这种采样模式硬连接到其硬件中，以进行多重 
采样抗锯齿处理。图 5.28显示了实践中使用的一些 MSAA模式。 
对于时间抗锯齿，覆盖模式是程序员想要的，因为样本位置可以逐 
帧变化。例如，Karis[862]发现基本的 Halton序列比GPU提供的 
任何 MSAA模式都更好。Halton序列在空间中生成样本，这些样 
本看起来是随机的，但差异很小，也就是说，它们很好地分布在空 
----------------------- Page 169-----------------------
间上，没有一个被聚类[1413,1938]。虽然子像素网格图案可以更好 
地逼近每个三角形覆盖网格单元的方式，但它并不理想。场景可以 
由任意的对象组成。图5.28。AMD和 NVIDIA图形加速器的MSAA 
采样模式。绿色方块是着色样本的位置，红色方块是计算和保存的 
位置样本。从左到右：2×，4×，6× （AMD）和8× （NVIDIA）采 
样。 （由D3DFSAAViewer生成。）5.4。别名和抗锯齿 145在屏 
幕上很小，这意味着没有采样率可以完美地捕获它们。如果这些微 
小物体或特征形成图案，则以恒定间隔采样会产生莫尔条纹和其他 
干涉图案。超级采样中使用的网格图案特别容易混淆。一种解决方 
案是使用随机抽样，其提供更随机的模式。如图5.28所示的模式当 
然有资格。想象一下远处的细齿梳子，每个像素都有几颗牙齿。当 
采样模式与齿频率进出异相时，规则模式会产生严重的伪影。具有 
较不有序的采样模式可以打破这些模式。随机化倾向于用噪声代替 
重复的混叠效应，人类视觉系统更加宽容[1413]。具有较少结构的 
图案有帮助，但是当重复像素到像素时它仍然可以表现出混叠。一 
种解决方案是在每个像素处使用不同的采样模式，或者随时间改变 
每个采样位置。交错采样指数采样！交错，其中一组中的每个像素 
具有不同的采样模式，在过去的几十年中偶尔会在硬件中得到支持。 
例如，ATI的SMOOTHVISION允许每个像素最多 16个样本和多 
达 16个不同的用户定义的采样模式，这些采样模式可以以重复模式 
 （例如，在4×4像素区块中）混合。Molnar[1234]以及Keller和 
Heidrich[880]发现，使用交错随机采样可以最大限度地减少在为 
----------------------- Page 170-----------------------
每个像素使用相同模式时形成的混叠伪像。其他一些GPU支持的算 
法值得注意。一种允许样本影响多个像素的实时抗锯齿方案是 
NVIDIA的旧Quincunx方法[365]。 “梅花形”是指五个物体的排 
列，四个正方形，五个在中心，例如六面模具上的五个点的图案。 
梅花形多重采样抗锯齿使用此模式，将四个外部样本放在像素的角 
落。见图5.25。每个角样本值被分配给其四个相邻像素。不是对每 
个样本进行相等的加权（与大多数其他实时方案一样），中心样本 
的权重为12，每个角样本的权重为18。由于这种共享，每个像素 
仅需要平均两个样本，并且结果明显优于双样本 FSAA方法[1678]。 
这种模式近似于二维帐篷过滤器，如前一节所述，它优于箱式过滤 
器。通过使用每个像素的单个样本，也可以将梅花形采样应用于时 
间抗锯齿[836,1677]。每帧从前一帧的每个轴偏移半个像素，在帧 
之间交替的偏移方向。前一帧提供像素角样本，双线性插值用于快 
速计算每像素的贡献。结果与当前帧平均。每个帧的相等权重意味 
着静态视图没有微光伪影。对齐移动对象的问题仍然存在，但是该 
方案本身很容易编码并且在每帧每个像素仅使用一个样本时提供更 
好的外观。当在单个帧中使用时，通过在像素边界处共享样本， 
Quincunx仅具有两个样本的低成本。RGSS模式更好地捕获更接近 
水平和垂直边缘的渐变。首先为移动设备开发 1465.着色基础图 
5.29。在左侧，显示了RGSS采样模式。每个像素需要四个样本。 
通过将这些位置移动到像素边缘，可以在边缘上进行样本共享。但 
是，为了解决这个问题，每个其他像素必须有一个反射的样本模式， 
----------------------- Page 171-----------------------
如右图所示。生成的样本模式称为 FLIPQUAD，每个像素需要两个 
样本。图形，FLIPQUAD模式结合了这两个理想的功能[22]。它的 
优点是每个像素的成本仅为两个样本，并且质量类似于 RGSS （每 
个像素需要四个样本）。该采样模式如图 5.29所示。Hasselgren 
等人研究了利用样本共享的其他廉价采样模式。[677]。与Quincunx 
一样，双样本 FLIPQUAD模式也可以与时间抗锯齿一起使用并分布 
在两个帧上。Drobot [382,383，1154]解决了混合重建抗锯齿 
 （HRAA）工作中哪种双样本模式最佳的问题。他探索了时间抗锯 
齿的不同采样模式，发现 FLIPQUAD模式是五种测试中最好的。棋 
盘图案也可用于时间抗锯齿。ElMansouri[415]讨论了使用双样本 
MSAA来创建棋盘渲染以降低着色器成本，同时解决混叠问题。 
Jimenez [836]使用SMAA，时间抗锯齿和各种其他技术来提供解 
决方案，其中抗锯齿质量可以响应于渲染引擎负载而改变。 
Carpentier和 Ishiyama[231]在边缘采样，将采样网格旋转45°。 
他们将这种时间抗锯齿方案与 FXAA （稍后讨论）相结合，以便在 
更高分辨率的显示器上进行高效渲染。形态学方法别名通常由边缘 
产生，例如由几何形状，锐利阴影或明亮高光形成的边缘。可以利 
用混叠具有与其相关联的结构的知识来提供更好的抗锯齿结果。 
2009年，Reshetov [1483]提出了一种算法，称之为形态抗锯齿 
 （MLAA）。“形态学”的意思是 “与结构或形状有关。”早在 1983 
年 Bloomenthal [170]就已经在这个领域进行了早期工作[830]。 
Reshetov的论文重新研究了多重采样方法的替代方案，强调搜索和 
----------------------- Page 172-----------------------
重建边缘[1486]。这种形式的抗锯齿作为后处理来执行。也就是说， 
渲染以通常的方式完成，然后将结果馈送到生成 5.4的过程。别名 
和抗锯齿 147图5.30。形态抗锯齿。左边是别名图像。目标是确定 
形成它的边缘的可能方向。在中间，算法通过检查邻居来记录边缘 
的可能性。给定样本，显示了两个可能的边缘位置。在右侧，最佳 
猜测边缘用于将相邻颜色与估计的覆盖范围成比例地混合到中心像 
素中。对图像中的每个像素重复该过程。反结果的结果。自2009 
年以来已经开发了各种各样的技术。那些依赖于额外缓冲区（如深 
度和法线）的技术可以提供更好的结果，例如亚像素重建抗锯齿 
 （SRAA）[43,429]，但是它们仅适用于抗锯齿几何边缘。分析方法， 
例如，几何缓冲抗锯齿（GBAA）和距离到边缘抗锯齿（DEAA）， 
使渲染器计算关于三角形边缘位于何处的附加信息，例如，边缘距 
像素中心的距离[829]。最通用的方案只需要颜色缓冲区，这意味着 
它们还可以改善阴影，高光或各种先前应用的后处理技术（如轮廓 
边缘渲染）的边缘 （第 15.2.3节）。例如，定向局部抗锯齿 （DLAA） 
[52,829]基于这样的观察：几乎垂直的边缘应该水平模糊，同样几 
乎水平的边缘应该与它们的邻居垂直模糊。更精细的边缘检测形式 
试图找到可能包含任何角度边缘的像素并确定其覆盖范围。检查潜 
在边缘周围的邻域，目标是尽可能重建原始边缘所在的位置。然后 
可以使用边缘对像素的影响来混合相邻像素的颜色。有关该过程的 
概念视图，请参见图5.30。Iourcha等人。[798]通过检查像素中的 
MSAA样本来改善边缘发现以计算更好的结果。请注意，边缘预测 
----------------------- Page 173-----------------------
和混合可以提供比基于样本的算法更高的精度结果。例如，每个像 
素使用四个样本的技术只能为对象的边缘提供五个级别的混合：没 
有覆盖样本，一个覆盖样本，两个，三个和四个。估计的边缘位置 
可以具有更多位置，因此提供更好的结果。基于图像的算法可以通 
过多种方式误入歧途。第一，如果两个对象之间的色差低于算法的 
阈值，则可能无法检测到边缘。存在三个或更多个不同表面重叠的 
像素难以解释。具有高对比度或高频率元素的曲面，其中 1485.着 
色基础颜色在像素之间快速变化，可能导致算法错过边缘。特别是， 
当对形态抗锯齿应用时，文本质量通常会受到影响。对象角落可能 
是一个挑战，一些算法赋予它们圆润的外观。边缘是直的假设也会 
对曲线产生不利影响。单个像素的改变可能导致重建边缘的方式发 
生大的变化，这可能会在帧到帧之间产生明显的伪像。改善该问题 
的一种方法是使用MSAA覆盖掩模来改善边缘确定[1484]。形态抗 
锯齿方案仅使用提供的信息。例如，在宽度上比像素宽的物体（例 
如电线或绳索）将在屏幕上具有间隙，只要它不会覆盖像素的中心 
位置。在这种情况下，采取更多样品可以提高质量;仅基于图像的抗 
锯齿不能。此外，执行时间可以根据查看的内容而变化。例如，一 
片草地的视野可能需要三倍于抗锯齿作为天空的视野[231]。所有这 
些说明，基于图像的方法可以为适度的内存和处理成本提供抗锯齿 
支持，因此它们被用于许多应用程序中。仅颜色版本也与渲染管道 
分离，使其易于修改或禁用，甚至可以作为GPU驱动程序选项公开。 
两种最流行的算法是快速近似抗锯齿（FXAA）[1079,1080,1084] 
----------------------- Page 174-----------------------
和亚像素形态抗锯齿 （SMAA）[828,830,834]，部分原因是它们都 
提供了实体（和免费）源代码实现。各种机器。两种算法都使用仅 
颜色输入，SMAA具有能够访问 MSAA样本的优点。每个都有自己 
的各种设置，在速度和质量之间进行权衡。成本通常在每帧1到2 
毫秒的范围内，主要是因为这是视频游戏愿意花费的。最后，两种 
算法也可以利用时间抗锯齿[1812]。Jimenez [836]提出了一种改进 
的SMAA实现，比FXAA更快，并描述了时间抗锯齿方案。最后， 
我们向读者推荐 Reshetov和Jimenez [1486]对形态学技术及其在 
视频游戏中的应用的广泛评论。5.5透明度，Alpha和合成半透明物 
体有许多不同的方式可以让光线穿过它们。对于渲染算法，这些可 
以大致分为基于光的效果和基于视图的效果。基于光的效果是指物 
体导致光线衰减或转向的效果，导致场景中的其他物体被点亮并以 
不同方式呈现。基于视图的效果是半透明对象本身被渲染的效果。 
在本节中，我们将讨论最简单的基于视图的透明度，其中半透明物 
体充当其后面物体颜色的衰减器。更精细的基于视觉和光线的效果， 
如磨砂玻璃，弯曲5.5。透明度，α和合成 149的光 （折射），由于 
透明物体的厚度引起的光衰减，以及由于视角引起的反射率和透射 
率变化将在后面的章节中讨论。给出透明幻觉的一种方法称为屏幕 
门透明度[1244]。我们的想法是使用像素对齐的棋盘填充图案渲染 
透明三角形。也就是说，渲染三角形的每个其他像素，从而使其后 
面的对象部分可见。通常屏幕上的像素足够接近，棋盘图案本身不 
可见。该方法的主要缺点是通常只能在屏幕的一个区域上令人信服 
----------------------- Page 175-----------------------
地呈现一个透明对象。例如，如果透明红色对象和透明绿色对象呈 
现在蓝色对象的顶部，则三种颜色中只有两种可以出现在棋盘图案 
上。此外，50％的棋盘是有限的。其他较大的像素掩模可用于提供 
其他百分比，但这些可能会产生可检测的模式[1245]。也就是说， 
这种技术的一个优点是它的简单性。透明对象可以在任何时间以任 
何顺序呈现，并且不需要特殊硬件。透明度问题通过使所有对象在 
它们覆盖的像素处不透明而消失。同样的想法用于剪切纹理的抗锯 
齿边缘，但在子像素级别，使用名为alphatocoverage的功能 （第 
6.6节）。由 Enderton等人介绍。[423]，随机透明度使用子像素 
screendoor掩模结合随机抽样。通过使用随机点画模式来表示片段 
的α覆盖，创建了合理但有噪声的图像。见图5.31。每个像素需要 
大量样本才能使结果看起来合理，并且所有子像素样本都需要相当 
大的存储量。有吸引力的是不需要混合，并且抗锯齿，透明度以及 
产生部分覆盖像素的任何其他现象都由单一机制覆盖。大多数透明 
度算法将透明对象的颜色与其后面对象的颜色混合在一起。为此， 
需要α混合的概念[199,387,1429]。当在屏幕上呈现对象时，RGB 
颜色和z缓冲深度与每个像素相关联。还可以为对象覆盖的每个像 
素定义另一个称为alpha （α）的组件。Alpha是描述给定像素的对 
象片段的不透明度和覆盖度的值。α为1.0表示物体是不透明的，完 
全覆盖了像素的感兴趣区域;0.0表示像素根本不被遮挡，即片段完 
全透明。像素的alpha可以表示不透明度，覆盖率或两者，具体取 
决于具体情况。例如，肥皂泡的边缘可以覆盖像素的四分之三，0.75， 
----------------------- Page 176-----------------------
并且可能几乎是透明的，让十分之九的光通过眼睛，因此它是十分 
之一的不透明，0.1。那么它的α将是0.75×0.1=0.075。然而，如 
果我们使用 MSAA或类似的抗锯齿方案，样本本身将考虑覆盖范 
围。四分之三的样品会受到肥皂泡的影响。在每个样本中，我们将 
使用0.1不透明度值作为alpha。1505.阴影基础图5.31。随机透 
明度。产生的噪音显示在放大区域。（图片来自NVIDIASDK 11 
[1301]样本，由NVIDIA公司提供。）5.5.1混合顺序为了使对象看 
起来透明，它会在现有场景的顶部渲染，其alpha值小于 1.0。由 
对象覆盖的每个像素将从像素着色器接收结果 RGBα （也称为 
RGBA）。将此片段的值与原始像素颜色混合通常使用over运算符 
完成，如下所示：co=αscs+ （1。αs）cd[overoperator]， （5.24） 
其中cs是透明对象的颜色（称为源），αs是对象的alpha，cd是 
混合前的像素颜色 （称为目标），co是结果由于将透明对象放在现 
有场景上而产生的颜色。在渲染管道以cs和αs发送的情况下，像 
素的原始颜色cd被结果co替换。如果传入的 RGBα实际上是不透 
明的 （αs=1.0），则该等式简化为通过对象的颜色完全替换像素的 
颜色。示例：混合。红色半透明物体被渲染到蓝色背景上。假设在 
某个像素处，对象的RGB阴影为（0.9,0.2,0.1），背景为（0.1,0.1,0.9）， 
对象的不透明度设置为 0.6。然后，这两种颜色的混合为 0.6 
 （0.9,0.2,0.1 ） + （1.0。6 ）（0.1,0.1,0.9 ），其颜色为 
 （0.58,0.16,0.42）。？over运算符为正在渲染的对象提供半透明 
外观。以这种方式完成的透明度是有效的，因为只要可以通过它看 
----------------------- Page 177-----------------------
到背后的物体，我们就会认为某些东西是透明的[754]。使用过模拟 
5.5。透明度，Alpha和合成 151图5.32。红色薄纱织物和红色塑 
料过滤器，给出不同的透明效果。注意阴影也是如何不同的。（图 
片由MorganMcGuire提供。）薄纱面料的真实效果。织物后面的 
物体视图部分遮挡 - 织物的线是不透明的。在实践中，松散的织物 
具有随角度变化的α覆盖[386]。我们的观点是alpha模拟材料覆盖 
像素的程度。过度操作员不太容易模拟其他透明效果，最明显的是 
通过彩色玻璃或塑料观察。在现实世界中保持在蓝色物体前面的红 
色滤光片通常使蓝色物体看起来很暗，因为该物体反射的光可以通 
过红色滤光片。见图 5.32。当over用于混合时，结果是红色和蓝 
色的一部分加在一起。最好将两种颜色相乘，并在透明物体本身上 
添加任何反射。这种类型的物理透射率在第 14.5.1节和第 14.5.2 
节中讨论。在基本的混合阶段操作符中，over是常用于透明效果的 
操作符[199,1429]。看到一些用途的另一个操作是加法混合，其中 
像素值被简单地求和。那是，co =αscs+cd。 （5.25）这种混合模 
式可以很好地用于发光效果，如闪电或火花，不会削弱背后的像素， 
而只会使它们变亮[1813]。但是，此模式看起来不正确透明度，因 
为不透明的表面不会出现1525.阴影基础图5.33。在左侧，使用z 
缓冲区以透明度渲染模型。以任意顺序渲染网格会产生严重错误。 
在右侧，深度剥离提供正确的外观，代价是额外的通行证。（图片 
由NVIDIA公司提供。）过滤[1192]。对于几个层状的半透明表面， 
例如烟雾或火，添加剂混合具有使现象的颜色饱和的效果[1273]。 
----------------------- Page 178-----------------------
要正确渲染透明对象，我们需要在不透明对象之后绘制它们。这是 
通过首先渲染所有不透明对象并混合关闭，然后渲染透明对象来完 
成的。从理论上讲，我们总是可以完成，因为 1.0的不透明alpha 
会给出源颜色并隐藏目标颜色，但这样做会更加昂贵，因为没有真 
正的收益。z缓冲区的限制是每个像素仅存储一个对象。如果多个 
透明对象与同一像素重叠，则单独的z缓冲区无法保持并稍后解析 
所有可见对象的效果。当在任何给定像素的透明表面上使用时，通 
常需要以从前到后的顺序呈现。不这样做会给出错误的感知线索。 
实现这种排序的一种方法是通过例如它们的质心沿视图方向的距离 
来对各个对象进行排序。这种粗略的分类可以很好地工作，但在各 
种情况下都有许多问题。首先，顺序只是一种近似，因此被分类为 
更远的对象可能位于被认为更近的对象的前面。对于所有视角，互 
穿的物体不可能在每个网格的基础上解决，不能将每个网格分成单 
独的块。有关示例，请参见图5.33中的左图。即使是具有凹陷的单 
个网格也可能对于其在屏幕上重叠的视图方向存在分类问题。尽管 
如此，由于其简单性和速度，以及不需要额外的内存或特殊的GPU 
支持，仍然经常使用粗略的透明度排序。如果实施，通常最好关闭 
z深度替换5.5。透明度，Alpha，和执行透明度时的合成153。也 
就是说，z缓冲区仍然正常测试，但幸存的表面不会改变存储的z 
深度;最接近的不透明表面的深度保持不变。这样，当相机旋转改变 
排序顺序时，所有透明对象将至少以某种形式出现，而不是突然出 
现或消失。其他技术也可以帮助改善外观，例如每次绘制每个透明 
----------------------- Page 179-----------------------
网格两次，首先渲染背面然后渲染前面[1192,1255]。也可以修改上 
方等式，使前后混合得到相同的结果。这种混合模式称为欠算子： 
co=αdcd+ （1。αd）αscs[在算子下]，ao =αs （1.αd）+αd=αs。 
αsαd+αd。 （5.26）注意，under要求目标保持alpha值，过去没 
有。换句话说，目标 - 在下面混合的更近的透明表面 - 不是不透 
明的，因此需要具有α值。下面的公式就像结束了，但是交换了源和 
目的地。另外，请注意计算alpha的公式是与顺序无关的，因为源 
和目标alpha可以交换，结果是相同的最终alpha。alpha的等式 
来自于将片段的alphas视为coverage。Porter和 Duff[1429]注 
意到，由于我们不知道任何一个片段的覆盖区域的形状，我们假设 
ea请注意，计算alpha的公式是与顺序无关的，因为源和目标alpha 
可以交换，结果是相同的最终alpha。alpha的等式来自于将片段 
的alphas视为coverage。Porter和 Duff[1429]注意到，由于我 
们不知道任何一个片段的覆盖区域的形状，我们假设ea请注意，计 
算alpha的公式是与顺序无关的，因为源和目标alpha可以交换， 
结果是相同的最终alpha。alpha的等式来自于将片段的alphas视 
为coverage。Porter和 Duff[1429]注意到，由于我们不知道任何 
一个片段的覆盖区域的形状，我们假设each片段与其alpha成比 
例地覆盖另一个。例如，如果αs=0.7，则像素以某种方式被分成两 
个区域，其中0.7被源片段覆盖而0.3不被覆盖。除了任何其他知 
识之外，覆盖例如αd=0.6的目标片段将与源片段成比例地重叠。 
该公式具有几何解释，如图5.34所示。面积=0.6面积=0.7。0.6 
----------------------- Page 180-----------------------
给定两个区域（α）0.7和0.6的片段，覆盖的总面积=0.7...0.7。 
0.6 +0.6 =0.88面积=0.7片段s片段d图5.34。一个像素和两 
个片段，s和d。通过沿不同轴对齐两个片段，每个片段覆盖另一个 
片段的比例量，即它们是不相关的。两个片段覆盖的区域等于输出 
下的α值αs。αsαd+αd。这转换为添加两个区域，然后减去它们重 
叠的区域。1545.着色基础图5.35。每个深度剥离通道绘制一个透 
明层。左边是第一遍，显示眼睛直接可见的图层。第二层（如中间 
所示）显示每个像素的第二个最接近的透明表面，在这种情况下是 
对象的背面。右边的第三层是第三个最接近的透明表面的集合。最 
终结果可以在第624页的图 14.33中找到。（图片由LouisBavoil 
提供。）5.5.2与顺序无关的透明度通过将所有透明对象绘制到单独 
的颜色缓冲区，然后将此颜色缓冲区合并到使用过场景的不透明视 
图。under运算符的另一个用途是用于执行称为深度剥离的顺序无 
关透明度 （OIT）算法[449,1115]。与顺序无关意味着应用程序不需 
要执行排序。深度剥离背后的想法是使用两个z缓冲区和多次通过。 
首先，进行渲染过程，以使所有曲面的z深度（包括透明曲面）位 
于第一个z缓冲区中。在第二遍中，渲染所有透明对象。如果对象 
的z深度与第一个z缓冲区中的值匹配，我们知道这是最近的透明 
对象，并将其 RGBα保存到单独的颜色缓冲区。我们还通过保存任 
何透明对象（如果有的话）超出第一个z深度并且最接近的z深度 
来 “剥离”该层。该z深度是第二最近的透明对象的距离。连续传 
球继续剥离并使用下方添加透明层。我们在经过一些次数后停止， 
----------------------- Page 181-----------------------
然后将透明图像混合在不透明图像的顶部。见图5.35。已经开发了 
关于该方案的若干变体。例如，Thibieroz [1763]给出了一种前后 
工作的算法，其优点是能够立即混合透明值，这意味着不需要单独 
的alpha通道。深度剥离的一个问题是知道有多少次通过足以捕获 
所有透明层。一种硬件解决方案是提供一个像素绘制计数器，它告 
诉在渲染过程中写入了多少像素;当没有像素通过传递时，渲染就完 
成了。使用 under的优点是最重要的透明层 - 眼睛首先看到的 - 
在早期就被渲染。每个透明表面总是增加它所覆盖的像素的alpha 
值。如果是5.5。透明度，Alpha和合成 155像素的α值接近 1.0， 
混合贡献使像素几乎不透明，因此更远的物体将具有可忽略的效果 
[394]。当通过渲染的像素数量低于某个最小值时，可以缩短前后剥 
离，或者可以指定固定数量的通过。这对于从前到后的剥离不起作 
用，因为最接近（通常是最重要的）层是最后绘制的，因此可能通 
过提前终止而丢失。虽然深度剥离是有效的，但它可能很慢，因为 
每个剥离的层是所有透明对象的单独渲染过程。Bavoil和 Myers 
[118]提出了双深度剥离，其中两个深度剥离层 （最近和最远的剩余 
剥离层）在每次通过中被剥离，从而将渲染通道的数量减少一半。 
刘等人。[1056]探索一种桶排序方法，其在单次通过中捕获多达32 
个层。这种方法的一个缺点是需要相当大的内存来保持所有层的排 
序顺序。通过 MSAA或类似方法进行抗锯齿将增加天文数字的成 
本。以交互速率正确地将透明对象混合在一起的问题不是我们缺乏 
算法的问题，而是有效地将这些算法映射到GPU的问题。1984年， 
----------------------- Page 182-----------------------
Carpenter提出了A-buffer [230]，这是另一种形式的多重采样。 
在A缓冲区中，渲染的每个三角形为其完全或部分覆盖的每个屏幕 
网格单元创建一个覆盖遮罩。每个像素存储所有相关片段的列表。 
不透明的片段可以剔除它们后面的片段，类似于z缓冲区。存储所 
有片段以用于透明表面。一旦形成所有列表，通过遍历片段并解析 
每个样本产生最终结果。通过 DirectX11[611,1765]中公开的新功 
能，可以在GPU上创建片段的链接列表。使用的功能包括无序访问 
视图 （UAV）和原子操作，如3.8节所述。通过 MSAA进行抗锯齿 
是通过访问coverage掩码和评估每个样本的像素着色器来实现的。 
该算法通过栅格化每个透明表面并插入以长数组生成的片段来工 
作。除了颜色和深度之外，还生成一个单独的指针结构，将每个片 
段链接到为像素存储的前一个片段。然后执行单独的传递，其中渲 
染屏幕填充四边形，以便在每个像素处评估像素着色器。此着色器 
通过跟踪链接检索每个像素处的所有透明片段。检索到的每个片段 
依次与先前的片段进行排序。然后将该排序列表反向混合到前面以 
给出最终的像素颜色。由于通过像素着色器执行混合，因此如果需 
要，可以为每个像素指定不同的混合模式。GPU和API的不断发展 
通过降低使用原子运算符的成本来提高性能[914]。A缓冲区的优点 
是只分配了每个像素所需的片段，GPU上的链表实现也是如此。从 
某种意义上说，这也是一个缺点，因为在开始渲染帧之前，所需的 
存储量是未知的。具有头发，烟雾或其他可能存在许多重叠透明表 
面的物体的场景会产生大量碎片。1565.着色基础图5.36。在左上 
----------------------- Page 183-----------------------
角，执行传统的后向前alpha混合，由于不正确的排序顺序导致渲 
染错误。在右上角，A缓冲区用于提供完美的非交互式结果。左下 
角显示了多层alpha混合的渲染。右下角显示了A缓冲区和多层图 
像之间的差异，可见性乘以4 [1532]。（图片由MarcoSalvi和英 
特尔公司的 KarthikVaidyanathan提供。）Andersson [46]指出， 
对于复杂的游戏场景，最多 50个透明网格对象（如树叶）和多达 
200个半透明粒子可能会重叠。GPU通常具有内存资源，例如预先 
分配的缓冲区和数组，链表方法也不例外。用户需要确定多少内存 
就足够了，内存不足会导致明显的瑕疵。Salvi和Vaidyanathan 
[1532]提出了一种解决这个问题的方法，多层alpha混合，使用英 
特尔引入的称为像素同步的GPU功能。见图5。这种能力提供了可 
编程混合，其开销小于原子。他们的方法改进了存储和混合，以便 
在内存耗尽时优雅地降级。粗略的排序顺序可以使他们的计划受益。 
DirectX11.3引入了光栅化器顺序视图（第3.8节），这是一种缓 
冲区，允许在支持此功能的任何 GPU 上实现此透明度方法 
[327,328]。移动设备具有类似的技术，称为磁贴本地存储，允许它 
们实现多层alpha混合[153]。然而，这种机制具有性能成本，因此 
这种类型的算法可能很昂贵[1931]。这种方法建立在 Bavoil等人引 
入的k缓冲剂的基础之上。[115]，其中前几个可见层被保存并尽可 
能地分类，更深的层被丢弃并尽可能合并。Maule等人。[1142]使 
用 k缓冲器并通过使用加权平均来解释这些更远的深层。加权和 
[1202]和5.5。透明度，Alpha和合成 15710％40％70％100％图 
----------------------- Page 184-----------------------
5.37。随着不透明度的增加，对象顺序变得更加重要。（Dunn[394] 
之后的图像。）加权平均[118]透明度技术是与顺序无关的，是单遍 
的，并且几乎在每个GPU上运行。问题是他们没有考虑对象的排序。 
因此，例如，使用阿尔法来表示覆盖范围，在一条薄纱蓝色围巾上 
面的薄纱红色围巾给出了紫罗兰色，而不是正确地看到一条带有蓝 
色透明的红色围巾。虽然几乎不透明的物体会产生不良结果，但这 
类算法对于可视化非常有用，并且适用于高度透明的表面和粒子。 
见图5.37。在加权和透明度中，公式为co=Xni=1 （αici）+cd 
 （1.Xni=1αi）， （5.27）其中n是透明表面的数量，ci和αi表示 
透明度值的集合，和cd是场景​ ​ 的不透明部分的颜色。当渲染透 
明表面时，两个和被累积并分别存储，并且在透明度通过的末尾， 
在每个像素处评估等式。这种方法的问题在于第一个总和饱和，即 
产生大于（1.0,1.0,1.0）的颜色值，并且背景颜色可能具有负面影 
响，因为α的总和可以超过1.0。加权平均方程通常是优选的，因为 
它避免了这些问题：csum =Xni=1 （αici），αsum=Xni=1αi， 
cwavg =csumαsum，αavg=αsumn，u = （1。αavg）n，co = 
 （1.u）cwavg+ucd。 （5.28）第一行表示透明度渲染期间生成的 
两个单独缓冲区中的结果。每个对csum有贡献的表面都会受到158 
加权影响.5。阴影基础图5.38。两个不同的摄像机位置查看相同的 
引擎模型，均使用加权混合顺序无关透明度渲染。按距离加权有助 
于澄清哪些表面更接近观察者[1185]。 （图片由MorganMcGuire 
提供。）其alpha;几乎不透明的表面会产生更多的颜色，而几乎透 
----------------------- Page 185-----------------------
明的表面几乎没有影响。通过将csum除以αsum，我们得到加权平 
均透明度颜色。值αavg是所有alpha值的平均值。对于 n个透明 
表面，值u是对该平均α应用 n次之后目标的估计可见性（不透明 
场景）。最后一行实际上是over运算符， （1.u）表示源的alpha。 
加权平均值的一个限制是，对于相同的alpha，它会平等地混合所 
有颜色，而不管顺序如何。McGuire和 Bavoil[1176,1180]引入了 
加权混合顺序无关透明度，以提供更有说服力的结果。在它们的配 
方中，到表面的距离也会影响重量，更接近的表面会产生更大的影 
响。此外，不是对α进行平均，而是通过将项 （1.αi）相乘并从 1减 
去来计算u，给出表面集的真实α覆​ ​ 盖。这种方法产生更具视觉 
冲击力的结果，如图5.38所示。缺点是在大环境中彼此靠近的物体 
可能具有与距离几乎相等的权重，使得结果与加权平均值几乎不同。 
此外，随着相机与透明物体的距离发生变化，深度权重可能会有效 
变化，但这种变化是渐进的。McGuire和 Mara[1181,1185]将这 
种方法扩展到包括合理的透射色效果。如前所述，本节中讨论的所 
有透明度算法都会混合各种颜色而不是过滤它们，从而模仿像素覆 
盖率。为了给出滤色器效果，像素着色器读取不透明场景，并且每 
个透明表面将其在该场景中覆盖的像素乘以其颜色，将结果保存到 
第三个缓冲区。这个缓冲区，现在，透明的不透明物体着色，然后 
在解析反射 5.5时用来代替不透明的场景。透明度，Alpha和合成 
159个parency缓冲区。此方法有效，因为与覆盖范围内的透明度 
不同，彩色传输与顺序无关。还有其他算法使用了此处介绍的几种 
----------------------- Page 186-----------------------
技术中的元素。例如，Wyman [1931]按照内存要求，插入和合并 
方法，是否使用了alpha或几何覆盖以及如何处理丢弃的片段来对 
先前的工作进行分类。他通过寻找先前研究中的差距，提出了两种 
新方法。他的随机分层alpha混合方法使用k-buffers，加权平均和 
随机透明度。他的另一种算法是Salvi和Vaidyanathan方法的变种， 
使用覆盖掩码而不是alpha。鉴于各种类型的透明内容，渲染方法 
和GPU功能，没有完美的渲染透明对象的解决方案。我们将感兴趣 
的读者引用到Wyman的论文[1931]和Maule等人的交互式透明度 
算法的更详细的调查[1141]。McGuire的演示[1182]提供了更广泛 
的视野，贯穿其他相关现象，如体积照明，彩色透射和折射，本书 
稍后将对此进行更深入的讨论。5.5.3预乘Alpha和合成over操作 
符还用于将对象的照片或合成渲染混合在一起。这个过程称为合成 
[199,1662]。在这种情况下，每个像素的alpha值与对象的 RGB 
颜色值一起存储。由alpha通道形成的图像有时称为遮罩。它显示 
了对象的轮廓形状。有关示例，请参见第203页的图6.27。然后可 
以使用该RGBα图像将其与其他这样的元素或背景混合。使用合成 
RGBα数据的一种方法是使用预乘alphas （也称为相关alpha）。 
也就是说，RGB值在使用之前乘以α值。这使得合成方程更有效： 
co =c's + （1.αs）cd，（5.29）其中c是预乘的源通道，取代公 
式 5.25中的αscs。预乘alpha也可以在不改变混合状态的情况下 
使用叠加和叠加混合，因为在混合过程中现在添加了源颜色[394]。 
请注意，对于预乘 RGBα值，RGB分量通常不大于alpha值，但可 
----------------------- Page 187-----------------------
以这样做以创建特别明亮的半透明值。渲染合成图像与预乘alphas 
自然地吻合。在黑色背景上渲染的抗锯齿不透明对象默认提供预乘 
值。假设白色 （1,1,1）三角形覆盖其边缘的一些像素的40％。使用 
 （非常精确）抗锯齿，像素值将设置为0.4的灰度，即，我们将保 
存该像素的颜色 （0.4,0.4,0.4）。如果 160存储着色基础，则α值也 
将为0.4，因为这是三角形覆盖的区域。RGBα值为（0.4,0.4,0.4,0.4）， 
这是一个预乘值。存储图像的另一种方式是使用未经过相应的 
alphas，也称为无关联的alphas，或者甚至是非弯曲的术语非预乘 
的alphas。一个未经过乘法的alpha就是它所说的：RGB值不会 
乘以 alpha值。对于白色三角形示例，未经过相应的颜色将为 
 （1,1,1,0.4）。此表示具有存储三角形的原始颜色的优点，但在显 
示之前，此颜色始终需要与存储的alpha相乘。每当执行滤波和混 
合时，最好使用预乘数据，因为线性插值等操作无法使用未经过相 
乘的α[108,164]正常工作。可以产生诸如物体边缘周围的黑色条纹 
之类的伪像[295,648]。有关进一步的讨论，请参见第6.6节的末尾。 
预乘alphas也允许更清晰的理论治疗[1662]。对于图像处理应用程 
序，无关联的alpha可用于屏蔽照片而不会影响基础图像的原始数 
据。此外，无关联的alpha意味着可以使用颜色通道的完整精度范 
围。也就是说，必须注意将未经过相乘的RGBα值正确地转换为用 
于计算机图形计算的线性空间。例如，没有浏览器正确地执行此操 
作，也不可能这样做，因为现在预期会出现错误的行为[649]。支持 
alpha的图像文件格式包括PNG （仅限非关联alpha），OpenEXR 
----------------------- Page 188-----------------------
 （仅关联）和TIFF （两种类型的alpha）。与alpha通道相关的概 
念是色度键控[199]。这是一个来自视频制作的术语，演员在绿色或 
蓝色屏幕上拍摄并与背景混合。在电影工业中，这个过程称为绿色 
筛选或蓝屏。这里的想法是指定特定的色调（用于电影工作）或精 
确值 （用于计算机图形）被认为是透明的;只要检测到背景，就会显 
示背景。这允许仅使用 RGB颜色给图像赋予轮廓形状;不需要存储 
alpha。该方案的一个缺点是物体在任何像素处完全不透明或透明， 
即，α实际上仅为 1.0或0.0。例如，GIF格式允许将一种颜色指定 
为透明。5.6显示编码当我们计算光照，纹理或其他操作的效果时， 
假设使用的值是线性的。通俗地说，这意味着加法和乘法按预期工 
作。但是，为了避免各种视觉伪像，显示缓冲区和纹理使用我们必 
须考虑的非线性编码。简短而邋answer的答案如下：在[0,1]范围 
内获取着色器输出颜色，并以1/2.2的幂提升它们，执行所谓的伽 
马校正。对传入的纹理和颜色执行相反的操作。在大多数情况下， 
您可以告诉GPU为您执行这些操作。本节介绍该快速摘要的方式和 
原因。5.6。显示编码 161我们从阴极射线管 （CRT）开始。在数字 
成像的早期，CRT显示器是常态。这些器件在输入电压和显示辐射 
之间呈现出幂律关系。随着应用于像素的能级增加，发射的辐射不 
会线性增长，但（令人惊讶地）与上升到大于 1的功率的水平成比 
例地增加。例如，假设功率为2.设置为50％的像素将发出四分之一 
的光量，0.52 =0.25，作为设置为1.0的像素[607]。尽管LCD和 
其他显示技术具有与CRT不同的固有色调响应曲线，但它们是用转 
----------------------- Page 189-----------------------
换电路制造的，这使得它们模仿CRT响应。该幂函数几乎匹配人类 
视觉的亮度敏感度的倒数[1431]。幸运巧合的结果是编码大致在感 
知上是均匀的。也就是说，一对编码值 N和 N+1之间的感知差异 
在可显示范围内大致恒定。测量为阈值对比度，我们可以在很宽的 
条件下检测出约 1％的亮度差异。当颜色存储在有限精度的显示缓 
冲区中时，这种接近最佳的值分布可最大限度地减少条带伪影（第 
23.6节）。同样的好处也适用于通常使用相同编码的纹理。显示传 
递函数描述了显示缓冲器中的数字值与显示器发出的辐射亮度之间 
的关系。因此，它也被称为电光学传递函数 （EOTF）。显示传输功 
能是硬件的一部分，计算机显示器，电视和电影放映机有不同的标 
准。对于过程的另一端，图像和视频捕获设备，还有一个标准传输 
功能，称为光电传递函数（OETF）[672]。当编码用于显示的线性 
颜色值时，我们的目标是抵消显示传递函数的效果，使得我们计算 
的任何值将发出相应的辐射水平。例如，如果我们的计算值加倍， 
我们希望输出辐亮度加倍。为了保持这种连接，我们应用显示传递 
函数的反转来抵消其非线性效应。这种使显示器的响应曲线无效的 
过程也称为伽马校正，其原因很快就会变得清晰。解码纹理值时， 
我们需要应用显示传递函数来生成用于着色的线性值。图5.39显示 
了在显示过程中使用解码和编码。个人计算机显示器的标准传输功 
能由称为sRGB的颜色空间规范定义。控制GPU的大多数API可以 
设置为在从纹理读取值或写入颜色缓冲区时自动应用正确的sRGB 
转换[491]。如第6.2.2节所述，mipmap生成也将考虑sRGB编码。 
----------------------- Page 190-----------------------
通过首先转换为线性值然后执行插值，纹理值之间的双线性插值将 
正常工作。通过将存储的值解码回线性值，混合新值，然后对结果 
进行编码，可以正确完成Alpha混合。在将值写入帧缓冲区以进行 
显示时，在渲染的最后阶段应用转换非常重要。如果在 162之后应 
用后处理5。着色基础tex2D （s，t）纹理着色和色调映射帧缓冲显 
示解码线性值编码显示传递函数图5.39。在左侧，GPU着色器访问 
PNG颜色纹理，并将其非线性编码值转换 （蓝色）为线性值。在着 
色和色调映射（第8.2.2节）之后，最终的计算值被编码（绿色） 
并存储在帧缓冲区中。该值和显示传递函数确定发射的辐射量（红 
色）。绿色和红色功能组合抵消，因此发出的辐射亮度与线性计算 
值成比例。显示编码，这种效果将在非线性值上计算，这通常是不 
正确的并且经常会导致伪像。显示编码可以被认为是一种压缩形式， 
一个最能保持价值感知效果的人[491]。考虑这个领域的一个好方法 
是我们使用线性值来执行物理计算，每当我们想要显示结果或访问 
可显示的图像（如颜色纹理）时，我们需要将数据移入或移出其显 
示编码形式，使用适当的编码或解码变换。如果您确实需要手动应 
用sRGB，则可以使用标准转换公式或一些简化版本。实际上，显 
示器由每个颜色通道的多个位控制，例如，对于消费者级监视器为 
8，给出一组在[0,255]范围内的级别。这里我们将显示编码的级别 
表示为范围[0.0,1.0]，忽略位数。线性值也在[0.0,1.0]范围内，表示 
浮点数。我们用x表示这些线性值，用y表示存储在帧缓冲器中的 
非线性编码值。要将线性值转换为sRGB非线性编码值，我们应用 
----------------------- Page 191-----------------------
sRGB显示传递函数的逆：y =f.1sRGB x（）= （1.055x1/2.4.0.055， 
其中x> 0.0031308,12.92x，其中x≤ 0.0031308，（5.30），其 
中x表示线性RGB三元组的通道。该公式适用于每个通道，这三个 
生成的值驱动显示。请注意5.6。显示编码163手动应用转换功能。 
错误是使用编码颜色而不是线性形式，另一种是对颜色进行解码或 
编码两次。两个变换表达式的底部是一个简单的乘法，这是因为数 
字硬件需要使变换完全可逆[1431]]。顶部表达式涉及将值提高到 
幂，几乎适用于输入值x的整个范围[0.0,1.0]。考虑到偏移和比例， 
该函数非常接近于更简单的公式[491]：y =f.1显示（x）=x1/， 
 （5.31），γ=2.2。希腊字母γ是名称 “伽马校正”的基础。正如计 
算值必须被编码用于显示一样，静止或摄像机捕获的图像在用于计 
算之前必须转换为线性值。您在显示器或电视上看到的任何颜色都 
有一些显示编码的 RGB三元组，您可以从屏幕截图或颜色选择器中 
获得这些颜色。这些值以 PNG，JPEG和GIF等文件格式存储，这 
些格式可以直接发送到帧缓冲区，以便在不进行转换的情况下显示 
在屏幕上。换一种说法，无论你在屏幕上看到什么，都是按照定义 
显示编码数据。在着色计算中使用这些颜色之前，我们必须将此编 
码形式转换回线性值。从显示编码到线性值我们需要的sRGB变换 
是x =fsRGB y（）=.......？y +0.0551.055？2.4，其中y>0.04045， 
y 12.92，其中y≤0.04045， （5.32），y表示标准化显示的通道值， 
即存储在图像或帧缓冲区中的值，表示为范围内的值[0.0,1.0]。此 
解码函数与我们之前的sRGB公式相反。这意味着如果着色器访问 
----------------------- Page 192-----------------------
纹理并且输出没有变化，它将显示与处理之前相同，如预期的那样。 
解码功能与显示传输功能相同，因为存储在纹理中的值已被编码以 
正确显示。我们转换为线性值，而不是转换为线性响应显示。更简 
单的伽玛显示传递函数是方程5.31的反函数：x =fdisplay （y）= 
y。 （5.33）有时您会看到更简单的转换对，特别是在移动和浏览器 
应用程序上[1666]：y =f.1 simpl （x）=√x，x =fsimpl （y）= 
y2; （5.34）也就是说，取用于转换的线性值的平方根进行显示，并 
将该值乘以其自身的倒数。虽然粗略近似，但这种转换比完全忽略 
问题更好。1645.阴影基础图5.40。两个重叠的聚光灯照亮一架飞 
机。在左图中，在添加0.6和0.4的光值之后不执行伽马校正。有 
效地对非线性值执行加法，从而导致错误。注意左侧灯光看起来比 
右侧亮得多，并且重叠看起来不切实际。在右图中，添加后对值进 
行伽马校正。灯本身比例更亮，并且它们在重叠的地方正确组合。 
如果我们不注意伽马，则较低的线性值将在屏幕上显得过于暗淡。 
相关的错误是如果不执行伽马校正，某些颜色的色调可能会发生偏 
移。说我们的γ=2.2。我们希望从显示的像素发射与线性计算值成 
比例的辐射，这意味着我们必须将线性值提高到（1/ 2.2）功率。 
线性值0.1给出0.351,0。2给出0.481，0.5给出0.730。如果不 
进行编码，这些使用的值将导致显示器发出的辐射度低于所需的辐 
射率。请注意，任何这些变换都始终保持0.0和 1.0不变。在使用 
伽马校正之前，暗表面颜色通常由建模场景的人员人为地提升，在 
逆显示变换中折叠。忽略伽马校正的另一个问题是对非线性值执行 
----------------------- Page 193-----------------------
对物理线性辐射值正确的阴影计算。图5.40中可以看到这方面的一 
个例子。忽略伽马校正也会影响抗锯齿边缘的质量。例如，假设三 
角形边缘覆盖四个屏幕网格单元 （图5.41）。三角形的图5.41。在 
左边，在黑色（显示为灰色）背景上由白色三角形边缘覆盖的四个 
像素，显示真实区域覆盖。如果不执行伽马校正，则中间调变暗将 
导致边缘的感知失真，如右图所示。5.6。显示编码165图5.42。 
在左边，一组抗锯齿线被伽马校正;在中间，该集合被部分纠正;在 
右边，没有伽马校正。（图片由Scott R.Nelson提供。）标准化 
辐亮度为 1（白色）;背景为0（黑色）。从左到右，细胞被覆盖 18,8,8,5 
和78。因此，如果我们使用盒式滤波器，我们希望将像素的归一 
化线性辐射度表示为0.125,0.375,0.625和0.875。正确的方法是对 
线性值执行抗锯齿，将编码函数应用于四个结果值。如果不这样做， 
则所表示的像素的辐亮度将太暗，导致边缘的感知变形，如图的右 
侧所示。这个神器被称为绳索，因为边缘看起来有点像扭绳 
[167,1265]。图5.42显示了这种效果。sRGB标准创建于 1996年， 
已成为大多数计算机显示器的标准。然而，从那时起，显示技术已 
经发展。已经开发出更亮并且可以显示更广泛颜色的监视器。第 
8.1.3节讨论了彩色显示和亮度，第8.2.1节介绍了高动态范围显示 
的显示编码。Hart的文章[672]是有关高级显示的更多信息的特别 
全面的来源。进一步阅读和资源 Pharr等。[1413]更深入地讨论采 
样模式和抗锯齿。Teschner的课程笔记[1758]显示了各种采样模式 
生成方法。Drobot[382,383]贯穿了之前关于实时抗锯齿的研究， 
----------------------- Page 194-----------------------
解释了各种技术的属性和性能。关于各种形态抗锯齿方法的信息可 
以在相关 SIGGRAPH 课程的注释中找到[829]。Reshetov和 
Jimenez [1486]提供了游戏中使用的形态学和相关时间抗锯齿功的 
最新回顾。对于透明度研究，我们再次将感兴趣的读者引用到 
McGuire的演讲[1182]和Wyman的作品[1931]。Blinn的文章“什 
么是像素？”[169]在讨论不同定义的同时，提供了几个计算机图形 
领域的精彩之旅。Blinn的脏像素和符号，符号，符号书[166,168] 
包括一些关于过滤和抗锯齿的介绍性文章，以及关于 1665.着色基 
础alpha，合成和伽马校正的文章。Jimenez的演讲[836]详细介绍 
了用于抗锯齿的最先进技术。Gritz和d'Eon [607]对伽马校正问题 
进行了很好的总结。Poynton的书[14​ ​ 31]对各种媒体中的伽马 
校正以及其他与颜色相关的主题进行了全面的报道。Selan的白皮 
书[1602]是一个较新的资料来源，解释了显示编码及其在电影行业 
中的应用，以及许多其他相关信息。第6章纹理 “所需要的只是渲 
染图像看起来正确。” -Jim Blinn表面的纹理就是它的外观和感 
觉 - 只要想想油画的质感。在计算机图形学中，纹理化是一个过程， 
它使用一些图像，函数或其他数据源来获取表面并在每个位置修改 
其外观。作为示例，不是精确地表示砖墙的几何形状，而是将砖墙 
的彩色图像应用于由两个三角形组成的矩形。查看矩形时，彩色图 
像显示在矩形所在的位置。除非观察者靠近墙壁，否则缺乏几何细 
节将不会引人注意。然而，由于缺乏几何形状，一些纹理砖墙可能 
不能令人信服。例如，如果砂浆应该是哑光的，而砖块是有光泽的， 
----------------------- Page 195-----------------------
观察者会发现两种材料的粗糙度都相同。为了产生更令人信服的体 
验，可以将第二图像纹理应用于表面。这种纹理不是改变表面的颜 
色，而是根据表面上的位置改变墙的粗糙度。现在砖块和砂浆都有 
来自图像纹理的颜色和来自这个新纹理的粗糙度值。观众可能会看 
到现在所有的砖都是有光泽的而且砂浆不是，但请注意每个砖面看 
起来都是完全平坦的。这看起来并不正确，因为砖块的表面通常有 
一些不规则性。通过应用凹凸贴图，可以改变砖的阴影法线，以便 
在渲染时，它们看起来不是完全平滑的。为了计算光照，这种纹理 
会摆动矩形的原始表面法线的方向。从浅视角看，这种颠簸的错觉 
可能会破裂。砖块应该从砂浆上面伸出来，遮住它。即使从直面观 
看，砖块也应该在灰浆上投下阴影。视差贴图使用纹理在渲染时使 
平面变形，并且视差遮挡贴图将光线投射到高度场纹理以提高真实 
感。位移贴图通过修改形成模型的三角形高度来真正取代曲面。图 
6.1显示了一个带有颜色纹理和凹凸贴图的示例。1671686.纹理图 
6.1。纹理。将颜色和凹凸贴图应用于此鱼以增加其视觉细节水平。 
 （图片由ElinorQuittner提供。）这些是使用越来越精细的算法可 
以用纹理解决的问题类型的例子。在本章中，详细介绍了纹理技术。 
首先，介绍了纹理化过程的一般框架。接下来，我们专注于将图像 
用于纹理表面，因为这是实时工作中最常用的纹理形式。简要讨论 
了程序纹理，然后解释了一些使纹理影响表面的常用方法。6.1。纹 
理管道 1696.1纹理管道纹理是一种有效建模表面材料和光洁度变 
化的技术。考虑纹理的一种方法是考虑单个阴影像素会发生什么。 
----------------------- Page 196-----------------------
如前一章所示，通过考虑材料的颜色和灯光以及其他因素来计算阴 
影。如果存在，透明度也会影响样品。纹理通过修改着色方程中使 
用的值来工作。这些值的更改方式通常基于曲面上的位置。因此， 
对于砖墙示例，基于表面位置，表面上任何点处的颜色被砖墙图像 
中的相应颜色替换。图像纹理中的像素通常称为纹素，以区别于屏 
幕上的像素。粗糙度纹理修改粗糙度值，并且凹凸纹理改变着色法 
线的方向，因此每个都改变着色方程的结果。纹理可以通过通用纹 
理流水线来描述。很快就会引入很多术语，但请记住：管道的每一 
部分都将详细描述。空间位置是纹理化过程的起点。这个位置可以 
在世界空间中，但更常见于模型的参照系，因此当模型移动时，纹 
理随之移动。使用 Kershaw的术语[884]，空间中的这个点然后应 
用投影仪功能来获得一组数字，称为纹理坐标，将用于访问纹理。 
此过程称为映射，这将导致短语纹理映射。有时纹理图像本身称为 
纹理贴图，尽管这不是严格正确的。在这些新值可用于访问纹理之 
前，可以使用一个或多个对应函数将纹理坐标变换为纹理空间。这 
些纹理空间位置用于从纹理获得值，例如，它们可以是阵列索引到 
图像纹理中以检索像素。然后，通过值转换函数再次可能转换检索 
到的值，最后这些新值用于修改曲面的某些属性，例如材质或阴影 
法线。图6.2显示了单个纹理应用的详细过程。管道复杂性的原因 
是每个步骤都为用户提供了有用的控制。应该注意的是，并非所有 
步骤都需要始终激活。对象空间位置投影仪功能对应函数获取值值 
变换函数参数空间坐标纹理空间位置纹理值变换纹理值图6.2。单个 
----------------------- Page 197-----------------------
纹理的广义纹理管道。1706.纹理（x，y，z）（ -2.3,7.1,88.2） 
uv （u，v）图6.3。砖墙的管道。使用此管道，当三角形具有砖墙 
纹理并在其表面上生成样本时会发生这种情况 （参见图6.3）。找到 
对象的本地参照系中的（x，y，z）位置;说它是（.2.3,7.1,88.2）。 
然后将投影仪功能应用于该位置。正如世界地图是将三维物体投影 
到二维中一样，这里的投影仪功能通常会改变 （x，y，z）将矢量转 
换为双元素矢量（u，v）。本例中使用的投影仪功能相当于正投影 
 （第2.3.1节），其作用类似于将砖墙图像照射到三角形表面上的 
幻灯片投影仪。为了返回到墙，其表面上的点可以转换为从0到 1 
的一对值。假设获得的值是 （0.32,0.29）。这些纹理坐标用于查找 
图像在此位置的颜色。我们的砖纹理的分辨率是256×256，因此对 
应函数将 （u，v）乘以256，得到 （81.92,74.24）。丢弃分数，像 
素 （81,74）在砖墙图像中找到，并且具有颜色 （0.9,0.8,0.7）。纹 
理颜色在sRGB颜色空间中，因此如果要在着色方程中使用颜色， 
它被转换为线性空间，给出（0.787,0.604,0.448）（第5.6节）。 
6.1.1投影仪功能纹理处理的第一步是获取曲面的位置并将其投影 
到纹理坐标空间，通常是二维（u，v）空间。建模包通常允许艺术 
家定义每个顶点的（u，v）坐标。这些可以从投影仪功能或网格展 
开算法初始化。艺术家可以像编辑顶点位置一样编辑 （u，v）坐标。 
投影仪功能通常通过将空间中的三维点转换为纹理坐标来工作。建 
模程序中常用的函数包括球面，圆柱面和平面投影[141,884,970]。 
6.1。纹理管道171图6.4。不同的纹理投影。球形，圆柱形，从左 
----------------------- Page 198-----------------------
到右显示平面和自然（u，v）投影。底行显示应用于单个对象（没 
有自然投影）的每个投影。其他输入可用于投影仪功能。例如，表 
面法线可用于选择六个平面投影方向中的哪一个用于表面。匹配纹 
理的问题出现在面相遇的接缝处; Geiss [521,522]讨论了一种混合 
它们的技术。塔里尼等人。[1740]描述多立方体贴图，其中模型被 
映射到一组立方体投影，其中不同的空间体积映射到不同的立方体。 
其他投影仪功能根本不是投影，而是表面创建和曲面细分的隐含部 
分。例如，参数化曲面具有一组自然的（u，v）值作为其定义的一 
部分。见图6.4。纹理坐标也可以从各种不同的参数生成，例如视图 
方向，表面温度或任何其他可以想象的参数。投影仪功能的目标是 
生成纹理坐标。将这些作为位置的函数得出只是一种方法。非交互 
式渲染器通常将这些投影仪功能称为渲染过程本身的一部分。单个 
投影仪功能可能足以满足整个模型，但艺术家通常必须使用工具来 
细分模型并分别应用各种投影仪功能[1345]。见图6.5。在实时工作 
中，投影仪功能通常在建模阶段应用，投影结果存储在顶点。这并 
非总是如此;有时在顶点或像素着色器中应用投影函数是有利的。这 
样做可以提高精度，并有助于实现各种效果，包括动画 （第6.4节）。 
一些渲染方法，如环境映射 1726.纹理图6.5。如何在单个模型上 
使用各种纹理投影。框映射由六个平面映射组成，每个框面对应一 
个映射。（图片由Tito Pagan提供。）（第 10.4节），具有自己 
的专用投影仪功能，每个像素进行评估。球形投影（图6.4中的左 
侧）将点投射到以某点为中心的假想球体上。此投影与 Blinn和 
----------------------- Page 199-----------------------
Newell的环境映射方案 （第 10.4.1节）中使用的相同，因此第407 
页的公式 10.30描述了此函数。该投影方法遇到与该部分中描述的 
顶点插值相同的问题。圆柱投影计算u纹理坐标与球面投影相同，v 
纹理坐标计算为沿圆柱轴的距离。该投影对于具有自然轴的对象（例 
如旋转表面）非常有用。当曲面接近圆柱轴时，会发生扭曲。平面 
投影类似于X射线束，沿着一个方向平行投射并将纹理应用于所有 
表面。它使用正交投影（第4.7.1节）。例如，这种类型的投影对 
于应用贴花很有用 （第20.2节）。由于对于投影方向边缘的表面存 
在严重的扭曲，艺术家经常必须手动将模型分解成近平面的碎片。 
还有一些工具可以通过展开网格或创建近乎最佳的平面投影集来帮 
助最小化失真，或者有助于此过程。目标是为每个多边形赋予纹理 
区域更公平的份额，同时保持尽可能多的网格连接。连接性很重要， 
因为采样伪像可以沿着纹理的不同部分相交的边缘出现。A6.1。纹 
理管道 173图6.6。雕像模型的几个较小的纹理，保存在两个较大 
的纹理。右图显示了如何打开三角形网格并在纹理上显示以帮助创 
建它。 （图片由TitoPagan提供。）良好展开的网格也减轻了艺术 
家的作品[970,1345]。第 16节。2.1讨论了纹理扭曲如何对渲染产 
生不利影响。图6.6显示了用于创建图6.5中的雕像的工作空间。 
这种展开过程是更大的研究领域，网格参数化的一个方面。感兴趣 
的读者可以参考Hormann等人的SIGGRAPH课程笔记。[774]。 
纹理坐标空间并不总是二维平面;有时它是一个三维体积。在这种情 
况下，纹理坐标表示为三元素矢量 （u，v，w），其中w是沿投影 
----------------------- Page 200-----------------------
方向的深度。其他系统使用多达四个坐标，通常指定为（s，t，r， 
q）[885];q用作齐次坐标中的第四个值。它的作用类似于电影或幻 
灯片投影仪，投影纹理的大小随距离而增加。举个例子，它可用于 
将装饰性聚光灯图案（称为遮光板）投影到舞台或其他表面上 
[1597]。另一种重要类型的纹理坐标空间是方向性的，其中空间中 
的每个点都由输入方向访问。可视化这样的空间的一种方式是单位 
球面上的点，每个点处的法线表示用于访问该位置处的纹理的方向。 
使用方向参数化的最常见纹理类型是立方体贴图（第6.2.4节）。 
值得注意的是，一维纹理图像和功能具有其用途。例如，在地形模 
型上，着色可以通过高度来确定，例如，低地是绿色; 山峰是白色的。 
线条也可以纹理化;一种用途是将雨水作为一组纹理有半透明图像 
的长线。这样的纹理对于从一个值转换到另一个值也是有用的，即， 
作为查找表。1746.纹理由于可以将多个纹理应用于曲面，因此可 
能需要定义多组纹理坐标。然而，应用坐标值，想法是相同的：这 
些纹理坐标在表面上插值并用于检索纹理值。然而，在插值之前， 
这些纹理坐标由对应函数变换。6.1.2对应函数对应函数将纹理坐标 
转换为纹理空间位置。它们可以灵活地将纹理应用于曲面。对应函 
数的一个示例是使用 API​ ​ 来选择现有纹理的一部分以供显 
示;只有这个子图像才会用于后续操作。另一种类型的对应器是矩阵 
变换，其可以应用于顶点或像素着色器。这使得能够在表面上平移， 
旋转，缩放，剪切或投射纹理。如第4.1.5节所述，变换的顺序很 
重要。令人惊讶的是，纹理变换的顺序必须与人们期望的顺序相反。 
----------------------- Page 201-----------------------
这是因为纹理变换实际上会影响确定图像所在位置的空间。图像本 
身不是被转换的对象;定义图像位置的空间正在改变。另一类对应函 
数控制图像的应用方式。我们知道图像将出现在 （u，v）在[0,1]范 
围内的表面上。但是在这个范围之外会发生什么？通信函数确定行 
为。在OpenGL中，这种类型的通信器功能称为 “包装模式”;在 
DirectX中，它被称为 “纹理寻址模式”。这种类型的常见对应函 
数是：。wrap （DirectX），repeat （OpenGL）或tile-图像在表 
面重复;在算法上，纹理坐标的整数部分被删除。此功能对于使材料 
图像重复覆盖表面非常有用，并且通常是默认设置。。镜像 - 图像 
在表面上重复，但在每次重复时都会被镜像（翻转）。例如，图像 
通常从0到 1出现，然后在 1到2之间反转，那么在2和3之间是 
正常的，然后是相反的，依此类推。这提供了沿纹理边缘的一些连 
续性。。钳位（DirectX）或钳位到边缘（OpenGL） - 范围[0,1] 
之外的值被钳位到此范围。这导致重复图像纹理的边缘。当双线性 
插值发生在纹理边缘附近时，此功能可用于避免从纹理的相对边缘 
意外地取样[885]。。border （DirectX）或 clamp to border 
 （OpenGL） -[0,1]之外的纹理坐标使用单独定义的边框颜色进行 
渲染。这个功能可以6.1。纹理管道175图6.7。图像纹理重复，镜 
像，夹具和边框功能在起作用。适用于将贴花渲染到单色表面上， 
例如，因为纹理的边缘将与边框颜色平滑地融合。见图6.7。可以针 
对每个纹理轴不同地分配这些对应函数，例如，纹理可以沿着u轴 
重复并且被夹在v轴上。在 DirectX中，还有一个镜像一次模式， 
----------------------- Page 202-----------------------
它沿着纹理坐标的零值镜像纹理一次，然后钳位，这对于对称贴花 
很有用。重复平铺纹理是向场景添加更多视觉细节的廉价方式。然 
而，在大约三次重复纹理之后，这种技术通常看起来不能令人信服， 
因为眼睛会挑出图案。避免这种周期性问题的常见解决方案是将纹 
理值与另一个非平铺的纹理组合。这种方法可以大大扩展，如 
Andersson [40]描述的商业地形渲染系统所示。在该系统中，基于 
地形类型，高度，坡度和其他因素组合多个纹理。纹理图像也与几 
何模型（例如灌木和岩石）放置在场景中的位置相关联。避免周期 
性的另一个选择是使用着色器程序来实现随机重组纹理图案或图块 
的专用对应函数。Wang瓷砖就是这种方法的一个例子。Wang瓷 
砖套装是一小块方形瓷砖，边缘相匹配。在纹理化过程中随机选择 
瓷砖[1860]。Lefebvre和 Neyret[1016]使用依赖纹理读取和表来 
实现类似类型的对应函数以避免模式重复。应用的最后一个通信函 
数是隐式的，并且是从图像的大小派生的。纹理通常在u和v的范 
围[0,1]内应用。如砖墙示例所示，通过将该范围内的纹理坐标乘以 
图像的分辨率，可以获得像素位置。能够在[0,1]范围内指定 （u，v） 
值的优点是可以交换具有不同分辨率的图像纹理，而无需更改存储 
在模型顶点的值。6.1.3纹理值使用对应函数生成纹理空间坐标后， 
坐标用于获取纹理值。对于图像纹理，这由 176完成.6。纹理访问 
纹理以从图像中检索纹理元素信息。该过程在6.2节中有详细论述。 
图像纹理构成了实时工作中绝大部分的纹理使用，但也可以使用程 
序功能。在程序纹理化的情况下，从纹理空间位置获得纹理值的过 
----------------------- Page 203-----------------------
程不涉及存储器查找，而是涉及函数的计算。程序纹理在6.3节中 
进一步描述。最直接的纹理值是 RGB三元组，用于替换或修改表面 
颜色;类似地，可以返回单个灰度值。另一种要返回的数据是 RGBα， 
如第5.5节所述。α （α）值通常是颜色的不透明度，其决定了颜色 
可能影响像素的程度。也就是说，可以存储任何其他值，例如表面 
粗糙度。还有许多其他类型的数据可以存储在图像纹理中，如将详 
细讨论凹凸贴图时所见（第6.7节）。从纹理返回的值可选地在使 
用前进行转换。可以在着色器程序中执行这些变换。一个常见示例 
是将数据从无符号范围（0.0到 1.0）重新映射到有符号范围（.1.0 
到 1.0），该范围用于着色存储在颜色纹理中的法线。6.2图像纹理 
在图像纹理中，二维图像有效地粘合到一个或多个三角形的表面上。 
我们已经完成了计算纹理空间位置的过程;现在我们将解决在给定 
位置的情况下从图像纹理获得纹理值的问题和算法。在本章的其余 
部分，图像纹理将简称为纹理。另外，当我们在这里引用像素的单 
元格时，我们指的是围绕该像素的屏幕网格单元格。如第 5.4.1节 
所述，像素实际上是一个显示的颜色值，它可以（并且应该为了更 
好的质量）受到其相关网格单元外部的样本的影响。在本节中，我 
们特别关注快速采样和过滤纹理图像的方法。5.4.2节讨论了混叠问 
题，特别是在渲染对象边缘方面。纹理也可能存在采样问题，但它 
们出现在正在渲染的三角形的内部。像素着色器通过将纹理坐标值 
传递给诸如texture2D之类的调用来访问纹理。这些值在（u，v） 
纹理坐标中，由对应函数映射到范围[0.0,1.0]。GPU负责将此值转 
----------------------- Page 204-----------------------
换为纹素坐标。不同 API 中的纹理坐标系有两个主要差异。在 
DirectX中，纹理的左上角是 （0,0），右下角是 （1,1）。这匹配了 
存储数据的图像类型数量，顶行是文件中的第一行。在OpenGL中， 
纹素（0,0）位于左下方，y轴位于 DirectX上。纹素有整数坐标， 
但我们经常想要访问纹素之间的位置并在它们之间进行混合。这提 
出了像素中心的浮点坐标是什么的问题。Heckbert [692]讨论了 
6.2。图像纹理177如何有两个系统：截断和舍入。DirectX9将每 
个中心定义为 （0.0,0。0） - 这使用舍入。这个系统有点令人困惑， 
因为左上角像素的左上角，在DirectX的原点，然后有值（.0.5，.0.5）。 
DirectX10向前更改为OpenGL的系统，其中纹素的中心具有小数 
值 （0.5,0.5） - 截断，或更准确地说，地板，其中分数被丢弃。地 
板是一个更自然的系统，可以很好地映射到语言，在那个像素 （5,9） 
中，例如，为u坐标定义5.0到6.0的范围，为v定义9.0到 10.0 
的范围。一个值得解释的术语point是依赖纹理读取，它有两个定 
义。第一种尤其适用于移动设备。通过texture2D或类似访问纹理 
时，每当像素着色器计算纹理坐标而不是使用从顶点着色器传入的 
未修改纹理坐标时，就会发生从属纹理读取[66]。请注意，这意味 
着对输入纹理坐标的任何更改，甚至是交换u和v值这样的简单操 
作。较旧的移动GPU （那些不支持OpenGL ES3.0的移动GPU） 
在着色器没有相关纹理读取时运行效率更高，因为可以预取纹素数 
据。对于早期的桌面GPU，这个术语的另一个较旧的定义尤为重要。 
在此上下文中，当一个纹理的坐标取决于某些先前纹理的值的结果 
----------------------- Page 205-----------------------
时，会发生从属纹理读取。例如，一个纹理可能会更改着色法线， 
这反过来会更改用于访问多维数据集地图的坐标。早期GPU上的此 
类功能有限甚至不存在。今天，这些读取可能会对性能产生影响， 
具体取决于批量计算的像素数量等因素。有关更多信息，请参见第 
23.8节。GPU中使用的纹理图像大小通常为2m×2n个纹素，其中 
m和 n是非负整数。这些被称为二次幂（POT）纹理。现代GPU 
可以处理任意大小的非二次幂（NPOT）纹理，这允许将生成的图 
像视为纹理。但是，一些较旧的移动GPU可能不支持 NPOT纹理 
的mipmapping （第6.2.2节）。图形加速器对纹理大小有不同的 
上限。例如，DirectX12最多允许 163842个纹素。假设我们有一 
个256×256像素大小的纹理，我们想把它用作正方形的纹理。只 
要屏幕上的投影方块大小与纹理大致相同，方块上的纹理看起来就 
像原始图像一样。但是，如果投影的方块覆盖的原始图像包含的像 
素数量是原始图像的10倍 （称为放大率），或者投影的方块仅覆盖 
屏幕的一小部分（缩小），会发生什么？答案是，它取决于您决定 
使用哪种采样和过滤方法来处理这两种不同的情况。本章讨论的图 
像采样和过滤方法适用于从每个纹理读取的值。但是，期望的结果 
是防止最终渲染图像中的混叠，理论上需要对最终的像素颜色进行 
采样和滤波。这里的区别在于将输入过滤到着色方程或过滤其输出。 
只要输入和输出是线性相关的 （对于诸如颜色的输入进行纹理化）， 
那么过滤单个纹理值就等于过滤最终颜色。但是，存储在纹理中的 
许多着色器输入值（例如曲面法线和粗糙度值）与输出具有非线性 
----------------------- Page 206-----------------------
关系。标准纹理过滤方法可能不适用于这些纹理，从而导致锯齿。 
第9.13节讨论了过滤此类纹理的改进方法。6.2.1放大倍数在图6.8 
中，尺寸为48×48像素的纹理在正方形上纹理化，并且相对于纹理 
尺寸来看方形非常接近，因此底层图形系统必须放大纹理。最常用 
的放大滤波技术是最近邻（实际滤波器称为盒式滤波器 - 见5.4.1 
节）和双线性插值。还有立方卷积，它使用4×4或 5×5像素阵列 
的加权和。这样可以实现更高的放大质量。尽管目前通常不能获得 
对三次卷积（也称为双三次插值）的本机硬件支持，但它可以在着 
色器程序中执行。在图6.8的左侧部分中，使用了最近邻方法。这 
种放大技术的一个特征是各个纹素可能变得明显。这种效应称为像 
素化，因为该方法在放大时将每个像素中心的最近纹理像素的值取， 
导致块状外观。虽然这种方法的质量有时很差，但每个像素只需要 
获取一个纹素。在该图的中间图像中，使用双线性插值（有时称为 
线性插值）。对于每个像素，这种滤波找到四个相邻纹素并在二维 
中线性插值以找到该像素的混合值。结果是模糊的，使用最近邻法 
的大部分锯齿都消失了。作为实验，尝试查看左图图6.8。纹理放大 
48×48图像到320×320像素。左：最近邻居过滤，每个像素选择 
最近的纹素。中：使用四个最接近的纹素的加权平均值进行双线性 
过滤。右：使用 5×5最近纹素的加权平均值进行立方滤波。6.2。 
图像纹理179 （x，y）（x，y +1）（x +1，y +1）（x +1，y） 
 （81,73）（82,74）（81.92,74.24）转换为（u'，v'）=0.0 （0.42,0.74） 
1.00.01.0u'v'图6.9。双线性插值。涉及的四个纹素由左边的四个 
----------------------- Page 207-----------------------
方块表示，texel中心用蓝色表示。右边是由四个纹素的中心形成的 
坐标系。斜视时，因为它与低通滤波器具有大致相同的效果，并且 
可以更多地显示脸部。回到第 170页的砖纹理示例：不丢弃分数， 
我们得到 （pu，pv）= （81.92,74.24）。我们在这里使用OpenGL 
的左下原始纹素坐标系，因为它与标准笛卡尔系统匹配。我们的目 
标是在四个最接近的纹素中进行插值，使用它们的纹素中心定义一 
个纹素大小的坐标系。见图6.9。为了找到最近的四个像素，我们从 
样本位置中减去像素中心分数（0.5,0.5），给出（81.42,73.74）。 
丢弃分数，四个最接近的像素范围从 （x，y）= （81,73）到 （x +1， 
y +1）= （82,74）。对于我们的示例，小数部分（0.42,0.74）是 
样本相对于由四个纹素中心形成的坐标系的位置。我们将此位置表 
示为 （u'，v'）。将纹理访问函数定义为t （x，y），其中x和y是 
整数，并返回纹素的颜色。任意位置的双线性插值颜色 （u'，v'）可 
以计算为两步过程。首先，底部纹素t （x，y）和t （x +1，y）水 
平插值 （使用u'），类似地，对于最顶部的两个纹素，t （x，y +1） 
和t （x +1，y +1）。对于底部纹素，我们得到 （1.u'）t （x，y） 
+u't （x +1，y）（图6.9中的底部绿色圆圈），以及顶部（1.u'） 
t （x，y +1）+u't （x +1，y +1）（顶部绿色圆圈）。然后垂直 
插入这两个值 （使用v'），因此在 （pu，pv）处的双线性插值颜色 
b是 b （pu，pv）= （1.v'）.. （1.u'）t （x ，y）+u't （x +1，y）？ 
+v'.. （1.u'）t （x，y +1）+u't （x +1，y +1）？= （1.u'） （1。 
v'）t （x，y）+u' （1.v'）t （x +1，y）+ （1.u'）v't （x，y +1） 
----------------------- Page 208-----------------------
+你不（x +1，y +1）。（6.1）直观地说，靠近我们样本位置的 
纹素将更多地影响其最终值。这确实是我们在这个等式中看到的。 
 （x +1，y +1）的右上角纹理有1806.纹理图6.10。最近邻，双 
线性插值，以及使用相同的2×2棋盘纹理重新映射之间的部分方式。 
注意最近邻采样如何给出略微不同的正方形尺寸，因为纹理和图像 
网格不完全匹配。u'v'的影响。注意对称性y：右上角的影响等于左 
下角和样本点形成的矩形区域。回到我们的例子，这意味着从这个 
纹素中检索的值将乘以0.42×0.74，特别是0.3108。从该纹理像素 
顺时针方向看，其他乘数为0.42×0.26,0.58×0.26和0.58×0.74， 
这些权重中的所有四个总和为 1.0。伴随放大的模糊性的常见解决方 
案是使用细节纹理。这些纹理代表精细的表面细节，从手机上的划 
痕到地形上的灌木丛。这种细节作为单独的纹理覆盖在放大的纹理 
上，以不同的比例。细节纹理的高频重复图案，结合低频放大纹理， 
具有类似于使用单个高分辨率纹理的视觉效果。双线性插值在两个 
方向上线性插值。但是，不需要线性插值。假设纹理由棋盘图案中 
的黑白像素组成。使用双线性插值可在纹理上提供不同的灰度样本。 
通过重新映射使得，例如，所有低于0.4的灰色都是黑色，所有高 
于0.6的灰色都是白色，而中间的灰色被拉伸以填充间隙，纹理看 
起来更像棋盘格，同时还在纹素之间进行一些混合。见图6.10。使 
用更高分辨率的纹理会产生类似的效果。例如，假设每个检查器正 
方形由4×4个纹素组成，而不是1×1。围绕每个检查器的中心，插 
值颜色将是完全黑色或白色。在图6.8的右侧，使用了双三次滤波 
----------------------- Page 209-----------------------
器，并且很大程度上消除了剩余的阻塞。应该注意的是，双三次滤 
波器比双线性滤波器更昂贵。但是，许多高阶滤波器可以表示为重 
复线性插值[1518] （另见第 17.1.1节）。结果，纹理单元中用于线 
性插值的GPU硬件可以通过多次查找来利用。如果认为双三次滤波 
器太昂贵，Qu'.lez [1451]提出了一种使用平滑曲线在一组2×2纹 
素之间进行插值的简单技术。我们首先描述曲线然后描述技术。两 
条常用曲线是6.2。图像纹理181smoothsteps （x）五次q （x） 
图6.11。smoothstep曲线s （x） （左）和五次曲线q （x） （右）。 
平滑曲线和五次曲线[1372]：s （x）=x2 （3.2x）|{z}smoothstep 
和q （x）=x3 （6x2.15x +10）|{z}五指。（6.2）这些对于你想 
要从一个值平滑地插值到另一个值的许多其他情况很有用。 
smoothstep曲线具有s' （0）=s' （1）=0的特性，并且在0和 1 
之间平滑。五次曲线具有相同的属性，但q'' （0）=q'' （1）=0， 
即二阶导数在曲线的起点和终点也是0。两条曲线如图6.11所示。 
该技术首先计算（u'，v'）（与公式6.1和图6.9中使用的相同）， 
首先将样本乘以纹理维度并加0.5。整数部分保留以供以后使用，分 
数存储在u'和v'中，它们在[0,1]范围内。然后将（u'，v'）转换为 
 （tu，tv）= （q （u'），q （v'）），仍然在[0,1]的范围内。最后， 
减去0.5并重新加入整数部分;然后将得到的u坐标除以纹理宽度， 
并且类似地对于v。此时，新纹理坐标与GPU提供的双线性插值查 
找一起使用。请注意，此方法将在每个纹素处给出平稳，这意味着 
如果纹素位于 RGB空间中的平面上，那么这种类型的插值将提供平 
----------------------- Page 210-----------------------
滑但仍然是阶梯状的外观，这可能并非总是如此期望。见图6.12。 
图6.12。放大一维纹理的四种不同方法。橙色圆圈表示纹素的中心 
以及纹素值（高度）。从左到右：最近邻，线性，使用每对相邻纹 
素之间的五次曲线，并使用三次插值。1826.纹理图6.13。缩小： 
通过一行像素单元格的棋盘纹理正方形视图，大致显示多个纹素如 
何影响每个像素。6.2.2缩小当纹理最小化时，几个纹素可能会覆盖 
像素的单元格，如图6.13所示。要为每个像素获取正确的颜色值， 
您应该集成影响像素的纹素的效果。然而，很难准确地确定特定像 
素附近的所有纹素的确切影响，并且实际上不可能实时地完成。由 
于这种限制，GPU上使用了几种不同的方法。一种方法是使用最近 
邻居，它与相应的放大滤镜完全相同，即选择在像素单元中心可见 
的纹素。此过滤器可能会导致严重的混叠问题。在图6.14中，最上 
面的邻居用在上图中。朝着地平线出现伪影，因为只有影响像素的 
许多纹素中的一个被选择来表示表面。当表面相对于观察者移动时， 
这种伪像甚至更明显，并且是所谓的时间混叠的一种表现。另一种 
常用的滤波器是双线性插值，再次与放大滤波器完全相同。该过滤 
器仅略微优于最近邻近的缩小方法。它混合了四个纹素而不是仅使 
用一个，但是当一个像素受到超过四个纹素的影响时，过滤器很快 
就会失败并产生混叠。更好的解决方案是可能如第5.4.1节所述， 
可以通过采样和滤波技术解决混叠问题。纹理的信号频率取决于其 
纹理像素在屏幕上的间隔距离。由于奈奎斯特极限，我们需要确保 
纹理的信号频率不大于采样频率的一半。例如，假设图像由交替的 
----------------------- Page 211-----------------------
黑线和白线组成，分开的纹素。然后波长为两个纹素宽（从黑线到 
黑线），因此频率为 12。为了在屏幕上正确地显示该纹理，频率 
必须至少为2×12，即每个纹素至少一个像素。因此，对于一般的 
纹理，每个像素最多应该有一个纹素，以避免混叠。为了实现这一 
目标，要么像素的采样频率必须增加，要么纹理频率必须降低。前 
面6.2中讨论的抗锯齿方法。图像纹理183图6.14。顶部图像使用 
点采样 （最近邻居）渲染，中心采用mipmapping，底部采用总和 
区域表。章节给出了提高像素采样率的方法。然而，这些仅使采样 
频率有限地增加。为了更全面地解决这个问题，已经开发了各种纹 
理缩小算法。所有纹理抗锯齿算法背后的基本思想都是相同的：预 
处理纹理并创建数据结构，这将有助于计算像素上一组纹素的效果 
的快速近似。对于实时工作，这些算法具有使用固定数量的时间和 
资源来执行的特征。以这种方式，每个像素拍摄固定数量的样本并 
组合以计算 （可能大量）纹素的效果。Mipmapping最流行的纹理 
抗锯齿方法称为mipmapping[1889]。它以某种形式在现在生产的 
所有图形加速器上实现。 “Mip”代表 parvo中的multum，拉丁 
语代表 “小地方的许多东西” - 这是一个原创纹理被反复过滤成较 
小图像的过程的好名字。当使用mipmapping最小化滤镜时，在实 
际渲染需要184之前，用一组较小版本的纹理增加原始纹理.6。纹 
理图6.15。通过拍摄原始图像 （级别0）形成mipmap，在金字塔 
的底部，将每个2×2区域平均为下一级别的纹素值。垂直轴是第三 
个纹理坐标，d。在该图中，d不是线性的; 它是样本用于插值的两 
----------------------- Page 212-----------------------
个纹理级别的度量。地点。纹理（在零级）被下采样到原始区域的 
四分之一，每个新纹素值通常被计算为原始纹理中四个相邻纹素的 
平均值。新的一级纹理有时被称为原始纹理的子纹理。递归地执行 
缩小，直到纹理的一个或两个维度等于一个纹素。该过程如图6.15 
所示。整个图像集通常称为 mipmap链。形成高质量 mipmap的 
两个重要因素是良好的滤波和伽马校正。形成mipmap级别的常用 
方法是采用每组2×2的纹素并对其进行平均以获得mip纹素值。 
然后使用的过滤器是盒式过滤器，可能是最差的过滤器之一。这可 
能导致质量差，因为它具有不必要地模糊低频的效果，同时保持一 
些导致混叠的高频[172]。最好使用高斯，Lanczos，Kaiser或类似 
的滤波器;任务[172,1592]存在快速，免费的源代码，一些API支持 
GPU本身更好的过滤。在纹理边缘附近，在过滤期间必须注意纹理 
是重复还是单个副本。对于在非线性空间中编码的纹理（例如大多 
数颜色纹理），在过滤时忽略伽马校正将修改mipmap级别的感知 
亮度[173,607]。当您离物体越来越远并且未经校正的mipmaps被 
使用时，物体整体看起来会更暗，对比度和细节也会受到影响。因 
此，将这些纹理从sRGB转换为线性空间非常重要（第 5.6节）， 
在该空间中执行所有mipmap过滤，并转换最终的6.2。图像纹理 
185像素空间纹理空间像素角的平移vu像素单元图6.16。左边是 
方形像素单元格及其纹理视图。右侧是像素单元在纹理本身上的投 
影。结果回到sRGB色彩空间进行存储。大多数API都支持sRGB 
纹理，因此将在线性空间中正确生成 mipmap并将结果存储在 
----------------------- Page 213-----------------------
sRGB中。当访问sRGB纹理时，它们的值首先转换为线性空间，以 
便正确地执行放大和缩小。如前所述，一些纹理与最终的阴影颜色 
具有根本的非线性关系。虽然这通常会导致过滤问题，但是由于过 
滤了数百或数千个像素，因此mipmap生成对此问题特别敏感。通 
常需要专门的mipmap生成方法以获得最佳结果。这些方法详见 
9.13节。纹理化时访问此结构的基本过程很简单。屏幕像素包围纹 
理本身的区域。当像素的区域投影到纹理上时 （图6.16），它包含 
一个或多个纹素。使用像素的单元格边界并不严格正确，但这里用 
来简化演示。单元格外的纹理可以影响像素的颜色;见5.4.1节。目 
标是大致确定纹理对像素的影响程度。有两种常用的计算方法用于 
计算d （OpenGL称为λ，也称为细节的纹理级别）。一种是使用由 
像素单元形成的四边形的较长边缘来近似像素的覆盖范围 
[1889];另一种方法是使用四个差分的最大绝对值.u/.x，.v/.x，.u 
/.y和.v/.y[901,1411]。每个差值是纹理坐标相对于屏幕轴的变化 
量的度量。例如，.u/ .x是一个像素沿x屏幕轴的 u纹理值的变化 
量。有关这些方程的更多信息，请参阅Williams的原始文章[1889] 
或 Flavell[473]或 Pharr[1411]的文章。麦科马克等人。[1160]讨 
论通过最大绝对值方法引入混叠，并且它们呈现替代公式。Ewins 
等人。[454]分析几种质量相当的算法的硬件成本。这些渐变值可用 
于使用Shader Model3.0或更高版本的像素着色器程序。由于它 
们基于相邻像素中值之间的差异，因此它们无法在受动态流控制影 
响的像素着色器部分中进行纹理化（第3.8节）。对于要在这样的 
----------------------- Page 214-----------------------
部分中执行的纹理读取（例如，在循环内部），必须更早地计算导 
数。请注意，由于顶点着色器无法访问渐变信息，需要在顶点着色 
器本身中计算渐变或细节水平，并在使用顶点纹理时将其提供给 
GPU。计算坐标d的目的是确定沿着mipmap的金字塔轴采样的 
位置。见图6.15。目标是像素到纹素比率至少为1：1以实现奈奎 
斯特速率。这里的重要原理是，随着像素单元包括更多纹素和d增 
加，访问纹理的更小，更模糊的版本。（u，v，d）三元组用于访 
问mipmap。值d类似于纹理级别，但是d不是整数值，而是具有 
级别之间距离的小数值。上面的纹理级别和d位置下面的级别被采 
样。 （你，v）位置用于从这两个纹理级别中的每一个中检索双线性 
插值样本。然后，根据从每个纹理级别到d的距离，对得到的样本 
进行线性插值。整个过程称为三线性插值，并按像素执行。d坐标 
上的一个用户控制是细节偏差水平 （LOD偏差）。这是添加到d的 
值，因此它影响纹理的相对感知清晰度。如果我们进一步向上移动 
金字塔 （增加d），纹理将看起来更模糊。任何给定纹理的良好 LOD 
偏差将随图像类型和使用方式而变化。例如，开始时有些模糊的图 
像可以使用负偏差，而用于纹理化的过滤（混叠）合成图像可以使 
用正偏差。可以为整个纹理或像素着色器中的每个像素指定偏差。 
为了更精细的控制，用户可以提供用于计算它的d坐标或导数。 
mipmapping的好处在于，不是试图对影响单个像素的所有纹素进 
行求和，而是访问和插入预组合的纹素集。无论缩小量多少，此过 
程都需要一定的时间。然而，mipmapping有几个缺陷[473]。一 
----------------------- Page 215-----------------------
个主要的是过度模糊。想象一下像素单元在u方向上覆盖大量纹素， 
在v方向上只有少数纹素。这种情况通常发生在观察者沿着几乎边 
缘的纹理表面看时。实际上，可能需要沿着纹理的一个轴和沿另一 
个的放大倍数进行缩小。访问mipmap的效果是检索纹理上的方形 
区域;检索矩形区域是不可能的。为了避免混叠，我们选择纹理上像 
素单元的近似覆盖范围的最大度量。这导致检索的样本通常相对模 
糊。这种效果可以在图6.14中的mipmap图像中看到。向右移动 
的线显示过度模糊。求和面积表另一种避免过度划分的方法是求和 
面积表（SAT）[312]。要使用此方法，首先要创建一个数组，该数 
组是纹理的大小，但包含更多的存储颜色精度（例如，红色，绿色 
和6.2的每个16位或更多。图像纹理 187像素空间纹理空格像素 
的单元格边界框Axuryurxyxyll CB pixel'scell ll图6.17。像素 
单元被反投影到纹理上，由矩形约束;矩形的四个角用于访问求和区 
域表。蓝色）。在此数组中的每个位置，必须计算并存储由此位置 
和纹素（0,0）（原点）形成的矩形中所有相应纹理的纹素的总和。 
在纹理化期间，像素单元在纹理上的投影由矩形约束。然后访问求 
和区域表以确定该矩形的平均颜色，该矩形作为像素的纹理颜色传 
回。使用图6.17中所示矩形的纹理坐标计算平均值。这是使用公式 
6.3中给出的公式完成的：c =s [xur，yur]。s [xur，yll]。s [xll， 
yur] +s[xll，yll] （xur.xll）（yur.yll）。（6.3）在这里，x和y是 
矩形的纹素坐标，s[x，y]是该纹素的总和面积值。该等式通过获取 
从右上角到原点的整个区域的总和，然后通过减去相邻角落的贡献 
----------------------- Page 216-----------------------
来减去区域A和 B.区域C已被减去两次，因此它被添加回左下角。 
注意，（xll，yll）是区域C的右上角，即（xll +1，yll +1）是边 
界框的左下角。使用求和区域表的结果如图6.14所示。到达地平线 
的线条在右边缘附近更锐利，但中间的对角线交叉线仍然过于模糊。 
问题是当沿着对角线观察纹理时，会生成一个大的矩形，许多纹素 
位于计算像素附近。例如，想象一个长而细的矩形，表示像素单元 
的背投影位于图6.17中整个纹理的对角线上。将返回整个纹理矩形 
的平均值，而不仅仅是像素单元格内的平均值。求和面积表是所谓 
的各向异性过滤算法的一个例子[691]。此类算法在非方形区域上检 
索纹理元素值。然而，SAT能够最有效地在水平和垂直方向上做到 
这一点1886.纹理像素空间纹理空间像素的纹理单元mipmap采样 
各向异性线图6.18。各向异性过滤。像素单元的反投影产生四边形。 
在长边之间形成各向异性线。方向。另请注意，对于大小为 16×16 
或更小的纹理，求和区域表占用的内存至少为内存的两倍，更大的 
纹理需要更高的精度。在合理的总体内存成本下提供更高质量的总 
面积表可以在现代GPU上实现[585]。改进的过滤对于高级渲染技 
术的质量至关重要。例如，Hensley等人。[718,719]提供了一种有 
效的实现方式，并显示了求和区域采样如何改善光泽反射。其他使 
用区域采样的算法可以通过SAT改进，例如景深[585,719]，阴影图 
[988]和模糊反射[718]。无约束各向异性过滤对于当前图形硬件， 
进一步改进纹理过滤的最常用方法是重用现有的mipmap硬件。基 
本思想是像素单元被反投影，然后对纹理上的这个四边形 （四边形） 
----------------------- Page 217-----------------------
进行多次采样，并且组合样本。如上所述，每个mipmap样本都有 
一个位置和一个与之相关的方形区域。该算法不是使用单个 
mipmap样本来近似这个四边形的覆盖范围，而是使用几个方块来 
覆盖四边形。四边形的较短边可用于确定d（与mipmapping不同， 
经常使用较长边）;这使得每个 mipmap样本的平均面积更小（并 
且模糊度更低）。四边形的长边用于创建平行于长边和四边形中间 
的各向异性线。当各向异性的量在1：1和2：1之间时，沿着该线 
取两个样品 （见图6.18）。在较高的各向异性比率下，沿轴线采集 
更多样品。该方案允许各向异性线在任何方向上运行，因此不具有 
求和区域表的限制。它也不需要纹理内存比mipmap更多，因为它 
使用 mipmap算法进行采样。各向异性过滤的一个例子如图6.19 
所示。6.2。图像纹理189图6.19。Mipmap与各向异性过滤。左 
边是三线性mipmapping，右边是 16：1各向异性过滤。在地平线 
上，各向异性过滤提供了更清晰的结果，并且具有最小的混叠。（图 
片来自three.js示例webgl材料纹理各向异性[218]。）这种沿轴 
采样的想法最初是由Schilling等人提出的。使用他们的Texram动 
态存储设备[1564]。Barkans描述了算法在Talisman系统中的使用 
[103]。McCormack等人提出了一种名为 Feline的类似系统。 
[1161]。Texram的原始配方具有沿各向异性轴的样品（也称为探 
针），给定相等的重量。护身符在轴的两端给两个探针一半的重量。 
Feline使用高斯滤波器内核来加权探针组。这些算法接近高质量的 
软件采样算法，例如椭圆加权平均 （EWA）滤波器，它将像素的影 
----------------------- Page 218-----------------------
响区域转换为纹理上的椭圆，并通过滤波器内核对椭圆内的纹素进 
行加权[691]。Mavridis和 Papaioannou提出了几种在GPU上使 
用着色器代码实现 EWA过滤的方法[1143]。6.2。3体积纹理图像 
纹理的直接扩展是通过（u，v，w）（或（s，t，r）值）访问的三 
维图像数据。例如，医学成像数据可以生成为三维网格;通过移动多 
边形通过该网格，可以查看这些数据的二维切片。一个相关的想法 
是以这种形式表示体积光。通过找到其在该体积内的位置的值以及 
光的方向来找到表面上的点上的照明。大多数GPU支持体积纹理的 
mipmapping。由于在体积纹理的单个mipmap级别内进行滤波涉 
及三线性插值，因此在 mipmap级别之间进行滤波需要四线性插 
值。由于这涉及平均16个纹素的结果，可能会导致精度问题，这可 
以通过使用更高精度的体积纹理来解决。Sigg和 Hadwiger[1638] 
讨论了与体积纹理相关的这个问题和其他问题，并提供了执行过滤 
和其他操作的有效方法。1906.纹理尽管体积纹理具有明显更高的 
存储要求并且过滤成本更高，但它们确实具有一些独特的优势。可 
以跳过为三维网格找到良好的二维参数化的复杂过程，因为三维位 
置可以直接用作纹理坐标。这避免了二维参数化通常会出现的变形 
和接缝问题。体积纹理也可用于表示诸如木材或大理石的材料的体 
积结构。纹理有这种纹理的模型似乎是用这种材料雕刻的。使用体 
积纹理进行表面纹理处理是非常低效的，因为绝大多数样本都没有 
使用。Benson和 Davis[133]和 DeBry等人。[334]讨论以稀疏八 
叉树结构存储纹理数据。该方案非常适合交互式三维绘图系统，因 
----------------------- Page 219-----------------------
为表面在创建时不需要为其分配明确的纹理坐标，并且八叉树可以 
将纹理细节保持在任何所需的水平。Lefebvre等。[1017]讨论在现 
代GPU上实现八叉树纹理的细节。Lefebvre和 Hoppe[1018]讨 
论了将稀疏体积数据打包成明显更小的纹理的方法。6.2.4立方体贴 
图另一种纹理是立方体纹理或立方体贴图，它有六个方形纹理，每 
个纹理与一个立方体的一个面相关联。使用三分量纹理坐标向量访 
问立方体贴图，该向量指定从多维数据集中心向外指向的光线方向。 
光线与立方体相交的点如下所示。具有最大幅度的纹理坐标选择相 
应的面（例如，矢量（.3.2,5.1，.8.4）选择.z面）。剩余的两个坐 
标除以最大幅度坐标的绝对值，即8.4。它们现在的范围从.1到 1， 
并且只是重新映射到[0,1]以计算纹理坐标。例如，坐标（.3.2,5.1） 
被映射到 （（。3.2/8.4 +1）/2，（5.1/8.4+1）/2）≈ （0.31,0.80）。 
立方体贴图可用于表示作为方向函数的值; 它们最常用于环境映射 
 （第10.4.3节）。6.2.5纹理表示在应用程序中处理许多纹理时， 
有几种方法可以提高性能。纹理压缩在6.2.6节中描述，而本节的 
重点是纹理图集，纹理数组和无边框纹理，所有这些都旨在避免在 
渲染时更改纹理的成本。在第 19.10.1节和第 19.10.2节中，描述 
了纹理流和代码转换。为了能够为GPU批量尽可能多的工作，通常 
最好尽可能少地改变状态 （第 18.4.2节）。为此，可以将几个图像 
放入一个较大的纹理中，称为纹理图集。这在图6.20的左侧说明。 
请注意，子纹理的形状可以是任意的，6.2。图像纹理191图6.20。 
左图：纹理图集，其中九个较小的图像已合成为单个大纹理。右图： 
----------------------- Page 220-----------------------
更现代的方法是将较小的图像设置为纹理数组，这是大多数API中 
的概念。如图6.6所示。N¨oll和Stricker[1286]描述了子纹理放置 
地图集的优化。由于mipmap的上层可能包含几个独立的，不相关 
的形状，因此还需要注意 mipmap的生成和访问。Manson和 
Schaefer [1119]提出了一种通过考虑表面的参数化来优化 
mipmap创建的方法，这可以产生明显更好的结果。Burley和 
Lacewell[213]提出了一个名为 Ptex的系统，其中细分曲面中的每 
个四边形都有自己的小纹理。优点是这避免了在网格上分配唯一纹 
理坐标，并且在纹理图集的断开部分的接缝上没有伪影。为了能够 
跨四边形进行过滤，Ptex使用邻接数据结构。虽然最初的目标是生 
产渲染，但 Hillesland[746]提出了打包的 Ptex，它将每个面的子 
纹理放入纹理图集中，并使用相邻面的填充以避免在过滤时间接。 
Yuksel [1955]提出了网格颜色纹理，它改进了 Ptex。Toth [1780] 
通过实现一种方法来为 Ptex类系统提供高质量的过滤，如果滤波器 
抽头超出[0,1]2的范围则被丢弃。使用地图集的一个难点是包装/ 
重复和镜像模式，这不会正确影响子纹理，只会影响整个纹理。在 
为地图集生成mipmap时可能会出现另一个问题，其中一个子纹理 
可能会流入另一个子纹理。然而，这可以通过在将每个子纹理放置 
到大纹理图集中并且对子纹理使用二次幂分辨率之前单独生成每个 
子纹理的mipmap层次来避免[1293]。这些问题的一个更简单的解 
决方案是使用称为纹理数组的 API 结构，它完全避免了 
mipmapping和重复模式的任何问题[452]。请参见图6.20的右侧 
----------------------- Page 221-----------------------
部分。纹理数组中的所有子纹理都需要具有1926.纹理相同的尺寸， 
格式，mipmap层次结构和 MSAA设置。像纹理图集一样，设置只 
对纹理数组进行一次，然后可以使用着色器中的索引访问任何数组 
元素。这比绑定每个子纹理快5倍[452]。一个也可以帮助避免状态 
变化成本的功能是对无绑定纹理的API支持[1407]。如果没有无绑 
定纹理，则使用API​ ​ 将纹理绑定到特定纹理单元。一个问题是 
纹理单元数量的上限，这使程序员的事情变得复杂。驱动程序确保 
纹理驻留在GPU端。对于无绑定纹理，纹理数量没有上限，因为每 
个纹理只与其数据结构的64位指针 （有时称为句柄）相关联。可以 
通过许多不同的方式访问这些句柄，例如，通过制服，通过变化的 
数据，来自其他纹理，或来自着色器存储缓冲对象 （SSBO）。应用 
程序需要确保纹理驻留在GPU端。无绑定纹理避免了驱动程序中的 
任何类型的绑定成本，这使得渲染更快。6.2.6纹理压缩直接攻击内 
存和带宽问题以及缓存问题的一种解决方案是固定速率纹理压缩 
[127]。通过让GPU在运行中解码压缩纹理，纹理可以需要更少的 
纹理内存，因此增加了有效的高速缓存大小。至少同样重要的是， 
这样的纹理使用起来更有效，因为它们在访问时消耗更少的存储器 
带宽。相关但不同的用例是添加压缩以提供更大的纹理。例如，在 
5122分辨率下使用每个纹素3个字节的非压缩纹理将占用768kB。 
使用纹理压缩，压缩比为6：1，一个10242纹理只占用512kB。 
在图像文件格式中使用了各种图像压缩方法，例如JPEG和 PNG， 
但在硬件中实现这些方法的解码成本很高（尽管有关纹理转码的信 
----------------------- Page 222-----------------------
息，请参见第 19.10.1节）。S3开发了一种称为S3纹理压缩（S3TC） 
的方案[1524]，它被选为DirectX的标准，在 DirectX 10中称为 
DXTC，它被称为BC （用于块压缩）。此外，它是OpenGL的事实 
上的标准，因为几乎所有的GPU都支持它。它具有创建尺寸固定的 
压缩图像，具有独立编码的部分，并且解码简单（因此快速）的优 
点。图像的每个压缩部分可以独立于其他部分处理。没有共享查找 
表或其他依赖项，这简化了解码。DXTC/ BC压缩方案有七种变体， 
它们共享一些共同属性。编码在4×4纹素块上完成，也称为块。每 
个块都是单独编码的。编码基于插值。对于每个编码量，存储两个 
参考值 （例如，颜色）。为块中的16个纹素中的每一个保存插值因 
子。它沿着两个参考值之间的线选择一个值，例如，从两个存储的 
6.2中等于或插入的颜色。图像纹理193名称存储参考颜色索引 
Alpha注释 BC1/ DXT18 B/4 bptRGB565×22bpt-1行 BC2 
/ DXT316B/8bptRGB565×22bpt4 bpt原始颜色与BC1BC3 
相同/ DXT516B/ 8bptRGB565×22bpt3bptinterp。颜色与 
BC1相同 BC48 B/4 bptR8×23bpt- 1通道 BC516B/ 8 bpt 
RG88×22×3bpt-2×BC4BC6H16B/ 8bpt参见文字见文本 - 
用于 HDR;1-2行BC78B/4 bpt见文见文可选 1-3行表6.1。纹 
理压缩格式。所有这些压缩块为4×4纹素。存储列显示每个块的字 
节数 （B）和每个纹素的位数 （bpt）。参考颜色的符号首先是通道， 
然后是每个通道的位数。例如，RGB565表示红色和蓝色为5位， 
绿色通道为6位。颜色。压缩来自仅存储两种颜色以及每个像素的 
----------------------- Page 223-----------------------
短索引值。七种变体之间的确切编码有所不同，表6.1总结了这些 
变体。请注意，“DXT”表示DirectX9中的名称，“BC”表示DirectX 
10及更高版本中的名称。从表中可以看出，BC1有两个 16位参考 
RGB值（5位红色，6位绿色，5位蓝色），每个纹素都有一个2 
位插值因子可从参考值中选择一个或两个中间值与未压缩的24位 
RGB纹理相比，这表示纹理压缩比为6：1。BC2以与BC1相同的 
方式对颜色进行编码，但是对于量化 （原始）alpha，每个纹素（bpt） 
增加4比特。对于 BC3，每个块具有以与DXT1块相同的方式编码 
的RGB数据。另外，使用两个8位参考值和每纹素3位内插因子对 
α数据进行编码。每个纹素可以选择参考α值中的一个或六个中间值 
中的一个。BC4有一个频道，在 BC3中编码为alpha。BC5包含两 
个通道，每个通道按BC3编码。BC6H用于高动态范围 （HDR）纹 
理，其中每个纹素最初每个 R，G和 B通道具有 16位浮点值。此模 
式使用 16个字节，结果为8bpt。它有一种模式用于单行 （类似于 
上述技术），另一种模式用于两行，其中每个块可以从一小组分区 
中进行选择。两种参考颜色也可以进行增量编码以获得更好的精度， 
并且根据使用的模式也可以具有不同的精度。在 BC7中，每个块可 
以有一到三行，并存储8bpt。目标是8位 RGB和 RGBA纹理的高 
质量纹理压缩。它与 BC6H共享许多属性，但是 LDR纹理的格式， 
而BC6H用于 HDR。注意，BC6H和 BC7分别在OpenGL中称为 
BPTCFLOAT和 BPTC。这些压缩技术可应用于立方体或体积纹理以 
及二维纹理。1An替代 DXT1模式为透明像素保留四种可能的插值 
----------------------- Page 224-----------------------
因子之一，将插值的数量限制为三个 - 两个参考值及其平均值。194 
6.纹理化基色亮度解压缩原始+=图6.21。ETC （爱立信纹理压缩） 
对像素块的颜色进行编码，然后修改每个像素的亮度以创建最终的 
纹理像素颜色。 （由JacobStr¨om压缩的图像。）这些压缩方案的 
主要缺点是它们是有损的。也就是说，通常无法从压缩版本中检索 
原始图像。在 BC1-BC5的情况下，仅使用四个或八个内插值来表示 
16个像素。如果图块中包含大量不同的值，则会有一些损失。实际 
上，如果正确使用，这些压缩方案通常会提供可接受的图像保真度。 
BC1-BC5的一个问题是用于块的所有颜色都位于RGB空间的直线 
上。例如，红色，绿色和蓝色不能在单个块中表示。BC6H和 BC7 
支持更多线路，因此可以提供更高的质量。对于OpenGLES，选择 
另一种称为爱立信纹理压缩 （ETC）[1714]的压缩算法以包含在API 
中。该方案具有与S3TC相同的特性，即快速解码，随机接入，无 
间接查找和固定速率。它将4×4纹素的块编码为64位，即每个纹 
素使用4位。基本思想如图6.21所示。每个2×4块（或4×2，取 
决于哪个给出最佳质量）存储基色。每个块还从一个小的静态查找 
表中选择一组四个常量，并且块中的每个纹素都可以选择添加该表 
中的一个值。这会修改每个像素的亮度。图像质量与DXTC相当。 
在包含在OpenGLES3.0中的ETC2[1715]中，未使用的位组合用 
于向原始ETC算法添加更多模式。未使用的比特组合是压缩表示（例 
如，64比特），其解压缩到与另一压缩表示相同的图像。例如，在 
BC1中，将两个参考颜色设置为相同是没有用的，因为这将指示一 
----------------------- Page 225-----------------------
个恒定的颜色块，只要一种参考颜色包含该恒定颜色，就可以获得 
该颜色。在 ETC中，一种颜色也可以从具有带符号数的第一种颜色 
进行增量编码，因此该计算可以上溢或下溢。这种情况用于发信号 
通知其他压缩模式。ETC2增加了两种新模式，四种颜色，每个块以 
不同的方式导出，最终模式是 RGB空间中用于处理平滑过渡的平 
面。爱立信alpha压缩（EAC）[1868]用一个分量（例如，alpha） 
压缩图像。此压缩类似于基本 ETC压缩，但仅适用于一个组件，并 
且生成的图像每个纹素存储4位。它可以选择6.2。图像纹理195 
xyxyz （nx，ny）n = （nx，ny，nz）图6.22。左：球体上的单位 
法线只需要编码x和y分量。对：对于 BC4/ 3Dc，xy平面中的方 
框包含法线，并且每个4×4法线块可以使用此方框内的8×8法线 
 （为清楚起见，此处仅显示4×4法线）。结合 ETC2，另外两个 EAC 
通道可用于压缩法线 （下面有关于此主题的更多信息）。所有 ETC1， 
ETC2和 EAC都是OpenGL4.0核心配置文件，OpenGL ES3.0， 
Vulkan和 Metal的一部分。正常地图的压缩（在第6.7.2节中讨论） 
需要一些小心。为 RGB颜色设计的压缩格式通常不适用于普通的 
xyz数据。大多数方法利用已知法线为单位长度的事实，并进一步 
假设其z分量为正（对于切线空间法线的合理假设）。这允许仅存 
储法线的x分量和y分量。z分量在运行中导出为 nz=q1。n2x。 
你好 （6.4）这本身导致适度的压缩量，因为只存储了两个组件， 
而不是三个。由于大多数GPU本身不支持三组件纹理，因此这也避 
免了浪费组件（或必须在第四组件中包装另一个数量）的可能性。 
----------------------- Page 226-----------------------
通常通过将x和y分量存储在 BC5/ 3Dc格式纹理中来实现进一步 
压缩。见图6.22。由于每个块的参考值划分了最小和最大x和y分 
量值，因此可以将它们视为在xy平面上定义边界框。三位插值因子 
允许在每个轴上选择八个值，因此边界框被划分为可能法线的8×8 
网格。或者，可以使用两个EAC通道（用于x和y），然后如上所 
述计算z。在不支持 BC5/ 3Dc或EAC格式的硬件上，常见的回退 
[1227]是使用 DXT5格式纹理并将两个组件存储在绿色和alpha组 
件中 （因为它们以最高精度存储） 。其他两个组件未使用。1966. 
纹理化 PVRTC [465]是 Imagination Technologies 的硬件名为 
PowerVR的纹理压缩格式，其最广泛的用途是用于iPhone和iPad。 
它为每个纹理元素提供2位和4位的方案，并压缩4×4纹素的块。 
关键思想是提供图像的两个低频（平滑）信号，这些信号是使用相 
邻的纹素数据块和插值获得的。然后，每个纹素的 1或2比特用于 
在图像上的两个信号之间进行内插。自适应可缩放纹理压缩（ASTC） 
[1302]的不同之处在于它将n×m个纹素的块压缩为 128位。块大 
小范围从4×4到 12×12，这导致不同的比特率，从每个纹素开始 
低至0.89比特，并且每个纹素高达8比特。ASTC使用各种技巧进 
行紧凑索引表示，并且每个块可以选择行数和端点编码。此外，ASTC 
可以处理每个纹理 1-4个通道以及 LDR和 HDR纹理的任何内容。 
ASTC是OpenGLES3.2及更高版本的一部分。上面提出的所有纹 
理压缩方案都是有损的，并且当压缩纹理时，可以在该过程上花费 
不同的时间量。在压缩上花费几秒甚至几分钟，就可以获得更高的 
----------------------- Page 227-----------------------
质量; 因此，这通常作为离线预处理完成，并存储以供以后使用。或 
者，可以花费几毫秒，结果质量较低，但纹理可以近乎实时地压缩 
并立即使用。一个例子是天空盒 （第 13.3节），当云可能稍微移动 
时，它每隔一秒左右重新生成一次。解压缩非常快，因为它是使用 
固定功能硬件完成的。这种差异称为数据压缩不对称，其中压缩可 
以并且确实比解压缩花费相当长的时间。Kaplanyan[856]提出了几 
种可以改善压缩纹理质量的方法。对于包含颜色和法线贴图的纹理， 
建议使用每个组件 16位创作映射。对于颜色纹理，然后执行直方图 
重新正规化 （在这 16位上），然后使用着色器中的比例和偏置常数 
 （每个纹理）反转其效果。直方图归一化是一种将图像中使用的值 
展开以跨越整个范围的技术，这实际上是一种对比度增强。每个组 
件使用 16位确保在重新规范化之后直方图中没有未使用的时隙，这 
减少了许多纹理压缩方案可能引入的带状伪像。如图6.23所示。此 
外，如果75％的像素高于116/255，Kaplanyan建议为纹理使用 
线性色彩空间，否则将纹理存储在sRGB中。对于法线贴图，他还 
指出，BC5/ 3Dc经常独立于y压缩x，这意味着并不总能找到最 
佳法线。相反，他建议对法线使用以下误差度量：e=arccos？n·nc 
||n||||数控||？，（6.5）其中n是原始法线，nc是相同的法线压 
缩，然后解压缩。6.2。图像纹理197图6.23。在纹理压缩期间使 
用每个组件16位与8位的效果。从左到右：原始纹理，DXT1从每 
个组件8位压缩，DXT1从每个组件 16位压缩，并在着色器中完成 
重新规范化。纹理已经用强光照进行渲染，以便更清晰地显示效果。 
----------------------- Page 228-----------------------
 （图片似乎由Anton Kaplanyan提供。应该注意的是，还可以在不 
同的颜色空间中压缩纹理，这可以用于加速纹理压缩。常用的变换 
是 RGB→YCoCg [1112]:.。YCoCg。。=。。1/41/21/41/20.1 
/ 2.1/4 1/2.1/4。。。。RG B。。，（6.6）其中Y是亮度项， 
Co和Cg是色度项。逆变换也很便宜：G= （Y +Cg），t = （Y.Cg）， 
R=t +Co，B =t。Co，（6.7）相当于少量的补充。这两个变换 
是线性的，可以看出，公式6.6是矩阵向量乘法，它本身是线性的 
 （见方程4.1和4.2）。这是重要的，因为不是将RGB存储在纹理 
中，而是可以存储YCoCg;纹理硬件仍然可以在YCoCg空间中执行 
过滤，然后像素着色器可以根据需要转换回RGB。应该注意的是， 
这种变换本身就是有损的，这可能是也可能不重要。还有另一种可 
逆的 RGB→YCoCg变换，总结为.......Co =R.Bt =B + （Co.1） 
Cg =G.tY =t + （Cg.1）...........t =Y. （Cg.1）G =Cg +t B= 
t。（公司1）R =B +Co，（6.8）其中。向右转。这意味着可以 
在24位RGB颜色和相应的YCoCg表示之间来回变换而不需要198 
6.纹理化任何损失。应当注意，如果RGB中的每个分量具有n位， 
则Co和Cg各自具有n+1位以保证可逆变换;Y只需要n位。Van 
Waveren和Casta。no[1852]使用有损YCoCg变换在CPU或GPU 
上实现对DXT5/ BC3的快速压缩。它们将Y存储在alpha通道中 
 （因为它具有最高的精度），而Co和Cg存储在 RGB的前两个组 
件中。由于Y分别存储和压缩，压缩变得很快。对于Co和Cg组 
件，他们找到一个二维边界框并选择产生最佳结果的方框对角线。 
----------------------- Page 229-----------------------
请注意，对于在CPU上动态创建的纹理，也可以更好地压缩CPU 
上的纹理。当通过GPU上的渲染创建纹理时，通常最好也压缩GPU 
上的纹理。YCoCg变换和其他亮度 - 色度变换通常用于图像压缩， 
其中色度分量的平均值超过2×2像素。这减少了 50％的存储量并 
且通常工作正常，因为色度趋于缓慢变化。Lee-Steere和 Harmon 
[1015]通过转换为色调饱和度值（HSV），在x和y 中将色调和饱 
和度下采样4倍，并将值存储为单通道 DXT1纹理，更进一步。Van 
Waveren和Casta.no也描述了压缩法线贴图的快速方法[1853]。 
Griffin和Olano [601]的一项研究表明，当几个纹理应用于具有复 
杂着色模型的几何模型时，纹理的质量通常可以很低而没有任何可 
察觉的差异。因此，根据使用情况，可以接受质量下降。Fauconneau 
[463]提出了 DirectX11纹理压缩格式的SIMD实现。6。3程序纹 
理给定纹理空间位置，执行图像查找是生成纹理值的一种方法。另 
一种是评估函数，从而定义程序纹理。虽然程序纹理通常用于离线 
渲染应用程序，但图像纹理在实时渲染中更为常见。这是由于现代 
GPU中图像纹理硬件的极高效率，它可以在一秒钟内执行数十亿次 
纹理访问。然而，GPU架构正朝着更便宜的计算和 （相对）更昂贵 
的存储器访问发展。这些趋势使得程序纹理在实时应用中得到了更 
多的应用。考虑到体积图像纹理的高存储成本，体积纹理是程序纹 
理化的特别有吸引力的应用。这种纹理可以通过各种技术合成。最 
常见的一种是使用一个或多个噪声函数来生成值 
[407,1370,1371,1372]。见图6.24。噪声函数通常以连续两个频率 
----------------------- Page 230-----------------------
的频率进行采样，称为八度音程。每个八度音阶都有一个权重，通 
常随着频率的增加而下降，这些加权样本的总和称为湍流函数。6.3。 
程序纹理 199图6.24。使用体积纹理的两个实时程序纹理示例。左 
边的大理石是使用光线行进渲染的半透明体积纹理。在右侧，对象 
是使用复杂的程序木质着色器[1054]生成的合成图像，并在真实世 
界环境的顶部合成。（左图来自 shadertoy “玩大理石， “由 
St'ephaneGuillitte提供。右图由 NicolasSavva，Autodesk，Inc。 
提供。）由于评估噪声函数的成本，三维数组中的晶格点通常是预 
先计算的并用于插值纹理值。有各种方法使用颜色缓冲混合来快速 
生成这些阵列[1192]。Perlin[1373]提出了一种快速，实用的采样 
噪声函数的方法，并展示了一些用途。Olano [1319]提供了噪声生 
成算法，允许在存储纹理和执行计算之间进行权衡。麦克尤恩等人。 
[1168]开发用于在没有任何查找的情况下计算着色器中的经典噪声 
以及单纯噪声的方法，并且源代码可用。Parberry[1353]使用动态 
编程来分摊几个像素上的计算以加速噪声计算。Green[587]提供了 
一种更高质量的方法，但是对于近交互式应用程序来说更是如此， 
因为它使用 50 个像素着色器指令进行单个查找。Perlin 
[1370,1371,1372]提出的原始噪声函数可以改进。Cook和DeRose 
[290]提出了一种称为小波噪声的替代表示，它避免了混叠问题，只 
是评估成本略有增加。刘等人。[1054]使用各种噪声函数来模拟不 
同的木材纹理和表面光洁度。我们还推荐 Lagae等人提供的最新报 
告。[956]关于这个主题。其他程序方法也是可能的。例如，通过测 
----------------------- Page 231-----------------------
量从每个位置到通过空间散射的一组 “特征点”的距离来形成细胞 
纹理。以各种方式映射得到的最近距离，例如，改变颜色或阴影法 
线，产生看起来像细胞，石板，蜥蜴皮和其他自然纹理的图案。 
Griffiths [602]讨论了如何有效地找到最近的邻居并在GPU上生成 
细胞纹理。2006.纹理另一种程序纹理是物理模拟或其他一些交互 
过程的结果，如水波纹或散布裂缝。在这种情况下，程序纹理可以 
在对动态条件的反应中产生有效的无限变化。在生成程序性二维纹 
理时，参数化问题可能比创作纹理带来更多困难，其中可以手动触 
摸或处理拉伸或接缝伪影。一种解决方案是通过将纹理直接合成到 
表面上来完全避免参数化。在复杂表面上执行此操作在技术上具有 
挑战性，并且是一个活跃的研究领域。见Wei等人。[1861]对该领 
域的概述。抗锯齿程序纹理比抗锯齿图像纹理更难，更容易。一方 
面，诸如mipmapping之类的预计算方法不可用，这给程序员带来 
了负担。另一方面，程序纹理作者具有关于纹理内容的 “内部信息”， 
因此可以定制它以避免混叠。对于通过对多个噪声函数求和而创建 
的程序纹理尤其如此。每个噪声函数的频率是已知的，因此可以丢 
弃任何会导致混叠的频率，实际上使计算成本降低。有多种技术可 
用于抗锯齿其他类型的程序纹理[407,605,1392,1512]。多恩等人。 
[371]讨论了先前的工作，并提出了一些重构纹理函数的过程，以避 
免高频，即带限。6.4纹理动画应用于曲面的图像不必是静态的。例 
如，视频源可以用作逐帧变化的纹理。纹理坐标也不必是静态的。 
应用程序设计人员可以明确地从一帧到另一帧更改纹理坐标，网格 
----------------------- Page 232-----------------------
数据本身或通过顶点或像素着色器中应用的函数。想象一下，瀑布 
已被建模，并且已经使用看起来像落水的图像进行纹理化。假设v 
坐标是流动的方向。为了使水移动，必须从每个连续帧上的v坐标 
中减去一定量。从纹理坐标中减去具有使纹理本身看起来向前移动 
的效果。通过将矩阵应用于纹理坐标可以创建更精细的效果。除了 
平移之外，这还允许线性变换，例如缩放，旋转和剪切[1192,1904]， 
图像变形和变形变换[1729]，以及广义投影[638]。通过在CPU或 
着色器中应用函数，可以创建更多精细的效果。通过使用纹理混合 
技术，可以实现其他动画效果。例如，从大理石纹理开始，以肉体 
纹理褪色，就可以让雕像变得生动[1215]。6.5。材质映射201反照 
率纹理粗糙度纹理高度场纹理图6.25。金属砖和砂浆。右侧是表面 
颜色的纹理，粗糙度（较浅的粗糙度）和凹凸贴图高度（较浅的较 
高）。 （图片来自three.js示例webgltonemapping [218]。）6.5 
材质贴图纹理的一个常见用途是修改影响着色方程的材质属性。真 
实世界的物体通常具有在其表面上变化的材料特性。要模拟这些物 
体，像素着色器可以从纹理中读取值，并在评估着色方程之前使用 
它们来修改材质参数。通常由纹理修改的参数是表面颜色。此纹理 
称为反照率颜色贴图或漫反射颜色贴图。但是，任何参数都可以通 
过纹理修改：替换它，将其相乘或以其他方式更改它。例如，在图 
6.25中，三个不同的纹理应用于曲面，替换常量值。可以进一步采 
用材料中的纹理。可以使用纹理来控制像素着色器本身的流程和功 
能，而不是修改等式中的参数。通过使一个纹理指定表面的哪个区 
----------------------- Page 233-----------------------
域具有哪种材料，可以将具有不同阴影方程和参数的两种或更多种 
材料应用于表面，从而导致对每一种材料执行不同的代码。例如， 
带有一些生锈区域的金属表面可以使用纹理来指示生锈所在的位 
置，根据纹理查找有条件地执行着色器的生锈部分，否则执行闪亮 
的金属着色器（第9.5.2节）。着色模型输入（如表面颜色）与着 
色器的最终颜色输出呈线性关系。因此，可以使用标准技术过滤包 
含这些输入的纹理，并避免混叠。包含非线性着色输入的纹理（如 
粗糙度或凹凸贴图（第6.7节））需要更加小心以避免混叠。考虑 
着色方程的滤波技术可以改善这种纹理的结果。第9.13节讨论了这 
些技术。2026.纹理贴花框贴花纹理帧缓冲内容背面或遮挡图6.26。 
实现贴花的一种方法。首先使用场景渲染帧缓冲，然后渲染一个框， 
对于框内的所有点，将贴花纹理投影到帧缓冲内容。最左边的纹素 
是完全透明的，因此它不会影响帧缓冲。黄色纹理像素不可见，因 
为它会被投射到表面的隐藏部分。6.6Alpha映射使用alpha混合 
或alpha测试，alpha值可用于许多效果，例如有效渲染树叶，爆 
炸和远处物体，仅举几例。本节讨论纹理与alpha的使用，并注意 
到各种限制和解决方案。一种与纹理相关的效果就是效果。举个例 
子，假设您想在茶壶上放一朵花的照片。你不想要整个画面，而只 
是花朵所在的部分。通过为纹素分配一个0的alpha，你可以使它 
透明，这样它就没有效果了。因此，通过正确设置贴花纹理的alpha， 
您可以使用贴花替换或混合底层表面。通常，夹具对应器功能与透 
明边框一起使用以将贴花的单个副本（相对于重复纹理）应用于表 
----------------------- Page 234-----------------------
面。图6.26显示了如何实现decaling的示例。有关贴花的更多信 
息，请参见第20.2节。alpha的类似应用是制作切口。假设您制作 
灌木的贴花图像并将其应用于场景中的矩形。原理与贴花相同，除 
了不是与下面的表面齐平，衬套将被绘制在其后面的任何几何形状 
的顶部。通过这种方式，您可以使用单个矩形渲染具有复杂轮廓的 
对象。在衬套的情况下，如果您围绕它旋转观察者，则幻觉失败， 
因为衬套没有厚度。一个答案是复制这个灌木矩形并沿着树干旋转 
90度。两个矩形形成廉价的三维灌木，有时被称为“十字树”[1204]， 
从地面看这种幻觉是相当有效的。见图6.27。Pelzer[1367]讨论了 
使用三个切口来表示草的类似配置。在第 13.6节中，我们讨论一种 
叫做广告牌的方法，用于将这种渲染减少到一个矩形。如果观察者 
移动到地面以上，则从上方看到灌木为6.6时，错觉就会破裂。Alpha 
Mapping203 + =图6.27。在左侧，灌木纹理贴图和它下面的 1 
位alpha通道贴图。在右边，灌木丛呈现在一个矩形上;通过添加旋 
转90度的矩形的第二个副本，我们形成了廉价的立体灌木。两个镂 
空。见图6.28。为了解决这个问题，可以以不同的方式添加更多切 
口 - 切片，分支，图层 - 以提供更有说服力的模型。第13.6.5节 
讨论了生成此类模型的一种方法;第857页的图 19.31显示了另一 
个。有关最终结果的示例，请参阅第2页和第 1049页上的图像。 
结合alpha贴图和纹理动画可以产生令人信服的特殊效果，例如闪 
烁的火把，植物生长，爆炸和大气效果。使用alpha贴图渲染对象 
有多种选择。Alpha混合（第 5.5节）允许使用分数透明度值，这 
----------------------- Page 235-----------------------
样可以对对象边缘以及部分透明对象进行抗锯齿处理。但是，alpha 
混合需要在不透明的三角形之后渲染混合三角形，并且按照从前到 
后的顺序。简单的交叉树是两个剪切纹理的示例，其中没有渲染顺 
序是正确的，因为每个四边形位于另一个的一部分的前面。即使在 
理论上可以对排序和获得正确的顺序进行排序，这样做通常也是低 
效的。例如，一块田地可能有数万片草叶，如图6.28所示。从一点 
点的地面看 “十字树”灌木丛，然后进一步向上，幻觉破裂的地方。 
2046.纹理切口。每个网格对象可以由许多单独的刀片制成。对每 
个刀片进行明确排序是非常不切实际的。在渲染时，可以通过几种 
不同的方式改善此问题。一种是使用alpha测试，这是在像素着色 
器中有条件地丢弃具有低于给定阈值的α值的片段的过程。这样就像 
 （texture.a <alphaThreshold）丢弃一样; （6.9）其中texture.a 
是纹理查找的alpha值，参数alphaThreshold是用户提供的阈值， 
用于确定将丢弃哪些片段。这种二元可见性测试使三角形能够以任 
何顺序呈现，因为透明片段被丢弃。我们通常希望对alpha为0.0 
的任何片段执行此操作。丢弃完全透明的片段还有一个额外的好处， 
即可以节省更多的着色器处理和合并成本，以及避免错误地将z缓 
冲区中的像素标记为可见[394]。对于剪切，我们经常将阈值设置为 
高于0.0，例如0.5或更高，然后采取进一步的步骤，然后完全忽略 
alpha值，而不是将其用于混合。这样做可以避免无序工件。但是， 
质量很低，因为只有两级透明度（完全不透明和完全透明）可用。 
另一个解决方案是为每个模型执行两次传递 - 一次用于实体剪切， 
----------------------- Page 236-----------------------
将其写入z缓冲区，对于半透明样品，另一个是半透明样品。alpha 
测试还有另外两个问题，即放大倍数太大[1374]和缩小太多 
[234,557]。当alpha测试与 mipmapping一起使用时，如果处理 
方式不同，效果可能会令人难以置信。图6.29顶部显示了一个示例， 
其中树的叶子变得比预期更透明。这可以用一个例子来解释。假设 
我们有一个具有四个alpha值的一维纹理，即（0.0,1.0,1.0,0.0）。 
通过平均，下一个mipmap级别变为 （0.5,0.5），然后最高级别为 
 （0.5）。现在，假设我们使用αt= 0.75。当访问mipmap级别0 
时，可以显示4个中的 1.5个纹素将在丢弃测试中存活。但是，当 
访问接下来的两个级别时，一切都将被丢弃，因为0.5 <0.75。有 
关另一个示例，请参见图 6.30。Casta.no [234]提出了一个在 
mipmap创建过程中完成的简单解决方案。对于mipmap级别k， 
覆盖ck定义为ck =1nkXi （α （k，i）>αt），（6.10）其中nk 
是 mipmap级别k中的纹素数，α （k，i）是来自像素i的mipmap 
级别k的alpha值，αt是公式6.9中的用户提供的alpha阈值。这 
里，我们假设α （k，i）>αt的结果如果为真则为1，否则为0。注 
意，k =0表示最低的 mipmap级别，即原始图像。对于每个 
mipmap级别，我们然后找到新的mipmap阈值αk，而不是使用α 
t，使得ck等于c0 （或尽可能接近）。这可以使用二进制6.6来完 
成。Alpha Mapping205图6.29。上：使用mipmapping进行 
alpha测试而不进行任何更正。底部：根据覆盖范围重新调整alpha 
值的alpha测试。（图片来自 “TheWitness”，由IgnacioCasta.no 
----------------------- Page 237-----------------------
提供。）搜索。最后，mipmap级别 k中所有纹素的alpha值按α 
t/αk缩放。此方法用于图6.29的底部，并且在NVIDIA的纹理工 
具中支持此方法。Golus [557]给出了一个变体，其中 mipmap没 
有被修改，而是随着mipmap级别的增加，alpha在着色器中被放 
大。206 6.纹理图 6.30。在顶部是具有混合的叶子图案的不同 
mipmap级别，较高级别为了可见性而缩放。在底部显示mipmap， 
因为它将使用0.5的alpha测试进行处理，显示对象在后退时如何 
具有更少的像素。（图片由 BenGolus提供[557]。）Wyman和 
McGuire[1933]提出了一种不同的解决方案，其中方程6.9中的代 
码行在理论上被替换为if texture.a（ <random（））discard; （6.11） 
随机函数返回一个统一值在[0,1]中，这意味着平均而言这将导致正 
确的结果。例如，如果纹理查找的alpha值为0.3，则将以30％的 
几率丢弃该片段。这是一种随机透明的形式，每个像素有一个样本 
[423]。在实践中，随机函数被替换为散列函数以避免时间和空间高 
频噪声：floathash2D （x，y）{returnfract （1.0e4*sin （17.0* 
x +0.1*y）* （0.1+） ABS （SIN （13.0*Y +X））））; （6.12） 
通过对上述函数的嵌套调用形成三维散列，即floathash3D （x，y， 
z）{return hash2D （hash2D （x，y），z）; }，返回[0,1]中的数 
字。散列的输入是对象空间坐标除以对象空间坐标的最大屏幕空间 
导数 （x和y），然后是钳位。需要进一步注意以获得z方向上的运 
动的稳定性，并且该方法最好与时间抗锯齿技术相结合。这种技术 
随着距离逐渐消失，所以近距离我们根本没有任何随机效应。这种 
----------------------- Page 238-----------------------
方法的优点是每个片段平均是正确的，而Casta.no的方法[234]为 
每个 mipmap级别创建一个单独的αk。但是，此值可能会因每个 
mipmap级别而异，这可能会降低质量并需要艺术家干预。Alpha 
测试显示放大倍数下的纹波伪影，可以通过将alpha贴图预先计算 
为距离场来避免[580] （另请参阅第677页的讨论）。6.6。Alpha 
Mapping207图6.31。叶子纹理的不同渲染技术，边缘部分alpha 
覆盖。从左到右：alpha测试，alpha混合，alpha到coverage， 
以及带有锐化边缘的alpha到coverage。（图片由BenGolus提 
供[557]。）Alpha到覆盖范围，以及相似特征透明度自适应抗锯齿， 
取片段的透明度值并将其转换为覆盖像素内的多少样本[1250]。这 
个想法就像屏幕门透明度，在 5.5节中描述，但是在子像素级别。 
想象一下，由于切口纹理，每个像素有四个样本位置，一个片段覆 
盖一个像素，但是25％透明（75％不透明）。alphatocoverage 
模式使片段变得完全不透明，但仅覆盖四个样本中的三个。此模式 
对于重叠草叶的切割纹理非常有用，例如[887,1876]。由于每个抽 
取的样本都是完全不透明的，最接近的叶子将沿其边缘以一致的方 
式隐藏其后面的物体。正确混合半透明边缘像素不需要排序，因为 
关闭了alpha混合。Alpha到覆盖范围有利于抗锯齿alpha测试， 
但在alpha混合时可以显示工件。例如，具有相同alpha覆盖百分 
比的两个alpha混合片段将使用相同的子像素模式，这意味着一个 
片段将完全覆盖另一个片段而不是与其混合。Golus[557]讨论了使 
用fwidth （）着色器指令为内容提供更清晰的边缘。见图6.31。对 
----------------------- Page 239-----------------------
于alpha映射的任何使用，了解双线性插值如何影响颜色值非常重 
要。想象一下彼此相邻的两个纹素：rgbα= （255,0,0,255）是一个 
纯红色，它的邻居rgbα= （0,0,0,2），是黑色的，几乎完全透明。 
两个纹素之间正好位置的 rgbα是什么？简单插值给出 
 （127,0,0,128），结果rgb值单独为 “调光器”红色。然而，这个 
结果实际上并不是暗淡的，它是一个完整的红色，已经被它的alpha 
预乘。如果插入alpha值，为了进行正确的插值，您需要确保插值 
前已插入的颜色已被alpha预乘。举个例子，假设几乎透明的邻居 
设置为rgbα= （0,255,0,2），给出一个微小的绿色。此颜色不会被 
alpha预乘，并且在插值时会给出结果（127,127,0,128） - 绿色 
的微小色调突然将结果转换为（预乘）黄色样本。该邻域纹素的预 
乘版本是（0,2,0,2），其给出了（127,1,0,128）的适当预乘结果。 
这个结果更有意义，产生的预乘颜色大部分是红色，带有难以察觉 
的绿色。2086.纹理忽略双线性插值的结果给出预乘结果会导致贴 
花和切割对象周围出现黑边。 “调光器”红色结果被管道的其余部 
分视为未经倍增的颜色，并且条纹变为黑色。即使使用alpha测试， 
此效果也可见。最好的策略是在完成双线性插值之前进行预乘 
[490,648,1166,1813]。WebGLAPI支持这一点，因为合成对于网 
页很重要。但是，双线性插值通常由GPU执行，在执行此操作之前， 
着色器无法对纹素值进行操作。图像不是以 PNG等文件格式预乘， 
因为这样做会失去色彩精度。使用alpha映射时，这两个因素默认 
会导致黑边缘。一种常见的解决方法是预处理剪切图像，使用从附 
----------------------- Page 240-----------------------
近的不透明纹理像素[490,685]得到的颜色绘制透明的“黑色”纹素。 
所有透明区域通常需要通过手动或自动方式重新绘制，以便 
mipmap级别也避免边缘问题[295]。值得注意的是，在形成具有α 
值的mipmap时应该使用预乘值[1933]。6.7凹凸贴图本节描述了 
一大系列小规模细节表示技术，我们统称为凹凸贴图。通常通过修 
改每像素着色例程来实现所有这些方法。它们比单独的纹理映射提 
供更多的三维外观，但不添加任何其他几何。对象上的细节可以分 
为三个尺度：覆盖许多像素的宏观特征，跨越几个像素的中观特征， 
以及远小于像素的微观特征。这些类别在某种程度上是流动的，因 
为观看者可以在动画或交互式会话期间在许多距离处观察相同的对 
象。宏几何由顶点和三角形或其他几何图元表示。在创建三维角色 
时，肢体和头部通常以宏观尺度建模。微观几何学被封装在着色模 
得到以下等式，首先由Cook和Torrance [285,286] 
��理贴图作为参数。所 
使用的阴影模型模拟表面的微观几何形状的相互作用，例如，闪亮 
的物体在显微镜下是光滑的，而漫射的表面在微观上是粗糙的。角 
色的皮肤和衣服似乎具有不同的材质，因为它们使用不同的着色器， 
或者至少在这些着色器中使用不同的参数。中间几何描述了这两个 
尺度之间的所有内容。它包含的细节太复杂，无法使用单个三角形 
进行有效渲染，但这足以让观察者区分几个像素的曲面曲率的个别 
变化。角色脸上的皱纹，肌肉细节，衣服上的褶皱和接缝都是中尺 
度的。一系列统称为凹凸贴图技术的方法通常用于中尺度建模。这 
些调整像素级别的阴影参数，使观看者感知小6.7。凹凸映射远离基 
----------------------- Page 241-----------------------
本几何体的209个扰动，其实际上保持平坦。不同类型的凹凸贴图 
之间的主要区别在于它们如何表示细节特征。变量包括现实主义的 
水平和细节特征的复杂性。例如，数字艺术家通常将细节雕刻到模 
型中，然后使用软件将这些几何元素转换为一个或多个纹理，例如 
凹凸纹理和可能是缝隙变暗的纹理。Blinn在 1978年引入了在纹理 
中编码中尺度细节的想法[160]。他观察到，如果在着色期间，我们 
用一个略微扰动的表面法线替换真实的表面，则表面看起来具有小 
尺度细节。他将描述扰动的数据存储到阵列中的曲面法线上。关键 
的想法是，我们不是使用纹理来改变照明方程中的颜色分量，而是 
访问纹理来修改表面法线。表面的几何法线保持不变;我们只修改照 
明方程中使用的法线。此操作没有物理等效物;我们对表面法线进行 
了更改，但表面本身在几何意义上保持平滑。就像每个顶点有一个 
法线给出三角形之间表面平滑的错觉一样，修改每个像素的法线会 
改变三角形表面本身的感知，不修改其几何形状。对于凹凸贴图， 
法线必须相对于某个参照系改变方向。为此，在每个顶点处存储切 
线框，也称为切线空间。该参照系用于将光转换为表面位置的空间 
 （反之亦然）以计算扰动法线的效果。对于应用了法线贴图的多边 
形曲面，除了顶点法线之外，我们还存储所谓的切线和切线矢量。 
比特向量也被错误地称为副法向量[1025]。切线和切线矢量表示法 
线贴图本身在对象空间中的轴，因为目标是将光线转换为相对于贴 
图。见图6.32。这三个向量，正常n，正切t，和bitangentb，形 
成一个基础矩阵：。... tx ty tz 0 bx by bz 0 nx ny nz 0 0 0 0 
----------------------- Page 242-----------------------
1。...... （6.13）该矩阵有时缩写为TBN，将光的方向 （对于给定的 
顶点）从世界空间转换为切线空间。这些矢量不必彼此真正垂直， 
因为法线贴图本身可能会扭曲以适合表面。然而，非正交基础会引 
入纹理偏斜，这可能意味着需要更多存储并且还可能具有性能影响， 
即，矩阵不能通过简单的转置反转[494]。一种节省记忆的方法是在 
顶点处仅存储切线和比特，并使用它们的叉积来计算法线。然而， 
这种技术仅适用于手性2106.纹理bbbbbnnnnnttttt图6。显示 
了一个球形三角形，每个角上都显示了切线框。像球体和圆环一样 
的形状具有自然的切线空间基础，如环面上的纬度和经度线所示。 
矩阵总是相同的[1226]。模型通常是对称的：飞机，人，文件柜和 
许多其他物体。由于纹理消耗大量内存，因此它们通常镜像到对称 
模型上。因此，仅存储对象纹理的一侧，但纹理映射将其放置在模 
型的两侧。在这种情况下，切线空间的旋向性在两侧是不同的，并 
且不能被假设。如果在每个顶点存储额外的信息以指示手性，则仍 
然可以避免在这种情况下存储法线。如果设置，该位用于否定正切 
和比特的交叉乘积以产生正确的法线。如果切线框架是正交的，那 
么也可以将基础存储为四元数（第4.3节），这两者都更节省空间 
并且可以节省每个像素的一些计算[494,1114,1154,1381,1639]。 
可能会有轻微的质量损失，但在实践中很少见到。切线空间的概念 
对于其他算法很重要。正如下一章所讨论的，许多着色方程仅依赖 
于表面的法线方向。然而，与表面相比，诸如拉丝铝或天鹅绒之类 
的材料也需要知道观察者和照明的相对方向。切线框架可用于定义 
----------------------- Page 243-----------------------
材料在曲面上的方向。Lengyel[1025]和 Mittring[1226]的文章提 
供了该领域的广泛报道。Sch¨uler[1584]提出了一种在像素着色器 
中即时计算切线空间基础的方法，无需为每个顶点存储预先计算的 
切线帧。Mikkelsen[1209]改进了这种技术，并推导出一种不需要 
任何参数化但是使用表面位置的导数和高度场的导数来计算扰动法 
线的方法。然而，与使用标准切线空间映射相比，这种技术可以导 
致显着的细节显着减少，并且可能产生艺术工作流问题[1639]。6.7。 
凹凸贴图211图6.33。在左侧，通过从凹凸纹理获取的 （bu，bv） 
值在u和v方向上​ ​ 修改法向量n，给n' （这是非标准化的）。 
在右侧，显示了高度场及其对着色法线的影响。这些法线可以在高 
度之间插值，以获得更平滑的外观。6.7.1 Blinn的方法Blinn的原 
始凹凸贴图方法在纹理中的每个纹素处存储两个有符号值 bu和 
bv。这两个值对应于沿u和v图像轴改变法线的量。也就是说，这 
些通常是双线性插值的纹理值用于缩放垂直于法线的两个矢量。将 
这两个向量加到法线上以改变其方向。两个值bu和bv描述了表面 
在该点面向的方向。见图6.33。这种类型的凹凸贴图纹理称为偏移 
矢量凹凸贴图或偏移贴图。表示凸起的另一种方法是使用高度场来 
修改曲面法线的方向。每个单色纹理值表示高度，因此在纹理中， 
白色是高区域而黑色是低区域（反之亦然）。有关示例，请参见图 
6.34。这是第一次创建或扫描凹凸贴图时使用的常见格式，它也是 
由Blinn在 1978年引入的。高度场用于导出u和v符号值，类似 
于第一种方法中使用的值。这是通过获取相邻列之间的差异以获得 
----------------------- Page 244-----------------------
u的斜率以及v的相邻行之间的差异来完成的[1567]。一种变体是 
使用Sobel滤波器，它为直接相邻的邻居提供更大的权重[535]。 
6.7.2法线贴图凹凸贴图的常用方法是直接存储法线贴图。算法和结 
果在数学上与Blinn的方法相同;只有存储格式和像素着色器计算会 
发生变化。2126.纹理图6.34。波浪形高度场凹凸图像及其在球体 
上的使用。法线贴图编码（x，y，z）映射到[.1,1]，例如，对于8 
位纹理，x轴值0表示.1.0和255表示 1.0。一个例子如图6.35所 
示。浅蓝色的颜色[128,128,255]将表示所示颜色映射的平坦表面， 
即[0,0,1]的法线。法线贴图表示最初作为世界空间法线贴图 
[274,891]引入，在实践中很少使用。对于那种类型的映射，扰动很 
简单：在每个像素处，从地图中检索法线，图6.35。使用法线贴图 
进行凹凸贴图。每个颜色通道实际上是表面法线坐标。红色通道是 
x偏差;越红，正常指向右边越多。绿色是y偏差，蓝色是z。右边 
是使用法线贴图生成的图像。请注意立方体顶部的展平外观。（图 
片由 Manuel M.Oliveira和 FabioPolicarpo提供。）6.7。凹凸 
贴图213图6.36。在类似游戏的场景中使用的法线贴图凹凸贴图的 
示例。左上角：未应用右侧的两个法线贴图。左下：应用法线贴图。 
右：正常地图。 （3D模型和法线贴图由 DulceIsisSegarraL'opez 
提供。）直接使用它和光的方向来计算表面上该位置的阴影。法线 
贴图也可以在对象空间中定义，这样模型就可以旋转，法线仍然有 
效。但是，world和object-space表示将纹理绑定到特定方向的特 
定几何体，这限制了纹理重用。相反，扰动法线通常在切线空间中 
----------------------- Page 245-----------------------
检索，即相对于表面本身。这允许表面变形，以及正常纹理的最大 
重用。切线空间法线贴图也可以很好地压缩，因为z分量的符号 （与 
未扰动的曲面法线对齐的符号）通常可以假定为正。可以使用法线 
贴图来提高实际效果 - 见图6.36。与过滤颜色纹理相比，过滤法线 
贴图是一个难题。一般来说，法线和阴影颜色之间的关系不是线性 
的，因此标准过滤方法可能会导致令人反感的混叠。想象一下，看 
着由闪亮的白色大理石块组成的楼梯。在某些角度，楼梯的顶部或 
侧面捕捉光线并反射出明亮的镜面高光。然而，楼梯的平均法线是 
例如45度角; 它将捕捉与原始楼梯完全不同方向的亮点。如果在没 
有正确过滤的情况下渲染具有清晰镜面高光的凹凸贴图，则会出现 
令人分心的闪光效果，因为高光闪烁在样品落下的运气中眨眨眼。 
2146.纹理朗伯曲面是一种特殊情况，法线贴图对着色几乎呈线性 
影响。朗伯阴影几乎完全是点积，这是一个线性操作。平均一组法 
线并使用结果执行点积相当于平均各个点积与法线：l·Pnj =1njn！ 
=Pnj =1 （l·nj）n。（6.14）注意平均向量在使用前未标准化。 
公式6.14表明，标准滤波和 mipmap几乎可以为 Lambertian曲 
面生成正确的结果。结果不太正确，因为朗伯阴影方程不是点积; 它 
是一个钳位点积-max （l·n，0）。夹紧操作使其非线性。这会使表 
面过度变暗以掠过光线方向，但实际上这通常并不令人反感[891]。 
需要注意的是，一些通常用于法线贴图的纹理压缩方法（例如从其 
他两个重建zcomponent）不支持非单位长度法线，因此使用非标 
准化法线贴图可能会造成压缩困难。在非朗伯曲面的情况下，通过 
----------------------- Page 246-----------------------
将阴影方程的输入过滤为一组而不是单独过滤法线贴图，可以产生 
更好的结果。第9.13节讨论了这样做的技巧。最后，从高度图 h（x， 
y）导出法线贴图可能很有用。这完成如下[405]。首先，使用居中 
差异计算x和y方向导数的近似值，如hx （x，y）=h （x +1，y）.h 
 （x.1，y）2，hy （x，y）=h （x，y +1）.h （x，y.1）2。 （6.15） 
texel处的非标准化法线 （x，y）然后是 n （x，y）= （。hx （x，y），。 
hx （x，y），1）。（6.16）必须注意纹理的边界。地平线映射[1027] 
可以用于通过使凸块能够将阴影投射到它们自己的表面上来进一步 
增强法线贴图。这是通过预先计算其他纹理来完成的，每个纹理与 
沿着表面平面的方向相关联，并为每个纹素存储该方向上的地平线 
角度。有关更多信息，请参见第 11.4节。6.8视差映射凸点和法线 
贴图的一个问题是凸点永远不会随着视角移动位置，也不会相互阻 
挡。例如，如果你沿着一个真正的砖墙看，在某个角度，你将看不 
到砖之间的砂浆。碰撞 6.8。视差映射 215视图矢量 pideal p 
heightfield多边形偏移 padjpvhz图6.37。左边是目标：表面上 
的实际位置是从视图矢量穿过高度场的位置找到的。视差贴图通过 
获取矩形上的位置处的高度并使用它来查找新的位置 padj来执行 
一阶近似。（在威尔士[1866]之后。）墙的地图将永远不会显示这 
种类型的遮挡，因为它只会改变法线。最好让凸起实际影响在每个 
像素上渲染表面上的哪个位置。视差映射的概念于 2001年由 
Kaneko[851]引入，并由Welsh [1866]进行了改进和推广。视差 
指的是当观察者移动时物体的位置相对于彼此移动的想法。随着观 
----------------------- Page 247-----------------------
众的移动，凸起应该看起来有高度。视差映射的关键思想是通过检 
查发现的可见高度来对像素中应该看到的内容进行有根据的猜测。 
对于视差映射，凸块存储在高度场纹理中。当在给定像素处查看表 
面时，在该位置处检索高度场值并用于移动纹理坐标以检索表面的 
不同部分。移位量基于所检索的高度和眼睛与表面的角度。见图 
6.37。高度值值要么存储在单独的纹理中，要么打包在未使用的颜 
色或某些其他纹理的alpha通道中（在将不相关的纹理打包在一起 
时必须小心，因为这会对压缩质量产生负面影响）。在用于移动坐 
标之前，高度场值被缩放和偏置。刻度确定高度场在表面上方或下 
方延伸的高度，并且偏差给出了没有发生位移的 “海平面”高度。 
给定纹理坐标位置p，调整后的高度场高度 h和具有高度值vz和水 
平分量vxy的归一化视图矢量v，新视差调整纹理坐标padj 是padj 
=p +h·vxyvz。（6.17）注意，与大多数着色方程不同，这里执 
行计算的空间很重要 - 视图向量需要在切线空间中。虽然这是一种 
简单的近似，但如果凸起高度变化相对较慢，这种变换在实践中效 
果相当好[1171]。附近的相邻纹素也有相同的高度，所以使用原始 
位置的高度作为估计的想法2166.纹理化p'padj图6.38。在视差 
偏移限制中，偏移最多移动远离原始位置的高度量，如虚线圆弧所 
示。灰色偏移显示原始结果，黑色显示有限结果。右边是用这种技 
术渲染的墙。（图片由TerryWelsh提供。）新位置的高度是合理 
的。然而，这种方法在浅视角下会分崩离析。当视图矢量靠近表面 
的地平线时，较小的高度变化会导致较大的纹理坐标偏移。近似失 
----------------------- Page 248-----------------------
败，因为检索到的新位置与原始表面位置的高度相关性很小或没有。 
为了改善这个问题，威尔士[1866]介绍了偏移限制的想法。我们的 
想法是将移动量限制为永远不会大于检索到的高度。然后该等式为 
p'adj =p +h·vxy。（6.18）请注意，此等式的计算速度比原始等 
式快。在几何学上，解释是高度定义了半径，超出该半径，位置不 
能移动。如图6.38所示。在陡峭 （面朝上）的角度，这个方程几乎 
与原始方程相同，因为vz接近 1.在浅角度，偏移的效果受到限制。 
在视觉上，这使得凹凸在浅角处减小，但这比纹理的随机采样要好 
得多。随着视图改变，纹理游泳也存在问题，或者对于立体渲染， 
观察者同时感知两个必须给出一致深度线索的视点[1171]。即使有 
这些缺点，具有偏移限制的视差映射仅花费一些额外的像素着色器 
程序指令，并且相对于基本法线贴图提供了相当大的图像质量改进。 
Shishkovtsov [1631]通过在凹凸贴图法线方向上移动估计位置来 
改善视差遮挡的阴影。6.8.1视差遮挡映射凹凸映射不会根据高度场 
修改纹理坐标;它只改变某个位置的阴影法线。视差映射提供了高度 
场效果的简单近似，假设像素的高度与其邻居的高度大致相同。这 
个假设可以快6.8。视差映射217图6.39。绿眼射线投射到表面平 
面上，定期采样（紫点）并检索高度。该算法找到眼睛光线与近似 
于弯曲高度场的黑色线段的第一个交叉点。分解。颠簸也可以永远 
不会相互遮挡，也不会投下阴影。我们想要的是在像素处可见的内 
容，即视图矢量首先与高度场相交的位置。为了更好地解决这个问 
题，一些研究人员提出沿着视图矢量使用光线行进，直到找到（近 
----------------------- Page 249-----------------------
似）交叉点。这项工作可以在像素着色器中完成，其中高度数据可 
以作为纹理访问。我们将这些方法的研究集中到视差映射技术的子 
集 中 ， 这 些 技 术 以 某 种 方 式 利 用 光 线 行 进 
[192,1171,1361,1424,1742,1743]。这些类型的算法被称为视差遮 
挡映射 （POM）或浮雕映射方法，以及其他名称。关键思想是首先 
沿投影矢量测试固定数量的高度场纹理样本。通常在掠射角处为视 
线产生更多样本，因此不会错过最近的交叉点[1742,1743]。检索沿 
射线的每个三维位置，将其转​ ​ 换为纹理空间，并进行处理以确 
定其是否高于或低于高度场。一旦找到高度场下方的样本，其下面 
的数量和上一个样本的数量用于查找交叉点位置。见图6.39。然后 
使用附加的法线贴图，颜色贴图和任何其他纹理，使用该位置对表 
面进行着色。多层高度场可用于产生悬垂，独立重叠表面和双面浮 
雕图冒充者;见 13.7节。高度场追踪方法也可用于使凹凸不平的表 
面投射阴影到自身，既硬[1171,1424]又柔软[1742,1743]。有关比 
较，请参见图6.40。关于这个主题有很多文献。虽然所有这些方法 
沿着光线行进，但存在一些差异。可以使用简单的纹理来检索高度， 
但也可以使用更高级的数据结构和更高级的根寻找方法。一些技术 
可能涉及着色器丢弃像素或写入2186.纹理图6.40。没有射线行进 
的视差映射（左）与射线行进（右）相比。在不使用光线行进时， 
在立方体的顶部有扁平化。通过光线行进，还会产生自我遮蔽效果。 
 （图片由ManuelM.Oliveira和 FabioPolicarpo提供。）到深度 
缓冲区，这可能会影响性能。下面我们总结一大堆方法，但请记住， 
----------------------- Page 250-----------------------
随着GPU的发展，最好的方法也是如此。这种 “最佳”方法取决于 
内容和光线行进期间完成的步骤数。确定两个常规样本之间的实际 
交叉点的问题是寻根问题。在实践中，高度场更多地被视为深度场， 
矩形的平面定义了表面的上限。这样，平面上的初始点高于高度场。 
找到上面的最后一点，然后是第一点，高度场的表面，Tatarchuk 
[1742,1743]使用割线方法的单个步骤来找到近似解。Policarpo等。 
[1424]在找到的两个点之间使用二进制搜索在更近的交叉点上磨 
练。Risser等。[1497]通过使用割线方法迭代来进行速度收敛。权 
衡是定期采样可以并行完成，而迭代方法需要较少的整体纹理访问， 
但必须等待结果并执行较慢的相关纹理提取。蛮力方法似乎整体表 
现良好[1911]。频繁地对高度场进行采样至关重要。McGuire和 
McGuire[1171]建议偏置mipmap查找并使用各向异性 mipmap 
来确保高频高度场的正确采样，例如代表尖峰或头发的高频场。还 
可以以比法线贴图更高的分辨率存储高度场纹理。最后，一些渲染 
系统甚至不存储法线贴图，更喜欢使用交叉滤波器从高度场导出法 
线[40]。第696页的公式 16.1显示了该方法。提高性能和采样精度 
的另一种方法是不是最初以规则的间隔对高度场进行采样，而是试 
图跳过干预空的空间。Donnelly[367]将高度场预处理成一组体素， 
在每个体素中存储离高度场表面有多远。在这6.8。视差映射219 
图6.41。法线贴图和浮雕贴图。正常映射不会发生自遮挡。浮雕贴 
图有重复纹理的轮廓问题，因为矩形更像是高度场的视图，而不是 
真正的边界定义。（图片由NVIDIA公司提供。）方式，可以快速 
----------------------- Page 251-----------------------
跳过介入空间，但代价是每个高度场的存储量更高。王等人。[1844] 
使用五维位移映射方案来保持从所有方向和位置到表面的距离。这 
允许复杂的曲面，自阴影和其他效果，代价是相当大的存储量。 
Mehra和 Kumar [1195]使用定向距离图来实现类似的目的。 
Dummer[393]介绍了，而 Policarpo和Oliveira [1426]改进了锥 
步映射的思想。这里的概念是还为每个高度场位置存储锥形半径。 
该半径定义了光线上的间隔，其中与高度场最多有一个交点。此属 
性允许沿着光线快速跳过而不会错过任何可能的交叉点，但代价是 
需要2206.纹理依赖纹理读取。另一个缺点是创建锥形步骤图所需 
的预计算，使得该方法不能用于动态改变高度场。Schroders和 
Gulik [1581]提出了四叉树浮雕映射，这是一种在遍历期间跳过卷 
的分层方法。Tevs等人。[1760]使用 “最大mipmap”允许跳过， 
同时最小化预计算成本。Drobot[377]也使用存储在mipmap中的 
四叉树状结构来加速遍历，并提出了一种在不同高度场之间进行混 
合的方法，其中一种地形类型转换为另一种。上述所有方法的一个 
问题是幻象沿着对象的轮廓边缘分解，这将显示原始表面的平滑轮 
廓。见图6.41。关键的想法是渲染的三角形定义了像素着色器程序 
应该评估哪些像素，而不是表面实际所在的位置。此外，对于曲面， 
轮廓问题变得更加复杂。Oliveira和 Policarpo[1325,1850]描述和 
开发了一种方法，该方法使用二次轮廓近似技术。Jeschke等人。 
[824]和 Dachsbacher等人。[323]两者都提供了一种更通用和更健 
全的方法（并回顾以前的工作），以正确处理轮廓和曲面。首先由 
----------------------- Page 252-----------------------
Hirche[750]探讨，一般的想法是将网格中的每个三角形向外挤出 
并形成棱镜。渲染此棱镜会强制评估可能出现高度场的所有像素。 
这种方法称为shell映射，因为展开的网格在原始模型上形成单独的 
shell。通过在与光线相交时保留棱镜的非线性特性，高度场的无伪 
像渲染变得可能，但计算成本很高。这种技术的令人印象深刻的用 
途如图6.42所示。图6.42。视差遮挡贴图，又名浮雕贴图，用于 
路径上，使石头看起来更逼真。地面实际上是一组简单的三角形， 
应用了高度场。 （图片来自 “孤岛危机”，由Crytek提供。）6.9。 
纹理灯221图6.43。投射纹理光。纹理投射到茶壶和地平面上，用 
于调制投影平截头体内光线的贡献 （在平截头体外设置为0）。（图 
片由NVIDIACorporation提供。）6.9纹理灯纹理还可用于增加 
光源的视觉丰富度，并允许复杂的强度分布或聚光灯功能。对于所 
有照明都限制在圆锥或平截头体上的光，可以使用投影纹理来调制 
光强度[1192,1597,1904]。这允许形状聚光灯，图案灯，甚至 “幻 
灯片投影”效果 （图6.43）。在专业剧院和电影照明中使用的剪纸 
术语之后，这些灯通常被称为遮光板或饼干灯。见第7节。图2用 
于讨论以与投射阴影类似的方式使用的投影映射。对于不限于平截 
头体但在所有方向上照明的光，可以使用立方体贴图来调制强度， 
而不是二维投影纹理。一维纹理可用于定义任意距离衰减函数。结 
合二维角度衰减图，这可以允许复杂的体积照明模式[353]。更普遍 
的可能性是使用三维 （体积）纹理来控制光的衰减[353,535,1192]。 
这允许任意体积的效果，包括光束。这种技术是内存密集型的（与 
----------------------- Page 253-----------------------
所有体积纹理一样）。如果灯光的效果量沿三个轴对称，通过将数 
据镜像到每个八分圆中，可以将内存占用减少八倍。可以将纹理添 
加到任何灯光类型以启用其他视觉效果。纹理灯允许艺术家轻松控 
制照明，艺术家可以简单地编辑使用的纹理。2226.纹理化进一步 
阅读和资源 Heckbert撰写了一篇关于纹理映射理论的详细调查 
[690]，并对该主题进行了更深入的报道[691]。Szirmay-Kalos和 
Umenhoffer[1731]对视差遮挡映射和置换方法进行了极好的彻底 
调查。有关正常表示的更多信息可以在Cigolle等人的着作中找到。 
[269]和 Meyer等人。[1205]。使用OpenGL[1192]的高级图形编 
程一书广泛涵盖了使用纹理算法的各种可视化技术。有关三维程序 
纹理的广泛报道，请参见纹理和建模：程序方法[407]。 “可编程图 
形硬件高级游戏开发”[1850]一书中有很多关于实现视差遮挡映射 
技术的细节，Tatarchuk的演示[1742,1743]和Szirmay-Kalos以及 
Umenhoffer的调查[1731]也是如此。对于程序纹理（和建模）， 
我们在互联网上最喜欢的网站是Shadertoy。显示屏上有许多有价 
值且引人入胜的程序纹理功能，您可以轻松修改任何示例并查看结 
果。访问本书的网站realtimerendering.com，获取许多其他资源。 
第七章阴影 “所有的变化，所有的魅力，生活的美丽都是由光与影 
组成的。 “-TolstoyShadows对于创建逼真的图像和向用户提供有 
关对象放置的视觉提示非常重要。本章重点介绍计算阴影的基本原 
理，并介绍最重要和最流行的实时算法。我们还简要讨论了不太受 
欢迎但体现重要原则的方法。我们不会在本章中花时间涵盖所有选 
----------------------- Page 254-----------------------
项和方法，因为有两本综合性书籍可以深入研究阴影领域 
[412,1902]。相反，我们专注于调查自出版以来出现的文章和演示 
文稿，偏向于经过实战考验的技术。本章中使用的术语如图7.1所 
示，其中遮挡物是将阴影投射到接收器上的对象。准时光源，i。例 
如，没有区域的那些，仅生成完全阴影区域，有时称为硬阴影。如 
果=+图7.1。暗影术语：光源，遮挡物，接收器，阴影，本影和半 
影。2232247.阴影图7.2。混合了硬阴影和柔和阴影。由于封堵器 
靠近接收器，因此来自板条箱的阴影是尖锐的。人的阴影在接触点 
处是锐利的，随着到封堵器的距离的增加而变软。遥远的树枝给出 
柔和的阴影[1711]。 （图片来自 “汤姆克兰西的分部”，由Ubisoft 
提供。）使用区域或体积光源，然后产生柔和的阴影。然后，每个 
阴影都可以有一个称为本影的完全阴影区域和一个称为半影的部分 
阴影区域。软阴影由其模糊阴影边缘识别。然而，重要的是要注意， 
通过使用低通滤波器模糊硬阴影的边缘通常无法正确渲染它们。从 
图7.2中可以看出，阴影投射几何体越接近接收器，正确的软阴影 
就越清晰。柔和阴影的本影区域不等于由准时光源产生的硬阴影。 
相反，当光源变大时，柔和阴影的本影区域的尺寸减小，并且如果 
光源足够大并且接收器距离封堵器足够远，它甚至可能消失。柔和 
阴影通常是优选的，因为半影边缘让观察者知道阴影确实是阴影。 
硬边阴影通常看起来不那么逼真，有时会被误解为实际的几何特征， 
例如表面的折痕。然而，硬阴影渲染速度比柔和阴影快。7.1。平面 
阴影225比半影更重要的是有任何阴影。如果没有一些阴影作为视 
----------------------- Page 255-----------------------
觉提示，场景往往难以令人信服，更难以察觉。正如Wanger所展 
示[1846]，通常情况下，阴影不准确，因为眼睛对阴影的形状是相 
当宽容的。例如，在地板上作为纹理应用的模糊黑色圆圈可以将角 
色锚定到地面。在接下来的部分中，我们将超越这些简单的建模阴 
影，并提供从场景中的遮挡物实时自动计算阴影的方法。第一部分 
处理在平面上投射阴影的特殊情况，第二部分介绍更一般的阴影算 
法，即将阴影投射到任意表面上。将覆盖硬阴影和柔和阴影。总之， 
提出了一些适用于各种阴影算法的优化技术。7.1平面阴影当对象将 
阴影投射到平面上时，会出现一个简单的阴影情况。本节介绍了几 
种用于平面阴影的算法，每种算法都具有阴影柔和度和真实感的变 
化。7.1.1投影阴影在此方案中，第二次渲染三维对象以创建阴影。 
可以导出矩阵，将对象的顶点投影到平面上[162,1759]。考虑图7.3 
中的情况，其中光源位于l，要投影的顶点为v，投影顶点位于p。 
我们将推导出阴影平面为y =0的特殊情况下的投影矩阵，然后将 
该结果推广到任何平面。我们首先推导出x坐标的投影。从图7.3 
左侧的类似三角形中，我们得到了px。lxvx。lx=lyly。vy..px= 
lyvx。lxvyly。vy。（7.1）以相同的方式获得z坐标：pz= （lyvz.lzvy） 
/ （ly.vy），而y坐标为零。现在这些方程可以转换成投影矩阵 M： 
M=。...ly.lx0000000.lzly00.10ly。...... （7.2）验证Mv 
=p是直截了当的，这意味着M确实是投影矩阵。2267.阴影图7.3。 
左：位于 l处的光源将阴影投射到平面y =0上。顶点v投影到平 
面上。投影点称为p。类似的三角形用于推导投影矩阵。右：阴影 
----------------------- Page 256-----------------------
被投射到一个平面上，π：n·x +d =0.在一般情况下，阴影应投射 
到的平面不是平面y =0，而是π：n·x +d =0.这种情况如图7.3 
右侧所示。目标是再次找到一个将v向下投影到p的矩阵。为此， 
在l处发出的穿过v的射线与平面π相交。这产生了投影点p：p=1。 
d +n·ln· （v.l）（v.l）。（7.3）该等式也可以转换成公式7.4所示 
的投影矩阵，满足 Mv = p ：M =。 ...... n · l + d 。 
lxnx.lxny.lxnz.lxd.lynx n·l +d。lyny.lynz.lyd.lznx.lzny n·l + 
d。lznz.lzd.nx.ny.nz n·l。...... （7。4）正如预期的那样，如果 
平面为y =0，则该矩阵变为公式7.2中的矩阵，即n = （0,1,0） 
和d =0.要渲染阴影，只需将此矩阵应用于应该在平面π上投射阴 
影的对象，并使用深色和无照明渲染此投影对象。在实践中，您必 
须采取措施避免允许在接收它们的表面下方渲染投影三角形。一种 
方法是向我们投影的平面添加一些偏差，以便阴影三角形始终呈现 
在曲面的前面。更安全的方法是首先绘制地平面，然后关闭z缓冲 
区绘制投影三角形，然后像往常一样渲染其余的几何体。预计7.1。 
平面阴影227图7.4。在左侧，显示正确的阴影，而在右侧的图中， 
由于光源位于物体的最顶端下方，因此会出现反物质。然后，三角 
形总是绘制在地平面的顶部，因为没有进行深度比较。如果地平面 
具有极限，例如，它是矩形，则投射的阴影可能落在其外部，从而 
打破了幻觉。要解决这个问题，我们可以使用模板缓冲区。首先， 
将接收器绘制到屏幕和模板缓冲区。然后，在关闭z缓冲区的情况 
下，仅在绘制接收器的位置绘制投影三角形，然后正常渲染场景的 
----------------------- Page 257-----------------------
其余部分。另一种阴影算法是将三角形渲染成纹理，然后将其应用 
于地平面。这种纹理是一种光照贴图，一种调制底层表面强度的纹 
理 （见第11.5.1节）。如将看到的，将阴影投影渲染到纹理的这种 
想法也允许弯曲表面上的半影和阴影。这种技术的一个缺点是纹理 
可以被放大，单个纹素覆盖多个像素，打破了幻觉。如果阴影情况 
不是逐帧变化，即光影脚轮相对于彼此不移动，则可以重复使用该 
纹理。如果没有发生任何变化，大多数阴影技术都可以从帧到帧重 
用中间计算结果中受益。所有阴影脚轮必须位于灯和地平面接收器 
之间。如果光源低于物体上的最高点，则会生成反物体[162]，因为 
每个顶点都是通过光源的点投射的。正确的阴影和反光影如图7.4 
所示。如果我们投影一个低于接收平面的对象，也会发生错误，因 
为它也不应该投射阴影。当然可以明确地剔除和修剪阴影三角形以 
避免这种伪影。接下来介绍的一种更简单的方法是使用现有的GPU 
管道来执行剪切投影。2287.阴影图7.5。在左边，使用Heckbert 
和 Herf的方法进行渲染，使用256次传球。在右边，海恩斯的方 
法一次性通过。用海恩斯的方法来说，本影过于庞大，这在门口和 
窗户周围尤为明显。7.1.2软阴影通过使用各种技术，投影阴影也可 
以变得柔和。在这里，我们描述了Heckbert和 Herf [697,722]生 
成柔和阴影的算法。该算法的目标是在地平面上生成一个显示柔和 
阴影的纹理。然后我们描述不太准确，更快的方法。只要光源有区 
域，就会出现柔和阴影。近似区域光效果的一种方法是使用放置在 
其表面上的几个点光源对其进行采样。对于这些准时光源中的每一 
----------------------- Page 258-----------------------
个，渲染图像并将其累积到缓冲器中。然后，这些图像的平均值是 
具有柔和阴影的图像。请注意，理论上，任何生成硬阴影的算法都 
可以与此累积技术一起使用以产生半影。实际上，由于涉及的执行 
时间，以交互速率这样做通常是站不住脚的。赫克伯特和赫尔夫使 
用基于平截头体的方法来产生阴影。这个想法是将光作为观察者， 
并且地平面形成平截头体的远剪切平面。截锥体足够宽以包围遮挡 
物。通过生成一系列地平面纹理来形成柔和阴影纹理。区域光源在 
其表面上进行采样，每个位置用于对表示地平面的图像进行着色， 
然后将阴影投射对象投影到该图像上。对所有这些图像求和并求平 
均以产生地平面阴影纹理。有关示例，请参见图7.5的左侧。采样 
区域光方法的一个问题是它看起来像它的样子：来自准时光源的几 
个重叠阴影。此外，对于n个阴影通道，只能生成n +1个不同的 
阴影。大量的传球给出了准确的结果，但成本过高。该方法对于获 
得（字面上） “地面实况”图像以用于测试其他更快算法的质量是 
有用的。7.2。曲面上的阴影229图7.6。投下阴影。通过从上方渲 
染阴影脚轮然后模糊图像并将其渲染在地平面上来生成阴影纹理。 
 （在Autodesk的A360查看器中生成的图像，来自Autodesk的 
Inventor样本的模型。）更有效的方法是使用卷积，即过滤。在某 
些情况下，模糊由单个点生成的硬阴影可能就足够了，并且可以产 
生可以与真实世界内容合成的半透明纹理。见图7.6。然而，在物体 
与地面接触的位置附近，均匀的模糊可能不能令人信服。还有许多 
其他方法可以提供更好的近似值，但需要额外付费。例如，Haines 
----------------------- Page 259-----------------------
[644]以投影的硬阴影开始，然后渲染轮廓边缘，渐变从中心的黑暗 
到边缘的白色，以创建合理的半影。请参见图7.5的右侧。然而， 
这些半影在物理上是不正确的，因为它们也应该延伸到轮廓边缘内 
的区域。Iwanicki[356,806]借鉴了球面谐波的思想，并用椭圆体近 
似遮挡字符，以提供柔和的阴影。所有这些方法都有各种近似和缺 
点，但比平均大量阴影图像要有效得多。7.2曲面上的阴影将平面阴 
影的概念扩展到曲面的一种简单方法是使用生成的阴影图像作为投 
影纹理[1192,1254,1272,1597]。从光的角度考虑阴影。无论光线 
看到什么都被照亮; 它看不到的是阴影。假设遮挡物从灯230中以 
黑色渲染.7。将视点阴影转换为白色纹理。然后可以将该纹理投影 
到要接收阴影的表面上。实际上，接收器上的每个顶点都有一个为 
其计算的（u，v）纹理坐标，并且纹理应用于它。这些纹理坐标可 
以由应用程序显式计算。这与前一部分中的地面阴影纹理略有不同， 
其中对象被投影到特定物理平面上。这里，图像是作为光的视图制 
作的，就像投影仪中的胶片帧一样。渲染时，投影阴影纹理会修改 
接收器曲面。它也可以与其他阴影方法结合使用，有时主要用于帮 
助感知对象的位置。例如，在平台跳跃视频游戏中，即使角色处于 
完全阴影中，主角也可能总是在其正下方给出一个投影[1343]。更 
精细的算法可以提供更好的结果。例如，Eisemann和D'ecoret[411] 
假设一个矩形顶灯并创建一堆物体水平切片的阴影图像，然后将其 
转换为mipmap或类似图像。通过使用其mipmap，每个切片的相 
应区域与其距接收器的距离成比例地访问，这意味着更远的切片将 
----------------------- Page 260-----------------------
投射更柔和的阴影。纹理投影方法存在一些严重的缺点。第一，应 
用程序必须识别哪些对象是封堵器以及哪些是其接收器。接收器必 
须由程序保持远离遮挡物的光线，否则阴影 “向后投射”。此外， 
遮挡物体不能遮挡自己。接下来的两节介绍了生成正确阴影的算法， 
无需这样的干预或限制。注意，通过使用预构建的投影纹理可以获 
得各种照明图案。聚光灯只是一个方形投影纹理，其内部有一个圆 
圈，用于定义光线。威尼斯百叶窗效果可以通过由水平线组成的投 
影纹理来创建。这种类型的纹理称为光衰减掩模，cookie纹理或图 
案图。通过简单地将两个纹理相乘，预构建的图案可以与在飞行中 
创建的投影纹理组合。这些灯将在第6.9节中进一步讨论。7.3影子 
卷由 Heidmann在 1991年[701]提出，基于Crow的阴影卷[311] 
的方法可以通过巧妙地使用模板缓冲器将阴影投射到任意对象上。 
它可以在任何GPU上使用，因为唯一的要求是模板缓冲区。它不是 
基于图像的（与下面描述的阴影贴图算法不同），因此避免了采样 
问题，从而在任何地方产生正确的锐利阴影。这有时可能是一个缺 
点。例如，角色的衣服可能会产生褶皱，这些褶皱会产生薄弱的阴 
影，这些阴影会造成严重的混乱。由于其不可预测的成本，今天很 
少使用阴影卷[1599]。我们在这里给出算法的简要描述，因为它说 
明了基于这些的一些重要原则和研究。7.3。ShadowVolumes231 
点三角形无限金字塔阴影体积金字塔图7.7。左：来自点光源的线延 
伸通过三角形的顶点以形成无限金字塔。右：上部是金字塔，下部 
是无限截断的金字塔，也称为阴影体。阴影体内的所有几何体都是 
----------------------- Page 261-----------------------
阴影。首先，想象一个点和一个三角形。将线从一个点延伸到三角 
形的顶点到无穷大，产生无限的三面金字塔。三角形下面的部分， 
即不包括该点的部分，是截断的无限金字塔，上部仅仅是金字塔。 
如图7.7所示。现在想象这个点实际上是一个点光源。然后，在截 
断金字塔的体积内（在三角形下面）的对象的任何部分都是阴影。 
该卷称为阴影卷。假设我们查看一些场景并通过一个像素跟踪来自 
眼睛的光线，直到光线击中要在屏幕上显示的对象。当光线正在通 
往此物体的路上时，我们每次穿过正面的阴影体（即面向观察者） 
的面时递增一个计数器。因此，每当光线进入阴影时，计数器就会 
递增。以相同的方式，每当光线穿过截头金字塔的背面时，我们递 
减相同的计数器。然后光线会从阴影中射出。我们继续递增和递减 
计数器，直到光线击中要在该像素处显示的对象。如果计数器大于 
零，则该像素处于阴影中;否则不是。当有多个投射阴影的三角形时， 
此原则也适用。见图7.8。使用光线执行此操作非常耗时。但是有一 
个更智能的解决方案[701]：模板缓冲区可以为我们进行计数。首先， 
清除模板缓冲区。其次，将整个场景绘制到帧缓冲区中，仅使用未 
点亮材质的颜色，将颜色缓冲区中的这些阴影组件和深度信息放入 
z缓冲区。第三，关闭z缓冲区更新和写入颜色缓冲区（尽管仍然 
进行了z缓冲区测试），然后绘制阴影卷的正面三角形。在此过程 
中，模板操作设置为在绘制三角形的任何位置增加模板缓冲区中的 
值。第四，使用模板缓冲区完成另一次传递，这次只绘制阴影体积 
的背面三角形。对于此传递，模板缓冲区中的值会在 232 7. 
----------------------- Page 262-----------------------
Shadows++11+1-1+1+1时递减。图7.8。使用两种不同计数 
方法计算阴影体积交叉的二维侧视图。在z-pass体积计数中，当光 
线通过阴影体积的前面三角形时计数递增，而在通过背面三角形时 
递减。因此，在A点，光线进入两​ ​ 个阴影体积为+2，然后留下 
两个体积，留下净计数为零，因此该点处于光照状态。在z-fail卷 
计数中，计数从表面开始（这些计数以斜体显示）。对于 B点的光 
线，z-pass方法通过两个正面三角形给出+2计数，而z-fail通过 
两个背面三角形给出相同的计数。C点显示了如何对z-fail阴影卷 
进行限制。从点C开始的射线首先击中前面三角形，给出.1。然后 
它退出两个阴影卷（通过它们的端盖，这种方法正常工作所必需的）， 
净计数为+1。计数不为零，因此该点在阴影中。两种方法始终为查 
看曲面上的所有点提供相同的计数结果。绘制三角形。仅当渲染的 
阴影体面的像素可见时（即，未被任何真实几何体隐藏），才进行 
递增和递减。此时，模板缓冲区保持每个像素的阴影状态。最后， 
再次渲染整个场景，这次仅显示受光影响的活动材质的组件，并且 
仅在模板缓冲区中的值为0时显示。值为0表示光线已经熄灭阴影 
的数量和进入阴影体积的次数一样多 - 即，这个位置被光照亮。这 
种计数方法是影子卷背后的基本思想。阴影体积算法生成的阴影示 
例如图7.9所示。有一种有效的方法可以在一次通过中实现该算法 
[1514]。但是，当物体穿透相机的近平面时，会发生计数问题。该 
解决方案称为z-fail，包括计算隐藏在可见表面后面而不是前面的交 
叉点[450,775]。图7.8显示了该替代方案的简要概述。为每个三角 
----------------------- Page 263-----------------------
形创建四边形会产生大量的透支。也就是说，每个三角形将创建必 
须渲染的三个四边形。球体7.3。影子卷233图7.9。影卷。在左侧， 
角色投下阴影。在右侧，显示模型的挤压三角形。（来自 Microsoft 
SDK [1208]样本 “ShadowVolume。”的图像）由一千个三角形 
组成，创建了三千个四边形，并且每个四边形可能跨越屏幕。一种 
解决方案是沿着对象的轮廓边缘仅绘制那些四边形，例如，我们的 
球体可能仅具有五十个轮廓边缘，因此仅需要五十个四边形。几何 
着色器可用于自动生成这样的轮廓边[1702]。剔除和夹紧技术也可 
用于降低填充成本[1061]。然而，阴影体积算法仍然有一个可怕的 
缺点：极端的可变性。想象一下，一个小的三角形在视野中。如果 
相机和灯光处于完全相同的位置，则阴影体积成本最低。形成的四 
边形不会覆盖任何像素，因为它们是视图的边缘。只有三角形本身 
很重要。假设观众现在围绕三角形运行，将其保持在视野中。当摄 
像机远离光源时，阴影体四边形将变得更加明显并覆盖更多的屏幕， 
从而导致更多的计算发生。如果观众碰巧进入三角形的阴影，阴影 
卷将完全填满屏幕，与我们的原始视图相比，需要花费大量时间进 
行评估。这种可变性使得影子卷在交互式应用程序中无法使用，其 
中一致的帧速率很重要。与其他情况一样，对光的观察可能导致算 
法成本的巨大，不可预测的跳跃。由于这些原因，应用程序大部分 
都放弃了影子卷。然而，考虑到在GPU上访问数据的新方法和不同 
方法的不断发展，以及研究人员巧妙地重新利用这些功能，影子卷 
可能有一天会重新被普遍使用。例如，Sintorn等人。[1648]概述 
----------------------- Page 264-----------------------
了影子体积算法，这些算法可以提高效率并提出自己的分层加速结 
构。提出的下一个算法阴影映射具有更加可预测的成本，非常适合 
GPU，因此构成了许多应用程序中阴影生成的基础。2347.阴影7.4 
阴影贴图1978年，Williams [1888]提出可以使用基于z缓冲区的 
常见渲染器在任意对象上快速生成阴影。我们的想法是使用z缓冲 
区从投射阴影的光源位置渲染场景。无论光线 “看到”是什么照亮， 
其余的都在阴影中。生成此映像时，只需要z缓冲。可以关闭在颜 
色缓冲区中的照明，纹理和写入值。z缓冲区中的每个像素现在包 
含最靠近光源的对象的z深度。我们将z-buffer的全部内容称为阴 
影贴图，有时也称为阴影深度图或阴影缓冲区。要使用阴影贴图， 
场景将再次渲染，但这次是针对观察者的。在渲染每个绘图基元时， 
将其在每个像素处的位置与阴影贴图进行比较。如果渲染点距离光 
源比阴影贴图中的对应值更远，则该点位于阴影中，否则不是。该 
技术通过使用纹理映射来实现。见图7.10。阴影映射是一种流行的 
算法，因为它是相对可预测的。构建阴影贴图的成本与渲染图元的 
数量大致呈线性关系，访问时间是不变的。阴影贴图可以生成一次 
并重复使用每个帧用于光和物体不移动的场景，例如用于计算机辅 
助设计。当生成单个z缓冲区时，光可以仅在特定方向上 “观察”， 
如相机。对于诸如太阳之类的远距离定向光，光的视图被设置为包 
含将阴影投射到眼睛看到的观察体积中的所有物体。灯光使用正交 
投影，其视图需要在x和y宽度和足够高，以查看这组对象。本地 
光源需要尽可能类似的调整。如果局部光线远离阴影投射物体，则 
----------------------- Page 265-----------------------
单个视锥体可能足以包含所有这些。或者，如果局部光线是聚光灯， 
它具有与之相关的天然平截头体，其截头体外的一切都被认为没有 
被照亮。如果本地光源位于场景内并被阴影脚轮包围，典型的解决 
方案是使用六视图立方体，类似于立方体环境映射[865]。这些被称 
为全向阴影贴图。全方位地图的主要挑战是避免两个独立地图相遇 
的接缝处的人工制品。King和 Newhall[895]深入分析了问题并提 
供了解决方案，Gerasimov [525]提供了一些实现细节。Forsyth 
[484,486]提出了一种用于全向光的通用多平截头体分割方案，该方 
案还在需要时提供更多的阴影图分辨率。Crytek[1590,1678,1679] 
基于每个视图的投影平截头体的屏幕空间覆盖率设置点光源的六个 
视图中的每一个的分辨率，所有地图存储在纹理图集中。并非场景 
中的所有对象都需要渲染到灯光的视图体积中。第一，只需要渲染 
可以投射阴影的对象。例如，如果已知地面只能接收阴影而不能投 
射阴影，则不必将其渲染到阴影贴图中。7.4。阴影贴图235图7.10。 
阴影贴图。在左上角，通过将深度存储到视图中的表面来形成阴影 
图。在右上方，显示的眼睛看着两个位置。在点va处看到球体，并 
且发现该点位于阴影图上的纹理像素a处。存储在那里的深度不是 
 （很多）小于点va来自光，因此点被照亮。在点vb处击中的矩形 
 （远）光比存储在纹素b处的深度更远，因此在阴影中。在左下角 
是从灯光的角度看的场景视图，白色更远。在右下角是使用此阴影 
贴图渲染的场景。根据定义，阴影脚轮是灯光视锥体内的那些。这 
个视锥体可以是au通过几种方式进行音韵或收紧，让我们可以安全 
----------------------- Page 266-----------------------
地忽视一些阴影脚轮[896,1812]。想想眼睛可见的一组阴影接收器。 
这组物体沿着光的视线方向在一定的最大距离内。超出此距离的任 
何东西都不能在可见接收器上投下阴影。类似地，可见接收器的集 
合可能小于光的原始x和y视图边界。见图7.11。另一个例子是， 
如果光源位于眼睛的视锥体内，则在这个额外的视锥体之外的任何 
物体都不能在接收器上投下阴影。仅渲染相关对象不仅可以节省渲 
染时间，还可以减小光锥体所需的尺寸，从而提高阴影贴图的有效 
分辨率，从而提高质量。此外，如果光平截头体的近平面尽可能远 
离光线，如果远平面是236，则会有所帮助.7。阴影眼睛的光眼睛 
的光眼图7.11。在左侧，灯光的视图包含了眼睛的视锥体。在中间， 
光线的远处平面被拉入以仅包括可见的接收器，因此将三角形剔除 
为施法者;近平面也进行了调整。在右边，光的平截头体侧面被束缚 
在可见的接收器上，剔除绿色的胶囊。尽可能接近。这样做会增加 
z缓冲区的有效精度[1792] （第4.7.2节）。阴影贴图的一个缺点是 
阴影的质量取决于阴影贴图的分辨率（以像素为单位）和z缓冲区 
的数值精度。由于在深度比较期间对阴影贴图进行采样，该算法易 
受混叠问题的影响，特别是靠近对象之间的接触点。一个常见的问 
题是自阴影混叠，通常称为 “表面痤疮”或 “阴影痤疮”，其中三 
角形被错误地视为遮蔽自身。这个问题有两个来源。一个是处理器 
精度的数值限制。另一个来源是几何的，因为点样本的值用于表示 
区域的深度。也就是说，为光产生的样本几乎从不与屏幕样本位于 
相同的位置（例如，像素通常在其中心处被采样）。当光的存储深 
----------------------- Page 267-----------------------
度值与观察到的表面深度进行比较时，光的值可能略低于表面的值， 
从而导致自阴影。这些错误的影响如图7.12所示。帮助避免 （但不 
总是消除）各种阴影图伪像的一种常用方法是引入偏差因子。当检 
查阴影贴图中找到的距离与被测位置的距离时，从接收器的距离中 
减去一个小的偏差。见图 7.13。这种偏差可以是一个恒定的值 
[1022]，但是当接收器大部分不面向光时，这样做可能会失败。更 
有效的方法是使用与接收器与光的角度成比例的偏置。表面越远离 
光线越倾斜，偏差越大，以避免问题。这种类型的偏差称为斜率偏 
差。可以通过使用诸如OpenGL的glPolygonOffset之类的命令来 
应用这两个偏差，以使每个多边形偏离光。请注意，如果表面直接 
面向灯光，它没有偏向7.4。阴影贴图237图7.12。阴影贴图偏差 
伪影。在左侧，偏差太低，因此发生自阴影。在右侧，高偏差导致 
鞋子不会投下接触阴影。阴影贴图分辨率也太低，使阴影呈现出块 
状外观。 （使用ChristophPeters的阴影演示生成的图像。）完全 
通过斜率偏差。因此，使用恒定偏置以及斜率标度偏差以避免可能 
的精度误差。坡度标度偏差也经常被钳位在某个最大值，因为当从 
光看时表面几乎是边缘开启时，切线值可能非常高。图7.13。暗影 
偏见。曲面渲染为顶灯的阴影贴图，垂直线表示阴影贴图像素中心。 
封闭深度记录在×位置。我们想知道表面是否以点显示的三个样品 
点亮。每个最接近的阴影贴图深度值用相同的颜色×显示。在左侧， 
如果没有添加偏差，蓝色和橙色样本将被错误地确定为阴影，因为 
它们比相应的阴影贴图深度更远离光。在中间，从每个样本中减去 
----------------------- Page 268-----------------------
恒定的深度偏差，使每个样本更接近光。蓝色样本仍被视为阴影， 
因为它不比光测试的阴影贴图深度更接近光。在右侧，通过将每个 
多边形移动远离与其斜率成比例的光来形成阴影贴图。所有样本深 
度现在都比它们的阴影贴图深度更近，因此所有样本深度都会亮起。 
2387.Shadows Holbert [759，760]引入了正常的偏移偏置，它 
首先将接收器的世界空间位置沿着表面的法线方向稍微移动，与光 
的方向和几何法线之间的角度的正弦成比例。请参见第250页的图 
7.24。这不仅会更改深度，还会更改在阴影贴图上测试样本的x坐 
标和y坐标。随着光线的角度变得越来越浅，这种偏移会增加，希 
望样品在表面上方足够远以避免自阴影。可以将该方法可视化为将 
样本移动到接收器上方的 “虚拟表面”。此偏移是世界空间距离， 
因此Pettineo [1403]建议按阴影贴图的深度范围对其进行缩放。 
Pesce[1391]提出了沿摄像机视角方向偏置的想法，这也可以通过 
调整阴影贴图坐标来实现。其他偏置方法在7.5节中讨论，因为在 
那里提出的阴影方法也需要测试几个相邻的样本。太多的偏差会导 
致一个称为漏光或彼得平移的问题，其中物体看起来漂浮在下面的 
表面上方。出现这种伪影是因为物体接触点下方的区域（例如，脚 
下的地面）被向前推得太远而因此没有接收到阴影。避免自阴影问 
题的一种方法是仅渲染阴影贴图的背面。被称为第二深度阴影映射 
[1845]，这种方案适用于许多情况，特别是对于不能手动调整偏差 
的渲染系统。当物体是双面的，薄的时，就会出现问题或彼此接触。 
如果对象是网格两侧可见的模型，例如棕榈叶或纸张，则可能发生 
----------------------- Page 269-----------------------
自阴影，因为背面和正面位于相同位置。类似地，如果不执行偏置， 
则在轮廓边缘或薄物体附近可能发生问题，因为在这些区域中背面 
靠近前面。增加偏差可以帮助避免表面痤疮，但该方案更容易受到 
光泄漏的影响，因为在接触点处接收器和封堵器的背面之间没有分 
离。见图7.14。选择哪种方案可能取决于具体情况。例如，Sousa 
等人。[1679]发现使用前脸为太阳阴影和背面的内部灯最适合他们 
的应用程序。请注意，对于阴影贴图，对象必须是 “水密的” （流 
形和封闭的，即实体;第 16.3.3节），或者必须将前面和背面都渲染 
到地图上，否则对象可能无法完全投射阴影。Woo [1900]提出了一 
种通用的方法，试图在字面上使用正面或背面进行遮蔽。我们的想 
法是将实体对象渲染到阴影贴图，并跟踪光线的两个最接近的表面。 
该过程可以通过深度剥离或其他与透明度相关的技术来执行。两个 
对象之间的平均深度形成一个中间层，其深度用作阴影贴图，有时 
称为双阴影贴图[1865]。如果物体足够厚，则可以最大限度地减少 
自阴影和漏光伪影。Bavoil等。[116]讨论解决潜在文物的方法，以 
及其他实施细节。主要缺点是额外费用7.4。阴影贴图239正面第 
二深度中点cabbb图7.14。顶置光源的阴影贴图表面。在左侧， 
面向灯光的表面（以红色标记）将被发送到阴影贴图。表面可能被 
错误地确定为遮蔽自己 （“痤疮”），因此需要偏离光线。在中间， 
只有背面三角形呈现在阴影贴图中。向下推动这些遮挡物的偏压可 
能使光泄漏到位置a附近的地平面上;偏向前可以使得标记为 b的 
轮廓边界附近的照明位置被视为阴影。在右边，在阴影图上的每个 
----------------------- Page 270-----------------------
位置处找到的最近的正面和背面三角形之间的中点处形成中间表 
面。在点c附近可能发生漏光（这也可能发生在第二深度阴影映射 
中），因为最近的阴影贴图样本可能位于该位置左侧的中间表面上， 
因此该点将更接近于光。与使用两个阴影贴图相关联。Myers[1253] 
讨论了遮挡和接收器之间的艺术家控制的深度层。当观察者移动时， 
随着阴影脚轮组的变化，灯的视图体积通常会改变大小。这些变化 
反过来导致阴影在帧与帧之间略微移动。发生这种情况是因为光的 
阴影贴图从光中采集了一组不同的方向，并且这些方向与前一组不 
一致。对于定向光，解决方案是强制生成的每个后续阴影贴图在世 
界空间[927,1227,1792,1810]中保持相同的相对纹素光束位置。也 
就是说，您可以将阴影贴图视为在整个世界上施加二维网格化参照 
系，每个网格单元表示地图上的像素样本。移动时，将为这些相同 
网格单元的不同集生成阴影贴图。换句话说，光的视图投影被强制 
到该网格以保持帧到帧的一致性。7.4.1分辨率增强与纹理的使用方 
式类似，理想情况下，我们希望一个阴影贴图纹素覆盖一个图像像 
素。如果我们的光源位于与眼睛相同的位置，阴影贴图与屏幕空间 
像素完美地一对一地映射（并且没有可见的阴影，因为光线正好照 
亮了眼睛看到的东西）。一旦光的方向改变，这个每像素比率就会 
改变，这可能会导致伪影。一个例子如图7.15所示。阴影是块状的 
并且定义不清楚，因为前景中的大量像素与阴影贴图的每个纹素相 
关联。这种不匹配称为透视混叠。单个阴影贴图纹理也可以2407. 
阴影图7.15。左边的图像是使用标准阴影贴图创建的;使用LiSPSM 
----------------------- Page 271-----------------------
向右移动图像。显示每个阴影贴图的纹素的投影。两张阴影贴图具 
有相同的分辨率，不同之处在于 LiSPSM对光的矩阵进行了改造， 
以便在观察者附近提供更高的采样率。（图片由维也纳科技大学的 
DanielScherzer提供。）如果表面几乎与光线接近，则会覆盖许多 
像素，但面向观察者。这个问题被称为投射混叠[1792];见图7.16。 
通过增加阴影贴图分辨率可以减少阻塞，但代价是额外的内存和处 
理。还有另一种方法可以创建灯光的采样模式，使其更接近相机的 
模式。这是通过改变场景向光投射的方式来完成的。通常我们认为 
视图是对称的，视图矢量位于平截头体的中心。然而，视图方向仅 
定义视图平面，但不定义哪些像素被采样。定义平截头体的窗口可 
以在该平面上移动，倾斜或旋转，从而创建四边形，从而提供世界 
与视图空间的不同映射。四边形仍然以规则的间隔进行采样，因为 
这是线性变换矩阵的性质以及GPU的使用。可以通过改变灯光的视 
图方向和视图窗口的边界来修改采样率。见图7.17。将光的视图映 
射到眼睛的位置有22个自由度[896]。对此解决方案空间的探索导 
致了几种尝试7.4的不同算法。阴影贴图241图7.16。在左边，灯 
几乎在头顶上。由于与眼睛视图相比分辨率较低，阴影的边缘有点 
粗糙。在右边，光线靠近地平线，所以每个阴影纹理元素都会在水 
平方向上覆盖更多的屏幕区域，因此会产生更多的锯齿状边缘。 
 （TheRealMJP在Github上的 “阴影”程序生成的图像。）以更 
好地匹配光的采样率到眼睛。方法包括透视阴影图 （PSM）[1691]， 
梯形阴影图（TSM）[1132]和光空间透视阴影图（LiSPSM） 
----------------------- Page 272-----------------------
[1893,1895]。有关示例，请参见第254页的图7.15和图7.26。此 
类中的技术称为透视变形方法。这些矩阵变形算法的一个优点是除 
了修改光的矩阵之外不需要额外的工作。每种方法都有自己的优点 
和缺点[484]，因为每种方法都可以帮助匹配某些几何和照明情况的 
采样率，同时使其他方面的这些速率恶化。劳埃德等人。[10621063] 
分析 PSM，TSM和 LiSPSM之间的等价性，用这些方法很好地概 
述了采样和混叠问题。当光的方向垂直于视图的方向 （例如，开销） 
时，这些方案最有效，因为透视变换可以被移动以使更多的样本更 
靠近眼睛。眼灯地板眼灯地板图7.17。对于顶灯，在左侧，地板上 
的采样与眼睛的速率不匹配。通过改变右侧的光的视图方向和投影 
窗口，采样率偏向于具有更接近眼睛的更高密度的纹理像素。2427. 
阴影矩阵变形技术无法提供帮助的一种照明情况是当灯光在相机前 
面并指向它时。这种情况被称为决斗挫折，或更通俗地称为 “头灯 
中的鹿”。更多的阴影图样本需要更近眼睛，但线性翘曲只会使情 
况变得更糟[1555]。这个和其他问题，例如质量的突然变化[430] 
和相机运动期间产生的阴影的 “紧张”，不稳定的质量[484,1227]， 
使得这些方法失宠。在查看器所在位置添加更多样本的想法很好， 
导致算法为给定视图生成多个阴影贴图。当Carmack在Quakecon 
2004的主题演讲中描述时，这个想法首先产生了明显的影响.Blow 
独立实施了这样一个系统[174]。这个想法很简单：生成一组固定的 
阴影贴图（可能在不同的分辨率下），覆盖场景的不同区域。在 Blow 
的计划中，四个阴影贴图嵌套在查看器周围。通过这种方式，可以 
----------------------- Page 273-----------------------
为附近的物体提供高分辨率的地图，远离这些物体的分辨率会下降。 
Forsyth[483,486]提出了一个相关的想法，为不同的可见对象集生 
成不同的阴影贴图。在他的设置中避免了如何处理跨越两个阴影贴 
图之间的边界的对象的过渡的问题，因为每个对象具有与其相关联 
的一个且仅一个阴影贴图。旗舰工作室开发了一个融合这两个想法 
的系统。一个阴影贴图用于附近的动态对象，另一个阴影贴图用于 
观察者附近的静态对象的网格部分，第三个阴影贴图用于整个场景 
中的静态对象。每帧生成第一个阴影贴图。其他两个只能生成一次， 
因为光源和几何形状是静态的。虽然所有这些特定的系统现在已经 
很老了，但是针对不同对象和情况的多个映射的想法，一些预先计 
算的和一些动态的，是自那时以来开发的算法中的共同主题。2006 
年恩格尔[430]，劳埃德等人。[1062,1063]和张等人。[1962,1963] 
独立研究了相同的基本思想.1的想法是通过平行于视图方向切割视 
锥体的体积为几个部分。见图7.18。随着深度的增加，每个连续的 
体积大约是前一个体积的深度范围的两到三倍[430,1962]。对于每 
个视图体积，光源可以制作紧密限制它的平截头体，然后生成阴影 
贴图。通过使用纹理图集或数组，可以将不同的阴影贴图视为一个 
大的纹理对象，从而最大限度地减少缓存访问延迟。获得的质量改 
进的比较如图7.19所示。恩格尔这个算法的名称，级联阴影贴图 
 （CSM），比张的术语，平行分裂阴影贴图更常用，但两者都出现 
在文献中并且实际上是相同的[1964]。这种类型的算法很容易实现， 
可以覆盖具有合理结果的大型场景区域，并且是健壮的。决斗挫折 
----------------------- Page 274-----------------------
问题可以通过以更接近眼睛的更高速率采样来解决，并且没有严重 
的最坏情况1Tadamura等人。[1735]七年前引入了这个想法，但 
在其他研究人员探索其有用性之前，它没有产生影响。7.4。阴影地 
图243视锥体灯图7.18。在左边，眼睛视锥体分为四卷。在右侧， 
为卷创建边界框，这些边框决定了四个阴影贴图中每个阴影贴图为 
定向光渲染的体积。 （在恩格尔之后[430]。）图7.19。在左侧，场 
景的宽可视区域导致2048×2048分辨率的单个阴影贴图显示透视 
锯齿。在右侧，沿视轴放置的四个 1024×1024阴影贴图显着提高 
了质量[1963]。在嵌入的红色框中显示围栏前角的缩放。（图片由 
香港中文大学张帆提供。）2447.阴影图7.20。阴影级联可视化。 
紫色，绿色，黄色和红色代表最近的最远级联。（图片由 Unity 
Technologies提供。）问题。由于这些优势，级联阴影映射在许多 
应用程序中使用。虽然可以使用透视变形将更多样本打包到单个阴 
影贴图的细分区域[1783]，但规范是为每个级联使用单独的阴影贴 
图。如图7.18所示，图7.20从观察者的角度显示，每个地图覆盖 
的区域可以变化。较近的阴影贴图的较小视图体积可在需要它们的 
地方提供更多样本。确定z-深度的范围如何在地图之间分配 - 称为 
z-分区的任务 - 可以非常简单或涉及[412,991,1791]。一种方法是 
对数分割[1062]，其中每个级联图的远距离与近距离平面距离的比 
率相同：r =crfn，（7.5）其中n和f是整个场景的近和远平面， 
c是地图的数量，和r是得到的比率。例如，如果场景最近的物体距 
离是1米，最大距离是 1000米，我们有三个级联地图，那么r=3 
----------------------- Page 275-----------------------
p 1000/1 =10.最近视图的近和远平面距离将是在图 1和 10中， 
下一个间隔是 10到 100来保持这个比例，而最后一个是 100到 
1000米。初始近深度对此分区有很大影响。如果近深度仅为0.1米， 
那么 10000的立方根是21.54，相当高的比例，例如0.1到2.154 
到46.42到1000.这意味着生成的每个阴影图必须覆盖更大的区域， 
降低其精度。在实践中，这种分区给靠近近平面的区域提供了相当 
大的分辨率，如果该区域中没有物体则浪费。避免这种不匹配的一 
种方法是将分区距离设置为对数和等距分布的加权混合 
[1962,1963]，但如果我们能够确定场景的紧密视界，那将更好。挑 
战在于设置近平面。如果设置得离眼睛太远，物体可能被这个平面 
夹住，这是一个非常糟糕的人工制品。对于剪切场景，艺术家可以 
设置7.4。Shadow Maps245这个值恰好提前[1590]，但对于交 
互式环境，问题更具挑战性。Lauritzen等。[991,1403]呈现样本分 
布阴影图（SDSM），其使用来自前一帧的z深度值来通过两种方 
法之一确定更好的分区。第一种方法是查看z深度的最小值和最大 
值，并使用它们来设置近平面和远平面。这是使用GPU上的所谓减 
少操作来执行的，其中由计算器或其他着色器分析一系列更小的缓 
冲器，其中输出缓冲器作为输入反馈，直到剩下 1×1缓冲器。通常， 
将值推出一点以调整场景中对象的移动速度。除非采取纠正措施， 
否则从屏幕边缘进入的附近物体仍可能导致帧出现问题，但下一步 
将很快得到纠正。第二种方法还分析深度缓冲区的值，制作一个称 
为直方图的图形，记录沿该范围的z深度分布。除了找到紧密的近 
----------------------- Page 276-----------------------
距离和远距离平面之外，图形中可能还有间隙，其中根本没有对象。 
通常添加到此类区域的任何分区平面都可以捕捉到对象实际存在的 
位置，从而为级联映射集提供更多z深度精度。在实践中，第一种 
方法是通用的，快速的 （通常在每帧 1ms范围内），并且给出了良 
好的结果，因此它已被多种应用所采用[1405,1811]。见图7.21。 
与单个阴影贴图一样，由于光样本逐帧移动而产生的闪烁伪像是一 
个问题，并且当对象在级联之间移动时可能更糟。多种方法用于维 
持世界空间中的稳定样本点，每种方法都有其自身的优势 
[41,865,1381,1403,1678,1679,1810]。当对象跨越两个阴影贴图 
之间的边界时，可能会发生阴影质量的突然变化。一种解决方案是 
使视图体积略微重叠。在这些重叠区域中采集的样本收集来自两个 
相邻阴影图的结果并进行混合[1791]。或者，可以通过使用抖动在 
该区域中采集单个样品[1381]。由于其受欢迎，已经投入相当大的 
努力来提高效率和质量[1791,1964]。如果阴影贴图的平截头体内没 
有任何变化，则不需要重新计算该阴影贴图。对于每个灯光，阴影 
脚轮列表可以通过查找哪些对象对光可见而预先计算，以及这些对 
象可以在接收器上投射阴影[1405]。由于很难察觉阴影是否正确， 
因此可以采用适用于级联和其他算法的一些快捷方式。一种技术是 
使用低水平的细节模型作为实际投射阴影的代理[652,1812]。另一 
个是考虑去除微小的遮挡物[1381,1811]。根据这种阴影不太重要的 
理论，更远的阴影贴图可以比帧一次更新频率更低。这个想法会冒 
大型移动物体造成的伪影，因此需要谨慎使用 
----------------------- Page 277-----------------------
[865,1389,1391,1678,1679]。Day [329]提出了从一帧到另一帧 
 “滚动”远处地图的想法，其思想是每个静态阴影贴图的大部分是 
2467.阴影图7.21。深度界限的影响。在左侧，没有使用特殊处理 
来调整近平面和远平面。在右侧，SDSM用于查找更严格的边界。 
请注意每个图像左边缘附近的窗口框架，二楼花箱下面的区域，以 
及一楼的窗口，由于松散的视图边界而导致的欠采样会导致伪影。 
指数阴影贴图用于渲染这些特定图像，但提高深度精度的想法对于 
所有阴影贴图技术都很有用。 （图片由ReadyatDawnStudios提 
供，版权归SonyInteractiveEntertainment所有。）可重复使用 
的帧到帧，只有条纹可能会改变，因此需要渲染。诸如 DOOM 
 （2016）之类的游戏维护着大量的阴影贴图，仅重新生成物体移动 
的图集[294]。可以将更远的级联地图设置为完全忽略动态对象，因 
为这样的阴影可能对场景贡献很少。在某些环境中，可以使用高分 
辨率静态阴影贴图代替这些更远的级联，这可以显着减少工作量 
[415,1590]。稀疏纹理系统 （第 19.10节）。1）可以用于单个静态 
阴影贴图将是巨大的世界[241,625,1253]。级联阴影贴图可以与烘 
焙光贴图纹理或其他更适合特定情况的阴影技术相结合[652]。 
Valient的演示文稿[1811]值得注意的是，它描述了各种视频游戏的 
不同影子系统定制和技术。第 11.5.1节详细讨论了预先计算的光影 
算法。创建几个单独的阴影贴图意味着为每个阴影贴图运行一组几 
何图形。提高效率的许多方法都建立在一次通过中将遮挡物渲染到 
一组阴影贴图的想法上。几何着色器可用于复制对象数据并将其发 
----------------------- Page 278-----------------------
送到多个视图[41]。实例几何着色器允许将对象输出到最多32个深 
度纹理[1456]。7.5。百分比 - 更近的过滤247多视口扩展可以执 
行诸如将对象渲染到特定纹理阵列切片[41,154,530]之类的操作。 
第21.3.1节在它们用于虚拟现实的背景下更详细地讨论了这些。视 
口共享技术的一个可能的缺点是生成的所有阴影贴图的遮挡物必须 
沿着管道向下发送，而不是发现与每个阴影贴图相关的集合 
[1791,1810]。你自己目前正处于世界各地数十亿光源的阴影之中。 
只有少数这些光可以帮助你。在实时渲染中，如果所有灯始终处于 
活动状态，则具有多个灯的大型场景可能会被计算淹没。如果一个 
空间体积在视锥体内但对眼睛不可见，则不需要评估遮挡该接收体 
积的物体[625,1137]。比特纳等人。[152]从眼睛使用遮挡剔除 （第 
19.7节）找到所有可见的阴影接收器，然后从光的角度将所有潜在 
的阴影接收器渲染到模板缓冲掩模。该掩模编码从光中看到哪些可 
见的阴影接收器。为了生成阴影贴图，它们使用遮挡剔除从光源渲 
染对象，并使用遮罩来剔除没有接收器的对象。各种剔除策略也适 
用于灯光。由于辐照度随着距离的平方而下降，因此常见的技术是 
在一定的阈值距离之后剔除光源。例如，第 19.5节中的门户剔除技 
术可以找出哪些灯影响哪些细胞。这是一个活跃的研究领域，因为 
性能优势可能相当大[1330,1604]。7.5百分比 - 更近的过滤阴影贴 
图技术的简单扩展可以提供伪软阴影。此方法还可以帮助改善分辨 
率问题，当单个光样本单元覆盖许多屏幕像素时，这些问题会导致 
阴影看起来像块状。解决方案类似于纹理放大（第6.2.1节）。不 
----------------------- Page 279-----------------------
是从阴影图中取出单个样本，而是检索四个最近的样本。该技术不 
在深度本身之间进行插值，而是在与表面深度进行比较的结果之间 
进行插值。也就是说，表面的深度与四个纹素深度分别进行比较， 
然后，对于每个阴影图样本，确定该点在光或阴影中。然后对这些 
结果，即阴影为0，对光为 1，然后进行双线性插值，以计算光对表 
面位置的实际贡献量。这种过滤导致人为柔和的阴影。根据阴影贴 
图的分辨率，摄像机位置和其他因素，这些半影会发生变化。例如， 
较高的分辨率使边缘的柔和变窄。尽管如此，一点点半影和平滑总 
比没有好。从阴影图检索多个样本并混合结果的这种想法称为百分 
比近似滤波（PCF）[1475]。区域灯产生柔和阴影。到达表面上的 
位置的光量是从该位置可见光的面积的比例的函数。PCF试图通过 
反转过程来逼近准阴（或定向）光的软阴影。2487.阴影区域光遮 
挡器接收器点光遮挡器pp图7.22。在左侧，来自区域光源的棕色 
线条显示了形成半影的位置。对于接收器上的单个点 p，可以通过 
测试区域光表面上的一组点并找出未被任何遮挡物阻挡的点来计算 
所接收的照明量。在右边，点光源不会产生半影。PCF通过反转过 
程来近似区域光的影响：在给定位置，它在阴影贴图上的可比较区 
域上进行采样，以得出照亮了多少样本的百分比。红色椭圆显示阴 
影贴图上采样的区域。理想情况下，该盘的宽度与接收器和封堵器 
之间的距离成比例。它不是从表面位置找到光的可见区域，而是从 
原始位置附近的一组表面位置找到准点光的可见性。见图7.22。名 
称 “百分比 - 近距离过滤”是指最终目标，即找到对光可见的样本 
----------------------- Page 280-----------------------
的百分比。该百分比是用于遮盖表面的光量。在 PCF中，位置靠近 
表面位置，大约相同的深度，但在阴影贴图上的不同纹理元素位置 
处生成。检查每个位置的可见性，然后混合这些得到的布尔值（点 
亮或不点亮）以获得柔和阴影。请注意，此过程是非物理过程：此 
过程不依赖于直接对光源进行采样，而是依赖于在曲面本身上进行 
采样的想法。到封堵器的距离不会影响结果，因此阴影具有相似大 
小的半影。尽管如此，该方法在许多情况下提供了合理的近似。一 
旦确定了要采样的区域的宽度，重要的是以避免混叠伪像的方式进 
行采样。如何对附近的阴影贴图位置进行采样和过滤有很多变化。 
变量包括要采样的区域的宽度，要使用的样本数量，采样模式以及 
如何对结果进行加权。使用功能较少的API，采样过程可以通过类 
似于双线性插值的特殊纹理采样模式加速，该模式访问四个相邻的 
7.5。百分比 - 更近的过滤249图7.23。最左边显示了使用最近邻 
采样的4×4 网格模式的PCF采样。最右侧显示磁盘上的 12抽头泊 
松采样模式。使用此模式对阴影贴图进行采样可以在左中间提供改 
进的结果，但工件仍然可见。在中间右侧，采样图案围绕其中心从 
像素到像素随机旋转。结构化阴影伪像变成 （更不用说令人讨厌的） 
噪声。（图片由John Isidoro，ATI Research，Inc。提供）位置。 
不是混合结果，而是将四个样本中的每一个与给定值进行比较，并 
且返回通过测试的比率[175]。但是，以常规网格图案执行最近邻居 
采样会产生明显的伪像。使用模糊结果但尊重物体边缘的联合双边 
滤波器可以提高质量，同时避免阴影泄漏到其他表面上[1343]。有 
----------------------- Page 281-----------------------
关此过滤技术的更多信息，请参见第 12.1.1节。DirectX10为PCF 
引入了单指令双线性滤波支持，给出了更平滑的结果 
[53,412,1709,1790]。与最近邻采样相比，这提供了相当大的视觉 
改善，但是来自常规采样的伪像仍然是个问题。最小化网格模式的 
一种解决方案是使用预先计算的泊松分布模式对区域进行采样，如 
图7.23所示。该分布将样本展开，使得它们既不相邻也不是规则模 
式。众所周知，对于每个像素使用相同的采样位置，无论分布如何， 
都可以产生图案[288]。通过围绕其中心随机旋转样本分布可以避免 
这种伪影，这会使混叠变成噪声。Casta.no [235]发现泊松采样产 
生的噪声因其平滑，风格化的内容而特别明显。他提出了一种基于 
双线性采样的高效加权抽样方案。PCF会使自我遮蔽问题和漏光， 
即粉刺和彼得潘宁变得更糟。斜坡刻度偏差完全基于其与光的角度 
将表面推离光线，假设样本在阴影贴图上不超过纹素。通过从表面 
上的单个位置在更宽的区域中取样，一些测试样品可能被真实表面 
阻挡。已经发明并使用了一些不同的附加偏差因子，并且成功地降 
低了自阴影的风险。Burley [212]描述了偏置锥，其中每个样本朝 
向与原始样本的距离成比例的光移动。Burley建议斜率为2.0，并 
伴有小的恒定偏差。见图7.24。2507.阴影图7.24。额外的阴影偏 
差方法。对于 PCF，在原始样品位置（五个点的中心）周围采集了 
几个样品。所有这些样品都应该点亮。在左图中，形成偏置锥并将 
样本向上移动。可以增加锥体的陡度以将样品拉到右侧足够近以便 
点亮，存在增加其他样品 （未示出）中真正被遮蔽的光泄漏的风险。 
----------------------- Page 282-----------------------
在中图中，所有样本都被调整为位于接收器的平面上。这适用于凸 
面，但在凹面处可能适得其反，如左侧所示。在右图中，正常的偏 
移偏移使样本沿着表面的法线方向移动，与正常和光线之间的角度 
的正弦成比例。对于中心样本，可以认为这是移动到原始表面上方 
的假想表面。这种偏差不仅会影响深度，还会改变用于测试阴影贴 
图的纹理坐标。Sch¨uler[1585]，Isidoro [804]，和Tuft [1790] 
提出了基于观察的技术，即接收器本身的斜率应该用于调整其余样 
本的深度。在这三者中，Tuft的配方[1790]最容易应用于级联阴影 
贴图。Dou等人。[373]进一步完善和扩展这一概念，考虑z深度如 
何以非线性方式变化。这些方法假设附近的样本位置在由三角形形 
成的同一平面上。被称为接收器平面深度偏差或其他类似术语，在 
许多情况下，该技术可以非常精确，因为该假想平面上的位置确实 
在表面上，或者如果模型是凸的则在其前面。如图7.24所示，凹陷 
附近的样本可能会隐藏。常数，斜率，接收平面，视角偏差的组合， 
虽然仍然需要对每个环境进行手动调整，但正常的偏移偏置已被用 
于解决自阴影问题[235,1391,1403]。PCF的一个问题是因为采样区 
域的宽度保持不变，阴影将显得均匀柔和，所有阴影宽度都相同。 
在某些情况下这可能是可以接受的，但在封堵器和接收器之间存在 
接地的情况下看起来是不正确的。见图7.25。7.6百分比 - 更接近 
的软阴影2005年，费尔南多[212,467,1252]发表了一种名为百分 
比隐形软阴影 （PCSS）的有影响的方法。它通过在7.6附近搜索附 
近区域来尝试解决方案。Percentage-CloserSoft Shadows 251 
----------------------- Page 283-----------------------
图7.25。百分比 - 更接近的过滤和百分比 - 更接近的软阴影。在 
左侧，硬阴影与一点 PCF过滤。在中间，恒定宽度柔和的阴影。在 
右侧，可变宽度的柔和阴影具有适当的硬度，物体与地面接触。（图 
片由NVIDIA公司提供。）阴影图找到所有可能的遮挡物。这些遮 
挡物与该位置的平均距离用于确定样本区域宽度：wsample = 
wlight dr。dodr，（7.6）其中dr是接收器与光的距离并做平均 
封堵器距离。换句话说，随着平均遮挡物越来越远离接收器并且更 
靠近光线，样本的表面区域的宽度增大。检查图7.22并考虑移动阻 
塞器的效果，看看它是如何发生的。图7.2 （第224页），7.25和 
7.26显示了示例。如果找不到遮挡物，位置完全亮起，无需进一步 
处理。类似地，如果位置完全被遮挡，则处理可以结束。否则，然 
后对感兴趣的区域进行采样并计算光的近似贡献。为了节省处理成 
本，样本区域的宽度可用于改变采样的数量。可以实现其他技术， 
例如，对于不太可能重要的远距离软阴影使用较低的采样率。这种 
方法的一个缺点是需要对阴影贴图的大小区域进行采样以找到遮挡 
物。使用旋转的 Poisson磁盘模式可以帮助隐藏欠采样伪像 
[865,1590]。Jimenez [832]注意到泊松采样在运动中可能是不稳定 
的，并且发现通过使用抖动和随机之间的函数形成的螺旋图案给出 
了帧到帧的更好结果。Sikachev等人。[1641]详细讨论了使用AMD 
引入的SM5.0中的PCSS的更快实现，并且通常用它们的名称来称 
呼接触硬化阴影（CHS）。这个新版本还解决了基本PCSS的另一 
个问题：半影的大小受阴影贴图分辨率的影响。见图7.25。首先生 
----------------------- Page 284-----------------------
成阴影贴图的mipmap，然后选择最接近用户定义的世界空间内核 
大小的 mip级别，可以最大限度地减少此问题。采样8×8区域以 
找到平均阻塞深度，仅需要 16个GatherRed （）纹理调用。一旦 
发现半影估计，较高分辨率的mip级别为2527.阴影用于阴影的锐 
利区域，而较低分辨率的mip级别用于较软区域。CHS已被用于大 
量视频游戏[1351,1590,1641,1678,1679]，并且研究仍在继续。例 
如，Buades等人。[206]呈现可分离的软阴影映射（SSSM），其 
中对网格进行采样的PCSS过程被分成可分离的部分，并且元素尽 
可能从像素到像素被重用。已经证明有助于加速每像素需要多个样 
本的算法的一个概念是分层最小/最大阴影图。虽然阴影贴图深度通 
常无法平均，但每个​ ​ mipmap级别的最小值和最大值都很有用。 
也就是说，可以形成两个 mipmap，一个保存每个区域中最大的 
zdepth （有时称为 HiZ），一个最小的。给定纹素位置，深度和要 
采样的区域，mipmap可用于快速确定完全亮起和完全阴影的条件。 
例如，如果纹素的z深度大于为 mipmap的相应区域存储的最大z 
深度，则纹理元素必须处于阴影中 - 不需要进一步的样本。这种类 
型的阴影图使得确定光可见度的任务更加有效 
[357,415,610,680,1064,1811]。PCF等方法通过对附近接收器位置 
进行采样来完成。PCSS的工作原理是找到附近遮挡物的平均深度。 
这些算法不直接考虑光源的面积，而是对附近的表面进行采样，并 
受阴影贴图的分辨率影响。PCSS背后的主要假设是平均阻滞剂是对 
半影大小的合理估计。当两个遮挡物（例如路灯和远处的山）在一 
----------------------- Page 285-----------------------
个像素处部分地遮挡相同的表面时，该假设被破坏并且可能导致伪 
影。理想情况下，我们希望确定从单个接收器位置可以看到多少区 
域光源。一些研究人员已经使用GPU探索了反投影。我们的想法是 
将每个接收器的位置视为视点，将区域光源视为视图平面的一部分， 
并将遮挡物投射到该平面上。Schwarz和Stamminger[1593]以及 
Guennebaud等人。[617]总结了以前的工作并提供了自己的改进。 
Bavoil等。[116]采用不同的方法，使用深度剥离来创建多层阴影贴 
图。反投影算法可以提供出色的结果，但每像素的高成本（到目前 
为止）意味着它们在交互式应用程序中尚未被采用。7.7过滤阴影贴 
图一种允许过滤生成的阴影贴图的算法是Donnelly和Lauritzen的 
方差阴影贴图 （VSM）[368]。该算法将深度存储在一个地图中，并 
将深度平方存储在另一个地图中。生成映射时可以使用 MSAA或其 
他抗锯齿方案。这些地图可以模糊，mipmap，放在求和区域表[988] 
或任何其他方法。将这些地图视为可过滤纹理的能力是一个巨大的 
优势，因为从它们检索数据时可以承担整个采样和过滤技术。7.7。 
过滤的阴影贴图253我们将在这里深入描述VSM，了解这个过程 
是如何运作的;此外，相同类型的测试用于此类算法中的所有方法。 
有兴趣了解该领域的读者应该访问相关参考文献，我们也推荐 
Eisemann等人的书。[412]，这给主题提供了更多的空间。首先， 
对于VSM，深度图在接收器的位置被采样 （仅一次）以返回最近的 
光遮挡物的平均深度。当称为第一时刻的平均深度 M1大于阴影接 
收器t上的深度时，认为接收器完全处于光照状态。当平均深度小 
----------------------- Page 286-----------------------
于接收器的深度时，使用以下等式：pmax （t）=σ2σ2+ （t .M1） 
2， （7.7）其中pmax是光中样本的最大百分比，σ2是方差，t是 
接收器深度，和 M1是阴影贴图中的平均预期深度。深度平方阴影 
图的样本M2 称为第二时刻（  ）用于计算方差：σ2=M2.M21。 7.8（ ） 
值pmax是接收器可见度百分比的上限。实际照明百分比p不能大 
于该值。这个上限来自切比雪夫不等式的片面变体。该方程试图使 
用概率理论估计表面位置上遮挡物的分布有多少超出表面与光的距 
离。Donnelly和 Lauritzen表明，对于固定深度的平面封堵器和平 
面接收器，p=pmax，因此方程7.7可以用作许多真实阴影情况的 
良好近似。迈尔斯[1251]建立了一个直觉，说明为什么这种方法有 
效。在阴影边缘处，区域上的方差增加。深度差异越大，方差越大。 
然后，（t.M1）2项是可见性百分比中的重要决定因素。如果该值 
略高于零，则这意味着平均遮挡物深度比接收器稍微靠近光，并且 
pmax接近 1 （完全点亮）。这将发生在半影的完全照亮的边缘。 
进入半影，平均遮挡深度越接近光线，因此该项变大，pmax下降。 
同时，方差本身在半影内变化，从几乎为零的边缘变为最大的方差， 
其中遮挡物的深度不同并且均匀地共享该区域。这些术语平衡，在 
半影上产生线性变化的阴影。见图7。26与其他算法进行比较。方 
差阴影映射的一个重要特征是它可以以优雅的方式处理由于几何形 
状引起的表面偏差问题。Lauritzen[988]给出了如何使用曲面斜率 
来修改第二时刻的值的推导。数值稳定性的偏差和其他问题可能是 
方差映射的问题。例如，公式7.8减去一个大值2547.阴影图7.26。 
----------------------- Page 287-----------------------
在左上角，标准阴影贴图。右上角，透视阴影映射，增加观察者附 
近的阴影贴图纹理密度。左下方，百分比更近的柔和阴影，当封堵 
器与接收器的距离增加时软化阴影。右下角，方差阴影映射具有恒 
定的软阴影宽度，每个像素用单个方差图样本着色。 （图片由Nico 
Hempe，YvonneJung和Johannes Behr提供。）来自另一个类 
似的价值。这种类型的计算倾向于放大基础数值表示的准确性的缺 
乏。使用浮点纹理有助于避免此问题。由于GPU的优化纹理功能得 
到有效利用，因此整体VSM在处理时间方面的质量显着提高。虽 
然 PCF需要更多样本，因此需要更多时间来避免产生更柔和阴影时 
的噪音，但VSM可以只使用一个高质量的样本来确定整个区域的 
效果并产生平滑的半影。这种能力意味着在算法的限制范围内，阴 
影可以任意软，无需额外成本。7.7。滤镜阴影贴图255图7.27。 
方差阴影映射，其中到光源的距离从左到右增加。（图片来自NVIDIA 
SDK 10[1300]样本，由 NVIDIA公司提供。）与 PCF一样，过滤 
内核的宽度决定了半影的宽度。通过找到接收器和最近的封堵器之 
间的距离，可以改变内核宽度，从而给出令人信服的柔和阴影。 
Mipmapped样本是半影的覆盖率差估计，宽度缓慢增加，产生四 
四方方的伪影。Lauritzen[988]详述了如何使用求和区域表来提供 
更好的阴影。一个例子如图7.27所示。当两个或多个遮挡物覆盖接 
收器并且一个遮挡物靠近接收器时，沿着半影区域的一个地方方差 
阴影映射分解。概率论中的切比雪夫不等式将产生与正确光百分比 
无关的最大光值。最接近的封堵器，仅通过部分隐藏光，抛出等式 
----------------------- Page 288-----------------------
的近似值。这导致光泄漏（也称为光泄漏），其中完全遮挡的区域 
仍然接收光。见图7.28。通过在较小区域上采集更多样本，可以解 
决此问题，将方差阴影映射转换为 PCF形式。与 PCF一样，速度和 
性能会受到影响，但对于阴影深度复杂度较低的场景，方差映射效 
果很好。Lauritzen[988]给出了一种艺术家控制的方法来改善问题， 
即将低百分比视为完全阴影并将剩余的百分比范围重新映射到0％ 
到 100％。这种方法可以减轻轻微的出血，以缩小半影整体为代价。 
虽然光线出血是一个严重的限制，但VSM很适合从地形产生阴影， 
因为这种阴影很少涉及多个遮挡物[1227]。能够使用过滤技术快速 
生成平滑阴影的承诺引起了对过滤阴影映射的极大兴趣;主要的挑 
战是解决各种出血问题。Annen等人。[55]介绍了卷积阴影图。扩 
展了Soler和Sillion的平面256算法背后的想法7.阴影图7.28。 
在左侧，应用于茶壶的方差阴影贴图。在右边，一个三角形（未显 
示）在茶壶上投下阴影，在地面阴影中造成令人反感的瑕疵。（图 
片由MarcoSalvi提供。）接收者[1673]，我们的想法是在傅立叶 
展开中对阴影深度进行编码。与方差阴影映射一样，可以过滤此类 
映射。该方法收敛于正确的答案，因此减少了漏光问题。卷积阴影 
映射的一个缺点是需要计算和访问几个术语，这大大增加了执行和 
存储成本[56,117]。Salvi[1529,1530]和Annen等人。[56]同时并 
独立地提出了使用基于指数函数的单个术语的想法。称为指数阴影 
贴图（ESM）或指数方差阴影贴图（EVSM），此方法将深度的指 
数与其第二时刻一起保存到两个缓冲区中。指数函数更接近于阴影 
----------------------- Page 289-----------------------
贴图执行的阶梯函数（即，是否在光照下），所以这可以显着减少 
出血伪影。它避免了卷积阴影映射具有的另一个问题，称为振铃， 
其中轻微的漏光可能发生在刚刚超过原始遮挡物深度的特定深度 
处。存储指数值的限制是第二时刻值可能变得非常大，因此使用浮 
点数超出范围。为了提高精度，并允许指数函数更陡峭地下降，可 
以生成z深度，使得它们是线性的[117,258]。由于其与VSM相比 
具有更高的质量，并且与卷积图相比具有更低的存储性和更好的性 
能，因此指数阴影贴图方法引起了三种滤波方法的最大兴趣。 
Pettineo[1405]注意到其他一些改进，例如，能够使用 MSAA来 
改善结果并获得有限的透明度，并描述了如何使用计算着色器提高 
过滤性能。最近，Peters和 Klein[1398]引入了时刻阴影映射。它 
提供更好的质量，但代价是使用四个或更多时刻，增加了存储成本。 
通过使用 16位整数来存储矩，可以降低这种成本。Pettineo[1404] 
实现并将这种新方法与ESM进行比较，提供了探索许多变体的代码 
库。7.8。体积阴影技术257级联阴影贴图技术可应用于滤波后的贴 
图以提高精度[989]。级联ESM优于标准级联映射的优点是可以为 
所有级联设置单个偏置因子[1405]。Chen和Tatarchuk [258]详细 
介绍了级联 ESM遇到的各种漏光问题和其他工件，并提出了一些解 
决方案。过滤后的地图可以被认为是一种廉价的 PCF形式，需要很 
少的样本。与PCF一样，这种阴影具有恒定的宽度。这些过滤后的 
方法都可以与 PCSS 结合使用，以提供可变宽度的半影 
[57,1620,1943]。矩影映射的扩展还包括提供光散射和透明效果的 
----------------------- Page 290-----------------------
能力[1399]。7.8体积阴影技术透明物体将衰减和改变光的颜色。对 
于某些透明对象集，可以使用与第5.5节中讨论的类似的技术来模 
拟这些效果。例如，在某些情况下，可以生成第二类阴影图。透明 
对象将呈现给它，并存储最接近的深度和颜色或alpha覆盖范围。 
如果接收器未被不透明阴影贴图阻挡，则测试透明度深度图，如果 
被遮挡，则根据需要检索颜色或覆盖[471,1678,1679]。这个想法让 
人联想到7.2节中的阴影和光线投影，存储的深度避免了投影到透 
明物体和光线之间的接收器上。这些技术不能应用于透明对象本身。 
自阴影对于物体（如头发和云）的真实渲染至关重要，其中物体是 
小的或半透明的。单深度阴影贴图不适用于这些情况。Lokovic和 
Veach [1066]首次提出了深影贴图的概念，其中每个阴影贴图纹理 
元素存储光如何随深度下降的函数。该函数通常由不同深度处的一 
系列样本近似，每个样本具有不透明度值。地图中包含给定位置深 
度的两个样本用于查找阴影效果。GPU上的挑战在于有效地生成和 
评估这些功能。这些算法使用类似的方法，并遇到了一些与顺序无 
关的透明度算法（第5.5节）中发现的类似挑战，例如紧密存储忠 
实代表每个函数所需的数据。Kim和 Neumann[894]是第一个提 
出基于GPU的方法的人，他们称之为不透明阴影贴图。仅存储不透 
明度的地图是在固定的深度集合处生成的。Nguyen和 Donnelly 
[1274]给出了这种方法的更新版本，产生了如第 1719页的图 17.2 
所示的图像。然而，深度切片都是平行且均匀的，因此需要很多切 
片来隐藏切片不透明度之间的工件。线性插值。Yuksel和 Keyser 
----------------------- Page 291-----------------------
[1953]通过创建更接近模型形状的不透明度贴图来提高效率和质 
量。2587.阴影图7.29。使用自适应体积阴影贴图进行头发和烟雾 
渲染[1531]。（经MarcoSalvi和 IntelCorporation许可转载， 
版权所有 IntelCorporation，2010。）这样做可以减少所需的层 
数，因为每层的评估对最终图像更为重要。为了避免不得不依赖于 
固定切片设置，已经提出了更多自适应技术。Salvi等人。[1531] 
引入自适应体积阴影图，其中每个阴影图纹理元素存储不透明度和 
层深度。像素着色器操作用于在光栅化时有损压缩​ ​ 数据流（表 
面不透明度）。这避免了需要无限量的内存来收集所有样本并在集 
合中处理它们。该技术类似于深阴影贴图[1066]，但压缩步骤在像 
素着色器中即时完成。将函数表示限制为小的，固定数量的存储的 
不透明度/深度对使得GPU上的压缩和检索更有效[1531]。成本高 
于简单混合，因为需要读取，更新和回写曲线，这取决于用于表示 
曲线的点数。在这种情况下，此技术还需要支持UAV和 ROV功能 
的最新硬件（3.8节结束）。有关示例，请参见图7.29。自适应体 
积阴影映射方法用于游戏GRID2中的真实烟雾渲染，平均成本低于 
2毫秒/帧[886]。F¨urst等。[509]描述并提供用于实现视频游戏的 
深阴影贴图的代码。它们使用链接列表来存储深度和alpha，并使 
用指数阴影贴图在点亮和阴影区域之间提供柔和过渡。7.9。不规则 
的Z缓冲区阴影259影子算法的探索仍在继续，各种算法和技术的 
综合变得越来越普遍。例如，Selgrad等人。[1603]研究存储具有 
链表的多个透明样本并使用具有分散写入的计算着色器来构建地 
----------------------- Page 292-----------------------
图。他们的工作使用深阴影图概念，以及过滤后的地图和其他元素， 
这为提供高质量的柔和阴影提供了更通用的解决方案。7.9不规则Z 
缓冲阴影由于几个原因，各种阴影贴图方法很受欢迎。它们的成本 
是可预测的，并且可以很好地适应不断增加的场景大小，最坏的是 
与原始数量成线性关系。它们很好地映射到GPU上，因为它们依靠 
光栅化来定期对灯光的世界进行采样。然而，由于这种离散采样， 
出现了问题，因为眼睛看到的位置不与光看到的位置一一对应。当 
光对表面的采样频率低于眼睛时，会出现各种混叠问题。即使采样 
率相当，也存在偏差问题，因为表面采样的位置与眼睛看到的位置 
略有不同。阴影体积提供精确的分析解决方案，因为灯光与曲面的 
相互作用会产生一组三角形，用于定义任何给定位置是照亮还是阴 
影。在GPU上实现时算法的不可预测成本是一个严重的缺点。近年 
来探索的改进[1648]令人着迷，但还没有在商业应用中采用的 “存 
在证据”。另一种分析阴影测试方法可能具有长期潜力：射线追踪。 
在第 11.2.2节中详细描述，基本思想很简单，特别是对于阴影。从 
接收器位置向光线射出光线。如果发现任何阻挡光线的物体，则接 
收器处于阴影中。许多快速光线跟踪器的代码专用于生成和使用分 
层数据结构，以最小化每条光线所需的对象测试数量。为动态场景 
构建和更新这些结构的每个框架是一个有数十年历史的主题和持续 
的研究领域。另一种方法是使用GPU的光栅化硬件来查看场景，但 
是不仅仅是z深度，而是存储关于光的每个网格单元中的遮挡物的 
边缘的附加信息[1003,1607]。例如，想象在每个阴影贴图纹素处存 
----------------------- Page 293-----------------------
储与网格单元重叠的三角形列表。这样的列表可以通过保守的光栅 
化生成，如果三角形的任何部分与像素重叠，而不仅仅是像素的中 
心，则三角形会生成一个片段 （第23.1.2节）。这种方案的一个问 
题是每个纹素的数据量通常需要被限制，这反过来可能导致确定每 
个接收器位置的状态的不准确性。鉴于 GPU 的现代链表原则 
[1943]，每个像素可以存储更多数据。然而，除了物理内存限制之 
外，在每个纹理元素的列表中存储可变数量的数据的问题是GPU处 
理可能变得非常低效，因为单个扭曲可以具有一些片段2607.阴影 
图7.30。不规则的z缓冲区。在左上角，来自眼睛的视图在像素中 
心处生成一组点。示出了形成立方体面的两个三角形。在右上角， 
这些点从灯的视图中显示出来。在左下角，强加了阴影贴图网格。 
对于每个纹素，生成其网格单元内所有点的列表。在右下角，通过 
保守地栅格化对红色三角形执行阴影测试。在触摸的每个纹理元素 
上，以浅红色显示，其列表中的所有点都针对三角形进行测试以获 
得光的可见性。（TimoAila和Samuli Laine[14]提供的底层光栅 
图像。）需要检索和处理许多项目的线程，而其余的线程都处于空 
闲状态，没有任何工作要做。构造着色器以避免由于动态 “if”语句 
和循环导致的线程分歧对性能至关重要。在阴影贴图中存储三角形 
或其他数据并测试接收器位置的替代方法是解决问题，存储接收器 
位置，然后测试三角形。这种保存接收器位置的概念，首先由 
Johnson等人研究。[839]和Aila和 Laine[14]，被称为不规则的z 
缓冲区 （IZB）。该名称有点误导，因为缓冲区本身具有阴影贴图的 
----------------------- Page 294-----------------------
正常，规则形状。相反，缓冲区的内容是不规则的，因为每个阴影 
贴图纹素将在其中存储一个或多个接收器位置，或者可能根本不存 
在。见图7.30。7.9。不规则的Z缓冲阴影261使用Sintorn等人 
提出的方法。[1645]和Wyman等人。[1930,1932]，多次通过算 
法创建 IZB并测试其内容以获得来自光的可见性。首先，从眼睛渲 
染场景，以找到从眼睛看到的表面的z深度。这些点被转换为灯光 
的场景视图，并且从光线的平截头体的这一组形成了紧密的边界。 
然后将这些点沉积在光的 IZB中，每个点放置在其相应纹理元素的 
列表中。请注意，某些列表可能是空的，即灯光可以看到但没有眼 
睛看到的表面的空间。保护性地将封堵器光栅化到灯的IZB以确定 
是否隐藏任何点，因此在阴影中。保守的光栅化确保即使三角形不 
覆盖浅纹理像素的中心，也会对它可能重叠的点进行测试。可见性 
测试发生在像素着色器中。测试本身可以看作是射线追踪的一种形 
式。从图像点到光的位置生成光线。如果一个点在三角形内并且比 
三角形的平面更远，则它是隐藏的。一旦所有遮挡物被光栅化，光 
能见度结果将用于遮蔽表面。此测试也称为视锥体跟踪，因为三角 
形可以被视为定义视锥体，其检查点以包含在其体积中。仔细编码 
对于使这种方法与 GPU 良好协作至关重要。Wyman 等人。 
[1930,1932]注意到它们的最终版本比最初的原型快两个数量级。这 
种性能提升的一部分是直接的算法改进，例如剔除表面法线背离光 
线的图像点（因此总是不亮）并避免为空纹理像素生成碎片。其他 
性能提升来自改进GPU的数据结构，以及通过在每个纹素中使用短 
----------------------- Page 295-----------------------
的，相似长度的点列表来最小化线程分歧。图7.30显示了一个低分 
辨率阴影贴图，其中包含用于说明目的的长列表。理想的是每个列 
表一个图像点。分辨率越高，列表越短，但也会增加封堵器生成的 
碎片数量用于评估。从图7.30的左下图可以看出，由于透视效应， 
地面上的可见点密度在左侧比右侧高得多。使用级联阴影贴图可以 
将更多的光照贴图分辨率更接近眼睛，从而有助于降低这些区域中 
的列表尺寸。这种方法避免了其他方法的采样和偏差问题，并提供 
了完美的阴影。出于美学和感知的原因，通常需要柔和的阴影，但 
是附近的遮挡物可能存在偏差问题，例如 Peter Panning。Story 
和Wyman [1711,1712]探索混合阴影技术。核心思想是使用遮挡 
距离来混合 IZB和 PCSS阴影，当遮挡物靠近时使用硬阴影结果， 
而当更远时使用柔和阴影。见图7.31。阴影质量通常对附近的对象 
最重要，因此通过仅在选定的子集上使用此技术可以降低IZB成本。 
该解决方案已成功用于视频游戏。本章以这样的图像开始，如第224 
页的图7.2所示.2627.阴影图7.31。在左侧，PCF为所有对象提供 
均匀柔化的阴影。在中间，PCSS通过距离遮挡物的距离来软化阴影， 
但是与箱子左角重叠的树枝阴影会产生伪影。在右边，来自 IZB的 
锐利阴影与来自 PCSS的柔和混合提供了改进的结果[1711]。（图 
片来自 “汤姆克兰西的分部”，由Ubisoft提供。）7.10其他应用 
将阴影贴图定义为定义一定体积的空间，将光线与黑暗分开，还可 
以帮助确定要遮挡的对象的哪些部分。Gollent [555]描述了 CD 
Projekt的地形阴影系统如何为每个区域计算仍然被遮挡的最大高 
----------------------- Page 296-----------------------
度，然后可以用于不仅遮蔽地形而且还遮蔽树木和场景中的其他元 
素。为了找到每个高度，为太阳渲染可见区域的阴影贴图。然后检 
查每个地形高度场位置以获得来自太阳的可见性。如果在阴影中， 
通过将世界高度增加固定步长直到太阳进入视野然后执行二分搜索 
来估计太阳首次可见的高度。换句话说，我们沿着垂直线行进并迭 
代以缩小与阴影贴图的表面相交的位置，该表面将光与暗分开。插 
入相邻高度以在任何位置找到该遮挡高度。图7.32中可以看到用于 
地形高度场软阴影的这种技术示例。我们将在第 14章中看到更多使 
用光线穿过光明和黑暗的区域。值得一提的最后一种方法是渲染屏 
幕空间阴影。由于分辨率有限，阴影贴图通常无法在小特征上产生 
准确的遮挡。这在渲染人脸时尤其成问题，因为我们特别容易注意 
到它们上的任何视觉瑕疵。例如，渲染发光的鼻孔（当不打算时） 
看起来很刺耳。虽然使用更高分辨率的阴影贴图或仅针对感兴趣区 
域的单独阴影贴图可以提供帮助，但另一种可能性是利用已存在的 
数据。在大多数现代渲染引擎中，在渲染过程中可以使用来自相机 
视角的深度缓冲，来自较早的预制。存储在其中的数据可以视为高 
度场。通过对该深度缓冲器进行迭代采样，我们可以执行射线行进 
过程（第6.8.1节）并检查朝向光的方向是否未被遮挡。虽然成本 
高昂，因为它涉及重复采样深度缓冲，但这样做可以为切割场景中 
的特写镜头提供高质量的结果，其中花费额外的毫秒通常是合理的。 
该方法由Sousa等人提出。[1678]并且通常在今天的许多游戏引擎 
中使用[384,1802]。7.10。其他应用263图7.32。地形点亮了第一 
----------------------- Page 297-----------------------
次看到太阳的高度，为每个高度场位置计算。注意阴影边缘的树木 
是如何正确遮蔽的[555]。 （CDPROJEKTR，TheWitcher R是CD 
PROJEKTCapitalGroup的注册商标.Witcher游戏cCDPROJEKT 
SA 由CD PROJEKT SA开发。保留所有权利.Witcher游戏基于 
Andrzej Sapkowski的散文。所有其他版权和商标它们是各自所有 
者的财产。）总结这整章，阴影映射是迄今为止用于投射到任意表 
面形状上的阴影的最常用算法。级联阴影贴图可在大面积（例如室 
外场景）中投射阴影时提高采样质量。通过SDSM找到近平面的良 
好最大距离可以进一步提高精度。百分比近似滤波（PCF）为阴影 
提供了一些柔和性，百分比更接近的软阴影 （PCSS）及其变体提供 
接触硬化，不规则的z缓冲区可以提供精确的硬阴影。过滤后的阴 
影贴图可提供快速的软阴影计算，并且当遮挡物远离接收器时也能 
正常工作，就像地形一样。最后，屏幕空间技术可以用于额外的精 
度，但成本显着。在本章中，我们将重点放在当前应用程序中使用 
的关键概念和技术上。每个都有自己的优势，选择取决于世界大小， 
组成 （静态内容与动画），材料类型 （不透明，透明，头发或烟雾）， 
灯光的数量和类型 （静态或动态;本地或远程;点，斑点或区域），以 
及诸如底层纹理可以隐藏任何工件的因素。GPU功能不断发展和改 
进，因此我们希望能够继续看到能够很好地映射到硬件的新算法。 
例如，第 19.10.1节中描述的稀疏纹理技术已应用于阴影贴图存储 
以提高分辨率[241,625,1253]。在一种创造性的方法中，Sintorn， 
2647.阴影图7.33。顶部是使用基本软阴影近似生成的图像。在底 
----------------------- Page 298-----------------------
部是基于体素的区域光阴影，使用锥形跟踪，在场景的体素化上。 
注意汽车的漫反射阴影要多得多。由于一天中的时间变化，照明也 
不同。 （图片由Crytek[865]提供。）K¨ampe和其他人[850,1647] 
探索了将光的二维阴影图转换为三维体素集 （小盒子;见13.10节）。 
使用体素的一个优点是它可以被分类为点亮或阴影，因此需要最小 
的存储空间。高度压缩的稀疏体素八叉树表示存储大量灯光和静态 
遮挡物的阴影。Scandolo等。[1546]使用双阴影贴图将它们的压缩 
技术与基于间隔的方案相结合，从而提供更高的压缩率。Kasyan 
[865]使用体素锥跟踪 （第 13.10节）从区域光源生成柔和阴影。有 
关示例，请参见图7.33。更多锥形跟踪阴影显示在第545页的图 
13.33中.7.10。其他应用程序265进一步阅读和资源本章的重点是 
基本原理以及影子算法需要的质量 - 可预测的质量和性能 - 对交 
互式渲染很有用。我们已经避免对这个渲染领域的研究进行详尽的 
分类，因为有两个文本可以解决这个问题。Eisemann等人的 “实 
时阴影”一书。[412]直接关注交互式渲染技术，讨论各种算法及其 
优势和成本。SIGGRAPH2012课程提供了本书的摘录，同时还增 
加了对新作品的参考[413]。他们的SIGGRAPH2013课程的演讲可 
以在他们的网站www。realtimeshadows.com。Woo和 Poulin 
的书 “ShadowAlgorithms DataMiner”[1902]概述了用于交互 
式和批量渲染的各种阴影算法。这两本书都提供了该领域数百篇研 
究论文的参考。Tuft的一对文章[1791，[1792]是对常用阴影贴图 
技术及所涉及问题的精彩概述。Bj.rge[154]提出了一系列适用于移 
----------------------- Page 299-----------------------
动设备的流行阴影算法，以及比较各种算法的图像。Lilley的演讲 
[1046]给出了实用阴影算法的可靠和广泛的概述，重点是GIS系统 
的地形渲染。Pettineo[1403,1404]和Casta.no [235]的博客文章 
对于他们的实用技巧和解决方案以及演示代码库特别有价值。见 
Scherzer等。[1558]对于专门针对硬阴影的工作的较短摘要。 
Hasenfratz等人对软阴影算法的调查。[675]已过时，但涵盖范围 
广泛的早期工作。第8章光与色 “揭开彩虹，正如它的erewhile所 
做的那样，温柔的人将 Lamia融化成阴影。 “-John Keats前面 
章节中讨论的许多RGB颜色值代表了光的强度和阴影。在本章中， 
我们将了解由这些值测量的各种物理光量，为后续章节奠定基础， 
从更基于物理的角度讨论渲染。我们还将更多地了解渲染过程经常 
被忽略的 “后半部分”：将场景线性光量表示为最终显示颜色的颜 
色转换。8.1光量基于任何基于物理的渲染方法的第一步是以精确的 
方式量化光。首先介绍辐射测量，因为这是与光的物理传输有关的 
核心领域。我们继续讨论光度测定法，该测光法处理由人眼敏感度 
加权的光值。我们对颜色的感知是一种心理物理现象：物理刺激的 
心理感知。颜色感知在比色法一节中讨论。最后，我们讨论了使用 
RGB颜色值进行渲染的有效性。8.1.1辐射测量辐射测量涉及电磁 
辐射的测量。如将在9.1节中更详细地讨论的，该辐射作为波传播。 
具有不同波长的电磁波 - 具有相同相位的两个相邻点之间的距离， 
例如，两个相邻峰值 - 倾向于具有不同的特性。在自然界中，电磁 
波存在于很大的波长范围内，从长度小于百分之一纳米的伽马波到 
----------------------- Page 300-----------------------
几十万公里长的极低频 （ELF）无线电波。人类可以看到的波浪267 
2688.光和彩色紫外红外微波X射线 - 射线 UHFVHFAM无线电 
ELF短波无线电长波无线电图8.1。可见光的波长范围，在完整电磁 
波谱中的上下文中示出。包括该范围的一小部分，从紫外光的约400 
纳米延伸到红光的700纳米以上。见图8.1。存在用于测量电磁辐 
射的各个方面的辐射量：总能量，功率（随时间的能量）和相对于 
面积，方向或两者的功率密度。表8.1总结了这些数量。在辐射测 
量中，基本单位是辐射通量，？。辐射通量是辐射能随时间流动的 
功率 - 以瓦特 （W）为单位测量。辐照度是辐射通量相对于面积的 
密度，即dθ/dA。辐照度是关于一个区域定义的，该区域可以是空 
间中的虚构区域，但通常是对象的表面。它以瓦/平方米为单位。在 
我们进入下一个数量之前，我们需要首先介绍立体角的概念，它是 
角度概念的三维扩展。角度可以被认为是平面中一组连续方向的大 
小的度量，弧度的值等于弧的长度，这组方向在半径为 1的圆周上 
相交。立体角度测量三维空间中连续方向的大小，以球面度（缩写 
为 “sr”）测量，它由半径为1[544]的封闭球体上的交叉点区域定 
义。立体角由符号ω表示。名称符号单位辐射通量？瓦特（W）辐 
照度 EW/ m2辐射强度 IW/ sr辐射率 LW/ （m2sr）表8.1。辐 
射量和单位。8.1。光量269图8.2。从球体的剖视图中移除了具有 
一个立体角的立体角的圆锥体。形状本身与测量无关。球体表面的 
覆盖范围是关键。在二维中，2π弧度的角度覆盖整个单位圆。将其 
扩展到三维，4π球面度的立体角将覆盖单位球体的整个区域。在图 
----------------------- Page 301-----------------------
8.2中可以看到一个立体角的立体角大小。现在我们可以引入辐射强 
度 I，它是相对于方向的磁通密度 - 更准确地说，是立体角 （d？/d 
ω）。它以每立体弧度的瓦数来衡量。最后，辐射度L是单个射线 
中电磁辐射的量度。更准确地说，它被定义为相对于面积和立体角 
 （d2π/dAdω）的辐射通量密度。该区域在垂直于射线的平面中测 
量。如果将辐射应用于某个其他方向的表面，则必须使用余弦校正 
因子。您可能会在参考此修正系数时使用术语 “投影面积”来遇到 
辐射定义。辐射是眼睛或照相机等传感器测量的（更多细节参见第 
9.2节），因此它对于渲染至关重要。评估着色方程的目的是计算沿 
着给定光线的辐射，从阴影表面点到相机。沿该射线的 L值是基于 
物理的等效于第 5章中的阴影数量。辐射的度量单位是每平方米每 
个球面度的瓦特数。环境中的辐射可以被认为是五个变量 （或六个， 
包括波长）的函数，称为辐射分布[400]。其中三个变量指定一个位 
置，另外两个指定一个方向。此功能描述了在太空中任何地方旅行 
的所有光考虑渲染过程的一种方式是眼睛和屏幕定义一个点和一 
组方向（例如，穿过每个像素的光线），并且针对每个方向在眼睛 
处评估该函数。基于图像的渲染，在第 13.4节中讨论，使用一个相 
关的概念，称为光场。在着色方程中，辐射通常以 Lo （x，d）或 
Li （x，d）的形式出现，其分别表示从点x 出来或进入它的辐射。 
方向向量d表示光线的方向，按照惯例，它总是指向远离x的方向。 
虽然这种惯例在Li的情况下可能有点令人困惑，但是在图8中，“光 
和颜色”图8.3。三种不同光波的SPD （光谱功率分布）。顶部SPD 
----------------------- Page 302-----------------------
用于绿色激光，其具有极窄的光谱分布。它的波形类似于第294页 
的图9.1中的简单正弦波。中间SPD用于由相同的绿色激光器和另 
外两个激光器（一个红色和一个蓝色）组成的光。这些激光器的波 
长和相对强度对应于显示中性白色的 RGB激光投影显示器。底部 
SPD用于标准 D65光源，这是一种典型的中性白色参考，用于表示 
户外照明。具有能量在可见光谱中连续扩散的这种SPD是自然光照 
的典型。因为d指向与光传播相反的方向，所以便于计算诸如点积。 
辐射的一个重要特性是它不受距离的影响，忽略了雾等大气效应。 
换句话说，无论距离观察者的距离如何，表面都将具有相同的辐射 
亮度。当距离较远时，表面覆盖较少的像素，但是每个像素处的表 
面的辐射是恒定的。大多数光波包含许多不同波长的混合物。这通 
常被视为光谱功率分布（SPD），其是示出光的能量如何在不同波 
长上分布的图。图8.3显示了三个例子。值得注意的是，尽管图8.3 
中的中间和底部SPD之间存在巨大差异，但它们被认为是相同的颜 
色。很明显，人眼会造成光谱仪不佳。我们将在8.1.3节详细讨论 
色彩视觉。所有辐射量都具有光谱分布。由于这些分布是波长密度， 
因此它们的单位是原始数量除以纳米的单位。例如，辐照度的光谱 
分布具有每平方米每纳米的瓦特单位。由于完整的SPD难以用于渲 
染，特别是在交互速率下，实际辐射量表示为 RGB三元组。在8.1.3 
节中，我们将解释这些三元组如何与光谱分布相关。8.1。轻量化 
271图8.4。光度曲线。8.1.2光度测量辐射测量法纯粹用物理量来 
处理，而不考虑人类的感知。相关领域，测光，就像测辐射，除了 
----------------------- Page 303-----------------------
它通过人眼的灵敏度对所有东西进行加权。放射性计算的结果通过 
乘以CIE光度曲线转换为光度单位，1是以555nm为中心的钟形曲 
线，表示眼睛对各种波长的光的响应[76,544]。见图8.4。转换曲线 
和测量单位是光度学理论和辐射测量理论之间的唯一区别。每个辐 
射量具有等效的度量光度量。表8.2显示了每个的名称和单位。这 
些单元都具有预期的关系（例如，勒克斯是每平方米的流明）。虽 
然逻辑上流明应该是基本单位，但历史上坎德拉被定义为基本单位 
而其他单位则来自它。在北美，照明设计师使用不推荐的英制测量 
单位测量照度，称为英尺烛光（fc），而不是勒克斯。在任何一种 
情况下，照度是大多数光度计测量的，并且在照明工程中很重要。 
亮度通常用于描述平面的亮度。例如，高动态范围（HDR）电视屏 
幕的峰值亮度通常在约 500至 1000尼特的范围内。相比之下，晴 
空的亮度约为8000尼特，60瓦的灯泡约为 120,000尼特，地平线 
的太阳有600,000尼特[1413]。1完整且更准确的名称是 “CIE明 
视光谱发光效率曲线”。 “明视”一词指的是比每平方米3.4坎德 
拉更亮或更亮的照明条件。在这些条件下，眼球锥细胞是活跃的。 
有一个相应的 “暗视”CIE曲线，以507nm为中心，用于当眼睛 
变暗以适应低于0.034坎德拉每平方米 - 无月夜或更暗。棒细胞在 
这些条件下是活跃的。2728.光和颜色辐射量：单位光度数量：单 
位辐射通量：瓦特（W）光通量：流明（lm）辐照度：W/ m2照 
度：勒克斯（lx）辐射强度：W/ sr发光强度：坎德拉（cd）辐射 
率：W/ （m2sr）亮度：cd/ m2=nit表8.2。辐射和光度数量和 
----------------------- Page 304-----------------------
单位。8.1.3比色法在8.1.1节中我们已经看到，我们对光的颜色的 
感知与光的SPD （光谱功率分布）密切相关。我们还看到这不是简 
单的一对一通信。图8.3中的底部和中间SPD完全不同，但被认为 
是完全相同的颜色。比色法处理光谱功率分布与颜色感知之间的关 
系。人类可以区分大约 1000万种不同的颜色。对于颜色感知，眼 
睛通过在视网膜中具有三种不同类型的视锥细胞受体起作用，每种 
类型的受体对不同波长的反应不同。其他动物有不同数量的颜色受 
体，在某些情况下多达十五[260]。因此，对于给定的SPD，我们的 
大脑只接收来自这些受体的三种不同信号。这就是为什么只有三个 
数字可用于精确表示任何颜色刺激的原因[1707]。但三个数字是什 
么？CIE （Commission Internationaled'Eclairage）提出了一套 
测量颜色的标准条件，并使用它们进行颜色匹配实验。在颜色匹配 
中，三个彩色灯投射在白色屏幕上，使它们的颜色加在一起形成一 
个补丁。要匹配的测试颜色预测在此修补程序旁边。测试色块具有 
单一波长。然后，观察者可以使用校准到加权[.1,1]范围的旋钮更改 
三个彩色灯光，直到测试颜色匹配为止。需要负重量来匹配某些测 
试颜色，并且这样的重量意味着相应的光被添加到波长的测试色块 
中。三个灯的一组测试结果，称为r，g和b，如图8.5所示。光几 
乎是单色的，每个光的能量分布狭窄地聚集在以下波长之一：r为 
645nm，g为526nm，b为444nm。将每组匹配权重与测试片波 
长相关联的函数称为颜色匹配函数。这些功能给出的是将光谱功率 
分布转换为三个值的方法。给定单一波长的光，可以从图形，旋钮 
----------------------- Page 305-----------------------
设置和创建的照明条件中读取三种颜色的灯光设置，这些设置将从 
屏幕上的两个光块产生相同的感觉。对于任意光谱分布，颜色匹配 
函数可以乘以分布，每条结果曲线下面积（即积分）给出相对量8.1。 
轻量化273图8.5。来自Stiles和 Burch的r，g和b2度颜色匹配 
曲线[1703]。这些颜色匹配曲线不应与颜色匹配实验中使用的光源 
的光谱分布混淆，后者是纯波长。设置彩色灯光以匹配光谱产生的 
感知颜色。相当不同的光谱分布可以解析为相同的三个权重，即他 
们对观察者看起来一样。给出匹配权重的谱分布称为 metamers。 
三个加权的r，g和b光不能直接表示所有可见颜色，因为它们的颜 
色匹配函数对于各种波长具有负权重。CIE提出了三种不同的假设 
光源，其色彩匹配功能对所有可见波长都是正的。这些曲线是原始 
r，g和b颜色匹配函数的线性组合。这要求光源的光谱功率分布在 
某些波长处为负，因此这些光是不可实现的数学抽象。它们的颜色 
匹配函数表示为x （λ），y （λ）和z （λ），如图8.6所示。颜色匹 
配函数y （λ）与光度曲线相同（图8.4），用此曲线将辐亮度转换 
为亮度。与前一组颜色匹配函数一样，x （λ），y （λ）和z （λ）用 
于通过乘法和积分将任何SPDs （λ）减少为三个数：X =Z780380 
s （λ）x （λ）dλ，Y =Z780380s （λ）y （λ）dλ，Z =Z780380 
s （λ）z （λ）dλ。（8.1）这些X，Y和Z三刺激值是在CIEXYZ 
空间中定义颜色的权重。将颜色分成亮度（亮度）和色度通常是方 
便的。色度是与其亮度无关的颜色特征。例如，尽管亮度不同，但 
两种蓝色，一种暗色和一种亮度可以具有相同的色度。2748.光和 
----------------------- Page 306-----------------------
颜色图8.6。Judd-Vos修改的CIE （1978）2度颜色匹配函数。请 
注意，两个x是同一曲线的一部分。以此目的，CIE通过将颜色投 
影到X +Y +Z =1平面上来定义二维色度空间。见图8.7。该空间 
中的坐标称为x和y，并且如下计算：x =XX +Y +Z，y =YX +Y 
+Z，z =ZX +Y +Z =1。X 。年。（8.2）z值不提供其他信息， 
因此通常省略。色度坐标x和y值的图表称为CIE1931色度图。见 
图8.8。图中的曲线轮廓显示可见光谱的颜色所在的位置，连接光谱 
末端的直线称为紫色线。黑点表示光源D65的色度，这是一种常用 
的白点 - 用于定义白色或无色 （无色）刺激的色度。总结一下，我 
们从一个实验开始，该实验使用了三个单波长光，并测量了每个需 
要多少光以匹配其他波长的光的外观。有时，为了匹配，必须将这 
些纯光添加到正在查看的样品中。这给出了一组颜色匹配函数，它 
们被组合起来创建一个没有负值的新集合。有了这个非负的颜色匹 
配函数集，我们可以将任何光谱分布转换为定义颜色的色度和亮度 
的XYZ坐标，可以将其简化为xy以仅描述色度，保持亮度恒定。 
8.1。轻量数275图8.7。CIE RGB原色的 RGB彩色立方体在XYZ 
空间中显示，其投影（紫色）显示在X +Y +Z =1平面上。蓝色 
轮廓包围可能的色度值的空间。从原点辐射的每条线具有恒定的色 
度值，仅在亮度上变化。图8.8。CIE 1931色度图。该曲线标有相 
应纯色的波长。白色三角形和黑点分别显示用于sRGB和 Rec的色 
域和白点。709色空间。2768.光线和颜色给定一个色点 （x，y）， 
从白点到该边界（光谱或紫色线）绘制一条线。色点与距区域边缘 
----------------------- Page 307-----------------------
的距离的相对距离是颜色的激发纯度。区域边缘上的点定义了主波 
长。图形中很少遇到这些比色术语。代替，我们使用饱和度和色调， 
它们分别与激发纯度和主波长松散地相关。在Stone[1706]和其他 
人[456,789,1934]的书中可以找到更精确的饱和度和色调定义。色 
度图描述了一个平面。完全描述颜色所需的第三个维度是Y值，亮 
度。然后定义所谓的xyY坐标系。色度图对于理解渲染中如何使用 
颜色以及渲染系统的限制非常重要。电视或计算机监视器通过使用 
R，G和 B颜色值的一些设置来呈现颜色。每个颜色通道控制显示 
器具有特定光谱功率分布的光。三种原色中的每一种都按其各自的 
颜色值进行缩放，并且这些被加在一起以产生观察者所感知的单个 
光谱功率分布。色度图中的三角形代表典型电视或计算机监视器的 
色域。三角形的三个角是原色，它是屏幕可以显示的最饱和的红色， 
绿色和蓝色。色度图的一个重要特性是这些限制颜色可以用直线连 
接，以显示整个显示系统的极限。直线表示通过混合这三种原色可 
以显示的颜色限制。白点表示当R，G和 B颜色值彼此相等时由显 
示系统产生的色度。值得注意的是，显示系统的全部色域是三维体 
积。色度图仅显示该体积在二维平面上的投影。有关更多信息，请 
参阅Stone的书[1706]。渲染中有几个感兴趣的RGB空间，每个 
空间由 R，G和 B原色和白点定义。为了比较它们，我们将使用不 
同类型的色度图，称为CIE1976UCS （均匀色度标度）图。该图是 
CIELUV颜色空间的一部分，CIEUV颜色空间由CIE （以及另一个颜 
色空间CIELAB）采用，旨在为XYZ空间提供更多感知上统一的替 
----------------------- Page 308-----------------------
代方案[1707]。在CIEXYZ空间中，相同量的明显不同的颜色对可 
以在距离上最多不同20倍。CIELUV对此进行了改进，使比率最多 
降低四倍。为了比较RGB空间的色域，这种增加的感知均匀性使 
1976年的图表比 1931年更好。对感知统一色彩空间的持续研究最 
近导致了 ICTCP[364]和Jzazbz [1527]空间。这些色彩空间在感知 
上比CIELUV更均匀，特别是对于现代显示器典型的高亮度和饱和 
色彩。然而，基于这些色彩空间的色度图尚未被广泛采用，因此我 
们在本章中使用CIE1976UCS图，例如图8.9的情况。8.1。光量 
277sRGBACEScg DCI-P3图8.9。CIE 1976UCS图显示了三个 
RGB色彩空间的原色和白点：sRGB，DCI-P3和ACEScg。sRGB 
图可用于Rec。709也是如此，因为两个颜色空间具有相同的原色 
和白点。在图8.9所示的三个 RGB空间中，sRGB是迄今为止在实 
时渲染中最常用的。重要的是要注意，在本节中，我们使用 “sRGB 
颜色空间”来指代具有sRGB原色和白点的线性颜色空间，而不是 
第 5.6节中讨论的非线性sRGB颜色编码。大多数计算机显示器是 
为sRGB色彩空间设计的，相同的原色和白点适用于 Rec。709色 
空间，用于高清电视显示器，因此对游戏机很重要。但是，更多的 
显示器正在使用更宽的色域。用于照片编辑的一些计算机监视器使 
用Adobe 1998颜色空间 （未示出）。最初为故事片制作而开发的 
DCI-P3色彩空间正在被广泛使用。Apple已经在从iPhone到Mac 
的产品线中采用了这种色彩空间，其他制造商也纷纷效仿。虽然超 
高清（UHD）内容和显示器被指定使用极宽色域Rec。2020色彩 
----------------------- Page 309-----------------------
空间，在许多情况下，DCI-P3也被用作UHD的事实上的色彩空间。 
建议 2020未显示在278中8.光和颜色图8.9，但其色域非常接近 
图中的第三个色彩空间ACEScg。ACEScg色彩空间由美国电影艺 
术与科学学院 （AMPAS）开发，用于电影计算机图形渲染。它不是 
用作显示颜色空间，而是用作渲染的工作色彩空间，在渲染后将颜 
色转换为适当的显示颜色空间。虽然目前sRGB色彩空间在实时渲 
染中无处不在，但使用更宽的色彩空间可能会增加。最直接的好处 
是针对宽色域显示器的应用[672]，但即使是针对sRGB或 Rec的应 
用也有优势。709显示。当在不同的颜色空间中执行时，诸如乘法 
的常规渲染操作给出不同的结果[672,1117]，并且有证据表明在 
DCI-P3或ACEScg空间中执行这些操作比在线性sRGB空间中执行 
它们产生更准确的结果[660] ，975,1118]。从 RGB空间到XYZ空 
间的转换是线性的，并且可以使用从 RGB空间的原色和白点导出的 
矩阵来完成[1048]。通过矩阵求逆和级联，可以导出矩阵以从XYZ 
转换到任何 RGB空间，或者在两个不同的 RGB空间之间转换。注 
意，在这种转换之后，RGB值可以是负值或大于 1。这些是超出色 
域的颜色，即在目标RGB空间中不可再现。可以使用各种方法将这 
些颜色映射到目标RGB色域[785,1241]。一种常用的转换是将RGB 
颜色转换为灰度亮度值。由于亮度与Y系数相同，因此该操作仅是 
RGB到XYZ转换的 “Y部分”。换句话说，它是RGB系数和 RGB 
到XYZ矩阵的中间行之间的点积。在sRGB和 Rec的情况下。在 
709个空间中，等式为[1704]Y =0.2126R +0.7152G +0.0722B。 
----------------------- Page 310-----------------------
 （8。3）这再次使我们看到光度曲线，如第271页的图8.4所示。 
该曲线表示标准观察者的眼睛如何响应各种波长的光，乘以三原色 
的光谱功率分布，并得到每个曲线。曲线是整合的。得到的三个权 
重是上述亮度方程的形式。灰度强度值不等于红色，绿色和蓝色的 
原因是因为眼睛对各种波长的光具有不同的灵敏度。比色法可以告 
诉我们两种颜色刺激是否匹配，但它无法预测它们的外观。给定XYZ 
颜色刺激的出现在很大程度上取决于诸如照明，周围颜色和先前条 
件等因素。诸如CIECAM02的颜色外观模型（CAM）试图处理这 
些问题并预测最终的颜色外观[456]。颜色外观建模是更广泛的视觉 
感知领域的一部分，其中包括诸如掩蔽之类的效果[468]。这是放置 
在物体上的高频率，高对比度图案倾向于隐藏瑕疵的地方。换句话 
说，纹理如8.1。LightPersities279波斯地毯将有助于掩盖色带和 
其他阴影瑕疵，这意味着需要为这些表面消耗更少的渲染工作。 
8.1.4使用RGB颜色渲染严格地说，RGB值表示感知而不是物理量。 
使用它们进行基于物理的渲染在技术上是一个类别错误。正确的方 
法是对光谱量执行所有渲染计算，通过密集采样或投影到合适的基 
础上表示，并且仅在最后转换为RGB颜色。例如，最常见的渲染操 
作之一是计算从对象反射的光。物体表面通常比其他波长更能反射 
某些波长的光，如光谱反射率曲线所述。计算反射光颜色的严格正 
确方法是将入射光的SPD乘以每个波长的光谱反射率，得到反射光 
的SPD，然后将其转换为 RGB颜色。相反，在 RGB渲染器中，灯 
光和曲面的 RGB颜色相乘，以给出反射光的 RGB颜色。在一般情 
----------------------- Page 311-----------------------
况下，这不会给出正确的结果。为了显示，我们将看一个极端的例 
子，如图8.10所示。图8.10。顶部曲线显示了设计用于投影屏幕 
的材料的光谱反射率。下面的两个图显示了具有相同RGB颜色的两 
个光源的光谱功率分布：中间曲线中的RGB激光投影仪和底部曲线 
中的D65标准光源。屏幕材料将反射来自激光投影仪的大约80％ 
的光，因为它具有与投影仪原色对齐的反射峰。然而，它将反射不 
到20％的D65光源光，因为大部分光源的能量超出了屏幕的反射 
峰值。此场景的RGB渲染将预测屏幕将反射两种灯光的相同强度。 
2808光和色光谱反射率图8.11。黄色香蕉的光谱反射率[544]。我 
们的示例显示了设计用于激光投影仪的屏幕材料。它在与激光投影 
仪波长匹配的窄带中具有高反射率，对于大多数其他波长具有低反 
射率。这使其反射来自投影仪的大部分光线，但吸收来自其他光源 
的大部分光线。在这种情况下，RGB渲染器将产生严重错误。但是， 
图8.10所示的情况远非典型。在实践中遇到的表面的光谱反射率曲 
线更平滑，如图8.11中所示。典型的光源SPD类似于 D65光源， 
而不是示例中的激光投影仪。当光源SPD和表面光谱反射率都很平 
滑时，RGB渲染引入的错误相对微妙。在预测渲染应用程序中，这 
些微妙的错误可能很重要。例如，两个光谱反射率曲线在一个光源 
下可以具有相同的颜色外观，而不是另一个光源。例如，在绘制修 
复的车身部件时，这个问题称为同色异谱失效或光源同色异谱，是 
一个严重的问题。在尝试预测此类效果的应用程序中，RGB渲染不 
合适。然而，对于大多数渲染系统，特别是那些不用于生成预测模 
----------------------- Page 312-----------------------
拟的交互式应用系统，RGB渲染的效果非常好[169]。即使是特征电 
影离线渲染最近才开始采用光谱渲染，但它还远未普及[660,1610]。 
本节仅涉及颜色科学的基础知识，主要是为了让人们了解光谱与颜 
色三元组的关系，并讨论器件的局限性。相关主题，将渲染场景颜 
色转换为显示值，将在下一节中讨论。8.2。场景到屏幕2818.2场 
景到屏幕本书接下来的几章主要关注基于物理的渲染问题。给定虚 
拟场景，基于物理的渲染的目标是计算场景中存在的辐射，如果它 
是真实的。然而，在那时，工作还远未完成。仍需要确定显示器帧 
缓冲区中的最终结果像素值。在本节中，我们将介绍此确定中涉及 
的一些注意事项。8.2。1高​ ​ 动态范围显示编码本节中的内容基 
于第5.6节，其中包含显示编码。我们决定将高动态范围（HDR） 
显示的覆盖推迟到本节，因为它需要有关主题的背景知识，例如色 
域，这在本书的那一部分尚未讨论过。第 5.6节讨论了标准动态范 
围（SDR）监视器的显示编码，SDR监视器通常使用sRGB显示标 
准，SDR电视使用Rec。709和 Rec。1886年的标准。两组标准 
具有相同的 RGB色域和白点（D65），以及有些相似（但不相同） 
的非线性显示编码曲线。它们也具有大致相似的参考白色亮度水平 
 （对于sRGB为80cd/ m2，对于Rec.709/ 1886为 100cd/ m 
2）。监视器和电视制造商并未密切关注这些亮度规格，他们实际上 
倾向于制造具有更亮白色水平的显示器[1081]。HDR显示使用Rec。 
2020和 Rec。2100标准。建议 2020定义了一个具有明显更宽色 
域的色彩空间，如图8.12所示，以及与 Rec相同的白点（D65）。 
----------------------- Page 313-----------------------
709和sRGB颜色空间。建议 2100定义了两种非线性显示编码： 
感知量化器 （PQ）[1213]和混合log-gamma （HLG）。HLG编码 
在渲染情况下使用不多，因此我们将重点关注PQ，其定义了 10,000 
cd/ m2的峰值亮度值。虽然峰值亮度和色域规格对于编码目的很 
重要，但就实际显示而言，它们有点令人向往。在撰写本文时，少 
数消费级 HDR显示器的峰值亮度水平甚至超过 1500cd/ m2。在 
实践中，显示色域比 DCI-P3 （也如图8.12所示）更接近 Rec。因 
此，HDR显示器执行从标准规格到实际显示功能的内部色调和色域 
映射。该映射可以受到应用程序传递的元数据的影响，以指示内容 
的实际动态范围和色域[672,1082]。从应用程序方面来看，有三条 
路径可以将图像传输到 HDR显示器，但根据显示和操作系统的不 
同，并非所有三种路径都可用：1。HDR10-HDR显示器以及 PC 
和控制台操作系统广泛支持。帧缓冲格式为每像素32位，每个RGB 
通道有 10个无符号整数位，alpha为2。它使用PQ非线性编码282 
8.光和颜色sRGBRec。2020DCI-P3D65图8.12。CIE1976UCS 
图显示Rec的色域和白点（D65）。2020年和sRGB/ Rec。709 
色空间。还显示了 DCI-P3色彩空间的色域用于比较。和 Rec。2020 
色彩空间。每个 HDR10显示模型都执行自己的色调映射，一个未 
标准化或记录的色调映射。2.scRGB （线性变体）-Windows操 
作系统仅支持。名义上它使用sRGB原色和白色级别，但两者都可 
以超过，因为标准支持小于0且大于 1的RGB值。帧缓冲格式为每 
通道 16位，并存储线性 RGB值。它可以与任何 HDR10显示器一 
----------------------- Page 314-----------------------
起使用，因为驱动程序会转换为HDR10。它主要用于方便和向后兼 
容sRGB。3.杜比视界专有格式，在显示器或任何控制台上尚未得到 
广泛支持 （在撰写本文时）。它使用自定义12位每通道帧缓冲​ ​ 
格式，并使用 PQ非线性编码和Rec。2020色彩空间。显示内部色 
调映射在各个模型中标准化（但未记录）。8.2。场景到屏幕283 
Lottes[1083]指出实际上有第四个选项。如果仔细调整曝光和颜色， 
则可以通过常规 SDR信号路径驱动 HDR显示，效果良好。除了 
scRGB之外的任何选项，作为显示编码步骤的一部分，应用程序需 
要将像素 RGB值从渲染工作空间转换为 Rec。2020年 - 需要3× 
3矩阵变换 - 并应用 PQ编码，这比 Rec更昂贵。709或sRGB编 
码函数[497]。Patry [1360]给出了 PQ曲线的廉价近似。在HDR 
显示器上合成用户界面（UI）元素时需要特别小心，以确保用户界 
面清晰且处于舒适的亮度级别[672]。8.2.2色调映射在5.6和8.2.1 
节中，我们讨论了显示编码，即将线性辐亮度值转换为显示硬件的 
非线性代码值的过程。显示编码应用的功能与显示器的电光传输功 
能 （EOTF）相反，这可确保输入线性值与显示器发出的线性辐亮度 
相匹配。我们之前的讨论掩盖了渲染和显示编码之间发生的重要步 
骤，我们现在准备探索这一步骤。色调映射或色调再现是将场景辐 
射值转换为显示辐射值的过程。在此步骤中应用的变换称为端到端 
传递函数或场景到屏幕变换。图像状态的概念是理解色调映射的关 
键[1602]。有两种基本的图像状态。参考场景辐射值来定义场景参 
考图像，并且参考显示辐射值来定义显示参考图像。图像状态与编 
----------------------- Page 315-----------------------
码无关。任一状态的图像可以线性或非线性地编码。图8。图13示 
出了图像状态，色调映射和显示编码如何在成像流水线中配合在一 
起，其处理从初始渲染到最终显示的颜色值。场景参考显示 - 参考 
渲染线性场景辐射色调映射线性显示辐射显示编码 （反 EOTF）显示 
非线性显示代码线性显示辐亮度 （EOTF）图8.13。合成 （渲染）图 
像的成像管道。我们渲染线性场景参考辐射值，色调映射转换为线 
性显示参考值。显示编码应用反 EOTF将线性显示值转换为非线性 
编码值 （代码），这些值将传递给显示器。最后，显示硬件应用EOTF 
将非线性显示值转换为从屏幕发射到眼睛的线性辐射。2848.光和 
颜色图8.14。图像再现的目的是确保由再现 （右）引起的感知印象 
尽可能接近原始场景（左）的感知印象。关于色调映射的目标存在 
几种常见的误解。不是确保场景到屏幕变换是身份变换，在显示器 
处完美地再现场景辐射值。它也不是将来自场景的高动态范围的每 
一点信息 “挤压”到显示器的较低动态范围，尽管考虑场景和显示 
器动态范围之间的差异确实起着重要作用。为了理解色调映射的目 
标，最好将其视为图像再现的一个例子[757]。图像再现的目标是创 
建显示提供的图像，该图像在给定显示特性和观看条件的情况下尽 
可能接近地再现 - 观看者在观察原始场景时将具有的感知印象。见 
图8.14。存在一种具有略微不同目标的图像再现。优选的图像再现 
旨在创建在某种意义上比原始场景看起来更好的显示器参考图像。 
优选的图像再现将在后面的8.2.3节中讨论。考虑到典型场景中的 
亮度范围超过8.2，将原始场景再现类似的感知印象的目标是具有挑 
----------------------- Page 316-----------------------
战性的。场景到屏幕285显示功能几个数量级。场景中至少一些颜 
色的饱和度（纯度）也可能远远超过显示能力。然而，摄影，电视 
和电影确实设法产生令人信服的原始场景的感知形象，文艺复兴时 
期的画家也是如此。通过利用人类视觉系统的某些属性，可以实现 
这一成就。视觉系统补偿绝对亮度的差异，称为适应的能力。由于 
这种能力，尽管再现的亮度小于原始的 1％，但是在昏暗房间中的 
屏幕上显示的室外场景的再现可以产生与原始场景类似的感知。但 
是，适应所提供的补偿是不完善的。在较低的亮度水平下，感知对 
比度降低（史蒂文斯效应），就像感知到的 “色彩” （亨特效应） 
一样。其他因素影响复制的实际或感知对比度。显示器的环绕（显 
示矩形外的亮度级别，例如室内照明的亮度）可以增加或减少感知 
对比度（Bartleson-Breneman效果）。显示闪光是通过显示缺陷 
或屏幕反射添加到显示图像的不需要的光，通常在相当程度上降低 
了图像的实际对比度。这些效果意味着如果我们想要保持与原始场 
景类似的感知效果，我们必须提高显示器参考图像值的对比度和饱 
和度[1418]。然而，这种对比度的增加加剧了现有问题。由于场景 
的动态范围通常比显示器的动态范围大得多，我们必须选择一个较 
窄的亮度值窗口来重现，该窗口上方和下方的值被剪切为黑色或白 
色。提升对比度进一步缩小了这个窗口。为了部分抵消暗和亮值的 
剪切，使用软滚动来带回一些阴影和高光细节。所有这些都产生了 
S形 （S形）色调 - 再现曲线，类似于光化学膜[1418]提供的曲线。 
这不是偶然的。柯达和其他公司的研究人员仔细调整了光化学薄膜 
----------------------- Page 317-----------------------
乳液的性质，以产生有效和令人愉悦的图像再现。由于这些原因， 
形容词 “电影”经常出现在色调映射的讨论中。曝光的概念对于色 
调映射至关重要。在摄影中，曝光是指控制落在胶片或传感器上的 
光量。然而，在渲染中，曝光是在应用色调再现变换之前对场景参 
考图像执行的线性缩放操作。暴露的棘手方面是确定要应用的缩放 
因子。色调再现变换和曝光紧密结合在一起。通常设计色调变换， 
期望它们将应用于以某种方式曝光的场景参考图像。通过曝光缩放 
然后应用色调再现变换的过程是一种全局色调映射，其中相同的映 
射应用于所有像素。相反，局部色调映射过程基于周围像素和其他 
因素使用不同的像素到像素的映射。实时应用程序几乎是ex2868. 
Light和Color集中使用全局色调映射（有一些例外[1921]），因 
此我们将专注于这种类型，讨论第一次色调再现变换然后曝光。重 
要的是要记住，场景参考图像和显示参考图像是根本不同的。物理 
操作仅在对场景引用的数据执行时有效。由于显示限制和我们讨论 
过的各种感知效果，在两个图像状态之间总是需要非线性变换。色 
调再现变换色调再现变换通常表示为将场景参考输入值映射到显示 
参考输出值的一维曲线。这些曲线可以独立地应用于 R，G和 B值 
或亮度。在前一种情况下，结果将自动显示在显示色域中，因为每 
个显示器提供的 RGB通道值将介于0和 1之间。但是，在 RGB通 
道上执行非线性操作（尤其是削波）可能会导致饱和度和色调发生 
偏移，除了理想的亮度变化之外。Giorgianni和 Madden[537]指 
出饱和度的变化可能在感知上是有益的。大多数再现变换用来抵消 
----------------------- Page 318-----------------------
史蒂文斯效应（以及环绕和观看眩光效果）的对比度增强将导致饱 
和度的相应提升，这也将抵消亨特效应。然而，色调偏移通常被认 
为是不合需要的，并且现代色调变换试图通过在色调曲线之后应用 
额外的 RGB调整来减少它们。通过将色调曲线应用于亮度，可以避 
免（或至少减少）色调和饱和度偏移。但是，显示器引用的颜色可 
能超出了显示器的RGB色域，在这种情况下，它需要重新映射。色 
调映射的一个潜在问题是将非线性函数应用于场景引用的像素颜色 
会导致问题使用一些抗锯齿技术。第 5.4.2节讨论了问题（以及解 
决它的方法）。莱因哈德色调再现算子[1478]是在实时渲染中使用 
的较早的色调变换之一。它使较暗的值大部分保持不变，而较亮的 
值渐近地变为白色。Drago等人提出了一种类似的色调映射算子。 
[375]能够调整输出显示亮度，这可能使其更适合HDR显示。Duiker 
创建了柯达电影响应曲线[391,392]的近似值，用于视频游戏。此曲 
线稍后由 Hable [628]修改以添加更多用户控制，并用于游戏 
Uncharted2.Hable在此曲线上的演示具有影响力，导致在几个游 
戏中使用 “Hable电影曲线”。Hable[634]后来提出了一条新曲线， 
与之前的工作相比具有许多优点。Day[330]呈现出一种S形曲线曲 
线，用于 InsomniacGames的游戏，以及游戏 “使命召唤：高级 
战争”。Gotanda [571,572]创造了色调变换，模拟电影和数码相 
机传感器的响应。这些用于游戏StarOcean4和其他游戏。Lottes 
[1081]指出显示闪光对显示器有效动态范围的影响是8.2。场景到屏 
幕287显着且高度依赖于室内照明条件。因此，为色调映射提供用 
----------------------- Page 319-----------------------
户调整很重要。他提出了一种色调再现变换，支持这种调整，可以 
与SDR以及HDR显示器一起使用。学院色彩编码系统 （ACES）由 
美国电影艺术与科学学院科学技术委员会创建，作为管理电影和电 
视行业色彩的标准。ACES系统将场景到屏幕转换分为两部分。第 
一个是参考渲染变换（RRT），它将场景参考值转换为标准的，设 
备中立的输出空间中的显示参考值，称为输出颜色编码规范 
 （OCES）。第二部分是输出设备变换 （ODT），它将颜色值从OCES 
转换为最终显示编码。有许多不同的ODT，每个ODT都是针对特 
定的显示设备和观看条件而设计的。RRT和适当的ODT的串联创建 
了整体变换。这种模块化结构便于处理各种显示类型和观看条件。 
Hart[672]建议对需要支持SDR和 HDR显示的应用进行ACES色 
调映射变换。尽管ACES设计用于电影和电视，但其变形在实时应 
用中的应用越来越多。默认情况下，在虚幻引擎[1802]中启用ACES 
色调映射，Unity引擎也支持它[1801]。Narkowicz给出了符合SDR 
和 HDRODT的ACES RRT的廉价曲线[1260,1261]，Patry[1359] 
也是如此。Hart[672]提出了ACESODT的参数化版本，以支持一 
系列设备。使用 HDR显示的色调映射需要一些小心，因为显示器也 
将应用他们自己的一些色调映射。Fry [497]呈现了Frostbite游戏 
引擎中使用的一组色调映射变换。它们为SDR显示器应用相对激进 
的色调再现曲线，对于使用HDR10信号路径的显示器（具有基于 
显示器的峰值亮度的一些变化）而言不太激进，并且使用杜比视觉 
路径的显示器没有色调映射（换句话说，它们依赖于显示器应用的 
----------------------- Page 320-----------------------
内置DolbyVision色调映射。Frostbite色调再现变换被设计为中 
性，没有明显的对比度或色调变化。目的是通过颜色分级应用任何 
所需的对比度或色调修改（第8.2.3节）。为此，色调再现变换应 
用于ICTCP色彩空间[364]，它是为色度和亮度轴之间的感知均匀性 
和正交性而设计的。霜冻变换对亮度进行色调映射，并随着亮度滚 
动显示白色而逐渐降低色度。这提供了一个没有色调变化的干净变 
换。具有讽刺意味的是，由于资产（例如火焰效果）被用于利用其 
先前变换中的色调变化，Frostbite团队最终修改了变换，使用户能 
够将某种程度的色调变换重新引入显示 - 参考颜色。图8.15显示 
了Frostbite变换与本节中提到的其他几个变换的比较。2888.光和 
颜色图8.15。应用了四种不同色调变换的场景。差异主要见于圆圈 
区域，其中场景像素值特别高。左上：剪辑 （加上sRGBOETF）;右 
上：Reinhard[1478];左下：Duiker[392];右下：冻伤 （保持色调 
的版本）[497]。Reinhard，Duiker和 Frostbite转换了所有通过 
裁剪丢失的高光信息。然而，Reinhard曲线倾向于使图像的较暗部 
分去饱和[628,629]，而Duiker变换增加了较暗区域的饱和度，这 
有时被认为是理想的特征[630]。通过设计，Frostbite变换保留了 
饱和度和色调，避免了在其他三个图像的左下圆圈中可以看到的强 
烈的色调偏移。 （图片由c2018ElectronicArts Inc.提供））曝光 
用于计算曝光的常用技术系列依赖于分析场景参考的亮度值。为避 
免引入失速，通常通过对前一帧进行采样来完成此分析。遵循 
Reinhard等人的推荐。[1478]，在先前实现中使用的一个度量是对 
----------------------- Page 321-----------------------
数平均场景亮度。通常，通过计算帧[224,1674]的对数平均值来确 
定曝光。通过执行一系列下采样后处理过程来计算该对数平均值， 
直到计算出帧的最终单个值。使用平均值往往对异常值过于敏感， 
例如，少量明亮像素可能影响整个帧的曝光。随后的实现通过改为 
使用亮度值的直方图来改善该问题。直方图不是平均值，而是允许 
计算中值，这更加稳健。直方图中的附加数据点可用于改善结果。 
例如，在The Orange BoxbyValve 中，基于第95百分位和中位 
数的启发式方法用于确定暴露[1821]。Mittring描述了使用计算着 
色器来生成亮度直方图[1229]。8.2。场景到屏幕289到目前为止讨 
论的技术的问题是像素亮度是用于驱动曝光的错误度量。如果我们 
看一下摄影实践，例如AnselAdams的Zone System [10]以及如 
何使用入射光度计来设置曝光，很明显，最好单独使用照明（没有 
表面反照率的影响）来确定曝光[757]。这样做是有效的，因为在第 
一次近似中，摄影曝光用于抵消照明。这导致主要显示对象的表面 
颜色的印刷品，其对应于人类视觉系统的颜色恒定性属性。以这种 
方式处理曝光还可确保将正确的值传递给色调变换。例如，电影或 
电视行业中使用的大多数色调变换被设计为将曝光的场景参考值 
0.18映射到显示器参考值0.1，期望0.18代表主要场景照明中的 
18％灰卡[1418]。 ，1602]。虽然这种方法在实时应用中尚不常见， 
它开始看到使用。例如，游戏合金装备V：地面零点具有基于照明 
强度的曝光系统[921]。在许多游戏中，基于已知的场景照明值，为 
环境的不同部分手动设置静态曝光水平。这样做可以避免意外的曝 
----------------------- Page 322-----------------------
光动态变化。8.2.3颜色分级在8.2.2节中，我们提到了首选图像再 
现的概念，即产生在某种意义上比原始场景看起来更好的图像的想 
法。通常，这涉及对图像颜色的创造性操纵，这一过程称为颜色分 
级。数字色彩分级已经在电影行业中使用了一段时间。早期的例子 
包括电影 O Brother，Where Art Thou？（2000）和Am'elie 
 （2001）。通常通过交互式地操纵示例场景图像中的颜色来执行颜 
色分级，直到实现期望的创意 “外观”。然后，在镜头或序列中的 
所有图像上重新应用相同的操作序列。颜色分级从电影传播到游戏， 
现在广泛使用[392,424,756,856,1222]。Selan [1601]展示了如何 
从颜色分级或图像编辑应用程序 “烘焙”任意颜色变换到三维颜色 
查找表（LUT）。这些表格通过使用输入的R，G和 B值作为x，y 
和z坐标来应用，用于在表格中查找新颜色，因此可用于从输入到 
输出颜色的任何映射，直到 LUT分辨率的限制。Selan的烘焙过程 
首先采用身份LUT（将每种输入颜色映射到相同颜色的 LUT）并“切 
片”它以创建二维图像。然后将此切片的 LUT图像加载到颜色分级 
应用程序中，并将定义所需创意外观的操作应用于该应用程序。需 
要注意仅将颜色操作应用于 LUT，从而避免诸如模糊之类的空间操 
作。然后将编辑的 LUT保存出来， “打包”到三维GPU纹理中， 
并在渲染应用程序中用于将相同的颜色变换应用于渲染像素。 
Iwanicki[806]提出了一种在 LUT中存储颜色变换时使用最小二乘 
最小化来减少采样误差的巧妙方法。2908.光和颜色图8.16。游戏 
Uncharted4中的场景。顶部的屏幕截图没有颜色分级。其他两个 
----------------------- Page 323-----------------------
屏幕截图均应用了颜色分级操作。为了说明的目的，选择极端的颜 
色分级操作（乘以高度饱和的青色）。在左下方的屏幕截图中，颜 
色分级应用于显示器引用（后色调映射）图像，并且在右下方屏幕 
截图中，将其应用于场景引用 （预色调映射）图像。（UNCHARTED 
4AThief'sEndc/TM2016SIE。由NaughtyDogLLC创建和开 
发。）在后来的出版物中，Selan [1602]区分了两种进行颜色分级 
的方法。在一种方法中，对显示参考图像数据执行颜色分级。另一 
方面，对通过显示变换预览的场景参考数据执行颜色分级操作。结 
果。当实时应用程序首次采用颜色分级时，显示参考方法占主导地 
位[756,856]。然而，由于其更高的视觉质量，现场引用的方法已经 
获得了关注[198,497,672]。见图8.16。将颜色分级应用于场景引用 
数据还提供了通过将色调映射曲线烘焙到分级LUT中来节省一些计 
算的机会[672]，如游戏 Uncharted4 [198]中所做的那样。在 LUT 
查找之前，必须将场景引用的数据重新映射到范围[0,1][1601]。在 
Frostbite引擎[497]中，感知量化器OETF用于此目的，尽管可以 
使用更简单的曲线。Duiker [392]使用对数曲线，而 Hable [635] 
建议使用应用一次或两次的平方根运算符。Hable[635]概述了常见 
的颜色分级操作和实现注意事项。8.2。场景到屏幕291进一步阅读 
和资源对于色度和色彩科学，“圣经”是Wyszecki和Stiles[1934] 
的 “颜色科学”。其他良好的色度参考包括 Hunt测量颜色[789]和 
Fairchild的颜色外观模型[456]。Selan的白皮书[1602]给出了图像 
再现和 “场景到屏幕”问题的良好概述。想要更多地了解这个主题 
----------------------- Page 324-----------------------
的读者会发现 Hunt [788]的再现色彩和Giorgianni和 Madden 
[537]的数字色彩管理是很好的参考。安塞尔·亚当斯摄影系列 
[9,10,11]中的三本书，尤其是 “否定”，了解电影摄影的艺术和科 
学如何影响图像再现的理论和实践到今天。最后，Reinhard和其他 
人[1480]出版的 “彩色成像：基础和应用”一书对整个研究领域进 
行了全面的概述。第9章基于物理的阴影 “让物体的形状成为它的 
样子，光，阴影和透视将永远使它美丽。” - 约翰·康斯特布尔在本 
章中，我们将介绍基于物理的阴影的各个方面。我们首先介绍9.1 
节中光物质相互作用的物理特性，然后在9.2到9.4节中，我们将 
展示这些物理如何连接到着色过程。第9.5至9.7节专门用于构建 
基于物理的着色模型的构建块，第9.8至9.12节讨论了涵盖各种材 
料类型的模型本身。最后，在9.13节中，我们描述了材料如何混合 
在一起，并且我们介绍了避免混叠和保持表面外观的过滤方法。9.1 
光的物理学光与物质的相互作用构成了基于物理的阴影的基础。要 
理解这些相互作用，有助于对光的本质有一个基本的了解。在物理 
光学中，光被建模为电磁横波，即垂直于其传播方向振荡电场和磁 
场的波。两个场的振荡是耦合的。磁场和电场矢量彼此垂直，并且 
它们的长度比是固定的。该比率等于相速度，我们将在后面讨论。 
在图9.1中，我们看到一个简单的光波。事实上，它是最简单的 - 一 
个完美的正弦函数。该波具有单个波长，用希腊字母λ （λ）表示。 
正如我们在8.1节中看到的那样，光的感知颜色与其波长密切相关。 
由于这个原因，单波长的光被称为单色光，这意味着 “单色”。然 
----------------------- Page 325-----------------------
而，实际中遇到的大多数光波是多色的，包含许多不同的波长。图 
9.1中的光波在另一方面非常简单。它是线性极化的。这意味着对于 
空间中的固定点，电场和磁场 293 2949.基于物理的阴影电磁图 
9.1。光，电磁横波。电场和磁场矢量以90°彼此和传播方向振荡。 
图中所示的波是最简单的光波。它既是单色的 （具有单一波长λ）又 
是线性极化的（电场和磁场各自沿单线振荡）。每一个都沿着一条 
线来回移动。相比之下，在本书中，我们关注的是非偏振光，这种 
光非常普遍。在非偏振光中，场振荡在垂直于传播轴的所有方向上 
均匀地扩展。尽管它们简单，但理解单色线性极化波的行为是有用 
的，因为任何光波都可以被分解成这种波的组合。如果我们使用给 
定相位跟踪波浪上的点（例如，随着时间的推移，我们将看到它以 
恒定的速度在空间中移动，这是波的相速度。对于穿过真空的光波， 
相速度c，通常称为光速，大约每秒300,000千米。在8.1.1节中， 
我们讨论了这样一个事实，即对于可见光，单个波长的大小在大约 
400-700纳米的范围内。为了给这个长度一些直觉，它大约是单根 
蜘蛛丝线宽度的一半到三分之一，它本身不到人类头发宽度的五十 
分之一。见图9.2。在光学中，谈论相对于光波长的特征的尺寸通常 
是有用的。在这种情况下，我们可以说蜘蛛丝线的宽度约为2λ-3λ 
 （2-3个光波长），并且头发的宽度约为 100λ-200λ。光波携带能 
量。能量流的密度等于电场和磁场的大小的乘积，这是因为大小彼 
此成比例 - 与电场的平方大小成比例。我们专注于电场，因为它比 
磁场更强烈地影响物质。在渲染中，我们关注的是随时间的平均能 
----------------------- Page 326-----------------------
量流量，其与平方波幅度成比例。该平均能量流密度是辐照度，用 
字母E表示。辐照度及其与其他光量的关系在8.1.1节中讨论。9.1。 
物理学295图9.2。左侧可见光波长相对于单根蜘蛛丝展示，宽度 
略超过1微米。在右侧，类似的蜘蛛丝线显示在人类头发旁边，以 
提供一些额外的背景。（图片由 URnano/罗切斯特大学提供。） 
光波线性组合。总波是分量波的总和。然而，由于辐照度与幅度的 
平方成正比，这似乎会导致矛盾。例如，将两个相等的波相加不会 
导致辐照度的 “1+1=4”情况？由于辐照度测量能量流量，这是 
否会违反能量守恒？这两个问题的答案分别是 “有时”和 “不”。 
为了说明，我们将看一个简单的例子：增加n个单色波，相位相同。 
n个波中的每一个的振幅是a。如前面提到的，每个波的辐照度E1 
与a2成比例，换句话说，对于某个常数k，E1=ka2。图9.3显示 
了此案例的三个示例场景。在左边，波浪都以相同的相位排列并相 
互加强。组合波辐照度如图9.3所示。将具有相同频率，极化和振 
幅的n个单色波加在一起的三种情况。从左到右：建设性干扰，破 
坏性干扰和非相干加法。在每种情况下，组合波（底部）的幅度和 
辐照度相对于n个原始波（顶部）示出。2969.基于物理的着色图 
9.4。单色波从两个点传播出来，频率相同。波在不同的空间区域中 
建设性地和破坏性地干涉。单波的n2倍，是单个波的辐照度值之和 
的n倍。这种情况称为建设性干扰。在图的中心，每对波都处于反 
相，相互抵消。组合波具有零振幅和零辐照度。这种情况是破坏性 
干扰。建设性和破坏性干扰是相干相加的两种特殊情况，其中波的 
----------------------- Page 327-----------------------
波峰和波谷以一致的方式排列。取决于相对相位关系，n个相同波 
的相干相加可以导致具有辐射的波在0到 n2倍于单个波的波长之 
间。然而，大多数情况下，当波加起来时，它们是相互不相干的， 
这意味着它们的相位是相对随机的。这在图9.3的右侧说明。在这 
种情况下，组合波的振幅是√na，并且单个波的辐照度线性地加到 
一个波的辐照度的n倍，正如人们所期望的那样。似乎破坏性和建 
设性干扰违反了能量守恒。但是图9.3没有显示完整的图片 - 它只 
显示了一个位置的波浪交互。当波在空间中传播时，它们之间的相 
位关系从一个位置变为另一个位置，如图9.4所示。在一些位置， 
波构造性地干涉，并且组合波的辐照度大于各个波的辐照度值之和。 
在其他地方，他们破坏性地干涉，使组合辐照度小于各个波辐照度 
值的总和。这并不违反能量守恒定律，因为通过相长干涉获得的能 
量和通过破坏性干扰损失的能量总是被抵消。当物体中的电荷振荡 
时发射光波。引起振荡的部分能量 - 热量，电能，化学能 - 被转 
换成光能，光能从物体辐射出去。在渲染中，这些对象被视为光源。 
我们在第5.2节中首先讨论了光源，它们将在第10章中从更基于物 
理的角度进行描述。光波发射后，它们会穿过太空，直到它们遇到 
一些与之相互作用的物质。9.1的核心现象。物理光297大多数光 
物质相互作用很简单，与上面讨论的发射情况非常相似。振荡电场 
推动和拉动物质中的电荷，使它们依次振荡。振荡电荷发射新的光 
波，其将入射光波的一些能量重定向到新的方向。这种称为散射的 
反应是各种光学现象的基础。散射光波具有与原始波相同的频率。 
----------------------- Page 328-----------------------
当通常情况下，原始波包含多个光频率时，每个光分别与物质相互 
作用。一个频率的入射光能量不会影响不同频率的发射光能，除了 
特定的和相对罕见的情况，如荧光和磷光，我们将不在本书中描述。 
分离的分子在所有方向上散射光，强度有一些方向性变化。更多的 
光在靠近原始传播轴的方向上向前和向后散射。分子作为散射体的 
有效性 - 其附近的光波将完全散射的可能性 - 随波长而变化很 
大。与长波长光相比，短波长光更有效地散射。在渲染中，我们关 
注许多分子的集合。与这种聚集体的光相互作用不一定类似于与分 
离的分子的相互作用。从附近分子散射的波通常是相互连贯的，因 
此表现出干扰，因为它们来自同一入射波。本节的其余部分专门讨 
论了几种重要的多分子光散射特殊情况。9.1.1颗粒在理想气体中， 
分子不会相互影响，因此它们的相对位置是完全随机且不相关的。 
虽然这是一种抽象，但对于正常大气压下的空气来说，它是一个相 
当不错的模型。在这种情况下，从不同分子散射的波之间的相位差 
是随机的并且不断变化。结果，散射波是不连贯的，它们的能量线 
性增加，如图9.3的右侧部分所示。换句话说，从n个分子散射的 
聚合光能是从单个分子散射的光的n倍。相反，如果分子紧密地堆 
积成远小于光波长的簇，则每个簇中的散射光波同相并且相长干涉。 
这导致散射波能量以二次方式相加，如图9.3左侧所示。因此，从 
一小组 n个分子散射的光的强度是从单个分子散射的光的 n2倍， 
这是相同数量的分子在理想气体中散射的光的n倍。这种关系意味 
着对于每立方米固定密度的分子，将分子聚集成簇将显着增加散射 
----------------------- Page 329-----------------------
光的强度。使簇更大，同时仍保持整体分子2989.基于物理的阴影 
密度恒定，将进一步增加散射光强度，直到簇直径变得接近光波长。 
除此之外，簇尺寸的额外增加不会进一步增加散射光强度[469]。这 
个过程解释了为什么云和雾如此强烈地散射光。它们都是由凝结产 
生的，凝结是空气中水分子聚集成越来越大的团簇的过程。即使水 
分子的总密度不变，这也显着增加了光散射。第 14.4.2节讨论了云 
渲染。在讨论光散射时，术语粒子用于指分离的分子和多分子簇。 
由于直径小于波长的多分子粒子的散射是来自孤立分子的放大（通 
过相长干涉）形式的散射，因此它表现出相同的方向变化和波长依 
赖性。这种类型的散射在大气颗粒的情况下称为瑞利散射，在嵌入 
固体中的颗粒的情况下称为廷德尔散射。随着粒径增加超过波长， 
散射波在整个粒子上不再同相的事实改变了散射的特性。散射越来 
越有利于向前方向，并且波长依赖性降低，直到所有可见波长的光 
均匀地散射。这种类型的散射称为米氏散射。瑞利和米氏散射在第 
14.1节中有更详细的介绍。9.1.2介质另一个重要的例子是光通过 
均匀介质传播，均匀介质是一个填充均匀间隔的相同分子的体积。 
分子间距不必完全规则，就像在晶体中一样。如果液体和非结晶固 
体的组成是纯的（所有分子都相同）并且它们没有间隙或气泡，则 
它们可以是光学均匀的。在均匀介质中，散射波被排列成使得它们 
在除了原始传播方向之外的所有方向上破坏性地干涉。在将原始波 
与从各个分子散射的所有波组合之后，最终结果与原始波相同，除 
了其相速度和 （在某些情况下）幅度。最终波没有表现出任何散射 - 
----------------------- Page 330-----------------------
它已经被破坏性干扰有效地抑制了。原始波和新波的相速度的比率 
定义了称为折射率（IOR）或折射率的介质的光学性质，由字母n 
表示。有些媒体是吸收性的。它们将部分光能转换为热能，导致波 
幅随距离呈指数减小。降低速率由衰减指数定义，用希腊字母κ 
 （kappa）表示。n和κ通常都随波长而变化。这两个数字一起完全 
定义了介质如何影响给定波长的光，并且它们通常组合成单个复数 
n +iκ，称为复合折射率。9.1。物理学299图9.5。四个小容器的 
液体具有不同的吸收性能。从左到右：清水，红石榴糖浆，茶和咖 
啡。折射率抽象出光相互作用的分子水平细节，并使得能够将介质 
作为连续体积处理，这更加简单。虽然光的相速不直接影响外观， 
但速度的变化确实如此，我们将在后面解释。另一方面，光吸收对 
视觉效果有直接影响，因为它会降低光的强度，并且（如果波长变 
化）也会改变其颜色。图9.5显示了一些光吸收的例子。非均匀介 
质通常可以被建模为具有嵌入散射粒子的均匀介质。抑制均匀介质 
中散射的破坏性干涉是由分子的均匀排列引起的，因此也是由它们 
产生的散射波引起的。分子分布的任何局部变化都将破坏这种破坏 
性干涉模式，允许散射光波传播。这种局部变化可以是不同分子类 
型的集群，气隙，气泡或密度变化。在任何情况下，它都会像前面 
讨论的粒子一样散射光，散射属性同样取决于簇的大小。甚至气体 
也可以这种方式建模。对于这些， “散射粒子”是由分子的恒定运 
动引起的瞬态密度波动。该模型可以为气体建立有意义的n值，这 
对于理解它们的光学特性很有用。图9.6显示了光散射的一些例子。 
----------------------- Page 331-----------------------
图9.6。从左到右：水，含几滴牛奶的水，含约10％牛奶的水，全 
脂牛奶和乳白色玻璃。大多数牛奶的散射粒子大于可见光波长，因 
此其散射主要是无色的，中间图像中有明显的蓝色色调。乳白玻璃 
中的散射颗粒均小于可见光波长，因此比红光更强烈地散射蓝光。 
由于分开的浅色和深色背景，透射光在左侧更明显，而散射光在右 
侧更明显。3009.基于物理的阴影图9.7。左图显示，在多米的距离 
上，水吸收光线，特别是红灯，相当强烈。正确的图像显示在多英 
里的空气中有明显的光散射，即使在没有重污染或雾的情况​ ​ 下 
也是如此。散射和吸收都与尺度有关。在小场景中不产生任何明显 
散射的介质在较大尺度上可能具有非常明显的散射。例如，当观察 
房间中的一杯水时，在空气中的光散射和在水中的吸收是不可见的。 
但是，在扩展环境中，两种效果都很重要，如图9.7所示。在一般 
情况下，介质的外观是由散射和吸收的某种组合引起的，如图9.8 
所示。散射程度决定了浑浊度，高散射会产生不透明的外观。除了 
极少数例外，例如图9.6中的乳白玻璃，固体和液体介质中的颗粒 
往往比光波长大，并且倾向于均匀地散射所有可见波长的光。因此， 
任何颜色色调通常由吸收的波长依赖性引起。介质的轻盈是这两种 
现象的结果。特别是白色是高散射和低吸收组合的结果。这将在第 
14.1节中详细讨论。9.1.3曲面从光学角度来看，物体表面是一个 
二维界面，用于分隔具有不同折射率值的体积。在典型的渲染情况 
下，外部容积包含空气，折射率约为 1.003，为简单起见，通常假 
设为 1。内部体积的折射率取决于制造物体的物质。当光波照射到 
----------------------- Page 332-----------------------
表面时，该表面的两个方面对结果具有重要影响：两侧的物质和表 
面几何形状。我们将首先关注物质方面，假设最简单的表面几何形 
状，一个完美的平面。我们将 “外部” （入射或入射波发生的一侧） 
上的折射率表示为n1，将 “折射率”表示为 “内部” （波将在穿过 
表面后发射的位置）。 N2。我们在前一节中已经看到，当光波遇 
到材料成分或密度不连续时，即折射率时，它会散射。A9.1。物理 
学光301图9.8。具有不同吸收和散射组合的液体容器。分离不同 
折射率的平面是一种特殊类型的不连续性，它以特定的方式散射光。 
边界条件要求平行于表面的电场分量是连续的。换句话说，电场矢 
量到表面平面的投影必须在表面的任一侧上匹配。这有几个含义：1。 
在地表，任何散射波必须与入射波同相或 180°异相。因此，在表面 
处，散射波的峰值必须与入射波的峰值或波谷对齐。这限制了散射 
波只进入两个可能的方向，一个继续向前进入表面，一个向后退去。 
第一个是透射波，第二个是反射波。2.散射波必须与入射波具有相 
同的频率。我们在这里假设单色波，但我们讨论的原理可以通过首 
先将其分解为单色分量来应用于任何一般波。3029.基于物理的阴 
影图9.9。撞击平面的光波分离折射率n1和 n2。图的左侧显示了 
入射波从左上方进入的侧视图。红色波段的强度表示波相。表面下 
方的波的间隔与比率（n1/ n2）成比例地变化，在这种情况下为 
0.5。相位沿着表面排列，所以间距的变化会弯曲 （折射）透射波方 
向。三角形结构显示了Snell定律的推导。为清楚起见，图的右上 
方分别显示了反射波。它具有与入射波相同的波间距，因此其方向 
----------------------- Page 333-----------------------
与表面法线具有相同的角度。该图的右下方显示了波方向矢量。3. 
当光波从一种介质移动到另一种介质时，相速度 - 波通过介质的速 
度 - 与相对折射率 （n1/ n2）成比例地变化。由于频率是固定的， 
因此波长也与（n1/ n2）成比例地变化。最终结果如图9.9所示。 
反射波和入射波方向与表面法线具有相同的角度θi。透射波方向以 
角度θt弯曲 （折射），其与θi：sin （θt）=n1n2sin （θi）具有以 
下关系。 （9.1）这个折射方程称为斯涅尔定律。它用于全局折射效 
应，将在第 14.5.2节中进一步讨论。虽然折射通常与透明材料 （如 
玻璃和水晶）有关，但它也会发生在不透明物体的表面。当不透明 
物体发生折射时，光在物体内部经历散射和吸收。光与物体的介质 
相互作用，就像图9.8中的各种液体杯一样。在金属的情况下，内 
部包含许多自由电子（未与分子结合的电子），其 “吸收”折射的 
光能并将其重定向到反射波中。这就是金属具有高吸收性和高反射 
率的原因。9.1。物理学光303图9.10。由于折射率的逐渐变化导 
致的光路弯曲的示例，在这种情况下由温度变化引起。（ “EE 
Lightnings热雾”，PaulLucas，根据CC BY2.0许可使用。）我 
们讨论的表面折射现象 - 反射和折射 - 需要折射率的突然变化， 
发生在小于一个的距离内波长。折射率的逐渐变化不会使光分裂， 
而是导致其路径弯曲，以折射中发生的不连续弯曲的连续模拟。当 
空气密度因温度而变化时，通常可以看到这种效果，例如海市蜃楼 
和热变形。见图9.10。即使是具有明确边界的物体，如果它浸没在 
具有相同折射率的物质中，也将没有可见表面。在没有折射率变化 
----------------------- Page 334-----------------------
的情况下，不会发生反射和折射。图9.11就是一个例子。到目前为 
止，我们一直关注物质在表面两侧的影响。我们现在将讨论影响表 
面外观的另一个重要因素：几何。严格来说，完全平坦的平面是不 
可能的。即使只有构成表面的单个原子，每个表面都有某种不规则 
性。然而，远小于波长的表面不规则性对光没有影响，并且比波长 
大得多的表面不规则性有效地使表面倾斜而不影响其局部平坦度。 
只有尺寸在1-100波长范围内的不规则性会导致表面的表现与平面 
不同，这种现象称为衍射，将在第9.11节中进一步讨论。在渲染中， 
我们通常使用几何光学，忽略诸如干涉和衍射的波效应。这相当于 
假设所有表面不规则性都小于光波长或更大。在几何光学中，光被 
建模为光线而不是波。在光线与表面相交的点处，表面局部地被处 
理为平面。图9.9右下角的图表可以看作是反射和折射的几何光学 
图片，与该图其他部分中呈现的波浪图片形成对比。我们将3049。 
基于物理的着色图9.11。这些装饰珠的折射率与水相同。在水面之 
上，由于它们的折射率与空气的折射率之间的差异，它们具有可见 
表面。在水下面，珠子表面的两侧的折射率是相同的，因此表面是 
不可见的。由于它们的有色吸收，珠子本身是可见的。从这一点开 
始，一直到几何光学领域，直到第9.11节，这是专门讨论基于波动 
光学的着色模型的主题。如前所述，比波长大得多的表面不规则性 
改变了表面的局部取向。当这些不规则性太小而无法单独渲染时 - 
换句话说，小于像素 - 我们将它们称为微观几何。反射和折射的方 
向取决于表面法线。微观几何学的效果是在表面上的不同点处改变 
----------------------- Page 335-----------------------
该法线，从而改变反射和折射的光方向。即使表面上的每个特定点 
仅在单个方向上反射光，每个像素也覆盖许多反射各个方向的光的 
表面点。外观由所有不同反射方向的聚合结果驱动。图9.12显示了 
两个表面的示例，这两个表面在宏观尺度上具有相似的形状，但显 
着不同的微观几何。对于渲染，而不是明确地对微观几何进行建模， 
我们对其进行统计处理并将表面视为具有微观结构法线的随机分 
布。结果是，我们将表面建模为在连续的方向上反射 （和折射）光。 
这种扩散的宽度，以及因此反射和折射细节的模糊性，取决于微观 
几何法向量的统计方差 - 换句话说，表面微尺度粗糙度。见图9.13。 
9.1。物理学光305图9.12。在左侧，我们看到两个表面的照片， 
右侧是微观结构图。顶部表面具有略微粗糙的微观几何学。入射光 
线撞击表面点，这些表面点的角度稍有不同并且以窄锥方向反射。 
可见效果是反射的轻微模糊。底面具有更粗糙的微观几何学。入射 
光线撞击的表面点在明显不同的方向上成角度，并且反射的光在宽 
锥体中展开，导致模糊的反射。图9.13。从宏观上看，表面可以被 
视为在多个方向上反射和折射光。9.1.4次表面散射折射光继续与物 
体的内部体积相互作用。如前所述，金属反射大部分入射光并迅速 
吸收其余部分。相反，非金属表现出各种各样的散射和吸收行为， 
其中基于物理的阴影图9.14。折射光在穿过材料时经历吸收。在该 
示例中，大部分吸收在较长波长处，主要留下短波长蓝光。此外， 
它从材料内部的粒子散射出来。最终，一些折射光从表面散射回来， 
如从各个方向离开表面的蓝色箭头所示。类似于图9.8中的液体杯 
----------------------- Page 336-----------------------
中所见的那些。具有低散射和吸收的材料是透明的，将任何折射光 
透射通过整个物体。第5.5节讨论了在没有折射的情况下渲染这种 
材料的简单方法，第 14.5.2节将详细介绍折射。在本章中，我们将 
重点关注不透明物体，其中透射光经历多次散射和吸收事件，直到 
最后一些物体从表面重新发射回来。见图9.14。这种次表面散射光 
以离入射点不同的距离离开表面。入口 - 出口距离的分布取决于材 
料中散射颗粒的密度和性质。这些距离与阴影比例（像素的大小或 
阴影样本之间的距离）之间的关系很重要。如果入口 - 出口距离与 
阴影比例相比较小，则可以假设它们实际上为零以用于着色目的。 
这允许次表面散射与表面反射结合到局部着色模型中，在一点处的 
出射光仅取决于同一点处的入射光。然而，由于次表面散射光具有 
与表面反射光明显不同的外观，因此将它们分成单独的阴影术是方 
便的。镜面术语模拟表面反射，扩散项模拟局部次表面散射。如果 
入口 - 出口距离与阴影比例相比较大，则需要专门的渲染技术来捕 
获在一个点进入表面并将光从另一个点离开的光的视觉效果。第 
14.6节详细介绍了这些全局次表面散射技术。局部和全局次表面散 
射之间的差异如图9.15所示。值得注意的是，局部和全局次表面散 
射技术可以模拟完全相同的物理现象。每种情况的最佳选择取决于 
9.2。Camera307镜面漫反射图9.15。在左侧，我们正在渲染具有 
次表面散射的材质。显示了两种不同的采样尺寸，黄色和紫色。大 
黄色圆圈表示覆盖大于次表面散射距离的区域的单个阴影样本。因 
此，可以忽略这些距离，使得次表面散射可以被视为局部着色模型 
----------------------- Page 337-----------------------
中的漫反射项，如右侧单独的图所示。如果我们靠近此表面，阴影 
样本区域会变小，如小紫色圆圈所示。现在，与阴影样本所覆盖的 
区域相比，次表面散射距离较大。需要全局技术来从这些样本中生 
成逼真的图像。仅在材料特性上，而且在观察规模上。例如，当渲 
染孩子玩塑料玩具的场景时，可能需要全局技术来准确渲染孩子的 
皮肤，并且局部漫反射阴影模型足以满足玩具的需要。这是因为皮 
肤中的散射距离比塑料中的散射距离大得多。然而，如果相机距离 
足够远，则皮肤散射距离将小于像素，并且局部阴影模型对于儿童 
和玩具都是准确的。相反，在极端特写镜头中，塑料会表现出明显 
的非局部次表面散射，并且需要全局技术来准确地渲染玩具。9.2 
相机如第8.1.1节所述，在渲染中我们计算从阴影表面点到相机位 
置的辐射亮度。这模拟了成像系统的简化模型，例如胶片相机，数 
码相机或人眼。这种系统包含由许多离散小传感器组成的传感器表 
面。例子包括眼睛中的棒和锥体，数码相机中的光电二极管或膜中 
的染料颗粒。这些传感器中的每一个都检测其表面上的辐照度值并 
产生颜色信号。辐照度传感器本身不能产生图像，因为它们平均来 
自所有进入方向的光线。出于这个原因，完整的成像系统包括具有 
单个小孔（开口）的防光外壳，该小孔限制光可以进入和撞击传感 
器的方向。放置在光圈处的透镜聚焦光，使得每个传感器仅从一小 
组进入方向接收光。外壳，光圈和镜头具有使传感器具有方向特定 
性的综合效果。他们的平均光照超过3089。基于物理的阴影小区 
域和一小组传入方向。而不是测量平均辐照度 - 正如我们在8.1.1 
----------------------- Page 338-----------------------
节中所见，量化了来自所有方向的光流的表面密度 - 这些传感器测 
量平均辐射度，其量化单个光线的亮度和颜色。从历史上看，渲染 
模拟了一种特别简单的成像传感器，称为针孔相机，如图9.16顶部 
所示。针孔相机具有极小的光圈 - 在理想情况下，零尺寸数学点 - 
没有镜头。点孔径限制传感器表面上的每个点以收集单个光线，其 
中离散传感器收集窄锥光线，其基部覆盖传感器表面并且其顶点在 
孔处。渲染系统以略有不同（但相当）的方式模拟针孔摄像机，如 
图9.16中间部分所示。针孔的位置由点c表示，通常称为 “摄像机 
位置”或 “眼睛位置”。该点也是透视变换的投影中心 （见第4.7.2 
节）。渲染时，每个着色样本对应于单个光线，因此对应于传感器 
表面上的采样点。抗锯齿过程（第 5.4节）可以解释为重建在每个 
离散传感器表面上收集的信号。然而，由于渲染不受物理传感器的 
限制，我们可以更一般地处理该过程，因为从离散样本重建连续图 
像信号。虽然已经建造了实际的针孔摄像机，对于大多数在实践中 
使用的相机以及人眼而言，它们都是糟糕的模型。使用镜头的成像 
系统的模型显示在图9.16的底部。包括透镜允许使用更大的孔径， 
这极大地增加了成像系统收集的光量。但是，它还会导致相机具有 
有限的景深 （第 12.4节），模糊太近或太远的物体。除了限制景深 
外，镜头还具有额外的效果。每个传感器位置都会接收一束光线， 
即使对于完美聚焦的点也是如此。每个着色样本代表单个观察光线 
的理想化模型有时会引入数学奇点，数值不稳定性或视觉混叠。在 
渲染图像时牢记物理模型可以帮助我们识别和解决这些问题。9.3 
----------------------- Page 339-----------------------
BRDF最终，基于物理的渲染归结为计算沿着一组视线进入摄像机 
的辐射。使用第8.1.1节中介绍的入射辐射的符号，对于给定的视 
图射线，我们需要计算的数量是 Li （c，.v），其中c是摄像机位置， 
而.v是沿着视线的方向。由于两种符号约定，我们使用.v。首先， 
Li （）中的方向向量总是指向远离给定点，在这种情况下是摄像机 
位置。其次，视图矢量v始终指向相机。9.3。BRDF309图9.16。 
这些相机模型图中的每一个都包含像素传感器阵列。实线通过这些 
传感器中的三个来限制从场景收集的光线组。每幅图中的插图显示 
了由像素传感器上的单点样本收集的光线。上图显示了针孔摄像头， 
中图显示了相同针孔摄像头的典型渲染系统模型，摄像头点为c， 
下图显示了带镜头的物理上更正确的摄像头。红色球体处于焦点， 
另外两个球体失焦。3109.基于物理的着色在渲染中，场景通常被 
建模为在它们之间具有媒体的对象的集合（单词 “媒体”实际上来 
自拉丁词 “中间”或 “中间”）。通常所讨论的介质是适量的相对 
清洁的空气，它不会明显影响光线的辐射，因此可以忽略以用于渲 
染目的。有时光线可能穿过介质，通过吸收或散射明显影响其辐射。 
这种媒体被称为参与媒体，因为它们参与了灯光在场景中的传输。 
第 14章将详细介绍参与媒体。在本章中，我们假设没有参与媒体， 
因此进入摄像机的辐射等于离开最近物体表面朝向摄像机方向的辐 
射：Li （c ，.v）=Lo （p，v）， （9.2）其中p是视线与最近物体 
表面的交点。按照公式9.2，我们的新目标是计算 Lo （p，v）。此 
计算是第 5.1节中讨论的着色模型评估的基于物理的版本。有时辐 
----------------------- Page 340-----------------------
射是由表面直接发出的。更常见的是，离开表面的辐射源自其他地 
方，并通过第9.1节中描述的物理相互作用被表面反射到视线中。 
在本章中，我们不考虑透明度 （第 5.5节和第 14.5.2节）和全局次 
表面散射 （第 14.6节）。换句话说，我们专注于局部反射现象，它 
将光线重新导向当前阴影点向外。这些现象包括表面反射以及局部 
次表面散射，并且仅取决于入射光方向l和出射视图方向v。局部反 
射率由双向反射分布函数（BRDF）量化，表示为f （l，v）。在其 
原始推导[1277]中，BRDF被定义为均匀表面。也就是说，假设 BRDF 
在表面上是相同的。但是，现实世界（以及渲染场景中）的物体很 
少在其表面上具有均匀的材料属性。即使是由单一材料组成的物体， 
例如由银制成的雕像，也会有划痕，失去光泽的斑点，污渍和其他 
变化，导致其视觉特性从一个表面点变为另一个表面点。从技术上 
讲，基于空间位置捕获 BRDF变化的函数称为空间变化的 BRDF 
 （SVBRDF）或空间BRDF （SBRDF）。然而，这种情况在实践中 
如此普遍，以至于经常使用短期 BRDF并且隐含地假设它取决于地 
面位置。传入和传出方向均具有两个自由度。经常使用的参数化涉 
及两个角度：相对于表面法线 n的高度θ和关于 n的方位角（水平 
旋转）。在一般情况下，BRDF是四个标量变量的函数。各向同性 
BRDF是一个重要的特殊情况。当进出方向围绕表面法线旋转时， 
这种 BRDF保持不变，保持它们之间的相对相对角度。图9.17显示 
了两种情况下使用的变量。各向同性 BRDF是三个标量变量的函数， 
因为光和相机9.3之间只有一个角度φ。BRDF311 nvlt图9.17。 
----------------------- Page 341-----------------------
BRDF。相对于给定的切向量t给出方位角φi和φo。用于各向同性 
BRDF而不是φi和φo的相对方位角φ不需要参考切向量。需要轮换。 
这意味着如果将均匀的各向同性材料放置在转盘上并旋转，则在给 
定固定光和相机的情况下，对于所有旋转角度看起来都是相同的。 
由于我们忽略了荧光和磷光等现象，我们可以假设给定波长的入射 
光在相同波长下反射。反射的光量可以基于波长而变化，其可以以 
两种方式之一建模。要么将波长视为BRDF的附加输入变量，要么 
将 BRDF视为返回频谱分布值。虽然第一种方法有时用于离线渲染 
[660]，但在实时渲染中总是使用第二种方法。由于实时渲染器将光 
谱分布表示为 RGB三元组，因此这仅表示BRDF返回 RGB值。为 
了计算Lo （p，v），我们将 BRDF合并到反射方程中：Lo （p，v） 
=Zl∈f （l，v）Li （p，l）（n·1）dl。（9.3）积分符号上的l∈下 
标表示对位于表面上方的单位半球中的 l个向量进行积分（以表面 
法线n为中心）。请注意，l在进入的方向的半球上连续扫过 - 它 
不是特定的 “光源方向”。这个想法是任何进入的方向都可以（并 
且通常会）具有与之相关的一些辐射。我们使用dl来表示l周围的 
微分立体角 （实心角在8.1.1节中讨论）。总之，反射率方程表明， 
出射辐射等于入射辐射的积分（超过lin）乘以BRDF乘以 n和 l 
之间的点积。为简洁起见，对于本章的其余部分，我们将省略 Li （）， 
Lo （）和反射方程的表面点p：Lo （v）=Zl∈f （l，v）Li （l）（n ·l） 
dl。（9.4）3129.基于物理的阴影在计算反射方程时，通常使用球 
面坐标φ和θ对半球进行参数化。对于该参数化，差分立体角d1等 
----------------------- Page 342-----------------------
于sinθidθirφi。使用此参数化，可以导出公式9.4的双积分形式， 
它使用球面坐标 （回想 （n·l）=cosθi）：Lo （θo，φo）=Z2？？ 
i=0Z？/2？i=0f （θi，φi，θo，φo）L （θi，φi）cosθisinθid 
θidφi。 （9.5）角度θi，φi，θo和φo如图9.17所示。在某些情况 
下，使用稍微不同的参数化是方便的，其中仰角的余弦μi=cosθi和 
μo=cosθo作为变量而不是角度θi和θo本身。对于该参数化，差 
分立体角d1等于dμidφi。使用 （μ，φ）参数化产生以下积分形式： 
Lo （μo，φo）=Z2？？i=0Z1μi=0f （μi，φi，μo，φo）L （μ 
i，φi）μidμidφi。（9.6）仅在光和视图方向都在表面上方的情况 
下定义 BRDF。通过将BRDF乘以零或者不首先评估 BRDF用于这 
些方向，可以避免光方向在表面下方的情况。但是表面下的视图方 
向呢，换句话说，点积n·v是负的？从理论上讲，这种情况永远不 
会发生。表面将背离相机，因此是不可见的。然而，在实时应用中 
常见的内插顶点法线和法线贴图可以在实践中产生这样的情况。通 
过将 n·v钳位到0或使用其绝对值，可以避免对表面下的视图方向 
评估BRDF，但是这两种方法都可能导致伪影。Frostbite引擎使用 
n·v的绝对值加上一个小数字（0.00001）来避免除以零[960]。另 
一种可能的方法是“软钳位”，随着n和v之间的角度增加超过90°， 
它逐渐变为零。物理定律对任何BRDF施加两个约束。第一个约束 
是亥姆霍兹互易性，这意味着可以切换输入和输出角度，并且函数 
值将是相同的：f （l，v）=f （v，l）。（9.7）在实践中，渲染中 
使用的 BRDF经常违反亥姆霍兹互易性而没有明显的伪影，除了特 
----------------------- Page 343-----------------------
别需要互易性的离线渲染算法，例如双向路径追踪。但是，在确定 
BRDF是否物理合理时，它是一种有用的工具。第二个限制是能量 
守恒 - 输出能量不能大于输入能量 （不计算发光的发光表面，作为 
特殊情况处理）。离线渲染算法 （如路径跟踪）需要9.3。BRDF313 
节能以确保收敛。对于实时渲染，不需要精确的节能，但近似的节 
能是重要的。使用明显违反节能的 BRDF渲染的表面太亮，因此可 
能看起来不切实际。方向半球反射率 R （l）是与 BRDF有关的函数。 
它可以用来衡量BRDF节能的程度。尽管名称有点令人生畏，但定 
向半球反射是一个简单的概念。它测量来自给定方向的光量，该光 
线完全反射到半球表面法线周围的任何传出方向。实质上，它测量 
给定进入方向的能量损失。该函数的输入是输入方向向量l，其定义 
如下：R （l）=Zv∈f （l，v） （n·v）dv。 （9.8）注意，这里v，与 
反射率方程中的l一样，扫过整个半球，并不代表单一的观察方向。 
类似但在某种意义上相反的函数，半球方向反射率R （v）可以类似 
地定义：R （v）=Z1∈f （l，v） （n·1）d1。 （9.9）如果 BRDF是 
倒数，则半球方向反射率和方向半球反射率相等，并且可以使用相 
同的函数来计算任一个。在可互换使用的情况下，定向反照率可用 
作两种反射率的总称。由于节能，定向半球反射率 R （l）的值必须 
始终在[0,1]范围内。反射率值0表示所有入射光被吸收或以其他方 
式丢失的情况。如果所有光都被反射，则反射率将为 1.在大多数情 
况下，它将介于这两个值之间。与 BRDF一样，R （l）的值随波长 
而变化，因此它表示为RGB矢量用于渲染目的。由于每个分量 （红 
----------------------- Page 344-----------------------
色，绿色和蓝色）被限制在[0,1]范围内，因此R （l）的值可以被认 
为是简单的颜色。请注意，此限制不适用于BRDF的值。作为分配 
函数，如果描述的分布非常不均匀，则BRDF可以在某些方向（例 
如突出显示的中心）具有任意高的值。BRDF节能的要求是对于 l 
的所有可能值，R （l）不大于1。最简单的BRDF是 Lambertian， 
它对应于第5.2节中简要讨论的 Lambertian着色模型。朗伯BRDF 
具有恒定值。区分朗伯阴影的众所周知的（n·l）因子不是BRDF的 
一部分，而是公式9.4的一部分。尽管简单，LambertianBRDF通 
常用于实时渲染以表示局部次表面散射3149.基于物理的着色（尽 
管它被更准确的模型所取代，如第9.9节所述）。朗伯表面的方向 
半球反射率也是常数。对于f （l，v）的常数值，求出等式9.8，得 
到作为 BRDF函数的方向半球反射率的以下值：R （1）=πf （l，v）。 
 （9.10）朗伯BRDF的恒定反射率值通常被称为漫反射色彩cdiff 
或反照率ρ。在本章中，为了强调与次表面散射的联系，我们将这个 
量称为地下反照率ρss。第9.9.1节详细讨论了地下反照率。公式9.10 
的BRDF给出以下结果：f （l，v）=ρssπ。（9.11）1/π因子是由 
于在半球上积分余弦因子产生π值的事实引起的。这些因素常见于 
BRDF。理解 BRDF的一种方法是在输入方向保持不变的情况下将其 
可视化。见图9.18。对于给定的入射光方向，BRDF的值如图9.18 
所示。示例 BRDF。来自每个图右侧的绿色实线是入射光方向，绿 
色和白色虚线是理想的反射方向。在第一行中，左图显示了 
Lambertian BRDF （一个简单的半球）。中间的数字显示 
----------------------- Page 345-----------------------
Blinn-Phong 突出显示增加了 Lambertian 术语。右图显示 
Cook-Torrance BRDF[285,1779]。请注意反射高光在反射方向上 
的强度不是很强。在底行，左图显示了Ward的各向异性模型的特 
写。在这种情况下，效果是使镜面反射倾斜。中间的图显示了Hapke 
/ Lommel-Seeliger “月球表面”BRDF[664]，它具有强烈的逆向 
反射。右图显示了Lommel-Seeliger散射，其中多尘的表面将光散 
射到掠射角。（图片由SzymonRusinkiewicz提供，来自他的 “bv” 
BRDF浏览器。）9.4。针对所有传出方向显示照明315。交叉点周 
围的球形部分是漫射分量，因为出射辐射具有在任何方向上反射的 
相等机会。椭圆形片是镜面波瓣。当然，这种波瓣在入射光的反射 
方向上，波瓣的厚度对应于反射的模糊性。根据互惠原则，这些相 
同的可视化也可以被认为是每个不同的入射光方向对单个输出方向 
有多大贡献。9.4照明反射率公式 （公式9.4）中的Li （l） （入射辐 
射）项代表从场景的其他部分照射到阴影表面点上的光。全局照明 
算法通过模拟光如何在整个场景中传播和反射来计算 Li （l）。这些 
算法使用渲染方程[846]，其反射方程是特殊情况。全局照明将在第 
11章中讨论。在本章和下一章中，我们将重点放在局部照明上，它 
使用反射方程在每个表面点局部计算阴影。在局部照明算法中，给 
出了Li （1）并且不需要计算。在逼真的场景中，Li （l）包括来自所 
有方向的非零辐射，无论是直接从光源发射还是从其他表面反射。 
与 5.2节中讨论的定向和准月光不同，真实世界的光源是覆盖非零 
立体角的区域光源。在本章中，我们使用限制形式的 Li （l），仅由 
----------------------- Page 346-----------------------
方向和准时灯组成，为第10章留下更一般的照明环境。这种限制允 
许更集中的讨论。虽然准时和定向光是非物理抽象，但它们可以作 
为物理光源的近似来导出。这样的推导很重要，因为它使我们能够 
将这些灯合并到基于物理的渲染框架中，并确信我们理解所涉及的 
错误。我们拿一个小的，遥远的区域光，并将lc定义为指向其中心 
的向量。我们还将光的颜色定义为从白色朗伯表面朝向光 （n=1c） 
的反射辐射。这是创作的直观定义，因为光的颜色直接对应于其视 
觉效果。根据这些定义，可以导出定向光，作为将区域光的大小缩 
小到零同时保持亮度值的极限情况[758]。在这种情况下，反射系数 
公式（公式9.4）中的积分简化为单个BRDF评估，其计算成本显 
着降低：Lo （v）=πf （lc，v）clight （n·lc）。 （9.12）点积 （n·l） 
经常被钳位到零，作为跳过表面下光线贡献的一种方便方法：Lo（v） 
=πf （lc，v）clight （n·lc）+。（9.13）3169.基于物理的着色请 
注意第 1.2节中介绍的x +表示法，它表示负值被钳制为零。准时灯 
可以类似地对待。唯一的区别是区域光不需要是远距离的，并且光 
线作为到光的距离的反平方而下降，如公式5.11 （第 111页）中所 
示。在多个光源的情况下，多次计算公式9.12并将结果相加：Lo 
 （v）=πXni =1f （lci，v）clighti （n·lci）+，（9.14）其中lci 
和clighti分别是第i个光的方向和颜色。请注意与公式5.6（第 109 
页）的相似之处。公式9.14中的π因子抵消了BRDF中经常出现的 
1/π因子（例如，公式9.11）。此取消将除法运算移出着色器，并 
使着色方程更易于阅读。但是，在从学术论文中调整 BRDF以用于 
----------------------- Page 347-----------------------
实时着色方程时必须小心。通常，BRDF在使用前需要乘以π。9.5 
菲涅耳反射在第9.1节中，我们讨论了高水平的光物质相互作用。 
在 9.3节中，我们介绍了用数学表达这些相互作用的基本机制： 
BRDF和反射方程。现在我们已经准备好开始深入研究特定现象， 
量化它们，以便它们可以用于着色模型。我们将从平面反射开始， 
首先在9.1.3节中讨论。物体的表面是周围介质（通常是空气）和 
物体物质之间的界面。光与两种物质之间的平面界面的相互作用遵 
循由Augustin-Jean Fresnel （1788-1827）（发音为freh-nel） 
开发的菲涅耳方程。菲涅耳方程需要遵循几何光学假设的平面界面。 
换句话说，假设表面在 1个光波长和 100个波长之间没有任何不规 
则性。小于该范围的不规则性对光没有影响，并且较大的不规则性 
有效地使表面倾斜但不影响其局部平坦度。入射在平坦表面上的光 
分成反射部分和折射部分。反射光的方向（由矢量ri表示）与表面 
法线n形成相同的角度 （θi）作为进入方向l。反射向量ri可以从n 
和l计算：ri=2 （n·l）n。湖 （9.15）见图9.19。反射的光量 （作 
为入射光的一部分）由菲涅耳反射率F描述，其取决于入射角θi。 
9.5。菲涅耳反射317图9.19。平面反射。光矢量l在法线 n周围 
反射，以产生ri。首先，l被投射到n上，我们得到正常的缩放版本： 
 （n·l）n。然后我们否定l，并将投影向量加两次以获得反射向量。 
如第9.1.3节所述，反射和折射受到平面两侧两种物质折射率的影 
响。我们将继续使用该讨论中的符号。值n1是物质在界面 “上方” 
的折射率，其中入射光和反射光传播，n2是物质在界面 “下方”的 
----------------------- Page 348-----------------------
折射率，其中折射光传播。菲涅耳方程描述了 F对θi，n1和 n2的 
依赖性。我们将描述它们的重要特征，而不是呈现有些复杂的方程 
本身。9.5.1外部反射外部反射是 n1<n2的情况。换句话说，光源 
自折射率较低的表面一侧。大多数情况下，这一面含有空气，折射 
率约为 1.003。为简单起见，我们假设n1 =1。从物体到空气的相 
反过渡称为内部反射，稍后将在9.5.3节中讨论。对于给定的物质， 
菲涅耳方程可以解释为定义反射函数 F（θi），仅取决于入射光角度。 
原则上，F （θi）的值在可见光谱上连续变化。出于渲染目的，其值 
被视为 RGB向量。函数F （θi）具有以下特征：。当θi=0时，光 
垂直于表面（l=n），F （θi）具有作为物质性质的值。该值F0可 
以被认为是物质的特征镜面颜色。θi=0时的情况称为法向入射。 
3189.基于物理的阴影。当θi增加并且光以越来越多的掠射角照射 
到表面时，F （θi）的值将趋于增加，在θi=90时所有频率 （白色） 
达到值 1.图9.20显示F （θi）功能，以几种不同的方式可视化，用 
于多种物质。曲线是高度非线性的 - 它们几乎没有变化，直到θi= 
75.左右，然后很快变为 1.从 F0到 1的增加大多是单调的，尽管有 
些物质 （例如图9.20中的铝）略有下降在去白色之前。在镜面反射 
的情况下，出射角或视角与入射角相同。这意味着表面与传入图9.20 
的掠射角度相同。菲涅耳反射率F用于三种物质的外部反射：玻璃， 
铜和铝（从左到右）。顶行具有作为波长和入射角的函数的 F的三 
维图。第二行显示转换为 RGB的每个入射角的F的光谱值，并绘制 
为每个颜色通道的单独曲线。玻璃曲线重合，因为菲涅耳反射率是 
----------------------- Page 349-----------------------
无色的。在第三行中，R，G和 B曲线相对于入射角的正弦绘制， 
以说明图9.21中所示的缩短。相同的x轴用于底行中的条带，其将 
RGB值显示为颜色。9.5。菲涅耳反射319图9.21。倾斜远离眼睛 
的表面被缩短。这种缩短与根据v和n之间的角度的正弦的突出表 
面点一致（对于镜面反射，这与入射角相同）。出于这个原因，菲 
涅耳反射率相对于图9.20和9.22中的入射角的正弦值绘制。光的 
值θi接近90.-也与眼睛有一个掠射角。因此，反射率的增加主要见 
于物体的边缘。此外，从相机的角度来看，表面上反射率增加最强 
的部分会缩短，因此它们占据的像素数量相对较少。为了显示菲涅 
耳曲线的不同部分与它们的视觉突出度成比例，图9.22中的菲涅耳 
反射率图和彩条以及图9.20的下半部分相对于sin （θi）而不是直 
接针对θi绘制。图9.21说明了为什么sin （θi）是一个适当的轴选 
择。从这一点来说，我们通常会使用符号 F （n，l）代替 F （θi）作 
为菲涅耳函数，以强调所涉及的向量。回想一下θi是矢量 n和l之 
间的角度。当菲涅耳函数作为BRDF的一部分合并时，通常用不同 
的矢量代替表面法线n。详细信息请参见第9.8节。掠射角度下反 
射率的增加通常被称为提取出版物中的菲涅耳效应（在其他领域， 
该术语具有与无线电波传输有关的不同含义）。您可以通过简短的 
实验看到菲涅耳效应。拿一部智能手机，坐在明亮的区域，如电脑 
显示器。不打开它，首先将手机靠近胸部，向下看，然后稍微倾斜， 
使其屏幕反射显示器。手机屏幕上的显示器反应应该相对较弱。这 
是b您可以通过简短的实验看到菲涅耳效应。拿一部智能手机，坐 
----------------------- Page 350-----------------------
在明亮的区域，如电脑显示器。不打开它，首先将手机靠近胸部， 
向下看，然后稍微倾斜，使其屏幕反射显示器。手机屏幕上的显示 
器反应应该相对较弱。这是b您可以通过简短的实验看到菲涅耳效 
应。拿一部智能手机，坐在明亮的区域，如电脑显示器。不打开它， 
首先将手机靠近胸部，向下看，然后稍微倾斜，使其屏幕反射显示 
器。手机屏幕上的显示器反应应该相对较弱。这是 b因为玻璃的垂 
直入射反射率非常低。现在将智能手机抬起，使其大致位于您的眼 
睛和显示器之间，然后再将屏幕角度调整为3209.基于物理的阴影 
图9.22。Schlick与菲涅耳反射率的近似值与六种物质的外部反射 
的正确值相比较。前三种物质与图9.20相同：玻璃，铜和铝 （从左 
到右）。底部的三种物质是铬，铁和锌。每种物质都有一个 RGB曲 
线图，实线显示完整的菲涅耳方程，虚线显示Schlick的近似值。 
每个曲线图下方的上部颜色条显示完整菲涅耳方程的结果，下部颜 
色条显示Schlick近似的结果。反映显示器。现在，手机屏幕上显 
示器的反射几乎与显示器本身一样明亮。除了它们的复杂性之外， 
菲涅耳方程还具有其他属性，使得它们在渲染中的直接使用变得困 
难。它们需要在可见光谱上采样的折射率值，并且这些值可以是复 
数。图9.20中的曲线表明基于特征镜面反射颜色F0的更简单的方 
法。Schlick[1568]给出了菲涅耳反射率的近似值：F （n，l）≈F0+ 
 （1.F0）（1. （n·1）+）5。（9.16）此功能是白色和 F0之间的 RGB 
插值。尽管如此简单，但近似值是相当准确的。图9.22包含几种与 
Schlick曲线不同的物质，在变为白色之前表现出明显的 “下降”。 
----------------------- Page 351-----------------------
事实上，选择底行中的物质是因为它们在很大程度上偏离了Schlick 
近似。即使是这些物质，产生的误差也非常微妙，如图中每个图底 
部的彩条所示。在极少数情况下，精确捕获此类材料的行为很重要， 
可以使用Gulbrandsen [623]给出的替代近似值。这种近似可以实 
现与金属的完整菲涅耳方程的紧密匹配，尽管它更接近9.5。菲涅耳 
反射率321比Schlick的计算价格昂贵。一个更简单的选择是修改 
Schlick的近似值，以允许将最终项提升到5以外的幂（如公式9.18 
所示）。这会将过渡的 “锐度”改变为90°处的白色，这可能导致 
更接近的匹配。Lagarde[959]总结了菲涅耳方程和它们的几个近似 
值。使用Schlick近似时，F0是控制菲涅耳反射率的唯一参数。这 
很方便，因为F0在[0,1]中具有明确定义的有效值范围，易于使用标 
准颜色选择界面进行设置，并且可以使用为颜色设计的纹理格式进 
行纹理化。此外，F0的参考值可用于许多真实世界的材料。折射率 
也可用于计算 F0。通常假设n1 =1，近似于空气的折射率，并使 
用n而不是n2来表示物体的折射率。这种简化给出了以下等式： 
F0=？n。1n+1？2。（9。17）如果使用（复数）结果的大小， 
该方程甚至对复值折射率（例如金属的折射率）起作用。在折射率 
在可见光谱上显着变化的情况下，计算 F0的精确RGB值需要首先 
在密集的波长采样下计算 F0，然后使用第8.1.3节中描述的方法将 
得到的光谱矢量转换为 RGB值。 。在一些应用[732,947]中，使用 
更一般形式的Schlick近似：F （n，l）≈F0+ （F90.F0） （1. （n·1） 
+）1p。（9.18）这提供了对菲涅耳曲线在90°处转换的颜色的控 
----------------------- Page 352-----------------------
制，以及转换的 “锐度”。这种更一般形式的使用通常是出于对增 
加艺术控制的渴望，但在某些情况下，它也可以帮助匹配物理现实。 
如上所述，改变功率可以导致某些材料的更紧密配合。此外，将 F90 
设置为白色以外的颜色可以帮助匹配菲涅耳方程式未能很好描述的 
材料，例如覆盖在细小灰尘中的表面，其中颗粒具有单个光波长的 
大小。9.5.2典型的菲涅耳反射率值物质在光学性质方面分为三大 
类。有电介质，它们是绝缘体;金属，是导体;和半导体，它们具有 
介于电介质和金属之间的特性。电介质的菲涅耳反射率值日常生活 
中遇到的大多数材料是电介质 - 玻璃，皮肤，木材，头发，皮革， 
塑料，石头和混凝土等等。水也是电介质。最后一个可能是3229. 
基于物理的阴影介质线性纹理颜色注意水 0.02 39 活组织 
0.02-0.0439-56水样组织朝向下方，干燥组织更高皮肤0.02847 
眼睛0.02544干燥角膜 （眼泪有一个与水相似的值）头发0.04661 
牙齿0.05868织物0.04-0.05656-67聚酯最高，大部分低于0.05 
石头 0.035-0.056 53-67石材中最常见的矿物质值塑料，玻璃 
0.04-0.05 56-63不包括水晶玻璃水晶玻璃0.05-0.07 63-75宝石 
0.05-0.08 63-80 不包括钻石和钻石模拟物类金刚石 0.13-0.2 
101-124钻石和钻石模拟物（如立方氧化锆，莫桑石）表9.1。来 
自各种电介质的外部反射的F0值。每个值作为线性数，纹理值 （非 
线性编码的8位无符号整数）和颜色样本给出。如果给出了一系列 
值，则颜色样本位于范围的中间。回想一下，这些是镜面反射的颜 
色。例如，宝石通常具有鲜艳的颜色，但这些颜色来自物质内部的 
----------------------- Page 353-----------------------
吸收并且与它们的菲涅耳反射率无关。令人惊讶的是，因为在日常 
生活中水已知导电，但这种导电性是由于各种杂质造成的。电介质 
具有相当低的F0值 - 通常为0.06或更低。在垂直入射时的这种低 
反射率使得菲涅耳效应对于电介质尤其可见。电介质的光学性质在 
可见光谱上很少变化很大，导致无色反射率值。几种常见电介质的 
F0值如表9.1所示。这些值是标量而不是 RGB，因为RGB通道对 
于这些材料没有显着差异。为方便起见，表9.1包括线性值以及使 
用sRGB传递函数（通常在纹理绘制应用程序中使用的形式）编码 
的8位值。其他电介质的F0值可以通过查看表中的类似物质来推断。 
对于未知的电介质，0.04是合理的默认值，与大多数常见材料相差 
不远。 9.5 。菲涅耳反射率 323 金属线性纹理颜色 钛 
0.542,0.497,0.449 194,187,179  铬  0.549,0.556,0.554 
196,197,196  铁  0.562,0.565,0.578  198,198,200  镍 
0.660,0.609,0.526 212,205,192  铂  0.673,0.637,0.585 
214,209,201 铜 0.955,0.638,0 。 538 250,209,194 钯 
0.733,0.697,0.652 222,217,211  汞  0.781,0.780,0.778 
229,228,228 黄铜（C260）0.910,0.778,0.423 245,228,174 锌 
0.664,0.824,0.850 213,234,237 黄 金 1.000,0.782,0.344 
255,229,158 铝 0.913,0.922,0.924 245,246,246 银 0.972 ， 
0.960,0.915252,250,245表9.2。来自各种金属 （和一种合金）的 
外部反射的 F0值，按照增加的亮度顺序排序。黄金的实际红色值略 
高于sRGB色域。显示的值是夹紧后的值。一旦光被传输到电介质 
----------------------- Page 354-----------------------
中，它可以被进一步散射或吸收。第9.9节将更详细地讨论此过程 
的模型。如果材料是透明的，光将持续直到它 “从内部”撞击物体 
表面，这将在第9.5.3节中详述。金属的菲涅耳反射值金属具有高 
的F0值 - 几乎总是0.5或更高。一些金属具有在可见光谱范围内 
变化的光学性质，导致有色反射率值。几种金属的 F0值如表9.2所 
示。与表9.1类似，表9.2具有线性值以及用于纹理化的8位sRGB 
编码值。但是，这里我们给出 RGB值，因为许多金属都有菲涅耳反 
射率的颜色。这些 RGB值使用sRGB （和Rec.709）原色和白点定 
义。黄金有一个不寻常的F0值。它是最强烈着色的，红色通道值略 
高于1 （它几乎不在sRGB/ Rec。709色域之外）和特别低的蓝色 
通道值 （表9.2中唯一的值显着低于0.5）。它也是最亮的金属之一， 
从表中的位置可以看出，该表按照增加亮度的顺序排序。黄金的明 
亮和强烈的颜色反射可能有助于其历史上独特的文化和经济意义。 
回想一下，金属会立即吸收任何透射光，因此它们不会出现任何次 
表面散射或透明度。金属的所有可见颜色都来自 F0。3249.基于物 
理的遮蔽物质线性纹理颜色金刚石 0.171,0.172,0.176 
115,115,116  硅  0.345,0.369,0.426  159,164,174  钛 
0.542,0.497,0.449 194,187,179表9.3。代表性半导体（晶体形式 
的硅）与明亮电介质 （金刚石）和深色金属 （钛）相比的 F0值。半 
导体的菲涅耳反射值正如人们所料，半导体在最亮的电介质和最暗 
的金属之间具有F0值，如表9.3所示。在实践中很少需要渲染这样 
的物质，因为大多数渲染的场景都没有充满晶体硅块。出于实际目 
----------------------- Page 355-----------------------
的，应避免F0值在0.2和0.45之间的范围，除非您故意尝试模拟 
异国情调或不切实际的材料。水中的菲涅耳反射率值在我们对外部 
反射率的讨论中，我们假设渲染的表面被空气包围。如果不是，则 
反射率将改变，因为它取决于界面两侧的折射率之间的比率。如果 
我们不能再假设 n1 =1，那么我们需要将公式9.17中的n替换为 
相对折射率n1/ n2。这产生以下，更一般的等式：F0=？n1。n2 
n1 +n2？2。（9.19）可能是最常遇到的情况，其中n16 =1是 
渲染水下场景时。由于水的折射率比空气的折射率高约1.33倍，因 
此F0的值在水下是不同的。这种效应对于电介质比对金属更强，如 
表9.4所示。参数化菲涅耳值常用的参数化结合了镜面反射颜色 F0 
和漫反射颜色ρss （漫反射颜色将在第9.9节中进一步讨论）。这种 
参数化利用了观察到金属没有漫反射颜色，并且电介质对F0具有一 
组有限的可能值，并且它包括 RGB表面颜色csurf和标量参数m， 
称为 “金属”或 “金属”。 m =1，然后将F0设置为csurf，将ρ 
ss设置为黑色。如果m =0，则将F0设置为介电值（常数或由附 
加参数控制），并将ρss设置为csurf。 “金属度”参数首先作为布 
朗大学[1713]使用的早期着色模型的一部分出现，其当前形式的参 
数化首先由皮克斯用于电影Wall-E [1669]。对于迪斯尼原则阴影模 
型，用于Wreck-It Ralph的迪士尼动画电影，Burley又增加了9.5。 
菲涅耳反射325物质线性纹理颜色皮肤 （在空气中）0.02847皮肤 
 （在水中）0.00072SchottK7玻璃 （在空气中）0.04258Schott 
K7玻璃 （在水中）0.00413钻石 （在空气中）0.172115钻石 （在 
----------------------- Page 356-----------------------
水中） ）0.08482铁（空气中）0.562,0.565,0.578 198,198,200 
铁（水中）0.470,0.475,0.492 182,183，186 金（空气中） 
1.000,0.782,0.344 255,229,158 金（水中）1.000,0.747,0.261 
255,224,140银 （空气中）0.972,0.960,0.915252,250,245银 （水 
中）0.964,0.950,0.899251,249,243表9.4。各种物质的空气和水 
中F0值的比较。正如人们所预期的那样，检查公式9.19时，折射 
率接近水的电介质受到的影响最大。相比之下，金属几乎没有受到 
影响。标量 “镜面反射”参数，用于在有限范围内控制电介质 F0 
[214]。这种形式的参数化用于虚幻引擎[861]，Frostbite引擎使用 
稍微不同的形式，其中电介质的可能 F0值范围更大[960]。游戏使 
命召唤：InfiniteWarfare使用一种变体将这些金属度和镜面反射参 
数打包成单个值[384]，以节省内存。对于那些使用此金属度参数化 
而不是直接使用F0和ρss的渲染应用程序，动机包括用户便利性和 
保存纹理或G缓冲区存储。在游戏 “使命召唤：无限战争”中，此 
参数化以不寻常的方式使用。艺术家为 F0和ρss绘制纹理，它们作 
为压缩方法自动转换为金属度参数化。使用金属性有一些缺点。它 
不能表达某些类型的材料，例如具有着色 F0值的涂层电介质。伪影 
可能发生在金属和电介质之间的边界上[960,1163]。一些实时应用 
所使用的另一种参数化技巧利用了在特殊抗反射涂层之外没有材料 
具有低于0.02的F0值的事实。该技巧用于抑制表示空腔或空隙的 
表面区域中的镜面高光。不使用单独的镜面遮挡纹理，F0低于0.02 
的值用于“关闭”菲涅耳边缘增亮。这种技术最初由Sch¨uler[1586] 
----------------------- Page 357-----------------------
提出，用于 Unreal [861]和 Frostbite[960]引擎。9.5.3内部反射 
尽管在渲染中经常遇到外部反射，但内部反射有时也很重要。当n1> 
n2时发生内部反射。326.基于物理的阴影nn1n2lt-nri图9.23。 
平面上的内反射，其中n1>n2。换句话说，当光在透明物体内部行 
进并且 “从内部”遇到物体表面时，就会发生内部反射。见图9.23。 
斯内尔定律表明，对于内反射，sinθt>sinθi。由于这些值都介于0 
和90之间，因此这种关系也意味着θt>θi，如图9.23所示。在外 
部反射的情况下，情况正好相反 - 将此行为与第302页的图9.9进 
行比较。这种差异是理解内部和外部反射如何不同的关键。在外部 
反射中，sinθ的有效（较小）值存在于0和 1之间的sinθi的每个 
可能值。对于内部反射也是如此。对于θi大于临界角θc的值，斯内 
尔定律暗示sinθt>1，这是不可能的。实际上发生的事情是没有θt。 
当θi>θc时，不发生传输，并且所有入射光都被反射。这种现象称 
为全内反射。在可以切换输入和传输矢量并且反射率保持相同的意 
义上，菲涅耳方程是对称的。结合Snell定律，这种对称意味着内 
反射的 F （θi）曲线将类似于外部反射曲线的 “压缩”版本。对于两 
种情况，F0的值都是相同的，并且内部反射曲线在θc而不是90处 
达到完美的反射率。这在图9.24中示出，其还表明，在内部的情况 
下，平均来说反射率更高。反射。例如，这就是为什么在水下看到 
的气泡具有高度反光的银色外观。内部反射仅发生在电介质中，因 
为金属和半导体可以快速吸收在其内部传播的任何光[285,286]。由 
于电介质具有实值折射率，因此从折射率或从F0计算临界角是直截 
----------------------- Page 358-----------------------
了当的：sinθc=n2n1=1。√F01+√F0。 （9.20）公式9.16中所 
示的Schlick近似对于外部反射是正确的。通过将透射角θt代入θi， 
它可以用于内反射。如果已经计算了传输方向向量t （例如，用于渲 
染折射 - 参见第 14.5.2节），则可以使用它来找到θt。否则Snell 
定律可以用9.6。微观几何学327qc玻璃 （外部反射）玻璃 （内部 
反射）RF00.20.40.60.80102030405060708090图9.24。 
玻璃 - 空气界面处的内部和外部反射曲线的比较。内部反射率曲线 
在临界角θc处变为 1.0。从θi计算θt，但这是昂贵的并且需要折射 
率，这可能是不可用的。9.6微观几何学如前面9.1.3节所述，表面 
不规则性远小于像素不能明确地建模，因此 BRDF会在统计上模拟 
它们的聚合效应。现在我们继续研究几何光学领域，它假设这些不 
规则性要么小于光波长 （因此对光的行为没有影响），要么大得多。 
第9.11节将讨论 “波光学领域” （大约1-100个波长）中的不规 
则性的影响。每个可见表面点包含许多微表面法线，它们反射不同 
方向的反射光。由于单个微平面的方向有些随机，因此将它们建模 
为统计分布是有意义的。对于大多数表面，微观几何表面法线的分 
布是连续的，在宏观表面法线处具有强峰。该分布的 “紧密度”由 
表面粗糙度决定。表面越粗糙，微观几何法线就越 “展开”。增加 
微尺度粗糙度的可见效果是反射的环境细节的更大模糊。在小而明 
亮的光源的情况下，这种模糊导致更广泛和更暗淡的镜面高光。来 
自较粗糙表面的那些较暗，因为光能被扩散到更宽的方向锥。这种 
现象可以在第293页的图9.12中的照片中看到.3289.基于物理的 
----------------------- Page 359-----------------------
着色图9.25。从可见细节逐渐过渡到微观尺度。图像序列从左到右 
排在顶行，然后从左到右排在底行。表面形状和照明是恒定的。只 
有表面细节的比例发生变化。图9.25显示了可见的反射率是如何由 
各个微尺度表面细节的聚合反射产生的。该系列图像显示由单个光 
照射的曲面，其中凸起的比例稳定地减小，直到最后一个图像中的 
凸起比单个像素小得多。许多小亮点中的统计模式最终成为所得聚 
合亮点形状的细节。例如，周边的单个凹凸高光的相对稀疏性成为 
远离其中心的聚合高光的相对暗度。对于大多数表面，微尺度表面 
法线的分布是各向同性的，这意味着它是旋转对称的，缺乏任何固 
有的方向性。其他表面具有各向异性的微米级结构。这样的表面具 
有各向异性的表面法线分布，导致反射和高光的方向模糊。见图 
9.26。一些表面具有高度结构化的微观几何学，导致各种微尺度正 
态分布和表面外观。面料是一个常见的例子 - 天鹅绒和绸缎的独特 
外观是由于它们的微观几何结构[78]。织物模型将在第9.10节中讨 
论。虽然多个表面法线是微观几何学对反射率的主要影响，但其他 
影响也很重要。阴影是指通过微尺度表面细节遮挡光源，如图9.27 
左侧所示。在图的中心显示掩蔽，其中一些面隐藏了其他人的相机。 
9.6。微观几何学329图9.26。左边是各向异性表面 （拉丝金属）。 
注意反射的方向模糊。在右边，显示相似表面的显微照片。注意细 
节的方向性。（显微照片由康奈尔大学计算机图形学程序提供。） 
图9.27。微尺度结构的几何效应。在左侧，黑色虚线箭头表示通过 
其他微观几何学被遮蔽（从光遮挡）的区域。在中心，红色虚线箭 
----------------------- Page 360-----------------------
头表示通过其他微观几何学被掩盖（从视图中遮挡）的区域。在右 
侧，示出了微尺度结构之间的光的互反射。如果微观几何高度与表 
面法线之间存在相关性，则阴影和遮蔽可以有效地改变正态分布。 
例如，想象一下通过风化或其他过程使凸起部分平滑的表面，并且 
下部保持粗糙。在掠射角度时，表面的下部将趋向于被遮蔽或遮盖， 
从而产生有效的更光滑的表面。见图9.28。对于所有表面类型，随 
着与法线的入射角θi的增加，表面不规则性的可见尺寸减小。在非 
常掠射的角度下，这种效果可以将观察到的不规则尺寸减小到比光 
的波长短，使得它们就光响应而言 “消失”。这两种效果与菲涅尔 
效应相结合，使得表面看起来具有高反射性和镜面效果，因为观察 
和照明角度接近90. [79,1873,1874]。自己确认一下。将一张无光 
纸卷成长管。而不是通过洞看，将你的眼睛稍高一点，所以你俯视 
它的3309.基于物理的阴影图9.28。所示的微观几何学在高度和表 
面法线之间具有很强的相关性，其中凸起区域是光滑的而下部区域 
是粗糙的。在顶部图像中，表面从接近宏观表面法线的角度照射。 
在这个角度，许多入射光线可以接触到粗糙的凹坑，并且许多光线 
在不同的方向上散射。在底部图像中，表面从掠射角照射。阴影会 
阻挡大部分凹坑，因此很少有光线照射它们，大多数光线都会从表 
面的光滑部分反射出来。在这种情况下，表观粗糙度很大程度上取 
决于照射角度。长度。将您的灯管指向明亮的窗户或电脑屏幕。当 
您的视角几乎与纸张平行时，您将看到纸张中窗口或屏幕的锐利反 
射。角度必须非常接近90.才能看到效果。微尺度表面细节遮挡的光 
----------------------- Page 361-----------------------
线不会消失。它可能反映在其他微观几何学上。在它到达眼睛之前， 
光可以以这种方式经历多次反弹。这种互反射显示在图9.27的右 
侧。由于在每次反弹时光被菲涅耳反射率衰减，因此在电介质中互 
相反射趋于微妙。在金属中，多次反射是任何可见漫反射的来源， 
因为金属缺乏次表面散射。彩色金属的多次反射反射比初级反射更 
深，因为它们是光与表面多次相互作用的结果。到目前为止，我们 
已经讨论了微观几何学对镜面反射率的影响，即表面反射率。在某 
些情况下，微尺度表面细节也会影响地下反射率。如果微观几何不 
规则性大于次表面散射距离，则阴影和掩蔽可以引起逆向反射效应， 
其中光优先被反射回入射方向。出现这种效果是因为当观看和照明 
方向差别很大时，遮蔽和遮蔽会遮挡被照亮的区域。见图9.29。逆 
向反射倾向于使粗糙表面具有平坦的外观。见图9.30。9.7。 
MicrofacetTheory331图9.29。由于微观粗糙度引起的逆向反射。 
两幅图都显示出具有低菲涅耳反射率和高散射反照率的粗糙表面， 
因此次表面反射在视觉上是重要的。在左侧，观看和照明方向类似。 
明亮的微观几何学部分也是最明显的部分，导致明亮的外观。在右 
侧，观看和照明方向差别很大。在这种情况下，明亮区域被遮挡， 
可见区域被遮蔽，导致外观较暗。图9.30。两个物体的照片由于微 
观表面粗糙度而表现出非朗伯，逆向反射行为。（照片右图由 
Peter-PikeSloan提供。）9.7 Microfacet理论许多 BRDF模型基 
于微观几何学对反射率影响的数学分析，称为微平面理论。该工具 
最初由光学界的研究人员开发[124]。它于1977年由 Blinn [159] 
----------------------- Page 362-----------------------
引入计算机图形学，1981年又由Cook和Torrance [285]引入。该 
理论基于微观几何的建模，作为微平面的集合。这些微小刻面中的 
每一个都是平坦的，具有单个微平面正常m。微平面根据微 BRDFf 
μ （l，v，m）单独反射光，所有微平面的组合反射率加到整个表面 
BRDF。通常的选择是每个微平面都是一个完美的菲涅耳镜，产生一 
个镜面微平面 BRDF，用于建模表面反射。但是，其他选择也是可 
能的。漫射微 BRDF 已被用于创建若干局部次表面散射模型 
[574,657,709,1198,1337]。衍射微 BRDF用于创建结合几何和波光 
学效应的阴影模型[763]。3329.基于物理的着色+++-- 图9.31。 
微表面的侧视图。在左边，我们看到积分 D （m）（n·m），投影 
到宏观表面平面上的微平面区域产生宏观表面的面积（在该侧视图 
中的长度），按照惯例为 1。在右边，积分 D （m） （v·m），投影 
到垂直于v 的平面上的微平面区域产生宏观表面到该平面上的投 
影，即cosθo或（v·n）。当多个微平面的投影重叠时，背面微平 
面的负投影区域抵消了 “额外的”正面微平面。 （在 MatejDrame 
的数字之后。）microfacet模型的一个重要特性是 microfacet法 
线m的统计分布。此分布由曲面的正态分布函数或NDF定义。一 
些参考文献使用术语 “法线分布”来避免与高斯正态分布混淆。我 
们将使用 D （m）来指代方程中的 NDF。NDFD （m）是微观几何 
表面区域上的微平面表面法线的统计分布[708]。将 D （m）积分在 
整个微平面法线上，得到微表面的面积。更有用的是，积分 D （m） 
 （n·m），D （m）投影到宏观表面平面上，按照惯例给出宏观曲面 
----------------------- Page 363-----------------------
贴片的面积等于1，如图9.31左侧所示。换句话说，投影 D （m） 
 （n·m）被归一化：Zm∈？D （m） （n·m）dm=1. （9.21）积分 
在整个球体上，这里用？表示，不同于本章中先前的球形积分，它 
仅集成在以 n为中心的半球上，由...表示。这种表示法用于大多数 
图形出版物，虽然有些参考文献[708]用来表示完整的球体。在实践 
中，图形中使用的大多数微结构模型都是高度场，这意味着对于外 
面的所有方向，D （m）=0。但是，公式9.21也适用于非高度场 
微观结构。更一般地，微表面和宏观表面在垂直于任何视图方向v 
的平面上的投影是相等的：Zm∈？D（m）（v·m）dm=v·n。（9.22） 
9.7。MicrofacetTheory333图9.32。对可见微平面的投影区域 亮（ 
红色）进行积分，得到宏观表面在垂直于v的平面上的投影面积。 
公式9.21和9.22中的点积不会被钳制为0.图9.31的右侧显示了原 
因。公式9.21和9.22强加了函数D （m）必须服从的约束是有效 
的NDF。直觉上，NDF就像是微平面法线的直方图。它在微平面 
法线更可能指向的方向上具有高值。大多数表面都有 NDF，在宏观 
表面法线 n处显示出强烈的峰值。第9.8.1节将介绍几种用于渲染 
的NDF模型。再看一下图9.31的右侧。尽管存在许多具有重叠投 
影的微平面，但最终用于渲染我们仅关注可见微平面，即在每个重 
叠集中最接近相机的微平面。这一事实表明了将投影的微平面区域 
与投影的宏观几何区域相关联的另一种方式：可见微平面的投影面 
积之和等于宏观表面的投影面积。我们可以通过定义掩蔽函数G1 
 （m，v）来数学地表达这一点，它给出了沿着视图向量v可见的具 
----------------------- Page 364-----------------------
有正常m的微平面的分数.G1 （m，v）D （m）的积分（v） ·m） 
+在球体上方然后给出投影到垂直于v：Z∈的平面上的宏观表面的 
面积。G1 （m，v）D （m） （v·m）+dm=v·n， （9.23），如图 
9.32所示。与公式9.22不同，公式9.23中的点积被钳制为零。此 
操作以第 1.2节中介绍的x +表示法显示。背面微平面不可见，因此 
在这种情况下不计算它们。乘积G1 （m，v）D （m）是可见法线 
的分布[708]。公式9.23对G1 （m，v）施加约束，但它不能唯一 
地确定它。存在满足给定微平面正态分布 D （m）[708]的约束的无 
限函数。这是因为 D （m）没有完全指定mi3349.基于物理的阴影 
交叉曲面。它告诉我们有多少微平面具有指向某些方向的法线，而 
不是它们如何排列。虽然多年来已经提出了各种G1功能，但是在 
Heitz[708]的优秀论文中，至少目前已经解决了使用哪种功能的困 
境。Heitz讨论了Smith掩蔽函数，该函数最初是为高斯正态分布 
[1665]导出的，后来推广到任意 NDF [202]。Heitz表明，在文献 
中提出的掩蔽函数中，只有两个 -Smith函数和Torrance-Sparrow 
 “V腔”函数[1779]- 等式9。因此在数学上是有效的。他进一步 
表明，Smith函数与Torrance-Sparrow函数的随机微表面行为更 
接近。Heitz还证明了Smith掩蔽函数是唯一可能的函数，它既遵 
循公式9.23又具有正常掩蔽独立性的方便性。这意味着G1 （m，v） 
的值不依赖于m的方向，只要m不是背面即，只要m·v≥0。史密 
斯G1函数具有以下形式：G1 （m ，v）=χ+ （m·v）1+？ （v）， 
 （9.24）其中χ+ （x）是正特征函数χ+ （x）= （1，其中x> 0,0， 
----------------------- Page 365-----------------------
其中x ≤0。（9.25）对于每个NDF，α （λ）函数是不同的。在 
Walter等人[1833]和 Heitz[708]的出版物中描述了对于给定NDF 
导出α的过程。史密斯屏蔽功能确实有一些缺点。从理论的角度来看， 
它的要求与实际表面的结构不一致[708]，甚至可能在物理上不可能 
实现[657]。从实用的角度来看，虽然它对于随机表面非常准确，但 
对于在法线方向和掩模之间具有更强依赖性的表面，例如图9.28所 
示的表面，其精度预计会降低，特别是如果表面具有一些重复结构 
 （和大多数面料一样）。然而，在找到更好的替代方案之前，它是 
大多数渲染应用程序的最佳选择。给定微观几何描述，包括微 BRDFf 
μ （l，v，m），正态分布函数D （m）和掩蔽函数G1 （m，v）， 
可以导出整个宏观表面BRDF[708,1833]：f （L，v）=Zm∈fμ （l， 
v，m）G2 （l，v，m）D （m） （m·l）+|n·l| （m·v）+|n·v |DM。 
 （9.26）该积分位于以n为中心的半球上，以避免收集来自地表下 
的光贡献。公式9.26使用联合屏蔽阴影函数G2 （l，v，m）代替 
屏蔽函数G1 （m，v）。此功能源自9.7。MicrofacetTheory335 
G1，给出了从两个方向可见的具有正常m的微平面的分数：视图 
向量v和光向量 l。通过包含G2函数，公式9.26使 BRDF能够考 
虑屏蔽和阴影，但不考虑微平面之间的互反射 （参见第329页的图 
9.27）。缺少微平面互反射是由公式9.26得出的所有 BRDF共有的 
限制。这样的BRDF有点太暗了。在第9.8.2和9.9节中，我们将 
讨论为解决此限制而提出的一些方法。Heitz[708]讨论了G2函数 
的几个版本。最简单的是可分离形式，其中使用G1分别评估掩蔽 
----------------------- Page 366-----------------------
和阴影并乘以：G2 （l，v，m）=G1 （v，m）G1 （l，m）。 （9.27） 
此表格相当于假设掩蔽和阴影是不相关的事件。实际上它们不是， 
并且假设使用这种形式的G2导致 BRDF过度变暗。作为一个极端 
的例子，考虑视图和光线方向相同的情况。在这种情况下，G2应该 
等于G1，因为没有任何可见小平面被遮蔽，但是公式9.27G2将等 
于G21。如果微表面是高度场，这通常是渲染中使用的微表面模型 
的情况，然后每当v和l之间的相对方位角φ等于0.时，G2 （l，v， 
m）应该等于min （G1 （v，m）， G1 （L，M））。有关φ的说 
明，请参见第311页的图9.17。这种关系表明了一种解决掩蔽和阴 
影之间相关性的一般方法，它可以用于任何G1函数：G2 （l，v， 
m）=λ （φ）G1 （v，m）G1 （l，m）+ （1.λ （φ））min （G1 
 （v，m），G1 （l，m）），（9.28）其中，λ （φ）是随角度φ增 
加而从0增加到 1的某种函数。Ashikhmin等。[78]建议高斯标准 
偏差为15. ~0.2（ 6弧度）：λ φ（）=1。e.7.3？2。9.29（ ）vanGinneken 
等人提出了不同的λ函数。[534]：λ （φ）=4.41φ4.41φ+1。 （9.30） 
无论光线和视图方向的相对对齐如何，另一个原因是在给定表面点 
处的掩蔽和阴影是相关的。两者都与点相对于表面其余部分的高度 
有关。对于较低点，掩蔽的概率增加，并且遮蔽的概率也增加。如 
果使用Smith掩蔽函数，则可以通过Smith高度相关掩蔽阴影函数 
精确地解释这种相关性：G2 （l，v，m）=χ+ （m·v）χ+ （m·l）1+？ 
 （v）+？ （l）。 （9.31）3369.基于物理的阴影Heitz还描述了一 
种结合方向和高度相关性的SmithG2形式：G2 （l，v，m）=χ+ 
----------------------- Page 367-----------------------
 （m·v）χ+ （m·l）1+max （？ （v），？ （l））+λ （v，l）min 
 （？（v），？（l）），（9.32）其中函数λ （v，l）可以是经验函 
数，如公式9.29和9.30中的公式，或专门针对给定NDF[707]的 
公式。在这些替代方案中，Heitz[708]推荐了Smith函数的高度相 
关形式 （公式9.31），因为它具有与不相关形式相似的成本和更高 
的精度。这种形式是在实践中最广泛使用的[861,947,960]，尽管一 
些从业者使用可分离的形式 （公式9.27）[214,1937]。一般的微平 
面 BRDF （公式9.26）不直接用于渲染。在给定微BRDFfμ的特定 
选择的情况下，它用于导出闭合形式的解（精确或近似）。这种派 
生的第一个例子将在下一节中给出。9.8用于表面反射的 BRDF模 
型除了少数例外，基于物理渲染的镜面 BRDF术语来自于微观理论。 
在镜面反射的情况下，每个microfacet都是一个非常光滑的菲涅耳 
镜。回想一下，这种镜子在单个反射方向上反射每个入射光线。这 
意味着每个小平面的微BRDFfμ （l，v，m）等于零，除非v平行于 
l的反射。对于给定的l和v 向量，该配置等同于微平均法线m与 
指向l和v之间正好中间的向量对齐的情况。该向量是半向量h。见 
图9.33。它通过添加v和l并对结果进行归一化来计算：h=l+v || 
l+v ||。 （9.33）图9.33。半矢量h与光和视图矢量形成相等的角 
度（以红色显示）。9.8。用于表面反射的 BRDF 模型 337 
lhvvvvvvvhhhhhhllllll图9.34。表面由微平面组成。只有红色的微 
观，它们的表面法线与半矢量 h对齐，参与从入射光矢量 l到视图 
矢量v的光反射。当从公式9.26导出镜面微平面模型时，菲涅耳镜 
----------------------- Page 368-----------------------
微观 BRDFfμ的事实（l，v，m）对于所有m都等于零6 =h是方 
便的，因为它将积分折叠成m=h时的积分函数的评估。这样做产 
生镜面 BRDF项fspec （l，v）=F （h，l）G2 （l，v，h）D （h） 
4 |n·l||n·v |。 （9.34）关于推导的细节可以在Walter等人的出版 
物中找到。[1833]，Heitz[708]和 Hammon[657]。Hammon还 
展示了一种通过计算n·h和l·h来优化 BRDF实现的方法，而无需计 
算向量h本身。我们在公式9中使用符号fspec作为 BRDF项。34 
表示它仅模拟表面（镜面）反射。在完整的 BRDF中，它可能会与 
模拟次表面 （漫反射）着色的附加术语配对。为了对公式9.34提供 
一些直觉，考虑只有那些碰巧使其法线与半矢量（m =h）对齐的 
微平面才能正确定向，以便将光从 l反射到v。见图9.34。因此， 
反射光的量取决于法线等于 h的微平面的浓度。该值由D （h）给 
出，从光和视图方向可见的那些微平面的分数，等于G2 （l，v，h）， 
以及每个微平面反射的光的部分，由F （h，l）指定。在菲涅耳函数 
的评估中，向量h代替表面法线，例如，在第320页上的公式9.16 
中评估Schlick近似时。在屏蔽阴影函数中使用半矢量可以实现轻 
微的简化。由于所涉及的角度永远不会大于90°，​ ​ 因此可以去 
除等式9.24,9.31和9.32中的χ+项。9.8.1正态分布函数正态分布 
函数对渲染曲面的外观有显着影响。在微平面法线球体上绘制的 
NDF的形状决定了反射光锥的宽度和形状 （镜面反射3389.基于物 
理的阴影图9.35。左边的图像是用非物理的渲染的Phong反射模 
型。该模型的镜面波瓣围绕反射矢量旋转对称。这种 BRDF经常在 
----------------------- Page 369-----------------------
计算机图形学的早期使用。中心的图像使用基于物理的microfacet 
BRDF进行渲染。左上角和中间显示了一个以掠射角点亮的平面。 
左上角显示不正确的圆形突出显示，而中心显示微平面 BRDF上的 
特征突出显示伸长。该中心视图与现实相符，如右图所示。高亮度 
形状的差异在下面两个渲染图像中显示的球体上更加微妙，因为在 
这种情况下，表面曲率是高光形状的主要因素。照片由（       ElanRuskin 
提供。）lobe），反过来决定了镜面高光的大小和形状。NDF影响 
表面粗糙度的整体感知，以及更微妙的视觉方面，例如高光是否具 
有明显的边缘或被雾霾包围。然而，镜面波瓣不是 NDF形状的简单 
副本。根据表面曲率和视角，它以及因此高光形状被或多或少地扭 
曲。对于在掠射角处观察的平坦表面，这种扭曲特别强烈，如图9.35 
所示。Ngan等人。[1271]提出了对这种扭曲背后原因的分析。各 
向同性正态分布函数渲染中使用的大多数NDF是关于宏观表面法 
线 n的各向同性 - 旋转对称的。在这种情况下，NDF只是一个变 
量的函数，n与微平均法线m之间的角度θm。理想的情况下，NDF 
可以写成cosθm的表达式，可以有效地计算为n和 m的点积。 
BeckmannNDF[124]是由光学界开发的第一个微平面模型中使用 
的正态分布。它至今仍在该社区广泛使用。它也是为Cook-Torrance 
BRDF选择的 NDF[285,286]。归一化贝克曼分布具有以下形式：D 
 （m）=χ+ （n·m）πα2b （n·m）4exp？ （n·m）2。1α2b （n·m） 
2？。 （9.35）术语χ+ （n·m）确保 NDF的值对于所有的微平均法 
线9.8为0。用于表面反射的BRDF模型339指向宏观表面下。该 
----------------------- Page 370-----------------------
属性告诉我们，这个 NDF，就像我们将在本节中讨论的所有其他 
NDF一样，描述了高度场显微表面。αb参数控制表面粗糙度。它 
与微观几何表面的均方根 （RMS）斜率成比例，因此αb=0表示完 
全光滑的表面。为了得到 BeckmannNDF的SmithG2函数，我 
们需要相应的？函数，插入公式9.24（如果使用G2的可分离形式）， 
9.31 （对于高度相关形式），或9.32 （对于方向和高度相关形式）。 
BeckmannNDF是形状不变的，它简化了α的推导。如 Heitz[708] 
所定义的，如果其粗糙度参数的效果等于缩小（拉伸）微表面，则 
各向同性 NDF是形状不变的。形状不变的 NDF可以用以下形式写 
出：D （m）=χ+ （n·m）α2 （n·m）4gp1。 （n·m）2α （n·m）！， 
 （9.36）其中g代表任意单变量函数。对于任意各向同性 NDF，的？ 
功能取决于两个变量。第一个是粗糙度α，第二个是矢量（v或l） 
的入射角，其中？计算。然而，对于形状不变的 NDF，？函数仅取 
决于变量a：a =n·sαp1。（n·s）2，（9.37）其中s是表示v或l 
的向量。事实是？在这种情况下，仅依赖于一个变量便于实现。单 
变量函数可以更容易地拟合近似曲线，并且可以在一维数组中制表。 
的？BeckmannNDF的函数是？（a）=erf （a）。12 +12a√π 
exp （.a2）。 （9.38）公式9.38的评估成本很高，因为它包括误差 
函数erf。因此，通常使用近似值[1833]：？（a）≈ （1.1.259a+ 
0.396a23.535a+2.181a2，其中a <1.6，0，其中a≥1.6。 （9.39） 
我们将讨论的下一个 NDF是 Blinn-PhongNDF。它在过去被广泛 
用于计算机图形学，尽管最近它已被其他发行版取代。Blinn-Phong 
----------------------- Page 371-----------------------
NDF仍然用于计算非常宝贵的情况 （例如，在移动硬件上），因为 
计算成本比本节讨论的其他 NDF 便宜。基于物理的阴影 
Blinn-PhongNDF由Blinn[159]推导出来作为 非物理的（ ）Phong 
阴影模型的修改[1414]：D （m）=χ+ （n·m）αp+22π （n·m）？ 
p。（9.40）功率αp是 PhongNDF的粗糙度参数。高值表示光滑 
表面，低值表示粗糙表面。对于非常光滑的表面，αp的值可以任意 
高 - 完美的镜子需要αp=∞。通过将αp设置为0，可以实现最大 
随机表面（均匀NDF）.αp参数不便于直接操作，因为其视觉冲击 
非常不均匀。对于小的αp值，小的数值变化具有大的视觉效果，但 
是可以在没有太多视觉影响的情况下显着改变大的值。因此，αp通 
常通过非线性映射从用户操纵的参数导出。例如，αp=ms，其中s 
是0和 1之间的参数值，m是给定应用中αp的上限。这种映射被 
几个游戏使用，包括使命召唤：黑色行动，其中m被设置为值8192 
[998]。当BRDF参数的行为在感知上不均匀时，这种 “接口映射” 
通常是有用的。这些映射用于解释通过滑块设置的参数或绘制在纹 
理中的参数。使用关系αp=2α2b 可以找到 Beckmann 和 
Blinn-Phong粗糙度参数的等效值。2 [1833]。当参数以这种方式 
匹配时，两个分布非常接近，特别是对于相对平滑的表面，如图9.36 
左上角所示。Blinn-PhongNDF不是形状不变的，并且它不存在分 
析形式？功能。沃尔特等人。[1833]建议使用贝克曼？与αp=2α.2b 
一起起作用。2参数等价。在1977年的论文[159]中，Blinn将Phong 
着色函数转换为微型 NDF，他提出了另外两个NDF。在这三个发 
----------------------- Page 372-----------------------
行版中，Blinn推荐了一个由Trowbridge和 Reitz[1788]衍生的发 
行版。这一建议没有受到广泛关注，但30年后，特罗布里奇 - 赖 
茨分布被沃尔特等人独立重新发现。[1833]，谁将其命名为GGX发 
行版。这一次，种子扎根了。几年之内，GGX发行版的采用开始在 
电影[214,1133]和游戏[861,960]行业中传播，而今天它可能是两者 
中最常用的发行版。Blinn的推荐似乎已经提前了 30年。尽管 
 “Trowbridge-Reitz发行版”在技术上是正确的名称，但我们在本 
书中使用了GGX名称，因为它已经确立。GGX分布是 D （m）=χ 
+ （n·m）α2gπ...1+ （n·m）2...α2g。1??2。（9.41）αg参数 
提供的粗糙度控制类似于 Beckmannαb参数提供的粗糙度控制。 
在迪士尼原则阴影模型中，Burley[214]公开了9.8。用于表面反射 
的BRDF模型 341图9.36。在左上方，比较了Blinn-Phong （蓝 
色虚线）和 Beckmann （绿色）分布，αb值在0.025到0.2之间 
 （使用参数关系αp=2α.2b.2）。在右上角，比较GGX （红色）和 
Beckmann （绿色）分布。αb的值与左图中的相同。通过眼睛调整 
αg的值以匹配高光尺寸。这些相同的值已用于底部图像上渲染的球 
体中。顶行使用 BeckmannNDF，底行使用GGX。对用户的粗糙 
度控制为αg= r2，其中r是0和 1之间的用户界面粗糙度参数值。 
将 r作为滑块值公开意味着效果以更线性的方式变化。大多数使用 
GGX发行版的应用程序都采用了这种映射。GGX分布是形状不变 
的，它的？功能比较简单：？（a）=。1+q1+1a22。（9.42） 
变量a仅作为a2出现在公式9.42中这一事实很方便，因为可以避 
----------------------- Page 373-----------------------
免公式9.37中的平方根。由于GGX发行版和史密斯掩蔽阴影函数 
的普及，人们一直致力于优化两者的组合。Lagarde观察到[960] 
GGX的高度相关SmithG2 （公式9.31）具有与镜面微平面BRDF 
的分母（公式9.34）组合时抵消的项。因此可以简化组合项：G2 
 （l，v）4 |n·l||n·v | =。0.5μpip2+μi （μi.α2μi）+μippα2+μo 
 （μo.α2μo）。（9.43）3429。基于物理的着色镀铬GGXBeckmann 
图9.37。NDF适合 MERL数据库中的测量铬。在左边，我们有针 
对铬 （黑色），GGX （红色;αg=0.006），贝克曼 （绿色;αb=0.013） 
和 Blinn-Phong （蓝色虚线;n=12000）的θm的镜面峰值图。右 
侧显示的渲染高光显示为chrome，GGX和 Beckmann。 （图片由 
BrentBurley[214]提供。）为了简洁，该等式使用变量替换μi= （n·l） 
+和μo= （n·v）+。Karis[861]提出了GGX的SmithG1函数的近 
似形式：G1 （s）≈2 （n·s）（n·s）（2.α）+α，（9.44）其中s 
可以用l或v。Hammon[657]表明这种近似形式的G1导致了由高 
度相关的SmithG2函数和镜面微平面BRDF分母组成的组合项的 
有效近似：G2 （l，v）4 |n·l||n ·v |≈0.5lerp （2|n·l||n·v |，|n·l 
|+|n·v |，α）， （9.45）使用线性插值算子，lerp （x，y，s）=x 
 （1.s）+ys。当比较图9.36中的GGX和 Beckmann分布时，很 
明显两者具有根本不同的形状。GGX比Beckmann具有更窄的峰 
值，以及围绕这些峰值的更长的 “尾巴”。在图底部的渲染图像中， 
我们可以看到GGX较长的尾部会在高光的核心周围产生雾霾或发 
光的外观。许多真实世界的材料都显示出类似的朦胧亮点尾部通常 
----------------------- Page 374-----------------------
比GGX分布的尾部长[214]。见图9.37。这种认识一直是GGX分 
布日益普及的重要因素，同时也在不断寻找能够更准确地拟合测量 
材料的新分布。Burley[214]提出了广义Trowbridge-Reitz （GTR） 
NDF，其目标是允许更多地控制 NDF的形状，特别是分布的尾部： 
D （m）=k （α，γ）π... 1 + （n·m）2..α2g。1??。（9.46）γ 
参数控制尾部形状。当γ=2时，GTR与GGX相同。随着γ的值减 
小，分布的尾部变得更长，并且随着它的增加，9.8。用于表面反射 
的 BRDF模型 343它们变得更短。在高γ值时，GTR分布类似于 
Beckmann。k （α，γ）项是归一化因子，我们在一个单独的方程 
中给出，因为它比其他NDF更复杂：k （α，γ）=......... （。1） （？ 
2.1 ）（1。（？2）（1。）），其中γ6= 1且α6= 1，（？2.1） 
ln （？2），其中γ=1且α6=1,1，其中α=1. （9.47）GTR分布不 
是形状不变的，这使得找到其SmithG2掩蔽阴影函数变得复杂。 
NDF出版后花了三年时间才发布了G2的解决方案[355]。这个G2 
解决方案非常复杂，有一些针对某些γ值的解析解表（对于中间值， 
必须使用插值）。GTR的另一个问题是参数α和γ以非直观的方式影 
响感知的粗糙度和 “发光”。学生t分布（STD）[1491]和指数幂 
分布 （EPD）[763]NDF包括形状控制参数。与GTR相比，这些函 
数在其粗糙度参数方面是形状不变的。在撰写本文时，这些是新发 
布的，因此尚不清楚它们是否可以在应用程序中使用。不是增加 
NDF的复杂性，更好地匹配测量材料的替代解决方案是使用多个镜 
面波瓣。库克和托兰斯[285,286]提出了这个想法。它由Ngan[1271] 
----------------------- Page 375-----------------------
进行了实验测试，他发现对于许多材料来说，添加第二个叶片确实 
可以显着提高贴合度。皮克斯的 PxrSurface材料[732]有一个 “粗 
糙的”叶片，旨在用于此目的（与主镜面相连）。附加波瓣是一个 
完整的镜面微平面BRDF，包含所有相关参数和术语。Imageworks 
使用更多手术方法[947]，使用两个GGX NDF的混合物作为扩展 
NDF暴露给用户，而不是整个单独的镜面BRDF术语。在这种情况 
下，所需的唯一附加参数是第二粗糙度值和混合量。各向异性正态 
分布函数虽然大多数材料具有各向同性表面统计，但有些材料的微 
观结构具有显着的各向异性，这显着影响它们的外观，例如，第329 
页的图9.26。为了准确地渲染这些材料，我们需要BRDF，特别是 
各向异性的 NDF。 。与各向同性 NDF不同，不能仅用角度θm来 
评估各向异性NDF。需要其他方向信息。在一般情况下，需要将微 
平面法线m转换为由法线，切线和双切线矢量分别定义的局部框架 
或切线空间 n，t和 b。请参见第210页的图6.32。实际上，此转 
换通常表示为三个单独的点积：m·n，m·t和m·b。3449.基于物理 
的着色当将法线贴图与各向异性BRDF组合时，重要的是确保法线 
贴图扰动切线和切线矢量以及法线。该过程通常通过将修改的 
Gram-Schmidt过程应用于扰动的法线n和内插的顶点切线和双切 
向量t0和b0 （下面假设n已经被归一化）来完成：t'=t0。 （t0·n） 
n=。t =t'kt'k，b'=b0。 （b0·n）n，b''=b'。 （b'·t）t）=。b= 
b''kb''k。 （9.48）或者，在第一行之后，可以通过取n和t的叉积 
来产生正交b向量。对于诸如拉丝金属或卷发之类的效果，需要对 
----------------------- Page 376-----------------------
切线方向进行逐像素修改，通常由切线图提供。此贴图是存储每像 
素切线的纹理，类似于法线贴图存储每像素法线的方式。切线图最 
常将切线矢量的二维投影存储在垂直于法线的平面上。此表示适用 
于纹理过滤，可以像普通地图一样进行压缩。某些应用程序存储标 
量旋转量，用于围绕n旋转切向量。虽然这种表现形式更紧凑，它 
很容易出现纹理过滤伪影，其中旋转角度从360°到0周围。创建各 
向异性NDF的常用方法是推广现有的各向同性NDF。所使用的一 
般方法可以应用于任何形状不变的各向同性 NDF[708]，这是形状 
不变的 NDF优选的另一个原因。回想一下，各向同性形状不变的 
NDF可以用以下形式写出：D （m）=χ+ （n·m）α2 （n·m）4gp1。 
 （n·m）2α （n·m）！， （9.49）其中g表示表示NDF形状的一维 
函数。各向异性形式是D （m）=χ+ （n·m）αxαy （n·m）4g。。 
q （t·m）2≤2×+ （b·m）2≤2y （n·m）。.. （9.50）参数αx和αy 
分别表示沿t和b方向的粗糙度。如果αx=αy，则公式9.50缩减回 
各向同性形式。各向异性NDF的G2掩蔽阴影函数与各向同性NDF 
的相同，除了变量a（传入函数）的计算方式不同：a =n·sqα2x （t·s） 
2 +α2y （b ·s）2，（9.51）其中（如公式9.37所示）s代表v或 
l。9.8。用于表面反射的BRDF模型 345图9.38。使用各向异性 
NDF渲染的球体：顶行的Beckmann和底行的GGX。在两行中， 
αy保持不变，αx从左向右增加。使用该方法，已经为 Beckmann 
NDF推导出各向异性版本，D （m）=χ+ （n·m）παxαy （n·m） 
4exp。.. （t·m）2？2x + （b·m）2？2y （n·m）2。。，（9.52） 
----------------------- Page 377-----------------------
和GGXNDF，D （m）=χ+ （n·m）παxαy？ （t·m）2≤2×+ （b·m） 
2≤2y+ （n·m）2≤2。 （9.53）两者都如图9.38所示。虽然参数化 
各向异性 NDF的最直接方法是使用各向同性粗糙度参数化两次，一 
次用于αx，一次用于αy，有时使用其他参数化。在迪士尼原理着色 
模型[214]中，各向同性粗糙度参数 r与第二标量参数kaniso组合， 
范围为[0,1]。因此，从这些参数计算αx和αy值：kaspect =p1。 
0.9kaniso，αx= r2kaspect，αy= r2kaspect。 （9.54）0.9因子 
将纵横比限制为 10：1.3469.基于物理的着色 Imageworks[947] 
使用允许任意程度的各向异性的不同参数化：αx=r2 （1+kaniso）， 
αy= r2 （1.kaniso）。 （9.55）9.8.2多次反射表面反射如前面第 
9.7节所述，微平面 BRDF框架不考虑从微表面多次反射 （“反弹”） 
的光。这种简化会导致一些能量损失和过度变暗，尤其是粗糙金属 
[712]。Imageworks [947]使用的技术结合了先前工作[811,878] 
中的元素来创建可以添加到BRDF以模拟多次反射表面反射的项： 
fms （l，v）=FRsF1π （1。 RsF1）..1。F （1.RsF1）？..1。RsF1 
 （1）？1。RsF1 （v）？，（9.56）其中RsF1是fsF1的方向反照 
率（9.3节），它是 F0设定为1的镜面BRDF项。函数 RsF1取决 
于粗糙度α和仰角θ。它相对平滑，因此可以在数值上预先计算 （使 
用公式9.8或9.9）并存储在小的二维纹理中。Imageworks发现 
32×32分辨率就足够了。函数 RsF1是半球上 RsF1的余弦加权平 
均值。它仅取决于α，因此可以存储在一维纹理中，或者可以将廉价 
的曲线拟合到数据中。由于RsF1关于 n旋转对称，因此可以用一 
----------------------- Page 378-----------------------
维积分计算 RsF1。我们还使用变量μ=cosθ的变化 （参见第312页 
的公式9.6）：RsF1=Rs∈RsF1 （s） （n·s）dsRs∈ （n·s）ds=1 
πZ2？？=0Z1μ=0 RsF1 （μ）μdμdφ=2Z1μ=0 RsF1 （μ）μ 
dμ。（9.57）最后，F是菲涅耳项的余弦加权平均值，以相同的方 
式计算：F=2Z1μ=0 F （μ）μdμ。（9.58）在广义Schlick形式 
 （公式9.18）用于F的情况下，Imageworks为公式9.58提供了 
一种封闭形式的解决方案：F=2p2F90 + （3p +1）F02p2 +3p 
+1。 （9.59）9.9。用于次表面散射的 BRDF模型347图9.39。在 
所有行中，表面的粗糙度从左到右增加。前两行显示金色材质。第 
一行是在没有 Imageworks多次反弹项的情况下渲染的，第二行是 
使用多次反弹项渲染的。对于较粗糙的球体，差异最明显。接下来 
的两行显示黑色介电材料。第三行是在没有多次反弹项的情况下渲 
染的，第四行是应用了多次反弹项。这里的差异更微妙，因为镜面 
反射率要低得多。（图片由Christopher Kulla[947]提供。）如果 
使用原始Schlick近似 （公式9.16），则解决方案简化为 F=2021 
F0+121。 （9。60）在各向异性的情况下，Imageworks使用αx 
和αy之间的中间粗糙度来计算fms。这种近似避免了增加RsF1查 
找表的维度的需要，并且它引入的错误很小。Imageworks多次反 
射镜面反射术语的结果如图9.39所示。9.9用于次表面散射的BRDF 
模型在上一节中，我们讨论了表面或镜面反射。在本节中，我们将 
讨论问题的另一面，即在表面下折射的光会发生什么。正如我们在 
9.1.4节中讨论的那样，这种光经过一些散射和吸收的组合，其中一 
----------------------- Page 379-----------------------
部分被重新发射回原始表面。我们将重点关注局部次表面散射或漫 
反射表面响应的 BRDF模型，在不透明的电介质中。金属是无关紧 
要的，因为它们没有任何明显的地下光相互作用。第 14章将介绍透 
明或表现出全局次表面散射的介电材料.3489.基于物理的着色我们 
开始讨论漫反射模型，其中有关于漫反射颜色属性的部分以及此颜 
色可能具有的实际值 - 世界材料。在下面的小节中，我们将解释表 
面粗糙度对漫反射着色的影响，以及选择是否对给定材料使用光滑 
表面或粗糙表面着色模型的标准。最后两个小节专门讨论光滑表面 
和粗糙表面模型本身。9.9。1地下反照率不透明电介质的地下反照 
率ρss是从表面逸出的光的能量与进入材料内部的光的能量之间的 
比率。ρss的值在0之间（所有光被吸收）和 1 （没有光被吸收） 
并且可以取决于波长，因此ρss被建模为用于渲染的 RGB矢量。对 
于创作，ρss通常被称为表面的漫反射颜色，正常入射菲涅耳反射 
率 F0通常被称为镜面反射颜色。地下反照率与第 14.1节中讨论的 
散射反照率密切相关。由于电介质传输大部分入射光而不是在表面 
反射它，因此地下反照率ρss通常更亮，因此在视觉上比镜面颜色 
F0更重要。由于它是由不同的物理过程产生的，而不是内部的镜面 
颜色吸收而不是表面的菲涅耳反射率-ρss通常具有与 F0不同的光 
谱分布 （因此RGB颜色）。例如，彩色塑料由透明，透明的基材组 
成，其内部嵌有颜料颗粒。镜面反射的光将是未着色的，而漫反射 
的光将被颜料颗粒的吸收着色;例如，红色塑料球有白色突出显示。 
次表面反照率可以被认为是吸收和散射之间 “竞争”的结果 - 光会 
----------------------- Page 380-----------------------
在它有机会被散射回物体之前被吸收吗？这就是液体上的泡沫比液 
体本身更亮的原因。发泡过程不会改变液体的吸收率，但是添加许 
多气液界面会大大增加散射量。这导致大部分入射光在被吸收之前 
被散射，导致高地下反照率和明亮的外观。新鲜雪是具有高反照率 
的物质的另一个例子。雪粒和空气之间的界面存在相当大的散射， 
但吸收很少，导致可见光谱中的地下反照率为0.8或更高。白色涂 
料略少，约为0.7。日常生活中遇到的许多物质，如混凝土，石头和 
土壤，平均在0.15到0.4之间。煤是具有极低地下反照率的材料的 
一个例子，接近0.0。许多材料在湿润时变暗的过程与液体泡沫例子 
相反。如果材料是多孔的，水会渗透到以前充满空气的空间中。介 
电材料的折射率更接近水而不是空气。相对折射率的降低降低了 
9.9。用于次表面散射的BRDF模型 349在材料内部散射，并且光 
在逃逸材料之前行进更长的距离（平均）。这种变化导致更多的光 
被吸收，并且地下反照率变得更暗[821]。这是一种常见的误解 （甚 
至反映在备受推崇的材料创作指南[1163]中），对于真实材料，ρss 
的值绝不应低于约0.015-0.03（8位非线性sRGB编码中的30-50） 
的下限创作。然而，该下限基于包括表面（镜面）以及表面下（漫 
反射）反射率的颜色测量，因此太高。实际材料可以具有较低的值。 
例如， “OSHABlack”涂料标准[524]的联邦规范的Y值为0.35 （满 
分 100）。给定测量条件和表面光泽度，该Y对应于约0.0035的ρ 
ss值 （8位非线性sRGB编码中为 11）。当从真实世界的表面获取 
ρss的点值或纹理时，重要的是分离出镜面反射。这种提取可以通 
----------------------- Page 381-----------------------
过小心使用受控照明和偏振滤光片来完成[251,952]。为了获得准确 
的颜色，还应进行校准[1153]。并非每个RGB三元组代表ρss的合 
理（或甚至物理上可能）值。反射光谱比发射光谱功率分布更受限 
制：对于任何波长，它们永远不会超过1，并且它们通常非常光滑。 
这些限制定义了颜色空间中的体积，其中包含ρss的所有合理的 
RGB值。即使是相对较小的sRGB色域也包含此体积以外的颜色， 
因此在设置ρss的值时必须小心，以避免指定不自然饱和和明亮的 
颜色。除了降低真实感外，在预先计算全局照明时，这些颜色会导 
致过亮的二次反射（见第 11.5.1节）。孟等人的2015年论文。[1199] 
是该主题的良好参考。9.9.2次表面散射和粗糙度的尺度一些用于局 
部次表面散射的 BRDF模型考虑了表面粗糙度 - 通常使用具有漫 
射微 BRDFfμ的微平面理论，而有些则没有。使用哪种模型的决定 
因素不仅仅是表面的粗糙程度，尽管这是一种常见的误解。正确的 
决定因素涉及表面不规则性和次表面散射距离的相对大小。见图 
9.40。如果微观几何不规则性大于次表面散射距离 （图的左上角）， 
那么次表面散射将表现出与微观几何相关的效果，例如逆向反射（第 
331页的图9.29）。对于这样的表面，应该使用粗糙表面漫射模型。 
如上所述，此类模型通常基于微平面理论，其中次表面散射被处理 
为每个微平面的局部，因此仅影响微BRDFfμ。如果散射距离都大 
于不规则性 （图9.40的右上角），那么为了对次表面散射进行建模， 
表面应该被认为是平坦的，并且不会发生逆向反射等效果。次表面 
3509.基于物理的着色图9.40。三个表面具有相似的NDF，但微观 
----------------------- Page 382-----------------------
几何尺度与次表面散射距离之间的关系不同。在左上方，次表面散 
射距离小于表面不规则性。在右上方，散射距离大于表面不规则性。 
下图显示了具有多个刻度粗糙度的微表面。红色虚线表示仅包含大 
于次表面散射距离的微结构的有效表面。散射不是微平面的局部， 
并且不能通过微平面理论建模。在这种情况下，应使用光滑表面漫 
反射模型。在表面具有比散射距离更大和更小的尺度的粗糙度的中 
间情况下，应该使用粗糙表面漫射模型，但是具有仅包括大于散射 
距离的不规则性的有效表面。漫反射和镜面反射都可以用微平面理 
论建模，但每个都具有不同的粗糙度值。镜面术语将使用基于实际 
表面粗糙度的值，并且漫反射术语将使用较低的值，基于有效表面 
的粗糙度。观察的范围也与此相关，因为它决定了 “微观几何学” 
的定义。例如，月球经常被引用作为应该使用粗糙表面漫射模型的 
情况，因为它表现出显着的逆向反射。当我们从地球上看月球时， 
观测的规模就是这样，即使是一个5英尺的巨石也是“微观几何学”。 
因此，我们观察到诸如逆向反射之类的粗糙表面漫反射效应就不足 
为奇了。9.9.3光滑表面次表面模型这里我们将讨论光滑表面次表面 
模型。这些适用于表面不规则性小于次表面散射距离的材料建模。 
漫反射阴影不受 9.9表面粗糙度的直接影响。用于次表面散射的 
BRDF模型351这样的材料。如果漫反射和镜面反射项是耦合的（本 
节中的某些模型就是这种情况），那么表面粗糙度可能会间接影响 
漫反射阴影。如9.3节所述，实时渲染应用程序通常使用朗伯项来 
模拟局部次表面散射。在这种情况下，BRDF扩散项是ρssoverπ： 
----------------------- Page 383-----------------------
fdiff （l，v）=ρssπ。（9.61）朗伯模型没有考虑到表面反射的光 
不能用于次表面散射的事实。为了改进该模型，应该在表面 （镜面） 
和次表面（漫反射）反射项之间进行能量权衡。菲涅耳效应意味着 
这种表面 - 次表面能量权衡随入射光角度θi而变化。随着入射角越 
来越大，漫反射率随着镜面反射率的增加而降低。解释这种平衡的 
一种基本方法是将弥散项乘以一减去镜面项[1626]的菲涅耳部分。 
如果镜面术语是平面镜的那个，则得到的漫射项是fdiff （l，v）= 
 （1.F （n，l））ρssπ。 （9.62）如果镜面术语是一个微平面 BRDF 
项，那么得到的漫反射项是fdiff （l，v）= （1.F （h，l））ρssπ。 
 （9.63）公式9.62和9.63导致出射光的均匀分布，因为 BRDF值 
不依赖于输出方向v。这种行为有一定意义，因为光在重新发射之 
前通常会经历多次散射事件，因此传出方向将随机化。但是，有两 
个原因可以怀疑出射光的分布不均匀。首先，由于公式9.62中的扩 
散 BRDF项随输入方向而变化，因此亥姆霍兹互易意味着它必须通 
过输出方向改变。第二，光线必须在出路时经历折射，这将对出射 
光施加一些方向偏好。Shirley等人。提出了平面耦合漫射项，解决 
菲涅耳效应和表面 - 次表面反射率的权衡，同时支持节能和亥姆霍 
兹互易[1627]。推导假设Schlick近似[1568] （公式9.16）用于菲 
涅耳反射：fdiff （l，v）=2120π （1.F0）ρss？1。？1。 （n·l）+？ 
5?? 1。？1。 （n·v）+？5？。 （9.64）公式9.64仅适用于镜面反 
射率是完美菲涅耳镜的表面。3529提出了一个可用于计算倒数， 
节能扩散项以与任何镜面项耦合的通用版本。基于物理的阴影 
----------------------- Page 384-----------------------
Ashikhmin和 Shirley [77]并由 Kelemen和 Szirmay-Kalos进一 
步完善[878]：fdiff （l，v）=ρss..1。Rspec （l）？..1。Rspec （v）？ 
π.. 1。Rspec？。（9.65）这里，Rspec是镜面反射项的方向反照 
率（第9.3节），Rspec是半球上的余弦加权平均值。可以使用公 
式9.8或9.9预先计算值Rspec并将其存储在查找表中。平均Rspec 
的计算方法与我们之前遇到的类似平均值相同：RsF1 （公式9.57）。 
公式9.65中的形式与公式9.56有一些明显的相似之处，这并不奇 
怪 ， 因 为 Imageworks 多 次 反 弹 镜 面 项 源 自 
Kelemen-Szirmay-Kalos耦合漫反射项。但是，有一个重要的区别。 
在这里，我们使用 Rspec代替 RsF1，完全镜面BRDF项的方向反 
照率包括菲涅耳，如果使用的话，还有多次反射镜面项fms。这种 
差异增加了 Rspec查找表的维度，因为它不仅取决于粗糙度α和仰 
角θ ，还取决于菲涅耳反射率。在 Imageworks 实现的 
Kelemen-Szirmay-Kalos耦合漫射项中，他们使用三维查找表，折 
射率为第三轴[947]。他们发现在积分中包含多次反弹项使Rspec 
比RsF1更平滑，因此 16×16×16表就足够了。图9.41显示了结 
果。如果 BRDF使用SchlickFresnel近似并且不包括多次反射镜面 
项，那么F0的值可以从积分中计算出来。这样做允许我们为 Rspec 
使用二维表，在每个条目中存储两个量，而不是三维表，如 Karis 
[861]所讨论的。或者，Lazarov[999]提出了一个适用于 Rspec的 
解析函数，类似地将F0从积分中分解出来以简化拟合函数。卡里斯 
和拉扎罗夫都使用镜面方向反照率Rspec用于与基于图像的照明相 
----------------------- Page 385-----------------------
关的不同目的。有关该技术的更多详细信息，请参见第 10.5.2节。 
如果两种技术都在同一个应用程序中实现，那么可以将相同的表查 
找用于两者，从而提高效率。这些模型是通过考虑表面（镜面）和 
次表面（漫反射）术语之间的能量守恒的含义而开发的。其他模型 
是从物理原理开发出来的。其中许多模型依赖于 Subrahmanyan 
Chandrasekhar （1910-1995）的工作，他开发了一种半定的，各 
向同性散射体积的BRDF模型。正如Kulla和Conty[947]所证明的， 
如果平均自由程足够短，则该 BRDF模型是任意形状的散射体积的 
完美匹配。ChandrasekharBRDF可以在他的书[253]中找到，尽管 
使用熟悉的渲染符号的更易于访问的形式可以在 Dupuy等人的论 
文的方程 30和 31 中找到。[397]。由于它不包括折射，因此 
ChandrasekharBRDF可用于仅对索引匹配的曲面建模。这些是折 
射率为9.9的表面。用于次表面散射的BRDF模型353图9.41。第 
一行和第三行显示添加到朗伯术语的镜面术语。第二和第四行显示 
与Kelemen-Szirmay-Kalos耦合漫射项一起使用的相同镜面术语。 
顶部两行的粗糙度值低于底部两行。在每行内，粗糙度从左到右增 
加。（图片由Christopher Kulla[947]提供。）两侧都是相同的， 
如第304页的图9.11所示。为了模拟非索引匹配的表面，必须修 
改BRDF以考虑光进入和离开表面的折射。这种修改是Hanrahan 
和 Krueger[662]和Wolff [1898]的工作重点。9.9.4粗糙表面次表 
面模型作为迪士尼原理着色模型的一部分，Burley [214]包括一个 
漫反射 BRDF术语，旨在包括粗糙度效应和匹配测量材料：fdiff （l， 
----------------------- Page 386-----------------------
v）=χ+ （n·1）χ+（n·v）ρssπ.. （1.kss）fd +1.25kssfss？，（9.66） 
3549.基于物理的着色，其中fd =？1+ （FD90.1） （1.n·l）5?? 1 
+ （FD90.1） （1.n·v）5？，FD90=0.5+2√α （h·l）2，fss =？1 
 （n·l） （n·v）。0.5？FSS+0.5，FSS=？1+ （FSS90.1） （1.n·l） 
5?? 1+ （FSS90.1） （1。n·v）5？，FSS90=√α （h·l）2， （9.67）， 
α是镜面粗糙度。在各向异性的情况下，使用αx和αy之间的中间值。 
这个等式通常被称为迪斯尼漫反射模型。地下项fss 的灵感来自 
Hanrahan-KruegerBRDF[662]，旨在作为远距离物体全球次表面 
散射的廉价替代品。漫反射模型基于用户控制的参数 kss在fss和 
fd粗糙漫反射项之间进行混合。迪士尼漫画模型已被用于电影 
[214]，以及游戏[960] （虽然没有地下术语）。完整的迪士尼漫射 
BRDF还包括一个光泽术语，主要用于模拟面料，但也有助于弥补 
由于缺乏多次反弹镜面术语而导致的能量损失。迪士尼光泽术语将 
在第9.10节中讨论。几年后，Burley提出了[215]一个更新的模型， 
旨在与全球次表面散射渲染技术相结合。由于迪士尼漫反射模型使 
用与镜面 BRDF术语相同的粗糙度，因此可能难以对某些材料进行 
建模。见图9.40。但是，使用单独的漫反射粗糙度值将是一个微不 
足道的修改。大多数其他粗糙表面漫射 BRDF都是使用microfacet 
理论开发的，具有 NDFD，micro-BRDFfμ和掩模阴影功能G2的 
各种不同选择。最着名的这些模型是由Oren和 Nayar[1337]提出 
的。Oren-NayarBRDF使用 Lambertianmicro-BRDF，球形高斯 
NDF和Torrance-Sparrow “V-cavity”掩蔽阴影函数。完整形式 
----------------------- Page 387-----------------------
的BRDF模拟一次二次弹跳。Oren和 Nayar在他们的论文中还包 
括一个简化的 “定性”模型。多年来已经提出了对Oren-Nayar模 
型的一些改进，包括优化[573]，调整以使 “定性”模型更接近完整 
模型而不增加其成本[504]，并将微观BRDF改为一个更准确的光滑 
表面漫反射模型[574,1889]。Oren-Nayar模型假设一个微观曲面 
具有完全不同的正态分布和掩蔽阴影函数，而不是当前镜面模型中 
使用的那些。使用各向同性GGX NDF和高度9.9导出两个漫射微 
平面模型。用于次表面散射的BRDF模型355与Smith掩蔽阴影函 
数相关。由Gotanda [574]得到的第一个模型是将一般微平面方程 
 （方程9.26）数值积分的结果，使用公式9.64中的镜面耦合漫反 
射项作为微观 BRDF。然后将分析函数拟合到数值积分数据中。 
Gotanda的BRDF没有说明方面之间的相互反射，拟合函数相对复 
杂。使用相同的 NDF，掩蔽阴影功能和微型BRDF作为Gotanda， 
Hammon[657]以数字方式模拟BRDF，包括interreflections。他 
表明，相互反射对于这种微平面配置很重要，代表了粗糙表面总反 
射率的一半。然而，第二次反弹几乎包含所有缺失的能量，因此 
Hammon使用来自两次反弹模拟的数据。此外，可能因为添加了反 
射来平滑数据，Hammon能够为模拟结果拟合一个相当简单的函 
数：fdiff （l，v）=χ+ （n·l）χ+ （n·v）ρssπ .. （1.αg）fsmooth + 
αgfrough+ρssfmulti？，（9.68）其中fsmooth =2120 （1.F0）？ 
1。（1.n·l）5？？1。（1.n·v）5？，frough =kfacing （0.9.4.4 
kfacing）？0.5 +n·hn·h？，kfacing =0.5 +0.5 （l·v），fmulti 
----------------------- Page 388-----------------------
=0.3641αg， （9.69），αg是GGX镜面粗糙度。为清楚起见，这 
里的条款与Hammon的演示中的因素略有不同。注意，fsmooth 
是来自公式9.64的耦合漫射BRDF，没有ρss/π因子，因为它在公 
式9.68中相乘。Hammon讨论了 “混合”BRDF，它可替代其他 
平滑表面漫反射 BRDF，以提高性能或改善与旧模型下创作的资产 
的兼容性。总体而言，Hammon的漫射BRDF价格低廉且基于合 
理的理论原理，尽管他没有显示与测量数据的比较。需要注意的是， 
表面不规则性大于散射距离的假设是 BRDF推导的基础，这可能会 
限制它可以精确建模的材料类型。见图9.40。简单的朗伯项，如公 
式9所示。许多实时渲染应用程序仍然实现了图61的实现。除了 
Lambertian项的低计算成本之外，它比其他漫反射模型更容易使用 
间接和烘焙照明，并且它与更复杂的模型之间的视觉差异通常是微 
妙的[251,861]。尽管如此，对照片级真实感的不断追求推动了更准 
确模型的使用。356 9.基于物理的着色图 9.42。使用为游戏 
Uncharted4构建的布料系统的材料。左上方球体具有标准 BRDF， 
其具有GGX microfacet镜面和朗伯漫射。上部中间球体使用织物 
BRDF。每个其他球体增加了不同类型的每像素变化，从左到右，从 
上到下：织物编织细节，织物老化，不完美细节，和小皱纹。 
 （UNCHARTED4 A Thief's Endc/ TM 2016 SIE。由 Naughty 
DogLLC创建和开发。）9.10用于布料布的 BRDF模型往往具有与 
其他类型材料不同的微观几何学。取决于织物类型，它可具有高度 
重复的编织微结构，从表面垂直突出的圆柱 （螺纹）或两者。因此， 
----------------------- Page 389-----------------------
布料表面具有特征性的外观，通常需要专门的着色​ ​ 模型，例如 
各向异性镜面高光，凹凸散射[919] （通过突出的半透明光纤散射光 
线引起的明亮边缘效应），甚至是视图方向的色彩偏移（由穿过织 
物的不同颜色的线程引起的）。除了 BRDF，大多数织物具有高频 
空间变化，这也是创造令人信服的布料外观的关键[825]。见图9.42。 
布料 BRDF模型分为三大类：从观察中创建的经验模型，基于微观 
理论的模型和微圆柱模型。我们将从每个类别中查看一些值得注意 
的例子。9.10。布料357的BRDF模型9.10.1经验布料模型在游戏 
Uncharted2[631]中，布料表面使用以下弥散 BRDF项：fdiff （l， 
v）=ρssπ？krim.. （v·n）+??rim +kinner.. 1。（v·n）+??内 
部+kdiff？， （9.70）其中krim，kinner和kdiff是边缘照明术语 
的用户控制的缩放因子，分别是使前向（内）表面和朗伯术语变亮 
的术语。此外，αrim和αinner控制边缘和内部项的衰减。此行为 
是非物理的，因为有几个视图相关的效果，但没有一个依赖于光的 
方向。相比之下，Uncharted4 [825]中的布料使用微平面或微圆柱 
模型，取决于镜面类型的布料类型 （详见以下两节）和 “包裹照明” 
经验次表面散射近似。弥散术语：fdiff （l，v）（n·l）+。ρssπ？ 
cscatter + （n·l）+？+ （n·l+w）+1+w。（9.71）这里我们使 
用1.2节中引入的 （x）+表示法，表示0和 1之间的钳位。奇数表 
示法fdiff （l，v）（n·l）+。。。。表示此模型会影响照明以及 BRDF。 
箭头右侧的术语取代了左侧的术语。用户指定的参数cscatter是散 
射颜色，值为w，使用范围[0,1]，控制包裹照明宽度。对于造型布 
----------------------- Page 390-----------------------
料，迪士尼使用他们的弥散 BRDF术语[214] （第9.9.4节），在模 
型粗糙散射中添加了光泽术语：fsheen （l，v）=ksheencsheen.. 
1。（h·l）+？5，（9.72）其中ksheen是调制光泽项强度的用户 
参数。光泽颜色csheen是白色和ρss的亮度归一化值之间的混合 
 （由另一个用户参数控制）。换句话说，ρss除以其亮度以隔离其 
色调和饱和度。9.10.2 Microfacet布料模型Ashikhmin等。[78] 
提出使用倒置高斯 NDF来模拟天鹅绒。这个 NDF在随后的工作中 
略有修改[81]，该工作也提出了一种用于建模材料的微平面BRDF 
的变体形式，没有掩蔽阴影术语和修改后的分母。游戏中使用的布 
BRDFThe Order：1886 [1266]结合了改进的 microfacet BRDF 
和来自Ashikhmin的天鹅绒NDF的广义形式和Premoze后来的 
报告[81]以及来自公式9.63的扩散项。广义的3589.基于物理的阴 
影图9.43。Imageworks光泽镜面术语添加到红色漫反射术语。从 
左到右，光泽粗糙度值为α=0.15,0.25,0.40,0.65和 1.0。 （图片由 
Alex Conty提供[442]。）velvet NDF是 D （m）=χ+ （n·m）π 
 （1+kampα2）。...1+kampexp？ （n·m）2？2.. （n·m）2.1？？.. 
1。（n·m）2？2。...，（9.73）其中α控制反向高斯的宽度，而kamp 
控制其幅度。全布 BRDF是f （l，v）=.. 1。F （h，l）≤ρssπ+F 
 （h，l）D （h）4 ... n·l +n·v。（n·l）（n·v）？。（9.74）这种 
BRDF的一种变体被用于游戏Uncharted4 [825]中，用于粗糙的织 
物，如羊毛和棉。Imageworks[947]使用不同的反向 NDF作为可 
以添加到任何BRDF的光泽项：D （m）=χ+ （n·m） （2+1？）... 
----------------------- Page 391-----------------------
1。 （n·m）2？12？2π。 （9.75）虽然这个NDF的史密斯掩蔽阴 
影函数没有封闭形式的解决方案，但 Imageworks能够用分析函数 
逼近数值解。Estevez和 Kulla[442]讨论了光泽阴影函数和光泽项 
与 BRDF 其余部分之间能量守恒的详细信息。有关使用 
Imageworks光泽术语渲染的一些示例，请参见图9.43。到目前为 
止，我们看到的每种布料都限于特定类型的织物。下一节中讨论的 
模型试图以更一般的方式对布料进行建模。9.10.3微型圆筒布料模 
型用于布料的微型圆筒模型与用于头发的微型圆筒模型非常相似， 
因此第14.7.2节中对头发模型的讨论可以提供额外的背景。想法 
9.11。这些模型背后的波动光学 BRDF模型359假设表面被一维线 
覆盖。Kajiya和Kay为这个案例开发了一个简单的BRDF模型[847]， 
由Banks[98]给出了坚实的理论基础。它被称为 Kajiya-KayBRDF 
或 BanksBRDF。该概念基于这样的观察：由一维线组成的表面在 
任何给定位置具有无限数量的法线，由垂直于该位置处的切向量t 
的法线平面定义。虽然从这个框架开发了许多较新的微型气缸模型， 
但由于其简单性，原始的 Kajiya-Kay型号仍然有一些用途。例如， 
在 Uncharted4 [825]游戏中，Kajiya-KayBRDF用于闪亮面料 （如 
丝绸和天鹅绒）的镜面术语。Dreamworks[348,1937]使用相对简 
单且可由艺术家控制的微圆柱模型用于织物。纹理可用于改变粗糙 
度，颜色和线的方向，这可以指出表面平面，用于模制天鹅绒和类 
似的织物。可以为经线和纬线设置不同的参数，以模拟复杂的变色 
织物，例如射丝。该模型被标准化为节能。Sadeghi等。[1526]提 
----------------------- Page 392-----------------------
出了一种基于织物样品以及单个线的测量的微柱模型。该模型还考 
虑了线程间的线程间屏蔽和阴影。在某些情况下，实际的头发 BSDF 
型号（第 14.7节）用于布料。Render-Man的PxrSurface材料[732] 
有一个 “模糊”叶片，它使用Marschner等人的头发模型中的 R 
项。[1128] （第14.7节）。由Wu和Yuksel [1924,1926]在实时 
布料渲染系统中实现的模型之一源自迪士尼用于动画电影的头发模 
型[1525]。9.11波动光学 BRDF模型我们在最后几节中讨论的模型 
依赖于几何光学，它将光线视为在光线而不是波浪中传播。如第303 
页所述，几何光学是基于任何表面不规则性小于波长或大于约 100 
个波长的假设。真实世界的表面并不那么乐观。它们往往在所有尺 
度上都有不规则性，包括 1-100波长范围。我们指的是具有纳米尺 
度等尺寸的不规则性，以区别于前面部分讨论的微观几何不规则性， 
这些不规则性太小而不能单独渲染但大于 100个光波长。纳米尺度 
对反射率的影响不能通过几何光学来建模。这些效果取决于光的波 
动性质，并且需要波动光学 （也称为物理光学）来对它们进行建模。 
表面层或薄膜，厚度接近光波长也会产生与光波特性有关的光学现 
象。在本节中，我们将讨论波形光学现象，如衍射和薄膜干涉，讨 
论它们（有时是令人惊讶的）重要性，以实际渲染看似相对平凡的 
材料。3609.基于物理的着色图9.44。在左侧，我们看到在空白空 
间中传播的平面波前。如果波前的每个点都被视为新球面波的来源， 
则新波在除前向之外的所有方向上都会破坏性地干涉，从而再次产 
生平面波前。在中心，海浪遇到障碍。障碍物边缘的球面波在其右 
----------------------- Page 393-----------------------
侧没有波浪，破坏性地干扰它们，所以有些波在边缘周围衍射或 “泄 
漏”。在右侧，平面波前从平坦表面反射。平面波阵面比左侧的点 
更早地遇到左侧的表面点，因此从左侧的表面点发射的球面波有更 
多的时间传播，因此更大。不同尺寸的球面波前沿着反射的平面波 
前的边缘建设性地干涉，并且在其他方​ ​ 向上破坏性地干涉。 
9.11.1衍射模型纳米尺度测量会引起称为衍射的现象。为了解释它， 
我们利用了惠更斯 - 菲涅耳原理，该原理指出波前的每个点 （具有 
相同波相的点集）都可以被视为新球面波的来源。见图9.44。当海 
浪遇到障碍时，惠更斯 - 菲涅耳原理表明它们会在拐角处稍微弯 
曲，这是衍射的一个例子。几何光学无法预测这种现象。在光入射 
到平面表面的情况下，几何光学确实可以正确地预测光将在单个方 
向上反射。也就是说，菲涅耳 - 惠更斯原理提供了额外的见解。它 
表明，表面上的球面波恰好恰好形成反射波前，通过相消干涉消除 
了所有其他方向的波。当我们观察具有纳米不规则性的表面时，这 
种见解变得重要。由于表面点的高度不同，表面上的球面波不再整 
齐排列。见图9.45。如图所示，光线分散在不同的方向。其一部分 
被镜面反射，即，在反射方向上累加到平面波前。剩余的光以取向 
于纳米几何的某些性质的方向图衍射出来。镜面反射和衍射光之间 
的划分取决于纳米几何形状凸起的高度，或者更确切地说，取决于 
高度分布的变化。衍射光在9.11周围的角展度。波动光学 BRDF型 
号361图9.45。在左边，我们看到平面波前入射到具有粗糙纳米尺 
度的表面。在中心，我们看到根据菲涅耳 - 惠更斯原理在表面上形 
----------------------- Page 394-----------------------
成球面波。在右边，我们看到在发生建设性和破坏性干扰之后，一 
些产生的波（红色）形成平面反射波。剩余部分（紫色）被衍射， 
不同量的光在每个方向上传播，这取决于波长。镜面反射方向取决 
于纳米几何形状凸起相对于光波长的宽度。有点违反直觉，更广泛 
的不规则导致更小的传播。如果不规则性大于 100个光波长，则衍 
射光和镜面反射光之间的角度很小，可以忽略不计。尺寸减小的不 
规则性导致衍射光的更广泛扩散，直到不规则性变得小于光波长， 
此时不发生衍射。在具有周期性纳米尺度的表面中，衍射最清晰可 
见，因为重复的图案通过相长干涉增强了衍射光，从而产生了彩色 
的彩虹色。在CD和DVD光盘以及某些昆虫中可以观察到这种现象。 
虽然衍射也发生在非周期性表面，但计算机图形界已经假设多年来 
效果很轻微。出于这个原因，除了少数例外[89,366,686,1688]，计 
算机图形文献多年来一直忽略衍射。然而，Holzschuch 和 
Pacanowski[762]最近对测量材料的分析表明，许多材料中存在显 
着的衍射效应，并且可以解释用当前模型拟合这些材料的持续困难。 
同一作者的后续工作[763]介绍了一种结合了微观和衍射理论的模 
型，通过使用一般的微平面 BRDF （公式9.26）和微观BRDF来解 
释衍射。同时，Toisoul和Ghosh [1772,1773]提出了捕获周期性 
纳米几何测量产生的虹彩衍射效应的方法，以及用点光源和基于图 
像的照明实时渲染它们的方法。9.11.2薄膜干涉模型薄膜干涉是一 
种波动光学现象，当从薄介质层顶部和底部反射的光路相互干扰时 
会发生这种现象。见图9.46。取决于波长和路径长度差之间的关系， 
----------------------- Page 395-----------------------
不同波长的光或者相长干涉或相消干涉。3629.基于物理的阴影 n 
图9.46。光入射到反射基板顶部的薄膜上。除了初级反射之外，存 
在多个光折射路径，从基板反射，并且从顶部薄膜表面的内部反射 
或者通过它折射。这些路径都是同一波的副本，但由于路径长度的 
不同而导致短的相位延迟，因此它们相互干扰。由于路径长度差随 
角度而变化，因此不同波长在相长干涉和相消干涉之间转换，最终 
结果是虹彩色移。为了使这种效果发生薄膜需要很薄的原因与相干 
长度的概念有关。该长度是光波的副本可以移位并且仍然与原始波 
相干干涉的最大距离。该长度与光的带宽成反比，光的带宽是其光 
谱功率分布（SPD）延伸的波长范围。激光具有极窄的带宽，具有 
极长的相干长度。它可能是英里，取决于激光的类型。这种关系是 
有意义的，因为被许多波长移位的简单正弦波仍将与原始波相干地 
干涉。如果激光是真正的单色，它将具有无限的相干长度，但实际 
上激光具有非零带宽。相反，具有极宽带宽的光将具有混沌波形。 
有意义的是，这种波形的副本需要在它停止与原件相干干涉之前仅 
移位一小段距离。理论上，理想的白光是所有波长的混合，其相干 
长度为零。然而，出于可见光光学的目的，人类视觉系统（仅在 
400-700nm范围内感测光）的带宽决定了相干长度，其约为 1微 
米。因此，在大多数情况下，问题的答案 “薄膜在不再引起可见干 
涉之前有多厚？”是 “约 1微米”。与衍射类似，多年来薄膜干涉 
被认为是特殊的仅在肥皂泡和油渍等表面上发生的情况效应。然而， 
Akin [27]指出，薄膜干涉确实会产生微妙的色彩9.12。分层材料 
----------------------- Page 396-----------------------
363图9.47。没有（在左侧）和（在右侧）薄膜干涉的皮革材料。 
由薄膜干涉引起的镜面着色增加了图像的真实感。（图片来自Atilla 
Akin，NextLimitTechnologies [27]。）对于许多日常表面，并 
展示了如何模拟这种效果可以增加真实感。见图9.47。他的文章引 
起了对基于物理的薄膜干涉的兴趣程度的显着增加，包括 
Render-Man的 PxrSurface [732]和 Imageworks着色模型[947] 
在内的各种着色模型都包含对此效果的支持。适合于实时渲染的薄 
膜干涉技术已经存在了一段时间。Smits和 Meyer[1667]提出了一 
种有效的方法来解决一阶和二阶光路之间的薄膜干扰。他们观察到 
所得到的颜色主要是路径长度差的函数，其可以根据膜厚度，视角 
和折射率有效地计算。它们的实现需要具有 RGB颜色的一维查找 
表。可以使用密集光谱采样计算表格的内容，并将其转换为RGB颜 
色作为预处理，这使得该技术非常快。在游戏 “使命召唤：无限战 
争”中，一种不同的快速薄膜近似被用作分层材料系统的一部分 
[386]。这些技术不能模拟薄膜中的多次反射光以及其他物理现象。 
Belcour和 Barla[129]提出了一种更准确，计算成本更高的技术， 
但仍以实时实施为目标。9.12分层材料在现实生活中，材料通常是 
相互叠加的。表面可能被灰尘，水，冰或雪覆盖; 它可能涂有漆或其 
他涂层3649.基于物理的遮阳，用于装饰或保护;或者它可以有多层 
作为其基本结构的一部分，例如许多生物材料。最简单且最具视觉 
意义的分层情况之一是透明涂层，其是在一些不同材料的基底上的 
光滑透明层。一个例子是粗糙木材表面上的光滑涂层。迪士尼原则 
----------------------- Page 397-----------------------
阴影模型[214]包括一个明确的术语，与虚幻引擎[1802]， 
RenderMan 的 PxrSurface 材 质 [732] 以 及 Dreamworks 
Animation [1937]和 Imageworks[947]等使用的阴影模型一样。 
透明涂层的最显着的视觉结果是由透明涂层和下面的基底反射的光 
产生的双重反射。当衬底是金属时，该第二次反射是最显着的，因 
为此时介电透明涂层和衬底的折射率之间的差异最大。当衬底是电 
介质时，其折射率接近透明涂层的折射率，导致第二次反射相对较 
弱。此效果类似于水下材料，如第324页的表9.4所示。透明涂层 
也可以着色。从物理角度来看，这种着色是吸收的结果。根据比尔 - 
朗伯定律 （第 14.1.2节），吸收的光量取决于光穿过透明涂层的路 
径长度。该路径长度取决于视图和光的角度，以及材料的折射率。 
更简单的清单实现（例如迪士尼原则模型和虚幻引擎中的实现）不 
会对此视图依赖进行建模。其他人也这样做，例如PxrSurface中的 
实现以及 Imageworks和 Dreamworks着色模型。Imageworks 
模型还允许连接任意数量的不同类型的层。在一般情况下，不同的 
层可以具有不同的表面法线。一些例子包括在平坦路面上行驶的水 
的小溪，在崎岖不平的土壤上铺上一层光滑的冰块，或在纸板箱上 
盖上皱褶的塑料包装。电影业使用的大多数分层模型支持每层单独 
的法线。这种做法在实时应用程序中并不常见，尽管虚幻引擎的 
clearcoat 实现支持它作为可选功能。Weidlich 和 Wilkie 
[1862,1863]提出了一种分层的微平面模型，假设与微平面的尺寸相 
比，层厚度较小。他们的模型支持任意数量的图层，并跟踪从顶层 
----------------------- Page 398-----------------------
到底部的反射和折射事件，并再次备份。它对于实时实现来说足够 
简单[420,573]，但不考虑层之间的多次反射。雅各布等人。[811， 
812]提出了一个全面而准确的模拟框架材料的框架，包括多次反射。 
虽然不适合实时实施，但该系统对于地面实况比较非常有用，并且 
所使用的思想可能暗示未来的实时技术。游戏 “使命召唤：无限战 
争”使用了一种特别值得注意的分层材料系统[386]。它允许用户组 
合任意数量的材料层。它支持9.13之间的折射，散射和基于路径长 
度的吸收。混合和过滤材料365图9.48。测试表面显示了使命召唤 
的各种功能：无限战多层材料系统。该材料模拟具有变形和散射的 
几何复杂表面，尽管每一侧仅由两个三角形构成。（图片由 
Activision Publishing，Inc。2018提供）层，以及每层不同的表 
面法线。结合高效的实施，该系统可实现前所未有的复杂实时材料， 
尤其是对于以60Hz运行的游戏而言令人印象深刻。见图9.48。9.13 
混合和过滤材料材料混合是组合多种材料的属性（即 BRDF参数） 
的过程。例如，为了模拟一块带有锈斑的金属板，我们可以绘制一 
个掩模纹理来控制锈斑位置，并用它来混合锈蚀的材料特性（镜面 
颜色 F0，漫反射颜色ρss和粗糙度α）。金属。被混合的每种材料 
也可以在空间上变化，参数存储在纹理中。混合可以作为预处理来 
完成，以创建新的纹理，通常称为 “烘焙”，或在着色器中即时生 
成。虽然表面法线n在技术上不是 BRDF参数，但其空间变化对于 
外观很重要，因此材料混合通常也包括法线贴图。材质混合对于许 
多实时渲染应用程序至关重要。例如，游戏TheOrder：1886具有 
----------------------- Page 399-----------------------
复杂的材料混合系统[1266,1267,1410]3669.基于物理的阴影，允 
许用户创作从广泛的库中抽取并由各种空间掩模控制的任意深度的 
材料堆叠。大多数材质混合都是作为离线预处理完成的，但某些合 
成操作可以根据需要推迟到运行时。此运行时处理通常用于环境， 
为平铺纹理添加独特的变化。流行的材料创作工具 Substance 
Painter和 Substance Designer使用类似的材料合成方法，Mari 
纹理绘画工具也是如此。即时混合纹理元素可提供多种效果，同时 
节省内存。游戏采用材料混合用于各种目的，例如：。显示建筑物， 
车辆和生物（或不死生物）的动态伤害[201,603,1488,1778,1822]。。 
允许用户定制游戏内设备和服装[604,1748]。。增加角色[603,1488] 
和环境[39,656,1038]的视觉变化。有关示例，请参见第891页的图 
20.5。有时一种材料混合在另一种材料之上，不透明度低于 100％， 
但即使完全不透明的混合物也会有像素（或纹素，如果在掩模边界 
上烘焙成纹理，则需要执行部分混合。在任何一种情况下，严格正 
确的方法是评估每种材料的着色模型并混合结果。但是，混合BRDF 
参数然后一次评估着色要快得多。在材料属性与最终阴影颜色具有 
线性或近似线性关系的情况下，例如漫反射和镜面颜色参数，通过 
这种插值引入很少或没有误差。在许多情况下，即使对于与最终阴 
影颜色具有高度非线性关系的参数（例如镜面粗糙度），沿着掩模 
边界引入的误差也不是令人反感的。混合法线贴图需要特别考虑。 
通过将过程视为高度图之间的混合，通常可以获得良好的结果，从 
中可以得出法线贴图[1086,1087]。在某些情况下，例如当在基础表 
----------------------- Page 400-----------------------
面上覆盖细节法线贴图时，其他形式的混合是优选的[106]。材料过 
滤是与材料混合密切相关的主题。材质属性通常存储在纹理中，通 
过GPU双线性过滤和 mipmapping等机制进行过滤。然而，这些 
机制基于以下假设：被过滤的量（其是着色方程的输入）与最终颜 
色（着色方程的输出）具有线性关系。线性再次适用于某些数量， 
但一般情况下并不适用。在法线贴图上使用线性mipmapping方法 
可以产生伪像，或者在包含非线性 BRDF参数的纹理上，例如粗糙 
度。这些伪影可以表现为镜面反射（闪烁高光），或表面光泽度或 
亮度的意外变化，表面与相机的距离发生变化。在这两者中，镜面 
混叠更加明显;用于减轻这些伪像的技术通常被称为镜面抗锯齿技 
术。我们现在将讨论其中几种方法。9.13。混合和过滤材料367图 
9.49。在左侧，圆柱体使用原始法线贴图进行渲染。在中心，使用 
包含平均和重整化法线的分辨率低得多的法线贴图，如图9.50左下 
图所示。在右侧，圆柱体以相同的低分辨率渲染纹理，但是包含符 
合理想 NDF的法线和光泽度值，如图9.50右下图所示。右侧的图 
像是原始外观的明显更好的表示。当以低分辨率渲染时，该表面也 
不易于混叠。（图片由 ILM的PatrickConran提供。）9.13.1过 
滤法线和正态分布大部分材料过滤伪像（主要来自镜面混叠），以 
及最常用的解法，都与法线的过滤有关和正态分布函数。由于其重 
要性，我们将在一定程度上讨论这方面。为了理解为什么会出现这 
些伪像以及如何解决它们，请回想一下 NDF是子像素表面结构的统 
计描述。当相机和表面之间的距离增加时，先前覆盖多个像素的表 
----------------------- Page 401-----------------------
面结构可以减小到子像素大小，从凹凸图的范围移动到 NDF的领 
域。这种转变与mipmap链密切相关，后者将纹理细节的减少封装 
为子像素大小。考虑如何对象的外观（如图9.49中左侧的圆柱体） 
进行建模以进行渲染。外观建模总是假设一定的观察范围。宏观 （大 
规模）几何体被建模为三角形，中尺度（中等尺度）几何体被建模 
为纹理，并且小于单个像素的微观尺度几何体通过BRDF建模。鉴 
于图像中显示的比例，将圆柱体建模为平滑网格（宏观尺度）并用 
法线贴图 （中尺度）表示凸起是合适的。选择具有固定粗糙度αb的 
BeckmannNDF来模拟微尺度正态分布。这种组合表示在此尺度下 
很好地模拟了汽缸外观。但是，当观察规模发生变化时会发生什么？ 
研究图9.50。顶部的黑框图显示了表面的一小部分，由四个法线贴 
图纹理覆盖。假设我们以一定比例渲染表面，使得每个法线贴图纹 
素平均被一个像素覆盖。对于3689.基于物理的着色图9.50。部分 
表面如图9.49所示。顶行显示正态分布 （红色显示的平均法线）和 
隐含的微观几何。底行显示了将四个NDF平均为一个的三种方法， 
如在 mipmapping中所做的那样。左边是基础事实（平均正态分 
布），中心分别显示平均（正常）和方差（粗糙度）的平均结果， 
右边显示适合平均 NDF的NDF波瓣。每个纹素，正态 （即分布的 
平均值或平均值）显示为红色箭头，由 BeckmannNDF包围，以 
黑色显示。法线和 NDF隐式指定基础表面结构，如横截面所示。中 
间的大驼峰是法线贴图中的凸起之一，小摆动是微观表面结构。法 
线贴图中的每个纹素与粗糙度相结合，可以看作是收集纹素所覆盖 
----------------------- Page 402-----------------------
的表面区域的法线分布。现在假设相机已经从对象移动得更远，因 
此一个像素覆盖了所有四个法线贴图纹素。在该分辨率下表面的理 
想表示将精确地表示在每个像素覆盖的较大表面区域上收集的所有 
法线的分布。可以通过平均顶级mipmap的四个纹素中的NDF来 
找到此分布。左下图显示了这种理想的正态分布。如果用于渲染， 
该结果将最准确地表示在较低分辨率下表面的外观。9.13。混合和 
过滤材料369底部中心图显示了法线分别平均的结果，每个分布的 
平均值和粗糙度，它们对应于每个的宽度。结果具有正确的平均法 
线（红色），但分布太窄。此错误将导致表面显得过于平滑。更糟 
糕的是，由于NDF非常狭窄，它会以闪烁的高光形式引起混叠。我 
们不能直接用 BeckmannNDF表示理想的正态分布。然而，如果 
我们使用粗糙度图，贝克曼粗糙度αb可以从纹理元素到纹素元素变 
化。想象一下，对于每个理想的 NDF，我们发现定向的 Beckmann 
叶片在方向和总宽度上最接近。我们将贝克曼叶的中心方向存储在 
法线贴图中，将粗糙度值存储在粗糙度​ ​ 图中。结果显示在右下 
角。这个 NDF更接近理想。与简单的正常平均相比，圆柱体的外观 
可以更加忠实地表现出来。如图9.49所示。为获得最佳结果，应将 
过滤操作 （如mipmapping）应用于正态分布，而不是法线或粗糙 
度值。这样做意味着考虑 NDF与法线之间关系的方式略有不同。通 
常，NDF定义在由法线贴图的每像素法线确定的局部切线空间中。 
然而，当在不同法线上过滤NDF时，将法线贴图和粗糙度贴图的组 
合定义为在底层的切线空间中定义倾斜的 NDF （对于正常指向不平 
----------------------- Page 403-----------------------
均的 NDF）是更有用的。几何表面。早期尝试解决NDF滤波问题 
[91,284,658]使用数值优化将一个或多个 NDF波瓣拟合到平均分 
布。这种方法存在稳健性和速度问题，并且今天使用不多。相反， 
当前使用的大多数技术通过计算正态分布的方差来工作。Toksvig 
[1774]巧妙地观察到，如果法线被平均而不是重新归一化，则平均 
法线的长度与正态分布的宽度成反比。也就是说，原始法线指向不 
同方向的越多，它们的平均值就越短。他提出了一种基于此正常长 
度修改 NDF粗糙度参数的方法。用修正的粗糙度评估 BRDF近似于 
滤波法线的扩散效应。Toksvig 的原始方程适用于 Blinn-Phong 
NDF：α'p=knkαpknk+αp （1.knk），（9。76）其中αp是原始 
粗糙度参数值，α'p是修正值，knk是平均法线的长度。该方程也 
可以与贝克曼 NDF一起使用，通过应用等价αp=2α.2b.2 （来自 
Walter等人[1833]），因为两个NDF的形状非常接近。使用GGX 
的方法不那么简单，因为GGX和 Blinn-Phong （或Beckmann） 
之间没有明确的等价。使用αb的αb等价在中心370处给出相同的 
值.9。基于物理的高光阴影，但高光外观是完全不同的。更令人不 
安的是，GGX分布的方差是不确定的，这使得这种基于方差的技术 
系列在与GGX一起使用时处于不稳定的理论基础上。尽管有这些理 
论上的困难，但使用公式9是相当普遍的。76具有GGX分布，通 
常使用αp=2α2g.2。这样做在实践中运作得相当好。Toksvig的方 
法具有考虑GPU纹理过滤引入的正常方差的优点。它也适用于最简 
单的正常mipmapping方案，线性平均而不规范化。此功能对动态 
----------------------- Page 404-----------------------
生成的法线贴图（如水波纹）特别有用，必须在运行时生成mipmap。 
该方法不适用于静态法线贴图，因为它不适用于压缩法线贴图的主 
流方法。这些压缩方法依赖于单位长度的正常情况。由于Toksvig 
的方法依赖于平均法线变化的长度，因此与其一起使用的法线贴图 
可能必须保持未压缩。即使这样，存储缩短的法线可能导致精度问 
题。Olano和 Baker的LEAN映射技术[1320]基于映射正态分布的 
协方差矩阵。与Toksvig的技术一样，它适用于GPU纹理过滤和线 
性mipmapping。它还支持各向异性正态分布。与Toksvig的方法 
类似，LEAN映射与动态生成的法线很好地配合，但为了避免精度 
问题，与静态法线一起使用时需要大量存储。Hery等人独立开发了 
类似的技术。[731,732]并在皮克斯的动画电影中用于渲染亚像素细 
节，如金属片和小划痕。LEAN映射的简单变体CLEAN映射[93] 
需要较少的存储，代价是失去各向异性支持。LEADR映射[395，396] 
将 LEAN映射扩展到也考虑了位移映射的可见性效果。实时应用程 
序中使用的大多数法线贴图都是静态的，而不是动态生成的。对于 
这样的地图，通常使用方差映射系列技术。在这些技术中，当生成 
法线贴图的 mipmap链时，计算通过平均丢失的方差。Hill[739] 
指出，Toksvig技术，LEAN映射和CLEAN映射的数学公式都可以 
用于以这种方式预先计算方差，这消除了这些技术在其原始形式中 
使用时的许多缺点。在某些情况下，预先计算的方差值存储在单独 
的方差纹理的mipmap链中。更常见的是，这些值用于修改现有粗 
糙度图的mipmap链。例如，该方法用于游戏 “使命召唤：黑色行 
----------------------- Page 405-----------------------
动”[998]中使用的方差图技术。通过将原始粗糙度值转换为方差值， 
将法线图中的方差相加，并将结果转换回粗糙度来计算修改的粗糙 
度值。对于游戏 The Order ：1886，Neubelt 和 Pettineo 
[1266,1267]以类似的方式使用Han[658]的技术。他们将法线贴图 
NDF与其 BRDF镜面术语的 NDF卷积，将结果转换为粗糙度，并 
将其存储在粗糙度​ ​ 图中。9.13。混合和过滤材料371为了改善 
结果，需要额外存储，方差可以在纹理空间x和y方向上计算并存 
储在各向异性粗糙度图[384,740,1823]中。该技术本身仅限于轴对 
齐的各向异性，这在人造表面中是典型的，但在自然发生的表面中 
则较少。以存储一个或多个值为代价，也可以支持定向各向异性 
[740]。与原始形式的Toksvig，LEAN和CLEAN映射不同，方差 
映射技术不考虑GPU纹理过滤引入的方差。为了弥补这一点，方差 
映射实现通常使用小滤波器[740,998]对法线贴图的顶层 mip进行 
卷积。当组合多个法线贴图 （例如，细节法线贴图[106]）时，需要 
注意正确地组合法线贴图的方差[740,960]。高曲率几何以及法线贴 
图可以引入正态方差。由此方差产生的伪像不会通过先前讨论的技 
术来减轻。存在一组不同的方法来解决几何正态方差。如果几何体 
上存在唯一的纹理映射（通常是字符的情况，环境则不那么），那 
么几何曲率可以 “烘焙”到粗糙度图[740]中。还可以使用像素着色 
器导数指令[740,857,1229,1589,1775,1823]在运行中估计曲率。 
如果正常缓冲区可用，则可以在渲染几何体时或在后处理过程中完 
成此估计。到目前为止讨论的方法主要关注镜面响应，但正态方差 
----------------------- Page 406-----------------------
也会影响漫反射。考虑正态方差对n·l项的影响可以帮助提高漫反射 
和镜面反射的准确性，因为两者都在反射积分中乘以该因子[740]。 
方差映射技术将正态分布近似为平滑高斯波瓣。如果每个像素覆盖 
数十万个凸起，这是一个合理的近似值，因此它们都可以平滑地平 
均。然而，在许多情况下，像素很多只能覆盖几百或几千个凸起， 
这可能导致 “硬质”外观。这方面的一个例子可以在第328页的图 
9.25中看到，这是一系列图像，显示了一个球体，其中有一个从图 
像到图像尺寸减小的凸起。右下图显示了当凸起足够小以平均成为 
平滑高光时的结果，但是左下方和下方中心的图像显示的凹凸小于 
像素，但不足以平滑平均。如果您要观察这些球体的动画渲染，那 
么嘈杂的高光会出现在帧与帧之间闪烁的闪光。如果我们绘制这样 
一个表面的 NDF，它看起来就像图9.51中的左图。随着球体的动 
画效果，h矢量在 NDF上移动并越过亮区和暗区，从而产生 “闪亮” 
的外观。如果我们在这个表面上使用方差映射技术，它将使用类似 
于图9.51右侧的平滑 NDF来有效地逼近该 NDF，从而失去闪亮的 
细节。在电影行业，这通常通过广泛的超级采样来解决，这在实时 
渲染应用程序中是不可行的，即使在离线渲染中也是不合需要的。 
3729.基于物理的着色图9.51。左边是随机凹凸不平的表面上的小 
补丁 （一侧有几十个凸起）的NDF。在右边是一个宽度大致相同的 
BeckmannNDF叶。（图片由MilosHasan提供。）已经开发了 
几种技术来解决这个问题。有些不适合实时使用，但可能为未来研 
究提供了途径[84,810,1941,1942]。已经设计了两种用于实时实现 
----------------------- Page 407-----------------------
的技术。Wang和 Bowles [187,1837]提出了一种用于在迪士尼无 
限3.0游戏中渲染闪闪发光的雪的技术。该技术旨在产生合理的闪 
亮外观，而不是模拟特定的NDF。它适用于具有相对稀疏闪光的雪 
等材料。Zirr和 Kaplanyan的技术[1974]模拟了多尺度上的正态分 
布，在空间和时间上是稳定的，并且允许更多种类的外观。我们没 
有空间来涵盖所有关于材料过滤的大量文献，因此我们将提到一些 
值得注意的参考文献。Bruneton等。[204]提出了一种用于处理跨 
越从几何到 BRDF的尺度的海洋表面上的变化的技术，包括环境照 
明。Schilling[1565]讨论了一种类似方差映射的技术，该技术支持 
使用环境贴图进行各向异性着色。Bruneton和 Neyret[205]提供 
了该领域早期工作的全面概述。进一步阅读和资源 McGuire的图形 
编码[1188]和Glassner的数字图像合成原理[543,544]是本章所涉 
及的许多主题的很好的参考。Dutr'e 的 Global Illumination 
Compendium [399]的某些部分有点过时（特别是 BRDF模型部 
分），但它是渲染数学（例如，球形和半球形积分）的良好参考。 
Glassner和 Dutr'e的参考资料均可在线免费获取。9.13。混合和 
过滤材料 373对于想要了解光与物质相互作用的读者，我们推荐 
Feynman无与伦比的讲座[469] （可在线获取），这对我们在编写 
本章物理部分时的理解非常重要。其他有用的参考资料包括Fowles 
的现代光学介绍[492]，这是一篇简短易懂的介绍性文本，以及Born 
andWolf [177]的光学原理，这是一本更为深入（比喻和字面）的 
书，提供了更深入的内容。概述。拿骚的 “物理学与化学”[1262] 
----------------------- Page 408-----------------------
以极其彻底和细节的方式描述了物体颜色背后的物理现象。第 10 
章局部照明 “光是正确的。” - 安德鲁assner在第9章中，我们 
讨论了基于物理的材料理论，以及如何用准时光源对它们进行评估。 
通过此内容，我们可以通过模拟灯光与曲面的交互方式来执行着色 
计算，以便测量在给定方向上向虚拟相机发送多少辐亮度。该光谱 
辐射亮度是场景参考的像素颜色，将被转换（第8.2节）到给定像 
素在最终图像中将具有的显示参考颜色。实际上，我们需要考虑的 
互动从不是准时的。我们在第9.13.1节中已经看到，为了正确评估 
阴影，我们必须解决整个像素覆盖区域上表面BRDF响应的积分， 
这是像素区域在表面上的投影。这种集成过程也可以被认为是一种 
抗锯齿解决方案。我们预先集成，而不是对其频率成分没有约束的 
着色函数进行采样。到目前为止，仅呈现了点光源和定向光源的效 
果，这限制了表面从少数离散方向接收光。这种照明描述是不完整 
的。实际上，表面从所有传入方向接收光。户外场景不仅仅是被太 
阳照亮。如果这是真的，阴影中或背离太阳的所有表面都将是黑色 
的。天空是由大气中的阳光散射引起的重要光源。通过观察月球的 
照片可以看到天空光的重要性，因为它没有大气层，因此缺少天空。 
见图10.1。在阴天，黄昏或黎明时，户外照明都是天窗。即使在晴 
朗的日子，当从地球上看时，太阳对着一个圆锥体，所以它不是无 
限小的。奇怪的是，太阳和月亮都有相似的角度，大约半度，尽管 
它们有巨大的尺寸差异 - 太阳的半径比月球大两个数量级。实际 
上，照明永远不会准时。无穷小实体在某些情况下可用作廉价近似 
----------------------- Page 409-----------------------
值，或用作更完整模型的构建块。为了形成更逼真的照明模型，我 
们需要集成 BRDF375376 10.局部照明图 10.1。在月球上拍摄的 
图像，由于缺乏散射阳光的气氛而没有天空光。此图像显示当场景 
仅由直接光源照亮时的场景。请注意漆黑色阴影，并且在远离太阳 
的表面上没有任何细节。这张照片显示了阿波罗 15号任务期间宇航 
员詹姆斯·B·欧文（James B.Irwin）旁边的月球车。前景中的阴影 
来自月球模块。照片由宇航员 DavidR.Scott拍摄，指挥官。（图 
片来自美国国家航空航天局的收集。）对表面上事件方向的整个半 
球的响应。在实时渲染中，我们更倾向于通过找到闭合形式的解或 
其近似来求解渲染方程 （第 11.1节）所需的积分。我们通常避免平 
均多个样本 （光线），因为这种方法往往要慢得多。见图 10.2。本 
章致力于探索此类解决方案。特别是，我们希望通过使用各种非功 
能性光源计算 BRDF来扩展我们的着色模型。通常，为了找到廉价 
的解决方案（或任何根本），我们需要近似光发射器，BRDF或两 
者。重要的是在感知框架中评估最终的着色结果，理解最终图像中 
哪些元素最重要，从而为这些元素分配更多的努力。我们从本章开 
始，使用公式来集成分析区域光源。这种发射器是场景中的主要灯， 
负责大部分直接照明 10.1。区域光源377图10.2。在左边，我们 
在第9章中看到的积分：表面积和准时光。在右边，本章的目的是 
扩展我们的阴影数学，以解释光表面上的积分。强度，所以对于这 
些，我们需要保留我们所有选择的材料属性。应该为这些发射器计 
算阴影，因为漏光会导致明显的伪影。然后，我们研究了表示更一 
----------------------- Page 410-----------------------
般照明环境的方法，这些环境由进入的半球上的任意分布组成。在 
这些情况下，我们通常接受更接近的解决方案。环境照明用于大型， 
复杂但不太强烈的光源。例子包括从天空和云层散射的光，间接光 
从场景中的大物体反射，以及调光器直接区域光源。这样的发射器 
对于图像的正确平衡是重要的，否则图像将显得太暗。即使我们考 
虑间接光源的影响，我们仍然不在全局照明领域 （第 11章），这取 
决于场景中其他表面的显式知识。10.1区域光源在第9章中，我们 
描述了理想化的无限小光源：准时和定向。图10.3显示了表面点上 
的入射半球，以及无穷小源和具有非零尺寸的区域光源之间的差异。 
左侧的光源使用第9.4节中讨论的定义。它从单个方向lc照亮表面。 
它的亮度由其色度表示，定义为白色朗伯表面朝向光线的反射辐射。 
点方向或方向光对方向v的出射辐射Lo （v）的贡献是πf （lc，v） 
clight （n·lc）+ （注意用于将负数钳位为零的x +符号，在 1.2节 
中介绍）。或者，区域光源（右侧）的亮度由其辐射亮度L1表示。 
区域光从表面位置对着立体角ω1。它对方向v的输出辐射的贡献是 
f （l，v）L1 （n·1）+对ω1的积分。37810.局部照明nnvv图10.3。 
考虑到由表面法线n定义的可能的入射光方向的半球，由光源照射 
的表面。在左边，光源是无穷小的。在右侧，它被建模为区域光源。 
无穷小光源背后的基本近似表示在下面的等式中：Lo （v）=Zl∈！ 
lf （l，v）Ll （n·1）+dl≈πf （lc，v）clight （n·lc） +。（10.1） 
面积光源对表面位置的照射有贡献的量是从该位置 （ω1）看到的其 
辐射亮度 （L1）和其大小的函数。正如我们在9.4节中看到的那样， 
----------------------- Page 411-----------------------
点和方向光源是在实践中无法实现的近似值，因为它们的零立体角 
意味着无限的辐射。理解近似引入的视觉错误将有助于知道何时使 
用它，以及在不能使用它时采取的方法。这些误差将取决于两个因 
素：光源的大小，通过它从阴影点覆盖的立体角来测量，表面有多 
光泽。图10.4显示了表面上的镜面高光尺寸和形状如何取决于材料 
粗糙度和光源尺寸。对于小光源，与视角相比，对着一个微小立体 
角的光源，误差很小。粗糙表面也倾向于显示光源尺寸小于抛光表 
面的效果。通常，朝向表面点的区域光发射和表面BRDF的镜面波 
瓣都是球面函数。如果我们考虑这两个函数的贡献是显着的方向集， 
我们获得两个立体角。误差的决定因素与发射角的相对大小成比例， 
与 BRDF镜面高光立体角的大小相比。最后，请注意，区域光的高 
光可以通过使用准时光并增加表面粗糙度来近似。该观察结果对于 
获得对区域光积分的成本较低的近似是有用的。它还解释了为什么 
在实践中许多实时渲染系统仅使用准时来源产生合理的结果：艺术 
家可以弥补错误。但是，这样做是有害的，10.1。区域光源379图 
10.4。从左到右，使用GGX BRDF，球体材料的表面粗糙度增加。 
最右边的图像复制系列中的第一个，垂直翻转。请注意，低粗糙度 
材质上的大圆盘光引起的高光和阴影看起来与粗糙度较大的材料上 
较小光源引起的高光效果相似。因为它将材料特性与特定的照明设 
置相结合。在改变照明场景时，以这种方式创建的内容看起来不正 
确。对于朗伯曲面的特殊情况，使用区域光的点光可以是精确的。 
对于这样的表面，出射辐射与辐照度成正比：Lo（v）=ρssπE，（10.2） 
----------------------- Page 412-----------------------
其中ρss是表面的地下反照率或漫反射颜色 （第9.9.1节）。这种关 
系让我们使用等式 10.1来计算辐照度，这更简单：E=Zl∈！lLl （n·l） 
+dl≈πclight （n·lc）+。（10.3）矢量辐照度的概念有助于理解在 
存在区域光源时辐照度如何表现。矢量辐照度由Gershun [526]引 
入，他将其称为光矢量，并由Arvo进一步扩展[73]。使用矢量辐照 
度，可以将任意大小和形状的面光源精确地转换为点光源或定向光 
源。想象一下，辐射李的分布进入太空中的点p。见图10.5。我们 
现在假设 Li是与波长无关的，因此可以表示为标量。对于以入射方 
向l为中心的每个无穷小立体角d1，构造与l对齐并且具有等于从 
该方向进入的（标量）辐射的时间乘以d1的向量。最后，将所有 
这些矢量相加以产生矢量辐照度e：e （p）=Zl∈？Li （p，l）ldl， 
 （10.4）在哪里？表示积分是在整个方向范围内执行的。380 10. 
局部照明pnep图10.5。矢量辐照度的计算。剩下：点p被各种形 
状，尺寸和辐射分布的光源包围。黄色的亮度表示发出的辐射量。 
橙色箭头是指向所有方向的向量，其中存在任何入射辐射，并且每 
个长度等于来自该方向的辐射量乘以箭头所覆盖的无穷小立体角。 
原则上应该有无限数量的箭头。右：矢量辐照度（大橙色箭头）是 
所有这些矢量的总和。矢量辐照度可用于计算点 p处任何平面的净 
辐照度。矢量辐照度e可用于通过执行点积 E：p （n）来找到通过 
任何方向的平面的p处的净辐照度。E （p，.n）=n·e （p），（10.5） 
其中n是平面的法线。通过平面的净辐照度是流过平面 “正侧”（由 
平面法线n定义）和流过 “负侧”的辐照度之间的差值。净辐照度 
----------------------- Page 413-----------------------
本身不适用于阴影。然而，如果没有通过 “负侧”发射辐射（换句 
话说，被分析的光分布没有 l和 n之间的角度超过90°的部分）， 
则 E （p，.n）=0并且E （p，n）=n·e （p）。 （10.6）单个区域 
光源的矢量辐照度可以与公式10.6一起用于照亮具有任何法线n的 
朗伯表面，只要n不远离区域光源的任何部分超过90°。见图10.6。 
如果我们假设 Li与波长无关，则不成立，那么在一般情况下我们不 
能再定义单个向量e。然而，彩色光通常在所有点处具有相同的相 
对光谱分布，这意味着我们可以将 Li分解为颜色c'和与波长无关的 
辐射分布L'i。在这种情况下，我们可以计算出 L'i的e，并通过将n·e 
乘以c'来扩展方程 10.6。这样做会产生用于计算10.1的辐照度的 
相同方程式。区域光源381ppe图10.6。矢量辐照度的单区光源。 
在左侧，箭头表示用于计算矢量辐照度的矢量。在右边，大的橙色 
箭头是矢量辐照度e。红色虚线表示光源的范围，并且红色矢量 （每 
个垂直于一条红色虚线）定义了一组表面法线的极限。该组外的法 
线将具有大于90°的角度。区域光源的某些部分。这样的法线不能 
使用e来正确计算它们的辐照度。定向光源，具有以下取代：lc=e 
 （p）ke （p）k，clight =c'ke （p）kπ。 （10.7）我们已经有效地 
将任意形状和大小的面光源转换为定向光源，而不会引入任何误差。 
对于简单情况，可以解析地求解用于找到矢量辐照度的等式 10.4。 
例如，想象一个球面光源，其中心为pl，半径为r1。光从球体上的 
每个点向所有方向发射恒定的辐射亮度L1。对于这样的光源，等式 
10。4和 10.7得到以下结果：lc=pl。pkpl。pk，clight =r2lkpl。 
----------------------- Page 414-----------------------
pk2Ll。 （10.8）该等式与全向光 （第5.2.2节）相同，其中clight0 
=L1，r0=r1，以及标准的反平方距离衰减1函数。可以调整该衰 
减函数以考虑球体内的点，并将光影响限制在给定的最大距离。有 
关此类调整的更多详细信息，请参见第5.2.2节。1注意，对于球形 
灯，衰减确实采用通常的反平方距离公式（其中距离是从光表面而 
不是其中心），这对于所有区域光形状通常都不是这样。值得注意 
的是，盘灯的衰减与1/ （d2 +1）成比例。382 10.局部照明只有 
在没有 “负面”辐照度时，所有这些都是正确的。考虑它的另一种 
方法是区域光源的任何部分都不能 “在地平线下”，或被表面遮挡。 
我们可以概括这个陈述。对于朗伯表面，区域和点光源之间的所有 
差异都是由遮挡差异引起的。来自点光源的辐照度遵守对于未被遮 
挡的所有法线的余弦定律。斯奈德得出了球形光源的解析表达式， 
将遮挡考虑在内[1671]。这个表达非常复杂。然而，由于它仅依赖 
于两个量 （r/ rl和θi，n和lc之间的角度），因此可以将其预先计 
算为二维纹理。Snyder还提供了两个适用于实时渲染的函数近似 
值。在图 10中。4我们看到区域照明的效果对粗糙表面不太明显。 
这种观察结果还允许我们使用基于物理的较少但仍然有效的方法来 
模拟朗伯表面上的区域光的效果：包裹照明。在这种技术中，对n·l 
的值进行了一些简单的修改，然后将其钳制为0.Forsyth[487]给出 
了一种形式的包裹照明：E=πclight？ （n·l）+kwrap1+kwrap？ 
+，（10.9）其中，对于点光源，kwrap的范围从0到覆盖整个半 
球的区域光源的 1。Valve [1222]使用另一种模仿大面积光源效果的 
----------------------- Page 415-----------------------
形式：E =πclight？（n·l）+12？2。（10.10）一般来说，如果 
我们计算区域照明，我们也应该修改我们的阴影计算以考虑非准时 
源。如果我们不这样做，一些视觉效果可以被强烈的阴影消除[193]。 
软阴影可能是区域光源最明显的效果，如第7章所述.10.1.1光泽材 
料区域光对非朗伯曲面的影响更为复杂。Snyder推导出球形光源的 
解决方案[1671]，但它仅限于原始的反射矢量 Phong材料模型，并 
且非常复杂。在今天的实践中，需要近似值。区域光在光泽表面上 
的主要视觉效果是亮点。见图 10.4。它的大小和形状与区域光相似， 
而高光的边缘根据表面的粗糙度而模糊。这一观察结果导致了几种 
经验近似的效应。这些在实践中可能非常有说服力。例如，我们可 
以修改突出显示计算的结果，以合并创建大平面突出显示区域的截 
止阈值[606]。这可以有效地产生球形光的镜面反射错觉，如图 10.7 
所示。10.1。区域光源383图10.7。光滑物体的亮点是光源形状的 
锐利反射。在左侧，通过对 Blinn-Phong着色器的高光值进行阈值 
处理来近似此外观。在右侧，使用未经修改的Blinn-Phong着色器 
渲染相同的对象以进行比较。 （图片由LarryGritz提供。）用于实 
时渲染的区域光照效果的大多数实际近似是基于每个阴影点找到的 
想法，一个等效的准时照明设置，可以模仿非无限小光源的影响。 
这种方法通常用于实时渲染以解决各种问题。这与我们在第9章中 
在表面的像素占位面积上处理 BRDF积分时所见的原理相同。它产 
生的近似值通常很便宜，因为所有工作都是通过改变阴影方程的输 
入而不引入任何额外的复杂性来完成的。因为数学没有被改变，我 
----------------------- Page 416-----------------------
们通常可以保证，在某些条件下，我们会回归到评估原始阴影，从 
而保留其所有属性。由于大多数典型系统的着色代码都基于准时光 
源，因此将区域光源用于区域光源仅会引入本地化的代码更改。开 
发的第一个近似值之一是在虚幻引擎的 “元素演示”[1229]中使用 
的Mittring粗糙度修改。我们的想法是首先找到一个锥体，其中包 
含大部分光源辐照度到入射到表面的方向的半球上。然后我们在镜 
面周围安装一个类似的锥体，其中包含 “大多数”BRDF。见图10.8。 
然后，两个锥体都是半球上的函数的替身，并且它们包含这两个函 
数具有大于给定的任意截止阈值的方向的集合。这样做之后，我们 
可以通过找到一个具有不同粗糙度的新 BRDF波瓣来近似光源和材 
料 BRDF之间的卷积，该波瓣具有相应的锥体，其立体角等于光瓣 
角度和材料的总和。一。Karis[861]展示了Mittring原理在GGX/ 
Trowbridge-ReitzBRDF （第9.8.1节）和球面光的应用，导致GGX 
粗糙度参数αg的简单修改：α'g=？αg+rl2kpl。pk？+。38410. 
局部照明图 10.8。GGXBRDF和一个锥体，用于封闭镜面反射大部 
分入射光辐射的方向。注意在 1.2节中引入的符号x +的使用，用于 
在0和 1之间进行钳位。这种近似效果相当好并且非常便宜，但是 
对于有光泽的，几乎像镜子的材料而言会分解。这种失败的发生是 
因为镜面波瓣始终是平滑的，并且无法模拟由区域光源在表面上的 
锐利反射引起的高光。也，大多数 microfacetBRDF模型的波瓣不 
是 “紧凑的” （局部的），但表现出宽的衰减（镜面尾部），使得 
粗糙度重新映射效果较差。见图10.9。不是改变材料粗糙度，另一 
----------------------- Page 417-----------------------
个想法是用光方向表示区域照明的光源，光方向根据被遮蔽的点而 
变化。这被称为最具代表性的点解决方案，修改光矢量，使其位于 
区域光表面上产生最大图10.9的点的方向上。球形照明。从左到右： 
通过数值积分，粗糙度修改技术和代表点技术计算的参考解。（图 
片由EpicGamesInc.的BrianKaris提供）10.1。区域光源385图 
10.10。Karis代表点近似为球体。首先，计算最接近球心 l的反射 
光线上的点：pcr= （l·r）r。湖最接近pcr的球面上的点是pcs=l 
+pcr·min （1，radius ||pcr ||）。能量对阴影表面的贡献。见图 
10.9。Picott[1415]使用光线上的点来创建与反射光线最小的角度。 
卡里斯[861]通过近似于效率最近角度的点来改进 Picott的公式，其 
中球体上的点与反射射线的距离最短。他还提出了一种廉价的配方， 
可以根据光线的强度进行测量，以保持整体发射的能量。见图 
10.10。大多数具有代表性的点解决方案都很方便，并且已针对各种 
轻型几何形状开发，所以理解他们的理论背景很重要。这些方法类 
似于蒙特卡洛积分中的重要性采样的概念，其中我们通过对积分域 
上的样本求平均来数值计算定积分的值。为了更有效地这样做，我 
们可以尝试优先考虑对总体平均值有很大贡献的样本。它们有效性 
的更严格证明在于定积分的中值定理，它允许我们用相同函数的单 
个评估来代替函数的积分：ZDf （x）dx=f （c）ZD 1。 （10.11） 
如果f （x）在D中是连续的，那么RD1是域的面积，点c∈D位 
于 D中函数minimum和maximum之间的线上。对于照明，我们 
考虑的积分是 BRDF与被光所覆盖的半球区域上的光辐照度的乘 
----------------------- Page 418-----------------------
积。我们通常认为我们的灯光均匀照射，因此我们只需要考虑光线 
衰减，并且大多数近似值也假设域区域 D从阴影点完全可见。即使 
有这些假设，确定点c和归一化因子 RD1仍​ ​ 然太昂贵，因此 
采用进一步的近似。38610.局部照明代表点解决方案也可以通过它 
们对突出显示形状的影响来构建。在表面的一部分上，由于反射矢 
量在区域光所对应的方向锥之外，代表点不会改变，我们可以用点 
光进行有效照明。然后，突出显示的形状仅取决于镜面反射的底层 
形状。或者，如果我们是反射矢量击中区域光的表面上的阴影点， 
则代表点将连续变化以指向最大贡献的方向。这样做有效地扩展了 
镜面波瓣峰值， “扩大”它，这种效果类似于图 10.7的硬阈值。这 
个宽而恒定的高光峰值也是近似值中剩余的误差源之一。在较粗糙 
的表面上，区域光反射看起来比地面实况解决方案 “更清晰” （即， 
通过蒙特卡洛积分获得）- 与粗糙度修改技术的过度模糊相反的视 
觉缺陷。要解决这个问题，Iwanicki和 Pesce [807]开发了通过将 
BRDF波瓣，软阈值，代表点参数和比例因子（用于节能）拟合到 
通过数值积分计算的球面区域照明结果而获得的近似值。这些拟合 
函数产生一个参数表，该参数表由材料粗糙度，球半径和光源中心 
与表面法线和视图矢量之间的角度索引。由于在着色器中直接使用 
这种多维查找表是昂贵的，因此提供了封闭形式的近似。最近，de 
Carpentier [231]推导出一种改进的配方，以便在刨光角度下更好 
地保持球形区域光源的高光形状，用于基于微绒毡的 BRDF。该方 
法通过找到最大化n·h的代表点来工作，表面法线和光线半矢量之 
----------------------- Page 419-----------------------
间的点积，而不是原始配方的n·r （源自Phong BRDF）。10.1.2 
一般光形状到目前为止，我们已经看到了几种通过均匀发射球形区 
域光和任意光泽 BRDF来计算阴影的方法。这些方法中的大多数采 
用各种近似，以便得到快速实时评估的数学公式，并且因此与问题 
的地面实况解决方案相比显示出不同程度的误差。然而，即使我们 
有计算能力来推导出一个精确的解，我们仍然会犯一个大错误，我 
们将其嵌入到我们的照明模型的假设中。真实世界的灯通常不是球 
体，它们几乎不是完美的均匀发射体。见图 10.11。球面区域的灯 
在实践中仍然很有用，因为它们提供了最简单的方法来打破准时灯 
引入的照明和表面粗糙度之间的错误关联。然而，球形光源通常是 
大多数真实灯具的良好近似，只要它们相对较小。由于基于物理的 
实时渲染的目标是生成令人信服的，合理的图像，所以只有到目前 
为止，我们才能通过将自己局限于理想化的场景来实现这一目标。 
这是计算机图形学中反复出现的权衡。我们可以10.1。区域光源387 
图10.11。常用的灯形。从左到右：球形，矩形（卡），管（线） 
和聚焦发射的管 （沿着光表面法线集中，不均匀地散布在半球中）。 
请注意他们创建的不同亮点。通常选择生成准确的解决方案，以简 
化问题，简化假设，或者为更一般的问题推导近似解决方案，从而 
更紧密地模拟现实。球形灯的最简单扩展之一是 “管”灯（也称为 
 “胶囊”），它可用于表示真实世界的荧光灯管。见图10.12。对 
于 LambertianBRDF，Picott[1415]显示了一个封闭形式的光照积 
分公式，相当于用线性光线段的极值点上的两个点光源评估具有适 
----------------------- Page 420-----------------------
当衰减函数的光照：Zp1p0？n·xkxk？1kxk2dx=n·p0kp0k2+ 
n·p1kp1k2 kp0kkp1k + （p0·p1），（10。12）其中p0和 p1 
是线性光的两个端点，n是表面法线。Picott还推导出与 Phong镜 
面BRDF积分的代表点解，将其近似为放置在光段上的点光源的光 
照，当连接到所考虑的表面点时，形成图 10.12。管灯。使用代表 
点解决方案计算图像[807]。388 10.局部照明与反射矢量的最小角 
度。这种代表点解决方案将线性光动态转换为点 1，因此我们可以 
使用球形光的任何近似来将灯具 “加厚”成胶囊。与球形灯一样， 
Karis[861]通过使用与反射向量的最小距离（而不是最小角度）的 
线上的点，在 Picott的原始解决方案中提供了更有效 （但稍微不那 
么准确）的变体，并且呈现了缩放公式。试图恢复节能。许多其他 
光形状的代表点近似可以相当容易地获得，例如环和 B'ezier段，但 
我们通常不希望分支我们的着色器太多。良好的光线形状可以用来 
代表我们场景中的许多真实世界的灯光。最具表现力的形状类别之 
一是平面区域光，其被定义为由给定几何形状约束的平面的一部分， 
例如矩形 （在这种情况下它们也被称为卡片灯），盘，或更一般地， 
多边形。这些图元可以用于广告牌和电视屏幕等发光面板，代表常 
用的摄影照明（柔光箱，弹跳卡），模拟许多更复杂的照明灯具的 
光圈，或代表从墙壁和其他反射的照明场景中的大表面。卡片灯 （以 
及磁盘）的第一个实际近似值之一是由Drobot[380]推导出来的。 
这又是一个代表性的点解决方案，但是由于将该方法扩展到平面的 
二维区域以及解决方案的整体方法的复杂性，这尤其值得注意。 
----------------------- Page 421-----------------------
Drobot从均值定理开始，并且作为第一近似，确定用于光评估的良 
好候选点应该位于照明积分的全局最大值附近。对于 Lambert 
BRDF，该积分是LlZl∈！l （n·l）+1r2ldl，（10.13）其中Ll是 
由光发射的恒定辐射，ωl是由光几何所对应的立体角， r1是在方 
向l上从表面到光平面的光线的长度，并且 （n·l）+是通常的朗伯钳 
位点积。 （n·l）+的最大值是光区域的边界上的点pc，其最接近点 
p'，该点是通过使来自表面的光线在法线方向上与光平面相交而得 
到的。类似地，1/ r2l的最大值是最靠近点p''的边界上的点pr， 
该点在光平面上最接近被遮蔽的表面点。见图 10.13。然后，被积 
函数的全局最大值将位于连接pr和 pc的段上：pmax =tmpc + 
 （1.tm）pr，tm∈[0,1]。Drobot使用数值积分来找到许多不同配 
置的最佳代表点，然后找到平均效果最好的单个tm。Drobot的最 
终解决方案采用了漫反射和镜面反射照明的进一步近似，所有这些 
都是通过与数字上发现的地面实况解决方案进行比较来实现的。他 
还为纹理卡片灯的重要案例推导出算法，10.1。区域光源389n图 
10.13。Drobot矩形区域光代表点近似的几何构造。其中发射不被 
假定为恒定但在纹理上由光的矩形区域调制。使用三维查找表来执 
行该过程，该三维查找表包含在不同半径的圆形足迹上的发射纹理 
的预集成版本。Mittring[1228]采用类似的方法进行光泽反射，将 
反射光线与纹理矩形广告牌相交，并根据光线交叉距离索引预先计 
算的纹理模糊版本。这项工作先于 Drobot的发展，但它是一种更 
经验，更少原则的方法，试图与地面实况完整解决方案相匹配。对 
----------------------- Page 422-----------------------
于平面多边形区域光的更一般情况，Lambert [967]最初为完美漫 
射表面导出精确的闭合形式解。这种方法由Arvo [74]改进，允许光 
滑材料建模为 Phong镜面反射叶。Arvo通过将矢量辐照度的概念 
扩展到更高维度的辐照度张量并使用斯托克定理来解决区域积分作 
为沿着积分域的轮廓的更简单积分来实现这一点。他的方法所做的 
唯一假设是，从阴影表面点（通常可以通过将光多边形剪切为与表 
面相切的平面来避开光线）完全可见光，并且BRDF是径向对称的 
余弦。不幸的是，在实践中，Arvo的分析解决方案对于实时渲染而 
言非常昂贵，因为它需要根据区域光多边形的每个边缘评估其时间 
复杂度在所使用的 Phong波瓣的指数中是线性的公式。最近， 
Lecocq[1004]通过找到轮廓积分函数的O （1）近似并将解扩展到 
一般的基于半矢量的 BRDF，使得该方法更加实用。到目前为止所 
描述的所有实际实时区域照明方法都采用某些简化假设来允许推导 
分析结构和39010.局部照明图 10.14。线性变换余弦技术背后的关 
键思想是使用3×3变换矩阵可以轻松缩放，拉伸和倾斜简单的余弦 
波瓣（左侧）。这允许余弦叶在球体上采用许多不同的形状。（图 
片由EricHeitz提供。）处理由此产生的积分的近似值。Heitz等人。 
[711]采用线性变换余弦 （LTCs）的不同方法，这产生了实用性，准 
确，一般的技术。他们的方法开始于在球体上设计一类具有高度表 
现力的功能（即，它们可以采用多种形状）并且可以容易地集成在 
任意球形多边形上。见图 10.14。LTC仅使用由3×3矩阵转换的余 
弦波瓣，因此可以在半球上调整大小，拉伸和旋转以适应各种形状。 
----------------------- Page 423-----------------------
一个简单的余弦 （与 Blinn-Phong不同，不是指数）与球面多边形 
的积分已经很成熟，可以追溯到兰伯特[74,967]。关键观察Heitz 
等人。make是用凸起上的变换矩阵扩展积分不会改变其复杂性。 
我们可以通过矩阵的逆变换多边形域并取消积分内的矩阵，回归到 
一个简单的余弦波作为被积函数。见图 10.15。对于通用BRDF和 
区域光形状，剩下的唯一剩余工作是找到将球体上的BRDF函数表 
示为一个或多个LTC的方法（近似值），可以离线完成并在使用BRDF 
参数索引的查找数组中制表：粗糙度，入射角等图 10.15。给定 LTC 
和球形多边形域（左侧），我们可以通过 LTC矩阵的逆转换它们以 
获得简单的余弦波瓣和新域（在右侧）。余弦波瓣与变换域的积分 
等于 LTC在原始域上的积分。（图片由 EricHeitz提供。）10.2。 
环境照明391开启。线性变换的基于余弦的解决方案既可以用于一 
般纹理多边形区域光源，也可以用于专门的，更便宜的计算形状， 
例如卡片，磁盘和线光。LTC可能比代表点解决方案更昂贵，但更 
准确。10.2环境光照原则上，反射率（公式9.3）不区分直接来自 
光源的光和从天空散射的间接光或场景中的物体。所有进入的方向 
都有辐射，反射方程对它们进行整合。然而，在实践中，直射光通 
常通过具有高辐射值的相对小的立体角来区分，并且间接光倾向于 
以中等到低的辐射值漫射地覆盖半球的其余部分。这种拆分提供了 
很好的实际理由来分别处理这两者。到目前为止，区域光技术讨论 
了整合从光的形状发出的恒定辐射。这样做会为每个着色曲面点创 
建一组具有恒定非零入射辐射的方向。我们现在研究的是在所有可 
----------------------- Page 424-----------------------
能的传入方向上整合由变化函数定义的辐射的方法。见图 10.16。 
虽然我们一般会谈到间接和 “环境”照明，但我们不打算研究全局 
照明算法。关键的区别在于，在本章中，所有着色数学都不依赖于 
场景中其他表面的知识，而是依赖于一小组光基元。所以，虽然我 
们可以，例如，使用区域光来模拟墙壁上的光反射，这是一种全局 
效应，着色算法不需要知道墙的存在。它拥有的唯一信息是光源， 
所有阴影都是在本地执行的。全局照明 （第 11章）通常与本章的概 
念密切相关，因为许多解决方案可被视为计算图 10.16的方法。在 
不同的环境照明场景下渲染场景。39210.局部照明右侧的一组局部 
光源图元，用于每个物体或表面位置，以模拟光在场景周围反射的 
相互作用。环境光是最简单的环境照明模型，其中辐射不随方向变 
化并具有恒定值 LA。甚至这种环境照明的基本模型也显着改善了视 
觉质量。不考虑间接从物体反弹的光的场景看起来非常不现实。在 
这样的场景中阴影中或背离光线的物体将是完全黑色的，这与现实 
中发现的任何场景不同。第376页的图 10.1中的moonscape接 
近，但即使在这样的场景中，一些间接光也会反射出附近的物体。 
环境光的确切影响取决于 BRDF。对于朗伯曲面，固定辐射率LA导 
致对出射辐射的恒定贡献，而不管表面法线n或视图方向v：Lo（v） 
=ρssπLAZl∈ （n·1）dl =ρssLA。（10.14）当着色时，这个恒定 
的出射辐射贡献被加到直接光源的贡献上。对于任意BRDF，等效 
方程是 Lo （v）=LAZl∈f （l，v）（n·1）dl。（10.15）该等式中 
的积分与方向反照率R （v）（9.3节中的等式9.9）相同，因此等 
----------------------- Page 425-----------------------
式等于 Lo （v）=LAR （v）。较旧的实时渲染应用程序有时假定 R 
 （v）的常数值，称为环境颜色camb。这进一步简化了Lo （v）= 
cambLA的等式。反射率方程忽略遮挡，即，将阻止许多表面点 “看 
到”其他对象或同一对象的其他部分的一些进入方向。这种简化通 
常会降低真实感，但对于环境光照尤其明显，当忽略遮挡时，环境 
光照看起来非常平坦。解决这个问题的方法将在 11.3节中讨论，特 
别是在第 11.3.4节中。10.3球面和半球函数为了将环境光照扩展到 
一个恒定项以外，我们需要一种方法来表示从任何方向到物体上的 
入射辐射。首先，我们将辐射亮度视为仅积分方向的函数，而不是 
表面位置。这样做是基于照明环境无限远的假设。到达给定点的辐 
射对于每个进入的方向可以是不同的。照明可以从左侧变为红色， 
从右侧变为绿色，或者从顶部阻挡而不是从侧面阻挡。这些类型的 
数量可以用球形 10.3表示。球面和半球函数 393函数，它们在单 
位球面上或在 R3中的方向空间上定义。我们将此域表示为S.这些 
函数如何工作不受它们是生成单个值还是多个值的影响。例如，通 
过为每个颜色通道存储单独的标量函数，用于存储标量函数的相同 
表示也可用于编码颜色值。假设朗伯表面，通过存储预先计算的辐 
照度函数（例如，与余弦波瓣卷积的辐射），可以使用球函数来计 
算环境照明，用于每个可能的表面法线方向。更复杂的方法存储辐 
射度并在运行时根据阴影表面点计算 BRDF的积分。球面函数也广 
泛用于全局照明算法（第 11章）。与球形函数相关的是半球的函数， 
对于仅定义一半方向的值的情况。例如，这些函数用于描述在没有 
----------------------- Page 426-----------------------
来自下方的光的表面处的入射辐射。我们将这些表示称为球形基础， 
因为它们是在球体上定义的函数的向量空间的基础。尽管环境/高光 
/方向形式（第 10.3.3节）在技术上不是数学意义上的基础，但为 
简单起见，我们也将使用该术语来引用它。将函数转换为给定表示 
称为投影，并且从给定表示中评估函数的值称为重建。每个表示都 
有自己的权衡取舍。我们可能在给定的基础上寻求的属性是：。高 
效的编码（投影）和解码（查找）。。能够表示具有少量系数和低 
重建误差的任意球函数。。投影的旋转不变性是旋转函数的投影的 
结果，与旋转函数然后投影它相同。这种等效意味着用例如球谐函 
数近似的函数在旋转时不会改变。。易于计算编码函数的总和和乘 
积。。易于计算球形积分和卷积。10.3.1简单列表形式表示球形 （或 
半球形）函数的最直接方法是选择多个方向并为每个方向存储一个 
值。评估函数涉及在评估方向周围找到一些样本并用某种形式的插 
值重建该值。这种表现形式简单而富有表现力。添加或乘以这些球 
形函数就像添加或相乘其对应的列表条目一样简单。39410.局部照 
明图10.17。在球体表面上分布点的几种不同方法。从左到右：随 
机点，立方网格点和球形t设计。通过根据需要添加更多样本，我 
们可以编码具有任意低误差的许多不同球函数。以一种允许有效检 
索的方式在一个球体上分布样本 （见图10.17）并不是微不足道的， 
同时相对平等地表示所有方向。最常用的技术是首先将球体展开为 
矩形域，然后使用点网格对该域进行采样。正如二维纹理所代表的 
那样，矩形上的点（纹素）网格，我们可以使用纹素作为样本值的 
----------------------- Page 427-----------------------
底层存储。这样做可以让我们利用GPU加速的双线性纹理过滤来快 
速查找 （重建）。在本章的后面，我们将讨论环境贴图 （第 10.5节）， 
它们是这种形式的球形函数，并讨论了展开球体的不同选项。列表 
形式有缺点。在低分辨率下，硬件过滤提供的质量通常是不可接受 
的。计算卷积的计算复杂度是处理照明时的常见操作，与样本数量 
成正比，并且可能过高。此外，投影在旋转下不是不变的，这对于 
某些应用可能是有问题的。例如，想象一下当它撞击物体表面时编 
码从一组方向发出的光的辐射。如果对象旋转，则编码结果可能会 
以不同方式重建。这可能导致编码的辐射能量的变化，其可以表现 
为场景动画的脉动伪像。通过在投影和重建期间采用与每个样本相 
关联的精心构造的核函数，可以减轻这些问题。但更常见的是，仅 
使用足够密集的采样就足以掩盖这些问题。通常，当我们需要存储 
复杂的高频函数时需要使用表格形式，这些函数需要以低误差编码 
许多数据点。如果我们需要紧凑地编码球形函数，只需要几个参数， 
就可以使用更复杂的基础。作为一种流行的基础选择，环境立方体 
 （AC）是最简单的表格形式之一，由沿着主轴定向的六个平方余弦 
叶构成[1193]。它被称为环境 “立方体”，因为它相当于将数据存 
储在 10.3的面中。球形和半球形函数395一个立方体，当我们从 
一个方向移动到另一个方向时进行插值。对于任何给定方向，只有 
三个波瓣是相关的，因此不需要从存储器中获取其他三个波瓣的参 
数[766]。在数学上，环境立方体可以定义为FAC （d）=dd·sel + 
 （c +，c。，d），（10.16）其中c +和c。包含立方体面的六个 
----------------------- Page 428-----------------------
值，sel + （c +，c。，d）是一个向量函数，它为每个组件假定一 
个来自c +或c的值。基于d中的各个分量是否为正。环境立方体 
类似于立方体贴图（第10.4节），每个立方体面上都有一个纹素。 
在某些系统中，针对此特定情况在软件中执行重建可能比在立方体 
贴图上使用GPU的双线性过滤更快。Sloan[1656]推导出一种简单 
的公式，用于在环境立方体和球谐函数基础之间进行转换（第 10.3.2 
节）。使用环境立方体的重建质量相当低。通过存储和插值八个值 
而不是六个值 （对应于立方体顶点），可以获得稍微好一些的结果。 
最近，Iwanicki和Sloan [808]提出了一种称为环境骰子（AD）的 
替代方案。基础由沿二十面体顶点定向的平方和四次幂余弦形成。 
存储的十二个值中有六个用于重建，并且确定检索哪六个的逻辑比 
环境立方体的相应逻辑稍微复杂一些，但结果的质量要高得多。 
10.3.2球形基底有很多种方法可以将函数投影（编码）到使用固定 
数量的值（系数）的表示中。我们所需要的只是一个数学表达式， 
它跨越我们的球形域，我们可以改变一些参数。然后，我们可以通 
过拟合来近似任何给定的函数，即找到最小化表达式和给定函数之 
间的误差的参数值。最小可能的选择是使用常数：Fc （θ，φ）=c·1。 
我们可以通过在单位球的表面积上求平均得到函数f的投影：c =1 
4？Rf （θ，φ）。周期函数的平均c也称为 DC分量。这个基础具 
有简单的优点，甚至尊重我们正在寻找的一些属性（易于重建，添 
加，产品，旋转不变性）。然而，它不能很好地表达大多数球形函 
数，因为它只是用它们的平均值代替它们。我们可以使用两个系数 
----------------------- Page 429-----------------------
a和b来构造稍微更复杂的近似：Fhemi （θ，φ）=a +cos （θ） 
+12 （b.a），39610.局部照明00 10 11234 51234 512 
34 5图10.18。基函数的基本例子。在这种情况下，空间是 “0到 
5之间的输入，其值介于0和 1之间。 “左图显示了这种功能的一 
个例子。中间的图显示了一组基函数 （每种颜色都是不同的函数）。 
右图显示了目标函数的近似值，通过将每个基函数乘以权重并将它 
们相加而形成。基函数按其各自的权重进行缩放。黑线显示求和的 
结果，它是原始函数的近似值，以灰色显示以进行比较。它创建了 
一个可以在极点处编码精确值的表示，并且可以在球体表面之间进 
行插值。这种选择更具表现力，但现在投影更复杂，并且对于所有 
旋转都不是不变的。事实上，这个基础可以看作是一个表格形式， 
只有两个样本，放在两极。一般来说，当我们谈论函数空间的基础 
时，我们意味着我们有一组函数，其线性组合（加权和求和）可用 
于表示给定域上的其他函数。这个概念的一个例子如图 10.18所示。 
本节的其余部分探讨了可用于近似球体上的函数的一些基础选择。 
球面径向基函数使用GPU硬件过滤的表格形式的低质量重建至少 
在某种程度上是由用于内插样本的双线性形状函数引起的。其他功 
能可用于对样本进行加权以进行重建。这些功能可以产生比双线性 
滤波更高质量的结果，并且它们可以具有其他优点。通常用于此目 
的的一类功能是球形径向基函数 （SRBF）。它们是径向对称的，这 
使得它们仅具有一个参数的功能，即它们所朝向的轴与评估方向之 
间的角度。基础由一组称为波瓣的这样的函数形成，这些函数遍布 
----------------------- Page 430-----------------------
球体。函数的表示由每个波瓣的一组参数组成。这个集合可以包括 
它们的方向，但它使投影更加困难（需要非线性，全局优化）。由 
于这个原因，通常假定波瓣方向是固定的，在球体上均匀分布，并 
且使用其他参数，例如每个波瓣的大小或其扩展，即所覆盖的角度。 
通过评估给定方向的所有叶片并对结果求和来执行重建。10.3。球 
面和半球函数397球面高斯SRBF波瓣的一个特别常见的选择是球 
面高斯（SG），在方向统计中也称为von Mises-Fisher分布。我 
们应该注意到von-Mises-Fisher分布通常包括归一化常数，我们在 
制定中避免使用归一化常数。单个波瓣可以定义为G （v，d，λ）= 
e？ （v·d.1）， （10.17）其中v是评估方向 （单位矢量），d是波 
瓣方向轴（平均值）分布，也是标准化的），λ≥0是叶片锐度（控 
制其角宽度，也称为浓度参数或扩散）[1838]。要构造球形基础， 
然后，我们使用给定数量的球面高斯的线性组合：FG （v）=XkwkG 
 （v，dk，λk）。 （10.18）将球函数投影到该表示中需要找到最小 
化重建误差的参数集{wk，dk，λk}。该过程通常通过数值优化来完 
成，通常使用非线性最小二乘法优化算法（例 如 
Levenberg-Marquardt）。请注意，如果我们允许完整集参数在优 
化过程中发生变化，我们就不会使用函数的线性组合，因此公式 
10.18不代表基础。只有当我们选择一组固定的波瓣 （方向和点差） 
时才能获得适当的基础，以便整个域被很好地覆盖[1127]，并通过 
仅拟合权重wk来执行投影。这样做也极大地简化了优化问题，因 
为现在可以将其表述为普通最小二乘优化。如果我们需要在不同的 
----------------------- Page 431-----------------------
数据集（投影函数）之间进行插值，这也是一个很好的解决方案。 
对于该用例，允许波瓣方向和锐度变化是有害的，因为这些参数是 
高度非线性的。这种表示的优势在于SG上的许多操作都具有简单 
的分析形式。两个球面高斯的乘积是另一个球面高斯 （见[1838]）： 
G1G2=G？v，d'||d'|| ，λ'？其中d'=λ1d1+λ2d2λ1+λ2，λ'= （λ 
1+λ2）||d'||。球体高斯在球体上的积分也可以通过分析计算：ZG 
 （v）dv=2π1。E2？λ，这意味着两个球面高斯产品的积分也有一 
个简单的公式。398 10.局部照明yzx 10图10.19。各向异性球面 
高斯。左图：球体上的ASG和相应的自上而下的图。右图：ASG 
配置的其他四个示例，显示了配方的表现力。 （图片由徐坤提供。） 
如果我们可以将光辐射表示为球面高斯，那么我们可以将其产品与 
以相同表示编码的BRDF进行整合以执行光照计算[1408,1838]。由 
于这些原因，SG已被用于许多研究项目[582,1838]以及工业应用 
[1268]。至于平面上的高斯分布，可以推广von Mises-Fisher分布 
以允许各向异性。徐等人。[1940]引入了各向异性球面高斯 （ASGs; 
见图10.19），它是通过用两个补充轴t和b增加单向d来定义的， 
它们共同形成一个正交切线框架：G （v，[d，t，b] ，[λ，μ]）=S 
 （v，d）e。？ （v·t）2.μ （v·b）2， （10.19）其中λ，μ≥0控制沿 
两轴的波瓣扩展切线框和S （v，d）= （v·d）+是平滑项。这个术 
语是定向统计中使用的 Fisher-Bingham分布与我们用于计算机图 
形的ASG之间的主要区别。徐等人。还为积分，乘积和卷积运算符 
提供分析近似。虽然SG具有许多理想的属性，但它们的一个缺点 
----------------------- Page 432-----------------------
是，与表格形式不同，并且通常在有限范围（带宽）的内核中，它 
们具有全局支持。即使它的衰减相当快，每个波瓣对于整个球体都 
是非零的。这个全局范围意味着如果我们使用 N个波瓣来表示一个 
函数，我们将需要它们中的所有 N个用于任何方向的重建。球面谐 
波球面谐波2 （SH）是球体上的一组正交基函数。正交基函数集是 
一组，使得来自该集的任何两个不同函数的内积为零。内部产品是 
点产品的更一般但相似的概念。两个向量的内积是它们的点积：组 
件对之间的乘法之和。我们可以类似地2我们在这里讨论的基函数 
更恰当地称为 “真实球谐函数”，因为它们代表了复值球谐函数的 
实部。10.3。球形和半球形函数39900 10 11234 51234 5 
1234 5图10.20。正交基函数。此示例使用与图10.18相同的空 
间和目标函数，但基函数已被修改为正交。左图显示目标函数，中 
间显示基本函数的正交集，右图显示缩放基函数。对目标函数的最 
终近似显示为黑色虚线，并且原始函数以灰色显示以进行比较。通 
过考虑这些函数的积分乘以两个函数得出内积的定义：hfi （x），fj 
 （x）i≡Zfi （x）fj （x）dx，（10.20）其中执行积分在相关领域。 
对于图 10.18所示的功能，相关域在x轴上介于0和5之间 （请注 
意，此特定功能集不是正交的）。对于球函数，形式略有不同，但 
基本概念是相同的：hfi （n），fj （n）i≡Zn∈？fi （n）fj （n）dn， 
 （10.21）其中n∈？表示积分是在单位球上执行的。正交集是一个 
正交集，其附加条件是集合中任何函数的内积等于 1.更正式地，一 
组函数{fj （）}为正交的条件是hfi （） ，fj （）i= （0，其中i6=j， 
----------------------- Page 433-----------------------
1，其中i=j。 （10.22）图10.20显示了一个类似于图10.18的例 
子，其中基函数是正交的。注意，正交基函数如图所示图 10.20不 
重叠。这种条件对于非负函数的标准正交集是必要的，因为任何重 
叠都意味着非零内积。在其范围的一部分上具有负值的函数可以重 
叠并且仍然形成正交集。这种重叠通常导致更好的近似，因为它允 
许碱基是平滑的。具有不相交域的基础倾向于导致不连续。400 10. 
局部照明标准正交基的优点是找到与目标函数最接近的近似值的过 
程很简单。为了执行投影，每个基函数的系数是具有适当基函数的 
目标函数ftarget （）的内积：kj=hftarget （），fj （）i，ftarget 
 （）≈Xnj =1kjfj （）。 （10.23）在实践中，这个积分必须用数字 
计算，通常通过蒙特卡罗采样，平均在球体上均匀分布的n个方向。 
正交基础在概念上类似于4.2.4节中介绍的三维向量的“标准基础”。 
标准基础的目标不是函数，而是点的位置。标准基础由三个向量 （每 
个维度一个）而不是一组函数组成。标准基础是通过公式 10.22中 
使用的相同定义的标准正交。将点投影到标准基础上的方法也是相 
同的，因为系数是位置矢量和基矢量之间的点积的结果。一个重要 
的区别是标准基准精确地再现了每个点，而一组有限的基函数只是 
近似于它的目标函数。结果永远不会精确，因为标准基础使用三个 
基矢量来表示三维空间。函数空间具有无限多个维度，因此有限数 
量的基函数永远无法完美地表示它。球谐函数是正交和正交的，并 
且它们具有其他几个优点。它们是旋转不变的，并且SH基函数的 
评估成本低廉。它们是单位长度矢量的x，y和z坐标中的简单多项 
----------------------- Page 434-----------------------
式。然而，像球形高斯一样，它们具有全局支持，因此在重建期间 
需要评估所有基函数。基函数的表达式可以在几个参考文献中找到， 
包括Sloan [1656]的介绍。他的演讲值得注意，因为它讨论了许多 
处理球谐函数的实用技巧，包括公式和某些情况下的着色器代码。 
最近，斯隆还推导出了有效的SH重建方法[1657]。SH基函数排列 
在频带中。第一个基函数是常数，接下来的三个是在球体上缓慢变 
化的线性函数，接下来的五个函数表示稍微更快变化的二次函数。 
见图 10.21。低频率（即在球体上缓慢变化）的函数，例如辐照度 
值，用相对较少的SH系数精确表示（我们将在第 10.6.1节中看到）。 
当投射到球谐波时，得到的系数表示投影函数的各种频率的幅度， 
即其频谱。在该谱域中，基本性质成立：两个函数的乘积的积分等 
于函数投影的系数的点积。此属性允许我们有效地计算光照积分。 
10.3。球形和半球形函数401 l=0l=1l=2l=3l=4图10.21。 
球谐波的前五个频段。每个球谐函数都有正值区域（绿色）和负值 
区域（红色），当它们接近零时渐渐变为黑色。（球形谐波可视化 
由RobinGreen提供。）对球谐函数的许多操作在概念上都很简单， 
在系数向量上归结为矩阵变换[583]。这些操作包括计算投射到球谐 
函数，旋转投影函数和计算卷积的两个函数的乘积的重要情况。在 
实践中SH中的矩阵变换意味着这些操作的复杂性在所使用的系数 
的数量上是二次的，这可能是相当大的成本。幸运的是，这些矩阵 
通常具有可以被利用来设计更快算法的特殊结构。Kautz等人。[869] 
提出了一种通过将旋转计算分解为围绕x轴和z轴的旋转来优化旋 
----------------------- Page 435-----------------------
转计算的方法。Hable[633]给出了一种快速旋转低阶SH投影的流 
行方法。Green的调查[583]讨论了如何利用旋转矩阵的块结构来加 
快计算速度。目前，现有技术通过对分区谐波的分解来表示，如 
Nowrouzezahrai等人所述。[1290]。下面描述的诸如球谐波和H 
基的频谱变换的常见问题是它们可以表现出称为振铃的视觉伪像 
 （也称为吉布斯现象）。如果原始信号包含无法用带限近似表示的 
快速变化，则重建将显示振荡。在极端情况下，这种重建功能甚至 
可以产生负值。可以使用各种预过滤方法来解决这个问题 
[1656,1659]。其他球面表示许多其他表示可以使用有限数量的系数 
来编码球面函数。线性变换后的余弦 （第 10.1.2节）是可以有效逼 
近 BRDF函数的表示的示例，同时具有易于在球体的多边形截面上 
可积的特性。402 10.局部照明球面小波[1270,1579,1841]是平衡空 
间中的局部性（具有紧凑支撑）和频率（平滑性）的基础，允许压 
缩表示高频函数。球形分段 同时具有易于在球体的多边形截面上可 
积的特性。402 10.局部照明球面小波[1270,1579,1841]是平衡空间 
中的局部性（具有紧凑支撑）和频率（平滑性）的基础，允许压缩 
表示高频函数。球形分段 同时具有易于在球体的多边形截面上可积 
的特性。402 10.局部照明球面小波[1270,1579,1841]是平衡空间中 
的局部性（具有紧凑支撑）和频率（平滑性）的基础，允许压缩表 
示高频函数。球形分段恒定基函数[1939]，将球体划分为恒定值的 
区域，并且依赖于矩阵因子分解的双聚类近似[1723]也已用于环境 
照明。10.3.3半球形基底尽管上述基础可用于表示半球形函数，但 
----------------------- Page 436-----------------------
它们是浪费的。信号的一半总是等于零。在这些情况下，通常优选 
使用直接在半球形域上构建的表示。这与在曲面上定义的函数尤其 
相关：BRDF，入射辐射和到达对象的给定点的辐照度都是常见的例 
子。这些函数自然地受限于以给定表面点为中心并与表面法线对齐 
的半球; 它们没有指向对象内部的方向值。环境/高光/方向这些线上 
最简单的表示之一是恒定函数和单个方向的组合，其中信号在半球 
上最强。它通常被称为环境/高光/方向（AHD）基础，其最常见的 
用途是存储辐照度。名称AHD表示各个组件所代表的含义：恒定 
的环境光，加上近似 “高亮”方向的辐照度的单向光，以及大部分 
入射光聚集的方向。AHD基础通常需要存储八个参数。两个角度用 
于方向矢量，两个RGB颜色用于环境和定向光强度。它的第一个值 
得注意的用途是在Quake III游戏中，动态物体的体积照明以这种 
方式存储。从那时起，它已被用于多个标题，例如 “使命召唤”特 
许经营权。对这种表示的投射有点棘手。因为它是非线性的，所以 
找到接近给定输入的最佳参数在计算上是昂贵的。在实践中，使用 
启发式代替。信号首先投射到球谐波，最佳线性方向用于定向余弦 
波瓣。给定方向，可以使用minimalsquares最小化来计算环境值 
和高亮值。Iwanicki和Sloan[809]展示了如何在执行非负性的同时 
执行此投影。光能传递法线贴图/半条命2 BasisValve使用新颖的 
表现形式，它表示在光能传递法向映射的背景下的定向辐照度，用 
于半条命2系列游戏[1193,1222]。最初设计用于存储预先计算的漫 
射光，同时允许正常映射，它是10.3。球形和半球形函数403nm2 
----------------------- Page 437-----------------------
m0m1bt图10.22。半条命2照明基础。三个基矢量在切平面上 
方具有大约26的仰角，并且它们在该平面中的投影在法线周围以 
120°间隔相等地间隔开。它们是单位长度，每一个都垂直于另外两 
个。现在经常被称为半条命2的基础。它通过在切线空间中采样三 
个方向来表示表面上的半球函数。见图 10.22。切线空间中三个相 
互垂直的基矢量的坐标是m0 =？.1√6，1√2,1√3？，m1 =？.1√ 
6，.1√2,1√3？，m2=√2√3,0,1√3！。 （10.24）对于重建，给定 
切空间方向d，我们可以沿三个基矢量插值 E0，E1和 E2-：3E （n） 
=X2 k =0 max （mk·n，0） 2EkX2 k =0 max （mk·n，0）2。 
 （10.25）格林[579]指出，如果以下三个值在切线空间方向d上预 
先计算，则公式 10.25可以显着降低成本：dk =max （mk·n，0） 
2X2 k =0 max （mk·n，0）2，（10.26）3GDC 2004演示文 
稿中给出的表述不正确。公式10.25中的表格来自SIGGRAPH2007 
演示文稿[579]。404 10.k=0,1,2的局部照明。等式 10.25然后简 
化为E （n）=X2 k=0dkEk。 （10.27）格林描述了这种表现的其 
他几个优点，其中一些在第 11.4节中讨论。半衰期2基础适用于定 
向辐照度。斯隆[1654]发现这种表示产生的结果优于低阶半球谐波。 
半球谐波/ H-BasisGautron等。[518]将球谐波专门化为半球形域， 
称为半球谐波 （HSH）。可以使用各种方法来执行此专业化。例如， 
Zernike多项式是正交函数，如球谐函数，但在单位磁盘上定义。 
与SH一样，这些可以用于变换频域（频谱）中的函数，这产生许 
多方便的属性。由于我们可以将单位半球转换为圆盘，我们可以使 
----------------------- Page 438-----------------------
用Zernike多项式来表示半球函数[918]。然而，用这些进行重建非 
常昂贵。Gautron等人的解决方案更经济，并且允许通过系数向量 
上的矩阵乘法进行相对快速的旋转。然而，HSH基础仍然比球谐函 
数更昂贵，因为它是通过将球的负极移动到半球的外边缘而构造的。 
这种移位操作使基函数成为非多项式，需要计算除法和平方根，这 
在GPU硬件上通常较慢。此外，基础在半球边缘始终是恒定的，因 
为它在移动之前映射到球体上的单个点。边缘附近的近似误差可能 
相当大，特别是如果仅使用几个系数 （球谐波频带）。Habel[627] 
介绍了 H基，其中，纵向参数化的部分球谐基础和横向参数化的部 
分 HSH。这个混合SH的移位和非移位版本的基础仍然是正交的， 
同时允许有效的评估。10.4环境映射在一个或多个图像中记录球形 
函数称为环境映射，因为我们通常使用纹理映射来实现表中的查找。 
这种表现形式是最强大和最受欢迎的环境照明形式之一。与其他球 
形表示相比，它消耗更多内存，但实时解码简单快速。此外，它可 
以表达任意高频率的球形信号（通过增加纹理的分辨率）并准确捕 
获任何 10.4。环境映射405环境辐射范围 （通过增加每个通道的位 
数）。这样的准确性是有代价的。与存储在其他常用纹理中的颜色 
和着色器属性不同，存储在环境贴图中的辐射值通常具有高动态范 
围。每个纹素平均值更多位意味着环境贴图比其他纹理占用更多空 
间，并且访问速度较慢。我们对任何全局球函数（即，用于场景中 
的所有对象的函数）具有基本假设，即入射辐射Li仅取决于方向。 
该假设要求被反射的物体和光线很远，并且反射器不会反射自身。 
----------------------- Page 439-----------------------
依赖于环境映射的着色技术通常不具有表示环境照明的能力，而在 
于我们如何将它们与给定材料集成。也就是说，为了执行整合，我 
们必须在 BRDF上使用哪种近似和假设？反射映射是环境映射的最 
基本情况，我们假设 BRDF是一个完美的镜像。光学平坦的表面或 
镜子将入射光线反射到光的反射方向 ri （第9.5节）。类似地，输 
出辐射亮度包括来自仅一个方向的入射辐射，即反射视图矢量r。以 
与ri （等式9.15）相同的方式计算该向量：r=2 （n·v）n。v。（10.28） 
镜子的反射方程大大简化：Lo （v）=F （n，r）Li （r）， （10.29） 
其中F是菲涅耳项 （第9.5节）。注意，与基于半矢量的BRDF （使 
用半矢量h和 l或v之间的角度）中的菲涅耳项不同，公式 10.29 
中的菲涅耳项使用表面法线n和反射矢量 r之间的角度（这是与 n 
和v之间的角度相同。由于入射辐射Li仅取决于方向，因此可以将 
其存储在二维表中。这种表示使我们能够利用任意的入射辐射分布 
有效地照亮任何形状的镜面状表面。我们通过计算每个点的 r并查 
找表中的辐亮度来实现。该表称为环境地图，由 Blinn和 Newell 
[158]引入。见图10.23。反射映射算法的步骤如下：。生成或加载 
表示环境的纹理。。对于包含反射对象的每个像素，计算对象表面 
上位置的法线。。从视图矢量和法线计算反射的视图矢量。。使用 
反射视图向量计算环境贴图中的索引，该索引表示反射视图方向上 
的入射辐射。406 10.局部照明nvr投影仪功能将反射视图矢量 （x， 
y，z）环境纹理图像反射观察者表面转换为纹理图像（u，v）图10.23。 
反射映射。观察者看到一个对象，并且从v和n计算反射的视图向 
----------------------- Page 440-----------------------
量r。反射的视图向量访问环境的表示。通过使用一些投影仪功能来 
计算访问信息，以将反射的视图矢量 （x，y，z）转换为用于检索环 
境的商店辐射的纹理坐标。。使用环境贴图中的纹素数据作为公式 
10.29中的入射辐亮度。值得一提的是潜在的环境映射障碍。使用 
环境映射时，平面通常不能很好地工作。平坦表面的问题在于从其 
反射的光线通常不会变化超过几度。这种紧密聚类导致环境表的一 
小部分被映射到相对较大的表面上。在第 11.6.1节中讨论的也使用 
发射辐射的位置信息的技术可以提供更好的结果。也，如果我们假 
设完全平坦的表面，例如地板，则可以使用平面反射的实时技术 （第 
11.6.2节）。用纹理数据照亮场景的想法也称为基于图像的照明 
 （IBL），通常当使用捕获360度全景，高动态范围图像的相机从真 
实场景获得环境地图时[332,1479]。使用具有法线贴图的环境映射 
特别有效，产生丰富的视觉效果。见图 10.24。这些功能组合在历 
史上也很重要。限制形式的碰撞环境映射是在消费级图形硬件中首 
次使用依赖纹理读取（第6.2节），从而将此功能作为像素着色器 
的一部分。有多种投影仪功能可将反射的视图矢量映射到一个或多 
个纹理中。我们在这里讨论更流行的映射，并注意每个映射的优势。 
10.4.1纬度 - 经度映射1976年，Blinn和 Newell[158]开发了第 
一个环境映射算法。他们使用的映射是在 10.4的地球仪上使用的熟 
悉的纬度/经度系统。环境映射407图10.24。一盏灯（在相机处） 
与凹凸和环境贴图相结合。从左到右：没有环境映射，没有凹凸贴 
图，相机没有光线，所有三个组合在一起。（从 AMD GPU 
----------------------- Page 441-----------------------
MeshMapper模型中生成的三个.js示例webgl材质 displamap 
[218]生成的图像。）地球，这就是为什么这种技术通常被称为纬度 
- 经度映射或纬度 - 长度映射的原因。他们的计划不像是从外面看 
的地球，而是像夜空中的星座图。就像地球上的信息可以展平为墨 
卡托或其他投影地图一样，可以将围绕空间中的点的环境映射到纹 
理。当针对特定表面位置计算反射视图矢量时，矢量被转换为球面 
坐标（ρ，φ）。这里，φ，相当于经度，从0到2π弧度变化，ρ， 
纬度，从0到π弧度变化。对 （ρ，φ）由公式10.30计算，其中r= 
 （rx，ry，rz）是归一化的反射视图向量，+z为向上：ρ=arccos 
 （rz）和φ=atan2 （ry，rx） ）。（10.30）有关atan2的说明， 
请参见第8页。然后，这些值用于访问环境贴图并检索在反射视图 
方向上看到的颜色。请注意，纬度 - 经度映射与墨卡托投影不同。 
它使纬度线之间的距离保持恒定，而墨卡托在极点处变为无穷大。 
将球体展开到平面中总是需要一些变形，特别是如果我们不允许多 
次切割，并且每个投影在保留区域，距离和局部角度之间都有自己 
的权衡。这种映射的一个问题是信息密度远不一致。从图10.25的 
顶部和底部的极端拉伸可以看出，极点附近的区域比赤道附近的区 
域接收更多的纹素。这种失真是有问题的，不仅因为它不会导致最 
有效的编码，而且在采用硬件纹理滤波时也会导致伪像，尤其是在 
两极奇点处可见。过滤内核不遵循纹理的拉伸，因此在具有较高纹 
理像素密度的区域中有效地收缩。另请注意，虽然408 10.Local 
Illumination图10.25。地球具有相等的纬度和经度线，与传统的 
----------------------- Page 442-----------------------
墨卡托投影相反。 （图片来自美国国家航空航天局的 “蓝色大理石” 
系列。）投影数学很简单，可能效率不高，因为诸如反余弦的超越 
功能在GPU上代价高昂。10.4.2球体映射最初由Williams [1889] 
提及，由 Miller和 Hoffman [1212]独立开发，sphere mapping 
是一般商业图形硬件支持的第一种环境映射技术。纹理图像是从完 
全反射的球体中正交观察的环境外观得出的，因此这种纹理称为球 
体图。制作真实环境的球体地图的一种方法是拍摄闪亮球体的照片， 
例如圣诞树装饰物。见图 10.26。得到的圆形图像也称为光探测器， 
因为它捕获球体位置处的照明情况。拍摄球形探针可以是有效的图 
10.26。球体图（左）和纬度 - 经度格式的等效图（右）。10.4。 
环境映射409vvynhzr hy图10.27。给定球面图空间中的恒定视图 
方向v和反射视图矢量 r，球体图的法线n在两者之间。对于原点 
处的单位球体，交点h具有与单位法线n相同的坐标。还示出了hy 
 （从原点测量）和球体图纹理坐标v （不与视图矢量v混淆）是如 
何相关的。捕获基于图像的光照的方法，即使我们在运行时使用其 
他编码。如果捕获具有足够的分辨率来克服方法之间的失真差异， 
我们总是可以在球形投影和另一种形式之间进行转换，例如稍后讨 
论的立方体映射 （第 10.4.3节）。反射球体在球体的正面显示整个 
环境。它将每个反射的视图方向映射到该球体的二维图像上的点。 
假设我们想要转向另一个方向，即在球体地图上给出一个点，我们 
会想要反射的视图方向。为此，我们将在该点处取球面上的曲面法 
线，然后生成反射的视图方向。因此，要反转过程并从反射的视图 
----------------------- Page 443-----------------------
矢量获取球体上的位置，我们需要在球体上导出曲面法线，然后生 
成访问球体贴图所需的（u，v）参数。球体的法线是反射视图矢量 
r和原始视图矢量 v 之间的半角矢量，它是球体图的空间中的 
 （0,0,1）。见图 10.27。该法向量n是原始和反射视图矢量的总和， 
即 （rx，ry，rz+1）。归一化这个向量给出单位法线：n=？rxm， 
rym，rz+1m？，其中m=qr2x+r2y + （rz+1）2。 （10.31） 
410 10.局部照明如果球体位于原点并且其半径为 1，则单位法线的 
坐标也是球体上法线的位置h。我们不需要hz，因为 （hx，hy）描 
述了球体图像上的一个点，每个值都在[.1,1]范围内。要将此坐标映 
射到范围[0,1）以访问球体贴图，请将每个划分为2并添加一半： 
m=qr2x+r2y + （rz+1）2，u=rx2m+0.5，并且v =ry2m 
+0.5。 （10.32）与纬度 - 经度映射相比，球形映射计算起来更简 
单，并且显示了一个位于图像圆边缘周围的奇点。缺点是球体贴图 
纹理捕获仅对单个视图方向有效的环境视图。此纹理确实捕获整个 
环境，因此可以计算新查看方向的纹理坐标。然而，这样做会导致 
视觉伪影，因为球形图的小部分由于新视图而变得放大，并且边缘 
周围的奇点变得明显。在实践中，球形图通常被假定为跟随相机， 
在视图空间中操作。由于球面图是针对固定视图方向定义的，因此 
球面图上的每个点原则上不仅定义反射方向，还定义表面法线。见 
图10.27。对于任意各向同性 BRDF，可以求解反射方程，并且其结 
果可以存储在球形图中。该 BRDF可包括漫反射，镜面反射，逆反 
射和其他术语。只要照明和视图方向是固定的，球形图就是正确的。 
----------------------- Page 444-----------------------
甚至可以使用在实际照射下的真实球体的摄影图像，只要球体的 
BRDF是均匀的和各向同性的。也可以索引两个球面图，一个具有 
反射矢量，另一个具有曲面法线，以模拟镜面反射和漫反射环境效 
果。如果我们调整存储在球体贴图中的值以考虑表面材料的颜色和 
粗糙度，我们有一种廉价的技术可以产生令人信服的（尽管与视图 
无关的）材料效果。这种方法由雕刻软件 PixologicZBrush推广为 
 “MatCap”着色。见图 10.28。10.4.3立方体绘图 1986年，Greene 
[590]介绍了立方体环境地图，通常称为立方体地图。这种方法是当 
今最流行的方法，其投影直接在现代GPU上的硬件中实现。通过将 
环境投影到立方体的侧面来创建立方体贴图，立方体的中心位于相 
机的位置。然后将立方体面上的图像用作环境贴图。见图 10.29和 
10.30。立方体贴图通常在 “交叉”图中可视化，即打开立方体并将 
其展平到平面上。但是，在硬件立方体贴图上存储为六个方形纹理， 
而不是单个矩形纹理，因此没有浪费的空间。10.4。环境映射411 
图10.28。 “MatCap”渲染的示例。左侧的对象使用右侧的两个球 
体贴图进行着色。顶部的地图使用视空间法线向量索引，而底部的 
地图使用视图空间反射向量，并且两者的值被加在一起。产生的效 
果非常有说服力，但移动视点会发现照明环境遵循摄像机的坐标框 
架。图10.29。Greene的环境地图的例证，显示关键点。左侧的多 
维数据集展开到右侧的环境贴图中。图 10.30。图10.26中使用的 
相同环境贴图，转换为立方体贴图格式。412 10.局部照明图 10.31。 
随着汽车改变位置，ForzaMotorsport7中的环境地图照明更新。 
----------------------- Page 445-----------------------
 （图片由微软Turn 10Studios提供。）可以通过在立方体中心使 
用相机渲染场景六次来合成地创建立方体贴图，以90°视角观察每 
个立方体面。见图 10.31。为了从真实环境生成立方体贴图，通常 
通过拼接或专用相机获取的球形全景图投影到立方体贴图坐标系 
中。与球体映射不同，立方体环境映射与视图无关。它还具有比纬 
度 - 经度映射更加均匀的采样特性，纬度 - 经度映射与赤道相比 
对极点进行过采样。Wan 等人。[1835,1836]提出了一种称为 
isocube的映射，它具有比立方体映射更低的采样率差异，同时仍 
然利用立方体映射纹理硬件来提高性能。访问立方体贴图非常简单。 
任何矢量都可以直接用作三分量纹理坐标，以便在指向的方向上获 
取数据。因此，对于反射，我们可以将反射的视图矢量r传递给GPU， 
甚至不需要对其进行标准化。在较旧的GPU上，双线性过滤可以显 
示沿立方体边缘的接缝，因为纹理硬件无法在不同的立方体面上正 
确过滤 （执行起来有些昂贵的操作）。开发了回避这个问题的技术， 
例如使视图投影稍宽，以便单个面也包含这些相邻的纹素。现在， 
所有现代GPU都可以正确地跨边缘执行此过滤，因此不再需要这些 
方法。10.4。环境映射413图10.32。与八面体展开（右）相比， 
立方体贴图展开球体（左）。（在 Nimitz的Shadertoy之后。） 
10.4.4其他预测今天，立方体贴图是环境照明最受欢迎的表格表示， 
因为它具有多功能性，再现高频细节的准确性以及GPU上的执行速 
度。但是，已经开发了一些值得一提的其他预测。Heidrich和Seidel 
[702,704]建议使用两个纹理来执行双抛物面环境映射。这个想法就 
----------------------- Page 446-----------------------
像球体映射的想法，但不是通过记录球体环境的反射来生成纹理， 
而是使用两个抛物线投影。每个抛物面创建一个类似于球体地图的 
圆形纹理，每个抛物面覆盖一个环境半球。与球体映射一样，反射 
的视图光线在地图的基础上计算，即在其参照系中计算。反射视图 
矢量的z分量的符号用于决定要访问的两个纹理中的哪一个。对于 
前方图像，访问函数是u=rx2 （1+rz）+0.5，v =ry2 （1+rz） 
+0.5 （10.33），对于后方图像，访问函数与rz的符号反转相同。 
与球形图相比，抛物线图具有更均匀的纹理纹理像素采样，甚至是 
立方体图。但是，必须注意在两个投影之间的接缝处进行适当的采 
样和插值，这使得访问双抛物面图更加昂贵。八面体映射[434]是另 
一个值得注意的预测。它不是将周围的球体映射到立方体，而是映 
射到八面体（见图 10.32）。为了将这种几何形状展平成纹理，将 
其八个三角形面切割并布置在平面上。可以是正方形或矩形配置。 
如果我们使用方形配置，访问八面体映射的数学是非常有效的。给 
定反射方向 r，我们使用414计算归一化版本 10.局部照明绝对值 
L1范数：r'=r|rx|+|ry|+|rz|。对于r'y为正的情况，我们可 
以用u=r'x·0.5 +0.5，v =r'y·0.5+0.5来索引方形纹理。（10.34） 
当r'y为负时，我们需要用变换u= （1。|r'z|）·符号 （r'x）·0.5+ 
0.5，v向外 “折叠”八面体的后半部分。 = （1。|r'x）| ·符号 （r'z）·0.5 
+0.5。（10。35）八面体映射不受双重抛物面映射的滤波问题的 
影响，因为参数化的接缝对应于所使用的纹理的边缘。纹理 “环绕” 
采样模式可以自动从另一侧访问纹素并执行正确的插值。虽然投影 
----------------------- Page 447-----------------------
的数学稍微涉及一些，但实际上表现更好。引入的失真量与立方体 
贴图的失真量相似，因此当不存在立方体贴图纹理硬件时，八面体 
贴图可能是一个很好的选择。另一个值得注意的用途是仅使用两个 
坐标表示三维方向 （归一化向量），作为压缩平均值 （第 16.6节）。 
对于围绕轴径向对称的环境贴图的特殊情况，Stone [1705]提出了 
使用单个一维纹理的简单因子分解，该纹理存储沿着来自对称轴的 
任何子午线的辐射值。他将这个方案扩展到二维纹理，在每一行中 
存储一个预先与不同的 Phong波瓣卷积的环境地图。这种编码可以 
模拟各种材料，并用于编码晴朗天空发出的辐射。10.5基于镜面图 
像的光照虽然环境贴图最初是作为渲染镜像表面的技术而开发的， 
但它也可以扩展为光泽反射。当用于模拟无限远光源的一般镜面反 
射效果时，环境贴图也称为镜面光探测器。使用该术语是因为它们 
捕获场景中给定点处的所有方向的辐射（因此探测），并使用该信 
息来评估一般 BRDF- 不仅是纯镜子或朗伯曲面的受限情况。名称 
镜面立方体贴图也用于将环境光照存储在立方体贴图中的常见情 
况，这些立方体贴图已经过操作以模拟光泽材质上的反射。为了模 
拟表面粗糙度，可以对纹理中的环境表示进行预滤波[590]。通过模 
糊环境贴图纹理，我们可以呈现镜面反射，看起来比完全镜像反射 
更粗糙。这种模糊应该以非线性方式进行，即纹理的不同部分应该 
是 10.5。高光镜面反射照明415图10.33。在顶端，原始环境贴图 
 （左）和应用于球体（右侧）的着色结果。在底部，使用高斯内核 
模糊的相同环境贴图模拟粗糙材质的外观。不同的模糊。需要进行 
----------------------- Page 448-----------------------
这种调整，因为环境贴图纹理表示具有到理想的方向球面空间的非 
线性映射。两个相邻纹理像素的中心之间的角距离不是恒定的，单 
个纹理像素也不包括立体角。预处理立方体贴图的专用工具，例如 
AMD的CubeMapGen （现在是开源），在过滤时会考虑这些因素。 
来自其他面的相邻样本用于创建mipmap链，并且每个纹素的角度 
范围都被考虑在内。图 10.33显示了一个示例。模糊环境地图，在 
凭经验接近粗糙表面的外观时，与实际的 BRDF无关。更原则的方 
法是在考虑给定的表面法线和视图方向时考虑 BRDF函数在球体上 
采用的形状。然后，我们使用此分布过滤环境贴图。见图 10.34。 
过滤带有镜面波瓣的环境贴图并非易事，因为 BRDF可以采用任何 
形状，具体取决于其粗糙度参数以及视图和法线向量。输入值的至 
少五个维度（粗糙度和视角和法线方向各自的两个极角）控制所得 
的凸起形状。为这些中的每个选择存储几个环境贴图是不可行的。 
10.5。1预过滤环境映射应用于光泽材料的环境照明预过滤的实际 
实施需要使用 BRDF的近似值，以便得到的纹理为416 10.局部照 
明图10.34。左图显示了反射物体的眼睛光线，以从环境纹理（在 
这种情况下为立方体贴图）中检索完美的镜面反射。右图显示了反 
射视图光线的镜面反射波瓣，用于对环境纹理进行采样。绿色方块 
表示立方体贴图的横截面，红色刻度线表示纹理像素之间的边界。 
独立于视图和法向量。如果我们将 BRDF的形状变化限制为仅材料 
光泽度，我们可以计算和存储一些与粗糙度参数的不同选择相对应 
的环境贴图，并选择适当的一个在运行时使用。在实践中，这意味 
----------------------- Page 449-----------------------
着限制我们使用的模糊核，并因此限制波瓣形状，以围绕反射矢量 
径向对称。想象一下，一些光线从给定的反射视角方向附近进入。 
直接来自反射视图方向的光将产生最大贡献，随着入射光的方向与 
反射视图方向的差异越来越大而下降。环境贴图纹理区域的面积乘 
以纹素的BRDF贡献给出了该纹素的相对效果。该加权贡献乘以环 
境地图纹理元素的颜色，并将结果相加以计算q。还计算加权贡献 
的总和s。最终结果q/s是在反射视图方向的波瓣上积分的整体颜 
色，并存储在生成的反射贴图中。如果我们使用 Phong材料模型， 
径向对称假设自然成立，我们几乎可以精确地计算环境光。Phong 
[1414]凭经验得出了他的模型，与我们在第9.8节中看到的 BRDF 
相比，没有物理动机。Phong的模型和我们在第9.8.1节讨论过的 
Blinn-Phong[159]BRDF都是余弦波提升到幂，但在 Phong着色 
的情况下，余弦是由反射的点积形成的（公式9.15）和视图矢量， 
而不是半矢量（见公式9.33）和法线。这使得反射波瓣旋转对称。 
请参见第338页的图9.35。对于径向对称的镜面波瓣，我们仍然无 
法容纳的唯一效果是，因为它使得波瓣形状取决于视图方向，因此 
是地平线削波。想想看一个闪亮的（不是镜子）球体。例如，在球 
体表面中心附近看一个对称的 Phong叶。查看10.5附近的表面。 
基于镜面图像的照明417图10.35。两个观众可以看到闪亮的球体。 
球体上的单独位置为两个观看者提供相同的反射视图方向。左侧观 
察者的表面反射采样对称的波瓣。正确的观察者的反射波瓣必须被 
表面的地平线切断，因为光线不能从地平线以下的表面反射。球体 
----------------------- Page 450-----------------------
的轮廓实际上必须切掉一片叶片，因为地平线以下没有光可以到达 
眼睛。见图10.35。这与我们之前在讨论区域照明近似值时看到的 
问题相同 （第 10.1节），实际上它经常被实时方法忽略。这样做会 
在掠射角度时产生过亮的阴影。Heidrich和Seidel [704]以这种方 
式使用单个反射贴图来模拟表面的模糊度。为适应不同的粗糙度级 
别，通常采用环境立方体贴图的 mipmap （第6.2.2节）。每个级 
别用于存储传入辐射的模糊版本，较高的mip级别存储较粗糙的表 
面，即较宽的Phong波瓣[80,582,1150,1151]。在运行时，我们可 
以通过使用反射向量来解决立方体贴图，并根据所需的 Phong指数 
 （材料粗糙度）强制选择给定的mip级别。见图10.36。图10.36。 
环境地图预过滤。立方体贴图已与不同粗糙度的GGX凸角卷积，结 
果存储在纹理 mip链中。随着粗糙度从左向右减小，得到的纹理 
mips显示在底部，并且在反射向量的方向上在球体上方呈现它们。 
418 10.局部照明较粗糙的材料使用较宽的过滤区域可以消除高频， 
因此需要较低的分辨率才能获得足够的结果，这样可以完美地映射 
到mipmap结构。此外，通过采用GPU硬件的三线性过滤，可以 
在预过滤的mip级别之间进行采样，模拟我们没有精确表示的粗糙 
度值。当与菲涅耳术语结合使用时，这种反射贴图对于光泽表面来 
说效果很好。出于性能和混叠的原因，要使用的mipmap级别的选 
择不仅应考虑阴影点处的材料粗糙度，还应考虑由阴影屏幕像素覆 
盖区覆盖的表面区域上的法线和粗糙度的变化。Ashikhmin 和 
Ghosh [80]指出，为了获得最佳结果，应比较两个候选 mipmap 
----------------------- Page 451-----------------------
级别的指数（由纹理硬件计算的缩小级别和对应于当前滤波器宽度 
的级别），以及应使用较低分辨率的mipmap级别。为了更准确， 
应考虑表面方差的扩大效应，并应采用对应于最佳拟合像素覆盖区 
中平均瓣的BRDF波瓣的新粗糙度水平。此问题与BRDF抗锯齿（第 
9.13.1节）完全相同，并且适用相同的解决方案。前面提出的滤波 
方案假定给定反射视图方向的所有波瓣具有相同的形状和高度。该 
假设还意味着叶片必须径向对称。除了地平线上的问题之外，大多 
数 BRDF在所有角度都没有均匀的，径向对称的波瓣。例如，在掠 
射角处，叶片通常变得更尖锐和更薄。而且，叶片的长度通常随仰 
角而变化。对于弯曲表面，通常不会感觉到这种效果。然而，对于 
诸如地板的平坦表面，径向对称滤波器会引入明显的误差。（参见 
第338页的图9.35。）对环境贴图进行计算生成预滤波环境贴图意 
味着计算每个纹素，对应于方向v，环境辐射与镜面凸角的积分 D： 
ZD （l，v）Li （l ）DL。该积分是球形卷积，并且通常不能以分析 
方式执行，因为用于环境地图的Li仅以表格形式已知。一种流行的 
数值解法是采用蒙特卡罗方法：ZD （l，v）Li （l）dl≈limN→∞1N 
XNk=1D （lk，v）Li （lk）p （lk，v）， （10.36）其中lk代表 
k=1,2,. 。。，N是单位球面 （方向）上的离散样本，10.5。基于 
镜面图像的照明419和 p （lk，v）是与在lk方向上生成样本相关 
联的概率函数。如果我们均匀地对球体进行采样，则p （lk，v）=1。 
虽然这个求和对于我们想要整合的每个方向v是正确的，但是当将 
结果存储在环境地图中时，我们还必须考虑投影所施加的失真，通 
----------------------- Page 452-----------------------
过将每个计算的纹理像素加权它所对应的立体角（参见 Driscoll 
[376]）。虽然蒙特卡罗方法简单而正确，但它们可能会将大量样本 
收敛到积分的数值，即使对于离线过程也可能很慢。这种情况对于 
mipmap的第一级尤其如此，其中我们编码浅的镜面反射（在 
Blinn-Phong的情况下为高指数，对于Cook-Torrance为低粗糙 
度）。我们不仅需要更多的纹素来计算（因为我们需要分辨率来存 
储高频细节），而且对于不接近完美反射的方向，波瓣可能几乎为 
零。大多数样本被 “浪费”，因为D （lk，v）≈0。为了避免这种现 
象，我们可以使用重要性采样，我们生成方向，其概率分布试图匹 
配镜面波瓣的形状。这样做是蒙特卡洛积分的常见方差减少技术， 
并且对于大多数常用的波瓣存在重要性采样策略[279,878,1833]。 
对于更有效的采样方案，还可以考虑环境图中辐射的分布以及镜面 
波瓣的形状[270,819]。然而，所有依赖点采样的技术通常仅用于离 
线渲染和地面实例模拟，因为通常需要数百个样本。为了进一步减 
少采样方差（即噪声），我们还可以估计采样之间的距离，并使用 
锥的总和而不是单个方向进行积分。使用锥体对环境贴图进行采样 
可以通过对其mip级别之一进行点采样来近似，选择其纹理像素大 
小跨越类似于锥体[280]的立体角的水平。这样做会引入偏差，但它 
允许我们大大减少实现无噪声结果所需的样本数量。可以借助于 
GPU 以交互速率执行这种类型的采样。同样利用面积样本， 
McGuire等。[1175]开发一种技术，旨在实时地近似用镜面反射的 
卷积结果，而不需要预先计算。该过程通过明智地混合非预先过滤 
----------------------- Page 453-----------------------
的环境立方体图的多个 mipmap级别来完成，以便重建 Phong 
lobe的形状。以类似的方式，Hensley等人。[718,719,720]使用 
求和区域表 （第6.2.2节）快速执行近似。McGuire等人和 Hensley 
等人的技术在技术上都没有任何预先计算，因为在渲染环境地图后， 
他们仍然需要我们分别生成 mip级别或前缀和。对于这两种情况， 
存在有效算法，因此所需的预计算比执行完全镜面波瓣卷积快得多。 
这两种技术都足够快，甚至可以实时用于环境照明的表面着色，但 
它们不如依赖于特殊预过滤的其他方法那么准确。420 10.局部照明 
Kautz等。[868]呈现另一种变型，用于快速生成滤波抛物线反射映 
射的分层技术。最近，Manson和Sloan [1120]使用有效的二次 B 
样条滤波方案显着改进了现有技术，以生成环境地图的mip级别。 
然后，通过组合少量样品，以类似于McGuire等人和 Kautz等人的 
技术的方式，使用这些特殊计算的B样条滤波mips，以产生快速且 
准确的近似。这样做允许实时生成与通过重要性采样的蒙特卡罗技 
术计算的地面实况无法区分的结果。快速卷积技术允许实时更新预 
滤波的立方体贴图，这在我们想要过滤的环境贴图动态渲染时是必 
需的。使用环境贴图通常使得对象难以在不同的照明情况之间移动， 
例如，从一个房间到另一个房间。可以在帧与帧之间（或每隔几帧 
一次）重新生成立方环境贴图，因此如果采用有效的滤波方案，则 
在新的镜面反射贴图中交换相对便宜。重新生成完整环境贴图的替 
代方法是将动态光源的镜面反射高光添加到静态基础环境贴图中。 
添加的高光可以是预先过滤的 “斑点”，它们被添加到预先过滤的 
----------------------- Page 454-----------------------
基础环境地图上。这样做可以避免在运行时进行任何过滤。限制是 
由于环境映射的假设，灯和反射物体是远距离的，因此不会随着被 
观察物体的位置而改变。这些要求意味着不能容易地使用局部光源。 
如果几何是静态的，但是一些光源（例如，太阳）移动，用于更新 
探针的廉价技术不需要在立方体贴图中动态渲染场景就是将表面属 
性（位置，法线，材料）存储在G缓冲区环境地图。第20.1节详 
细讨论了G缓冲区。然后，我们使用这些属性计算表面在环境贴图 
中的出射辐射。该技术用于使命召唤：无限战争[384]，巫师3[1778] 
和孤岛惊魂4 [1154]等。10.5.2MicrofacetBRDF的分裂积分近似 
环境光的有用性是如此之大，以至于已经开发了许多技术来减少立 
方体图预滤波中固有的 BRDF近似问题。到目前为止，我们已经描 
述了通过假设一个 Phong波瓣然后乘以完美镜像菲涅耳项后乘法 
的近似：Zl∈f （l，v）Li （l）（n·l）dl≈F （n ，v）Zl∈DPhong 
 （r）Li （1）（n·1）dl，（10.37）其中RDPhong （r）被预先计 
算为每个 r到环境立方体图中。如果我们使用第 337页上的公式 
9.34考虑镜面微平面 BRDFfsmf，则重复10.5。这里为了方便起 
见，基于镜面图像的照明421，fsmf （l，v）=F （h，l）G2 （l，v， 
h）D （h）4 |n·l||n·v | ， （10.38）我们注意到，即使假设D （h） 
≈DPhong （r）有效，我们也从照明积分中去除了BRDF的重要部 
分。去除阴影项G2 （l，v，h）和半矢量菲涅耳项 F （h，l），其在 
积分外的应用没有理论基础。Lazarov[998]表明，使用依赖于n·v 
的完美镜像菲涅耳，而不是像微型平台BRDF那样的 n·h，产生比 
----------------------- Page 455-----------------------
完全不使用菲涅耳项更大的误差。Gotanda [573]，Lazarov[999] 
和 Karis[861]独立推导出类似的分裂积分近似：Zl∈fsmf （l，v） 
Li （l）（n·l）dl≈Zl∈D （r ）Li （1）（n·1）dlZl∈fsmf （l，v） 
 （n·1）dl。（10.39）注意尽管这种解决方案通常被称为 “分裂积 
分”，但我们并不将积分分解为两个不相交的项，因为那不是一个 
很好的近似值。记住fsmf包括镜面反射叶 D，我们注意到后者以及 
n·l项在两侧都被复制。在分裂积分近似中，我们在两个积分中包括 
围绕环境图中的反射矢量对称的所有项。Karis称他的推导分裂和因 
为它是在预先计算中使用的重要性采样数值积分器（公式 10.36） 
上完成的，但实际上它是相同的解决方案。得到的两个积分都可以 
有效地预先计算。第一个仅取决于表面粗糙度和反射矢量，假设是 
径向对称的 D波瓣。在实践中，我们可以使用任何波瓣，强加n=v 
=r。可以预先计算此积分并将其存储在立方体贴图的mip级别中， 
照常。为了在将半矢量BRDF转换为反射矢量周围的波瓣时在环境 
光和分析光之间获得类似的亮点，径向对称波瓣应使用修改的粗糙 
度。例如，要使用半角从纯 Phong 反射向量镜面项转换为 
Blinn-PhongBRDF，通过将指数除以4得到良好的拟合[472,957]。 
第二个积分是镜面项 Rspec（v）的半球方向反射（第9.3节）。Rspec 
函数取决于仰角θ，粗糙度α和菲涅耳项 F.通常使用Schlick近似（公 
式9.16）实现F，其仅在单个值F0上参数化，从而使 Rspec成为 
三个参数的函数。Gotanda以数字方式预先计算Rspec，将结果存 
储在三维查找表中。Karis和 Lazarov注意到 F0的值可以从Rspec 
----------------------- Page 456-----------------------
中计算出来，导致两个因子，每个因素取决于两个参数：仰角和粗 
糙度。Karis使用这种洞察力将 Rspec的预计算查找减少到可以存 
储在双通道纹理中的二维表，而 Lazarov通过函数拟合推导出对两 
个因子中的每一个的分析近似。更准确和更简单的分析近似422 10. 
局部照明图 10.37。卡里斯 “拆分和”近似。从左到右：粗糙度增 
加的材料。第一行：参考解决方案。第二行：分裂积分近似。第三 
行：分裂积分，其中所需的径向对称性加到镜面波瓣 （n=v =r）。 
最后一个要求是引入最多错误的原因。（图片由BrianKaris，Epic 
Games Inc.提供）后来由 Iwanicki和 Pesce[807]推导出来。请注 
意，Rspec也可用于提高漫射 BRDF模型的精度 （参见第352页的 
公式9.65）。如果两种技术都在同一个应用程序中实现，那么 Rspec 
的实现可以用于两者，从而提高效率。分裂积分解决方案对于恒定 
的环境贴图是精确的。立方体贴图部分提供缩放镜面反射率的光照 
强度，这是在均匀照明下正确的BRDF积分。根据经验，卡里斯和 
拉扎罗夫都观察到近似也适用于一般环境地图，特别是如果频率内 
容相对较低，这在室外场景中并不少见。见图 10.37。与基本事实 
相比，该技术中最大的误差来源是对预滤波环境立方体图的径向对 
称，非限幅镜面反射波瓣的限制 （图10.35）。Lagarde[960]建议 
基于表面粗糙度使用于从反射方向向法线取预滤波环境图的矢量偏 
斜，因为根据经验，这减少了与地面实况相比的误差。这样做是合 
理的，因为它部分地补偿了没有用表面进入的辐射半球削波波瓣。 
10.5.3不对称和各向异性的Lobes到目前为止我们所看到的解决方 
----------------------- Page 457-----------------------
案都局限于各向同性的镜面波瓣，这意味着当进出方向绕表面法线 
旋转时它们不会改变 （见第9.3节），并围绕10.5径向对称。基于 
镜面图像的照明423图10.38。比较GGXBRDF 红色（ ）和GGXNDF 
波瓣的图的两个视图，其适于围绕反射矢量径向对称（绿色）。后 
者已被缩放以匹配GGX镜面波瓣的峰值，但请注意它如何无法捕获 
基于半矢量的 BRDF的各向异性形状。在右侧，注意两个裂片在球 
体上创建的高光差异。 （使用迪士尼的 BRDFExplorer开源软件生 
成的图像。）反射向量。MicrofacetBRDF波瓣定义在半矢量周围 
h = （l +v）/ ||l +v || （公式9.33）因此，即使在各向同性的情 
况下也不会有我们需要的对称性。半矢量取决于光方向l，其对于环 
境照明没有唯一定义。所以，在 Karis[861]之后，对于这些 BRDF， 
我们强加n=v =r并得出恒定的粗糙度校正因子，以使镜面高光的 
大小与原始的半矢量公式相匹配。这些假设都是相当大的误差来源 
 （见图10.38）。我们在第10.5.1节中提到的一些方法可用于以交 
互速率计算具有任意BRDF的环境照明，例如来自Luksch等人的 
那些。[1093]和Colbert和 Kriv'anek[279,280]。然而，由于这些 
方法需要数十个样本，因此它们很少用于表面的实时着色。相反， 
它们可被视为蒙特卡洛积分的快速重要性采样技术。通过在镜面波 
瓣上施加径向对称来创建预滤波环境贴图，并且通过访问对应于当 
前表面镜面粗糙度的预滤波凸角的简单直接逻辑，我们的结果仅在 
直接观察表面 （n=v）时保证是正确的。在所有其他情况下，没有 
这样的保证，并且在掠射角度下，无论 BRDF波瓣的形状如何，我 
----------------------- Page 458-----------------------
们都会产生误差，因为我们忽略了真实的波瓣不能下降到阴影表面 
点的地平线以下。通常，镜面反射的精确方向上的数据可能不是最 
符合现实的。Kautz和 McCool通过使用存储在预滤波环境图中的 
径向对称叶片的更好的采样方案来改进幼稚预积分[867]。他们提出 
了两种方法。第一个使用单个样本，但试图找到最好的424 10。局 
部照明波瓣在当前视图方向上近似 BRDF，而不是依赖于恒定的校 
正因子。第二种方法平均来自不同叶片的几个样品。第一种方法更 
好地模拟掠射角度的表面。它们还导出校正因子以解释使用径向对 
称波瓣近似与原始 BRDF相比反射的总能量的差异。第二种解决方 
案将结果扩展到包括半矢量模型典型的拉伸高光。在这两种情况下， 
优化技术用于计算驱动预滤波叶片采样的参数表。Kautz和McCool 
的技术使用贪婪拟合算法和抛物线环境贴图。最近，Iwanicki和 
Pesce [807]使用一种称为 Nelder-Mead最小化的方法，对GGX 
BRDF和环境立方体图进行了类似的近似。他们还分析了利用现代 
GPU的硬件各向异性过滤能力来加速采样的想法。使用来自预过滤 
立方体图的单个样本，但使其位置适应更复杂的镜面BRDF峰值的 
想法，Revie[1489]也探讨了毛发渲染与延迟着色相结合（第20.1 
节）。在这种情况下，限制并不直接源于环境映射，而是源于在G 
缓冲区中编码尽可能少的参数的需要。McAuley[1154]扩展了这个 
想法，使用这种技术对延迟渲染系统中的所有表面。McAllister等。 
[11501151]开发一种技术，通过利用 LafortuneBRDF的特性，能 
够呈现各种效果，包括各向异性和逆向反射。该 BRDF[954]本身是 
----------------------- Page 459-----------------------
基于物理的渲染的近似。它由多个Phong叶片组成，围绕反射方向 
扰动。Lafortune证明了这种 BRDF能够通过将这些叶片拟合到 
He-Torrance模型[686]以及从gonioreflectometer测量真实材料 
来表示复杂材料。McAllister的技术依赖于注意到，由于Lafortune 
叶片是广义Phong叶片，因此可以使用传统的预过滤环境地图，其 
mips编码不同的 Phong指数。格林等人。[582]提出了一种类似的 
方法，其使用高斯波瓣而不是 Phong波瓣。此外，他们的方法可以 
扩展到支持环境地图的方向阴影（第 11.4节）。10.6辐照度环境 
映射上一节讨论了使用滤波环境贴图进行光泽镜面反射。这些图也 
可用于漫反射[590,1212]。镜面反射的环境贴图具有一些共同的属 
性，无论它们是未过滤的还是用于镜面反射，或者它们被过滤并用 
于光泽反射。在这两种情况下，镜面反射环境贴图都使用反射的视 
图矢量进行索引，并且它们包含辐射值。未过滤的环境贴图包含传 
入的辐射亮度值，过滤的环境贴图包含传出的辐射亮度值。10.6。 
辐照环境映射425图10.39。计算辐照度环境地图。表面法线周围 
的余弦加权半球从环境纹理（在这种情况下为立方体贴图）中采样 
并求和以获得与视图无关的辐照度。绿色方块表示立方体贴图的横 
截面，红色刻度线表示纹理像素之间的边界。尽管显示了立方体贴 
图表示，但是可以使用任何环境表示。相比之下，漫反射的环境贴 
图仅使用曲面法线n进行索引，并且它们包含辐照度值。因此，它 
们被称为辐照度环境地图[1458]。图10.35显示环境贴图的光泽反 
射在某些条件下由于其固有的模糊性而存在误差。相同的反射视图 
----------------------- Page 460-----------------------
矢量可以对应于不同的反射情况。辐照度环境贴图不会发生此问题。 
曲面法线包含漫反射的所有相关信息。由于与原始照明相比，辐照 
度环境图极其模糊，因此可以以显着较低的分辨率存储它们。通常 
使用预滤波镜面环境贴图的最低mip级别之一来存储辐照度数据。 
此外，与我们之前研究过的光泽反射不同，我们没有整合到需要被 
修剪到表面法线周围的半球的 BRDF波瓣。环境照明与钳位余弦波 
瓣的卷积是精确的，而不是近似值。对于地图中的每个纹素，我们 
需要总结影响面向给定法线方向的表面的所有照明的余弦加权贡 
献。通过将覆盖整个可见半球的深远过滤器应用于原始环境地图来 
创建辐照度环境地图。滤波器包括余弦因子。见图10.39。图10.26 
 （第408页）中的球体图具有相应的辐照度图，如图 10.40所示。 
使用的辐照度图的一个例子如图 10.41所示。辐照度环境贴图与镜 
面反射环境或反射贴图分开存储和访问，通常在与视图无关的表示 
中，例如立方体贴图。见图10.42。而不是反射的视图矢量，表面 
426 10.局部照明图 10.40。从GraceCathedral球体地图形成的辐 
照度图。左图是原始球体图。通过对每个像素上方的半球中的加权 
颜色求和来形成右图。（左图由 PaulDebevec提供，debevec.org; 
右图由斯坦福大学计算机图形实验室 RaviRamamoorthi提供。） 
图10.41。使用辐照度图执行的角色照明。 （图片由游戏 “Deador 
Alive R3”，Tecmo，Ltd。2001）提供。）normal用于访问立 
方体贴图以检索辐照度。从辐照度环境图中检索的值乘以漫反射率， 
从镜面反射环境图中检索的值乘以镜面反射率。菲涅耳效应也可以 
----------------------- Page 461-----------------------
建模，在掠射角[704,960]增加镜面反射 （并可能降低漫反射）。由 
于辐照度环境图使用极宽的滤波器，因此难以通过采样在运行中有 
效地创建它们。King[897]讨论了如何在GPU上执行卷积以创建辐 
照度图。通过将环境地图转换为频域，他能够在2004年代硬件上 
以超过300FPS的速率生成辐照度图。10.6。辐照环境映射427图 
10.42。立方体贴图（左）及其对应的滤光辐照度图（右）。（经 
MicrosoftCorporation许可转载。）漫反射或粗糙表面的滤波环 
境贴图可以低分辨率存储，但有时也可以从相对较小的场景反射贴 
图生成，例如，64×64像素的立方体贴图面。这种方法的一个问题 
是渲染成这种小纹理的区域光源可能 “落在纹理像素之间”，导致 
光线完全闪烁或掉落。为了避免这个问题，Wiley和Scheuermann 
[1886]提出在渲染动态环境地图时通过大 “卡片” （纹理矩形）来 
表示这样的光源。与光泽反射的情况一样，动态光源也可以添加到 
预滤光辐照度环境图中。Brennan[195]给出了一种廉价的方法。想 
象一下单个光源的辐照度图。在光的方向上，当光线直接照射到表 
面时，辐射是最大的。给定表面法线方向（即给定纹理像素）的辐 
射度随着与光的角度的余弦而下降，在表面背离光线的地方为零。 
GPU可用于通过渲染半球 （表示以观察者为中心的半球，半球的极 
点沿着光的方向）直接快速地将此贡献直接添加到现有的辐照度图。 
10.6.1球面谐波辐照度尽管我们已经讨论过仅使用立方体贴图等纹 
理来表示辐照度环境贴图，但其他表示也是可能的，如第 10.3节所 
述。特别是球面谐波作为辐照度环境地图表示非常流行，因为来自 
----------------------- Page 462-----------------------
环境照明的辐照度是平滑的。利用余弦波瓣进行辐射辐射会导致从 
环境地图中去除所有高频分量。Ramamoorthi和 Hanrahan[1458] 
表明，只用前九个SH系数（每个428 10.局部照明系数是 RGB矢 
量，因此我们需要存储27个浮点数），可以将辐照度环境图表示为 
约 1％的精度。 ）。然后可以将任何辐照度环境图解释为球函数E 
 （n）并使用等式10.21和 10.23投影到九个RGB系数上。这种形 
式比立方体或抛物线图更紧凑，并且在渲染过程中，可以通过评估 
一些简单的多项式来重建辐照度，而不是访问纹理。通常，如果辐 
照度环境地图代表间接照明（交互式应用中的常见情况），则需要 
较低的精度。在这种情况下，四个系数，对于恒定基函数和三个线 
性基函数，通常可以产生良好的结果，因为间接照明倾向于低频， 
即随角度变化缓慢。Ramamoorthi和 Hanrahan[1458]也表明， 
通过将每个系数乘以常数，可以将入射辐射函数 L （l）的SH系数 
转换成辐照度函数 E （n）的系数。这样做可以快速地将环境贴图过 
滤到辐照度环境贴图中，即将它们投影到SH基础中，然后将每个 
系数乘以常数。例如，这是 King[897]的快速辐照度滤波实现的工 
作原理。该想法是从辐射度计算辐照度等效于在进入辐射函数 L （l） 
和钳位余弦函数cos （θi）+之间执行球形卷积。由于钳位余弦函数 
关于球体的z轴旋转对称，因此它在SH中呈现特殊形式：其投影 
在每个频带中仅具有一个非零系数。非零系数对应于图 10.21 （第 
401页）中间列中的基函数，也称为区域谐波。在一般球函数和旋 
转对称函数（例如钳位余弦函数）之间执行球面卷积的结果是球体 
----------------------- Page 463-----------------------
上的另一个函数。可以在函数的SH系数上有效地执行该卷积。卷 
积结果的SH系数等于 p两个函数的系数的乘积（乘法），按4π/ 
 （2l +1）缩放，其中l是频带索引。然后，辐照度函数 E （n）的 
SH系数等于辐射函数 L （l）的系数乘以钳位余弦函数cos （θi）+ 
的系数，由频带常数缩放。超过前九个的cos （θi）+系数具有较小 
的值，这解释了为什么九个系数足以表示辐照度函数 E （n）。可以 
以这种方式快速评估SH辐照度环境图。Sloan [1656]描述了一种 
有效的GPU实现。这里有一个固有的近似，因为虽然 E （n）的高 
阶系数很小，但它们不是零。见图10.43。近似值非常接近，尽管π 
/2和π之间的曲线 “摆动”应该为零，在信号处理中称为振铃。它 
通常发生在具有高频率的函数用少量基函数近似时，如第 10.3.2节 
所示。π/2处的钳位为急剧变化，这意味着我们的钳位余弦函数具 
有无限频率信号。在大多数情况下，振铃并不明显，但在极端光照 
条件下可以看到颜色变化或 10.6。辐照度环境映射429 00 11.2 
0.80.60.40.2 -0.2p/ 4 p/ 23p/ 4 p图10.43。钳位余弦函数 
 （红色）与其九系数球谐函数近似（蓝色）。近似值非常接近。注 
意π/2和π之间的轻微下降和零上升。物体阴影两侧明亮的 “斑点”。 
如果辐照度环境贴图用于仅存储间接照明（经常发生），则振铃不 
太可能成为问题。有一些预过滤方法可以最大限度地减少问题 
[1656,1659]。见图 10.44。图10.40显示了直接导出的辐照度图如 
何与由九项函数合成的辐照度图进行比较。该SH表示可以在渲染 
期间使用当前曲面法线n[1458]进行评估，或者可以用于快速创建 
----------------------- Page 464-----------------------
立方体或抛物线图以供以后使用。这种照明便宜并且为漫射情况提 
供了良好的视觉效果。图 10.44。左：由振铃引起的视觉伪像的示 
例。右：可能的解决方案是使原始功能更平滑，彼得 - 派克斯隆的 
ourtesy。）430 10.局部照明动态渲染的立方环境地图可以投射到 
SH基础上[871,897,1458]。由于三次环境地图是入射辐射函数的离 
散表示，因此等式 10.21中球体上的积分成为立方体贴图纹素的总 
和：kLj =Xtfj （r [t]）L[t]dω[t] ，（10.40）其中t是当前立方 
体贴图纹素的索引，r[t]是指向当前纹素的方向向量，fj （r[t]）是 
在r[t]评估的第j 个SH基函数，L[t]是存储在纹素中的辐射度，d 
ω[t]是纹素对应的立体角。Kautz[871]，King[897]和Sloan[1656] 
描述了如何计算dω[t]。要将辐射系数kLj转换为辐照度系数，这些 
需要乘以钳位余弦函数cos （θi）+的缩放系数：kEj=k'cos +jkLj 
=k'cos +j Xtfj （r [t]）L[t]dω[t]，（10.41）其中kEj是辐照 
度函数 E （n）的第j 个系数，kLj是进入辐射函数 L （l）的第j 个系 
数，k'cos+j 是钳制的第j 个系数余弦函数cos （θi）+由p4π/ （2l 
+1）缩放 （l是频带索引）。给定t和立方体图分辨率，因子k'cos 
+jfj （r[t]）dω[t]对于每个基函数fj （）是恒定的。这些基本因子 
可以离线预先计算并存储在立方体贴图中，立方体贴图的分辨率应 
与要渲染的动态环境贴图的分辨率相同。通过在每个颜色通道中打 
包单独的基础因子，可以减少使用的纹理数量。为了计算动态立方 
体图的辐照度系数，将适当的基本因子图的纹素与动态立方体图的 
纹素相乘，并将结果相加。除了关于动态辐照度立方体图的信息之 
----------------------- Page 465-----------------------
外，King[897]也提供了关于GPUSH投影的实现细节。动态光源 
可以添加到现有的SH辐照度环境地图中。通过计算灯的辐照度贡 
献的SH系数并将它们添加到现有系数来完成该合并。这样做可以 
避免重新计算整个辐照度环境贴图的需要。这是一个简单的过程， 
因为存在点，圆盘和球面光系数的简单解析表达式 
[583,871,1656,1690]。对系数求和与对辐照度求和具有相同的效 
果。通常这些表示以带状谐波给出，对于与z轴对齐的光，然后可 
以应用旋转以将光定向到任意方向。区域谐波旋转是SH旋转的一 
个特例 （第 10.3.2节），效率更高，只需要一个点积而不是全矩阵 
变换。具有更复杂形状的光源的系数可以通过将它们绘制成图像然 
后在数值上投影到SH基础上来计算[1690]。对于物理天空模型的 
特殊情况，Habel[626]展示了 Preetham天窗在球谐函数中的直接 
扩展。10.6。辐照度环境映射431将常见分析光源投射到SH中的 
难易程度很重要，通常环境照明用于代替遥远或不太强烈的光源。 
补光灯是一个重要的案例。在渲染中，放置这些光源以模拟场景中 
的间接光，即光从表面反射。通常不计算填充光的镜面贡献，特别 
是因为这些光相对于阴影对象可以在物理上较大并且与场景中的其 
他照明源相比相对暗淡。这些因素使他们的镜面高光更加分散，不 
那么引人注目。这种类型的灯在电影和视频的照明中具有真实世界 
的类比，其中物理补光通常用于在阴影中添加照明。在球谐波空间 
中，进行相反的推导也很简单，即从SH中投射的辐射中提取分析 
光源。在他对SH技术的调查中，Sloan [1656]展示了如果给定具 
----------------------- Page 466-----------------------
有已知轴的定向光源，很容易从SH辐照度表示计算光应该具有的 
强度以最小化其自身与编码之间的误差。辐照度。在他之前的工作 
中[1653]斯隆展示了如何通过仅采用第一（线性）波段中的系数来 
选择近似最佳方向。调查还包括一种提取多个方向灯的方法。这项 
工作表明球谐函数是光总和的实用基础。我们可以将多个灯投射到 
SH中，并提取较少数量的方向灯，这些灯可以非常接近投影组。 
lightcuts[1832]框架提供了聚合不太重要的灯的原则方法。虽然最 
常用于辐照度，但SH投影可用于模拟光泽的，视图相关的 BRDF 
照明。Ramamoorthi和 Hanrahan[1459]描述了一种这样的技术。 
它们不是单一颜色，而是在立方体图中存储编码环境地图的视图依 
赖性的球面谐波投影的系数。然而，在实践中，这种技术比我们之 
前看到的预滤波环境贴图方法需要更多的空间。Kautz等人。[869] 
使用SH系数的二维表导出更经济的解决方案，但是该方法限于相 
当低频的照明。10.6.2其他表示尽管立方体图和球面谐波是辐照度 
环境图的最常用表示，但其他表示也是可能的。见图 10.45。许多 
辐照度环境地图有两种主要颜色：顶部的天空颜色和底部的底色。 
受此观察的启发，Parker等人。[1356]呈现仅使用两种颜色的半球 
照明模型。假设上半球发射均匀的辐射亮度 Lsky，并假设下半球发 
出均匀的辐射 Lground。这种情况下的辐照度积分是 E =.... ... 
π?? 1。12sinθ？Lsky+12sinθLground？，其中θ<90。，π？1 
2sinθLsky+？1。12sinθ？Lground？，其中θ≥90。，（10.42） 
432 10.局部照明图 10.45。各种编码辐照度的方法。从左到右：环 
----------------------- Page 467-----------------------
境地图和通过蒙特卡罗积分计算的漫射照明用于辐照度;辐照度用 
环境立方体编码;球谐函数;球面高斯;和 H-基（它只能代表一个方 
向的半球，所以背面法线没有阴影）。（通过Yuriy O'Donnell和 
DavidNeubelt的Probulator开源软件计算的图像。）其中θ是表 
面法线和天空半球轴之间的角度。贝克和博伊德提出了一种更快的 
近似（由Taylor [1752]描述）：E=π？1+cosθ2Lsky +1。cosθ 
2Lground？，（10.43），它是天空和地面之间的线性插值，使用 
 （cosθ+1）/ 2作为插值因子。术语cosθ通常快速计算为点积， 
并且在天空半球轴是基本轴之一（例如，y轴或z轴）的常见情况 
下，不需要计算所有，因为它等于n的世界空间坐标之一。近似值 
相当接近并且明显更快，因此对于大多数应用来说，它更适合于完 
整表达式。Forsyth[487]提出了一种廉价且灵活的照明模型，称为 
trilight，它包括定向，双向，半球形和包裹照明作为特殊情况。Valve 
最初引入了辐照度的环境立方体表示 （第 10.3.1节）。通常，我们 
在第 10.3节中看到的所有球面函数表示都可用于预先计算的辐照 
度。对于辐照度函数所代表的低频信号，我们知道SH是一个很好 
的近似。我们倾向于创建特殊方法来简化或使用比球谐波更少的存 
储。如果我们想要评估遮挡和其他全局照明效果，或者如果我们想 
要合并光泽反射 （第 10.1.1节），则需要更复杂的高频表示。预计 
算照明以考虑所有相互作用的一般概念称为预计算辐射传输 
 （PRT），将在第11.5.3节中讨论。捕获高频率的光泽照明也称为 
全频照明。小波表示通常在此上下文中使用[1059]作为压缩环境地 
----------------------- Page 468-----------------------
图并在simi 10.7中设计有效运算符的手段。误差来源433与我们 
在球谐函数中看到的相似。Ng等人。[1269,1270]展示了使用Haar 
小波来推广辐照度环境映射以模拟自阴影。它们以小波为基础存储 
环境贴图和阴影函数，它们在物体表面上变化。这种表示是值得注 
意的，因为它相当于环境立方体图的变换，执行每个立方体面的二 
维小波投影。因此，它可以被视为立方体贴图的压缩技术。10.7误 
差源要正确执行着色，我们必须评估非准时光源的积分。在实践中， 
这个要求意味着我们可以根据所考虑的灯的特性采用许多不同的技 
术。通常，实时引擎可以分析地模拟一些重要的光，在光区域上近 
似积分并通过阴影图计算遮挡。所有其他光源 - 遥远的灯光，天空， 
补光灯，和光在表面上反弹 - 通常由镜面反射分量的环境立方体图 
表示，以及漫反射辐照度的球形基底。采用混合技术进行照明意味 
着我们永远不会直接使用给定的 BRDF模型，但具有不同程度的误 
差的近似值。有时 BRDF近似是明确的，因为我们拟合中间模型以 
计算光照积分 -LTC就是一个例子。其他时候，我们在某些（通常 
是罕见的）条件下构建对于给定 BRDF精确的近似值，但是在一般 
预滤波立方体映射中存在误差属于该类别。在开发实时着色模型时 
要考虑的一个重要方面是确保不同形式的照明之间的差异不明显。 
具有来自不同表示的相干光可能在视觉上比每个所呈现的绝对近似 
误差更重要。遮挡对于逼真的渲染也是至关重要的，因为在没有遮 
挡的情况下，光线 “泄漏”通常比不应该在应有的地方更明显。大 
多数区域光表示对于阴影来说并不是微不足道的。今天，即使在考 
----------------------- Page 469-----------------------
虑 “软化”效果（第7.6节）时，现有的实时阴影技术都不能准确 
地考虑光的形状。我们计算一个标量因子，当一个物体投射阴影时， 
我们将它们相乘以减少给定光线的贡献，这是不正确的;我们应该在 
与 BRDF进行整合时考虑这种遮挡。环境照明的情况特别困难，因 
为我们没有明确的主导光方向，所以不能使用准时光源的遮蔽技术。 
即使我们已经看到一些相当先进的照明模型，重要的是要记住这些 
并不是真实世界照明源的精确表示。例如，在环境照明的情况下， 
我们假设无限远434 10.局部照明图10.46。生产照明。Trailer（ Park 
5.档案颜料印花，17x22英寸。制作静物画来自GregoryCrewdson 
的 Beneath the Roses 系列 .c Gregory Crewdson 。礼貌 
Gagosian。）光芒源，永远不可能。我们所看到的所有分析灯都在 
一个更强大的假设上工作，即灯在其表面上的每个点上均匀地在出 
射半球上发出辐射。在实践中，这种假设可能是错误的来源，因为 
真正的灯光往往是强烈的方向性。在摄影和电影照明中，经常使用 
特制的面具和过滤器 （称为图案片，黄瓜或饼干）来产生艺术效果。 
例如，参见摄影师GregoryCrewdson的图10.46中的复杂电影摄 
影。为了在保持大面积发射的同时限制照明角度，可以在大型发光 
面板 （所谓的柔光箱）的前面添加称为蜂窝的屏蔽黑色材料的网格。 
镜子和反射器的复杂配置也可用于灯具的外壳，例如室内照明，汽 
车前灯和手电筒。见图 10.47。这些光学系统产生一个或多个远离 
物理中心辐射光的虚拟发射器，在执行衰减计算时应考虑此偏移量。 
请注意，应始终在感知的，面向结果的框架中评估这些错误（除非 
----------------------- Page 470-----------------------
我们的目标是进行预测渲染，即可靠地模拟曲面的真实外观）。在 
艺术家的手中，某些简化，即使不现实，仍然可以产生有用和富有 
表现力的原语。当物理模型使艺术家更容易创建视觉上合理的图像 
时，物理模型非常有用，但它们并不是他们自己的目标。10.7。错 
误来源435图10.47。相同的盘灯具有两种不同的发射轮廓。左： 
磁盘上的每个点均在出射半球上均匀发光。右：发射集中在磁盘正 
常周围的波瓣中。进一步阅读和资源 “光科学与魔术：亨特摄影照 
明概论”一书[791]是理解真实世界摄影灯的绝佳参考。对于电影照 
明设置照明技术员手册：电影照明设备，实践和配电[188]是一个很 
好的介绍。Debevec在图像照明领域开创的工作对于需要从真实世 
界场景捕捉环境地图的人来说非常感兴趣。SIGGRAPH2003课程 
[333]以及Reinhard等人的高动态范围成像：采集，显示和基于图 
像的照明一书涵盖了大部分这项工作。[1479]。可以帮助模拟的一 
种资源是光配置文件。照明工程学会 （IES）发布了照明测量的手册 
和文件格式标准[960,961]。这种格式的数据通常可从许多制造商处 
获得。IES标准仅限于通过其角度发射轮廓描述光。它没有完全模拟 
光学系统对衰减的影响，也没有模拟光表面区域的发射。 
Szirmay-Kalos [1732]关于镜面反射效应的最新报告包括许多对环 
境制图技术的参考。第 11章全局照明“如果它看起来像计算机图形， 
那就不是好的计算机图形。” -Jeremy BirnRadiance是渲染过程 
计算的最终数量。到目前为止，我们一直使用反射方程来计算它： 
Lo （p，v）=Zl∈f （l，v）Li （p，l）（n·1）+dl，（11。1）其 
----------------------- Page 471-----------------------
中Lo （p，v）是来自视图方向v上的表面位置p的输出辐射，是 
高于p的方向的半球，f （l，v）是针对v评估的 BRDF和当前进入 
的方向l ，Li （p，l）是从l进入p的入射辐射，而 （n·l）+是 l和 
n之间的点积，负值被钳制为零。11.1渲染方程反射方程是完全渲 
染方程的一个受限特例，由Kajiya于 1986年提出[846]。渲染方程 
使用了不同的形式。我们将使用这个版本：Lo （p，v）=Le （p，v） 
+Zl∈f （l，v）Lo （r （p，l）,. l）（n·l）+dl，（ 11.2）其中新 
元素是 Le （p，v），它是从方向v的表面位置p发出的辐射，以及 
下面的替换：Li （p，l）=Lo （r （p，l），。 L）。（11。3）该 
术语意味着从方向 l到达位置 p的入射辐射等于从相反方向上的某 
个其他点的出射辐射。在这种情况下， “其他点”由射线投射函数 
r （p，l）定义。此函数返回第一个表面点的位置，该点位于从方向 
l的p投射的光线中。见图 11.1。437438 11.全局照明 Li （p，l） 
Lo （r （p，l）， -l）plr （p，l） -l图11.1。阴影表面位置p， 
发光方向 l，射线投射函数r （p，l）和入射辐射亮度Li （p，l）也 
表示为 Lo （r （p，l），... l）。渲染方程的含义很简单。为了遮蔽 
表面位置p，我们需要知道在视图方向v上离开p的出射辐射Lo。 
这等于发射的辐射亮度 Le加上反射的辐射亮度。在前面的章节中已 
经研究了光源的发射，以及反射率。甚至射线投射操作员也不像看 
起来那样陌生。例如，z缓冲区计算从眼睛投射到场景中的光线。 
唯一的新术语是Lo （r （p，l）,. l），它明确表明入射到一个点的 
辐射必须从另一个点传出。不幸的是，这是一个递归术语。也就是 
----------------------- Page 472-----------------------
说，它是通过对来自位置r （r （p，l），l'）的输出辐射的又一个求 
和来计算的。这些又需要计算来自位置r （r （r （p，l），l'），l''） 
和无限的出射辐射。令人惊讶的是，现实世界可以实时计算所有这 
些。我们直观地知道这一点，灯光照亮了一个场景，光子在每次碰 
撞时反弹并被吸收，反射，并以各种方式折射。渲染方程是重要的， 
因为它在一个简单的方程中总结了所有可能的路径。渲染方程的一 
个重要特性是它相对于发射的光线是线性的。如果我们将灯光强度 
提高两倍，阴影的结果将会亮两倍。材料对每种光的响应也独立于 
其他来源。也就是说，一盏灯的存在不会影响另一种光与材料的相 
互作用。在实时渲染中，通常仅使用本地照明模型。只需要在可见 
点处的表面数据来计算照明 - 这正是GPU可以最有效地提供的。 
原始图像被独立地处理和光栅化，之后它们被丢弃。在点 b处执行 
计算时，无法访问点a处的照明计算结果。透明度，反射和阴影是 
全局照明算法的示例。他们使用来自其他物体的信息，而不是被照 
亮的物体。这些效果极大地增加了渲染图像的真实感，并提供了帮 
助观察者理解空间关系的提示。同时，它们也很复杂，可能需要预 
先计算或渲染多次计算某些中间信息的过程。11.1。渲染公式439 
LSDELSDSSELDELEDDSS图11.2。一些路径及其相同的符号， 
因为它们到达了眼睛。注意，从网球继续显示两条路径。考虑光照 
问题的一种方法是通过光子所采用的路径。在局部照明模型中，光 
子从光传播到表面（忽略介入的物体），然后到达眼睛。阴影技术 
考虑了这些介入物体的直接遮挡效应。环境地图捕获从光源到远处 
----------------------- Page 473-----------------------
物体的照明，然后将其应用于局部有光泽的物体，这些物体将这种 
光反射到眼睛。辐照度图还捕获光对远处物体的影响，在半球的每 
个方向上集成。从所有这些物体反射的光被加权并求和以计算表面 
的照度，然后由眼睛看到。以更正式的方式思考光传输路径的不同 
类型和组合有助于理解存在的各种算法。Heckbert[693]有一个符 
号方案，可用于描述技术模拟的路径。光子沿着其从光 （L）到眼睛 
 （E）的行程的每次相互作用可以被标记为漫射 （D）或镜面 （S）。 
可以通过添加其他表面类型（例如 “光泽”）进一步进行分类，这 
意味着有光泽但不是镜像。见图11.2。算法可以通过正则表达式简 
要概括，显示它们模拟的交互类型。有关基本表示法的摘要，请参 
见表11.1。光子可以采用从光到眼的各种路径。最简单的路径是 LE， 
眼睛直接看到光。基本的z缓冲区是L （D|S）E，或等效地，LDE 
|LSE。光子离开光线，到达漫反射或镜面表面，然后440 11.全局 
照明操作员描述示例说明。零个或多个S.零个或多个镜面反弹+一 
个或多个 D +一个或多个漫反射？零或一个S？零或一个镜面反弹 
|或者/或 D|SS是漫反射或两个镜面反弹 （）组 （D|S）。零或更 
多的弥散或特殊表11.1。正则表达式表示法。到达眼睛。请注意， 
对于基本渲染系统，点光源没有物理表示。给予灯几何形状会产生 
系统 L （D|S）？E，其中光也可以直接进入眼睛。如果将环境映射 
添加到渲染器，则紧凑表达式不太明显。虽然赫克伯特的符号从一 
个眼睛到另一个眼睛，从另一个方向构建表达式通常更容易。眼睛 
将首先看到镜面或漫射表面，（S |D）E。如果曲面是镜面反射， 
----------------------- Page 474-----------------------
则它还可以选择性地反射渲染到环境贴图中的（远距离）镜面或漫 
反射曲面。因此，还有一条额外的潜在路径:( （S|D）？S |D）E。 
要计算眼睛直接看到光线的路径，请添加？对于这个中心表达，使 
其成为可选的，并用光本身上限：L （（S|D）？S|D）？E。该表 
达式可以扩展为 LE|LSE|LDE|LSSE|LDSE，它分别显示所有可 
能的路径，或者更短的 L （D|S）？S？E。每个都有用于理解关系 
和限制。符号的部分功能在于表达算法效果并能够构建它们。例如， 
L （S |D）是生成环境地图时编码的内容，SE是随后访问该地图的 
部分。渲染方程本身可以通过简单表达式 L （D|S）来概括。E，即 
来自光的光子在到达眼睛之前可以达到零到几乎无限数量的漫射或 
镜面表面。全球照明研究侧重于沿着这些路径计算光传输的方法。 
当将其应用于实时渲染时，我们通常愿意牺牲一些质量或正确性来 
进行有效评估。两种最常见的策略是简化和预先计算。例如，我们 
可以假设在到达眼睛之前的所有光线都是漫反射的，这种简化可以 
适用于某些环境。我们还可以预先计算离线间对象效果的一些信息， 
例如生成记录表面上照度级别的纹理，然后实时执行依赖于这些存 
储值的基本计算。本章将展示如何使用这些策略实时实现各种全局 
照明效果的示例。11.2。一般全局照明441图11.3。路径跟踪可以 
生成逼真的图像，但计算量很大。上面的图像每个像素使用超过两 
千个路径，每个路径长达64个段。渲染花了两个多小时，它仍然表 
现出一些轻微的噪音。（ “Country Kitchen”模型由Jay-Artist， 
Benedikt Bitterli渲染资源，根据 CC BY 3.0 [149]许可。使用 
----------------------- Page 475-----------------------
Mitsuba渲染器渲染。）11。2一般全局照明前面的章节重点介绍 
了解决反射方程的各种方法。我们假设了一定的入射辐射分布Li， 
并分析了它如何影响阴影。在本章中，我们将介绍旨在解决完整渲 
染方程的算法。两者之间的区别在于，前者忽略了辐射来自的地方 - 
简单地给出了它。后者明确说明：到达一点的辐射是从其他点发射 
或反射的辐射。解决完整渲染方程的算法可以生成令人惊叹的逼真 
图像 （图11.3）。然而，这些方法对于实时应用来说计算成本太高。 
那么，为什么要讨论它们？第一个原因是在静态或部分静态场景中， 
这些算法可以作为预处理运行，存储结果以供以后在渲染期间使用。 
例如，这是游戏中的常用方法，我们将讨论此类系统的不同方面。 
第二个原因是全局照明算法建立在严格的理论基础之上。它们直接 
来自渲染方程，并且它们所做的任何近似都经过精心分析。在设计 
实时解决方案时，可以并且应该应用类似的推理。即使我们做出某 
些捷径，我们也应该意识到后果是什么以及442 11.全局照明的正 
确方法是什么。随着图形硬件变得越来越强大，我们将能够减少折 
衷并创建更接近正确物理结果的实时渲染图像。解决渲染方程的两 
种常用方法是有限元方法和蒙特卡罗方法。光能传递是一种基于第 
一种方法的算法;各种形式的光线追踪使用第二种。在这两者中，光 
线追踪更受欢迎。这主要是因为它可以在同一框架内有效地处理一 
般光传输 - 包括体积散射等效应。它还可以更容易地扩展和并行 
化。我们将简要介绍这两种方法，但感兴趣的读者应该参考任何一 
本优秀的书籍，这些书籍涵盖了在非实时设置中解决渲染方程的细 
----------------------- Page 476-----------------------
节[400,1413]。11.2.1光能传递光能传递[566]是第一种用于模拟漫 
射表面之间反射光的计算机图形技术。它的名称来自算法计算的数 
量。在经典形式中，光能传递可以计算来自区域光的互反射和柔和 
阴影。已经有关于该算法的全书[76,275,1642]，但基本思想相对简 
单。光在环境中反弹。你打开灯，照明很快达到平衡。在这种稳定 
状态下，每个表面本身可以被视为光源。基本光能传递算法简化了 
所有间接光来自漫射表面的假设。这个前提不适用于在墙壁上铺有 
抛光大理石地板或大镜子的地方，但对于许多建筑设置而言，这是 
一个合理的近似值。光能传递可以跟随有效无限数量的漫反射。使 
用本章开头介绍的符号，其光传输集是LD。E.光能传递假设每个表 
面都由一些贴片组成。对于这些较小区域中的每一个，它计算单个 
平均光能传递值，因此这些小块需要足够小以捕获光照的所有细节 
 （例如，阴影边缘）。但是，它们不需要一对一地匹配下面的表面 
三角形，或者甚至在尺寸上是均匀的。从渲染方程开始，我们可以 
推导出补片 i的光能传递等于Bi =Bei +ρssXj FijBj，（11.4）其 
中Bi表示补片i的光能传递，Bei是辐射出射，即，由贴片i发射 
的光能传递，ρss是地下反照率 （第9.3节）。发射仅对光源非零。 
Fij是补丁i和j 之间的形状因子。形状因子定义为 Fij=1AiZAiZ 
AjV （i，j）cosθiscosθjπd2ijjdaidaj，（11.5）11.2。一般全局 
照明443 ninjij图11.4。两个表面点之间的形状因子。其中Ai是 
贴片i的区域，V （i，j）是点i和j 之间的可见度函数，如果它们之 
间没有阻挡光则等于1，否则为零。值θi和θj 是两个贴片法线和光 
----------------------- Page 477-----------------------
线连接点i和j 之间的角度。最后，dij是光线的长度。见图 11.4。 
形状因子是纯粹的几何术语。它是留下贴片i的均匀漫射辐射能量 
的一部分，其入射在贴片j 上[399]。两个补丁的面积，距离和方向， 
以及它们之间的任何表面，影响它们的形状因子值。想象一下由计 
算机显示器代表的补丁。房间里的每个其他补丁都将直接接收从监 
视器发出的任何光的一部分。如果表面落后或无法 “看到”显示器， 
则该分数可以为零。这些分数都加起来一个。光能传递算法的重要 
部分是准确地确定场景中的片对之间的形状因子。利用计算的形状 
因子，将所有斑块的方程式 （公式 11.4）组合成单个线性系统。然 
后解决系统，从而为每个补丁产生光能传递值。随着补丁数量的增 
加，由于高计算复杂性，减少这种矩阵的成本相当可观。由于算法 
扩展性差并且具有其他限制，因此经典的光能传递很少用于生成照 
明解决方案。然而，预先计算形状因子并在运行时使用它们来执行 
某种形式的光传播的想法在现代实时全局照明系统中仍然很流行。 
我们将在本章后面的章节（第 11.5.3节）中讨论这些方法。11.2.2 
光线跟踪光线投射是从某个位置发射光线以确定特定方向上的物体 
的过程。光线跟踪使用光线来确定各种场景元素之间的光传输。在 
最基本的形式中，光线从相机通过像素网格射入场景。对于每条光 
线，找到最近的对象。然后通过向每个灯射出光线并检查其间是否 
有任何物体来检查该交叉点是否处于阴影中。不透明物体阻挡光 
线;透明物体会削弱它。其他射线可以从交叉点产生。如果表面有光 
泽，则在反射方向上产生光线。此光线444 11.全局照明拾取相交 
----------------------- Page 478-----------------------
的第一个对象的颜色，而第一个对象的交叉点则测试阴影。也可以 
在透明固体物体的折射方向上产生光线，再次递归地评估。这种基 
本机制非常简单，已经编写了适合名片背面的功能光线跟踪器 
[696]。经典光线追踪只能提供有限的效果：锐利的反射和折射以及 
硬阴影。但是，相同的基本原理可用于求解完全渲染方程。Kajiya 
[846]意识到射线和评估它们携带多少光的机制可以用来计算公式 
11.2中的积分。该等式是递归的，这意味着对于每条射线，我们需 
要在不同的位置再次评估积分。幸运的是，处理这个问题的坚实数 
学基础已经存在。在曼哈顿计划期间为物理实验开发的蒙特卡罗方 
法专门用于处理这类问题。不是通过正交规则直接计算每个着色点 
中积分的值，而是在来自域的多个随机点处评估被积函数。然后使 
用这些值来计算积分值的估计值。采样点越多，精度越高。该方法 
最重要的特性是只需要对被积函数进行点评估。给定足够的时间， 
我们可以用任意精度计算积分。在渲染的上下文中，这正是光线跟 
踪提供的内容。当我们拍摄光线时，我们从公式 11.2中对被积函数 
进行点采样。即使在交叉点处有另一个要评估的积分，我们也不需 
要它的最终值，我们可以再次对其进行点样。当光线在场景中反弹 
时，会构建一条路径。沿着每条路径传播的光提供了对被积函数的 
一种评估。此过程称为路径跟踪 （图11.5）。图11.5。路径跟踪算 
法生成的示例路径。所有三条路径都通过胶片平面中的相同像素， 
并用于估计其亮度。图底部的地板高度光泽，并以小立体角反射光 
线。蓝色框和红色球体是漫射的，因此在交叉点处将光线均匀地散 
----------------------- Page 479-----------------------
布在法线周围。11.2。一般全局照明445图11.6。使用蒙特卡罗路 
径跟踪时样本数量不足导致的噪声。左边的图像每像素有8条路径， 
右边的图像每像素有 1024条路径。（来自 Benedikt Bitterli 
RenderingResources的 “CornellBox”模型，在CCBY3.0[149] 
下获得许可。使用Mitsuba渲染器渲染。）跟踪路径是一个非常强 
大的概念。路径可用于渲染光泽或漫反射材质。使用它们，我们可 
以生成柔和阴影并渲染透明对象以及焦散效果。将路径跟踪扩展到 
体积中的采样点（而不仅仅是曲面）后，它可以处理雾和次表面散 
射效果。路径跟踪的唯一缺点是实现高视觉保真度所需的计算复杂 
性。对于电影质量图像，可能需要跟踪数十亿个路径。这是因为我 
们从不计算积分的实际值，只计算其估计值。如果使用太少的路径， 
则这种近似将是不精确的，有时是相当的。另外，即使对于彼此相 
邻的点，结果也可能大不相同，因为人们期望照明几乎相同。我们 
说这样的结果有很大的差异。在视觉上，这表现为图像中的噪声 （图 
11.6）。已经提出了许多方法来对抗这种效果而不追踪额外的路径。 
一种流行的技术是重要抽样。我们的想法是，通过在大部分光线来 
自的方向上拍摄更多光线，可以大大减少变化。关于路径追踪和相 
关方法的主题已经发表了许多论文和书籍。Pharr等。[1413]提供 
了对现代离线光线跟踪技术的很好的介绍。Veach [1815]为光传输 
算法的现代推理奠定了数学基础。我们将在本章末尾的第 11.7节中 
以交互速率讨论光线和路径跟踪。446 11.全球照明 11。3环境遮 
挡上一节中介绍的一般全局照明算法计算量很大。它们可以产生各 
----------------------- Page 480-----------------------
种复杂效果，但生成图像可能需要数小时。我们将以最简单但仍具 
有视觉冲击力的解决方案开始探索实时替代方案，并在整个章节中 
逐步构建更复杂的效果。一个基本的全局照明效果是环境遮挡 
 （AO）。该技术由Landis [974]于21世纪初在 Industrial Light 
＆Magic开发，旨在改善电影珍珠港计算机生成的飞机上使用的环 
境照明质量。尽管效果的物理基础包括相当多的简化，但结果看起 
来令人惊讶。当照明缺乏方向变化并且不能显示对象细节时，该方 
法便宜地提供关于形状的提示。11.3.1环境遮挡理论环境遮挡的理 
论背景可以直接从反射方程导出。为简单起见，我们将首先关注朗 
伯表面。来自这些表面的输出辐射率 Lo与表面辐照度E成比例。辐 
照度是入射辐射的余弦加权积分。通常，它取决于表面位置p和表 
面法线n。同样，为简单起见，我们将假设对于所有进入方向l，进 
入辐射率是恒定的，Li （1）=LA。这导致用于计算辐照度的以下等 
式：E （p，n）=Zl∈LA （n·1）+dl =πLA，（11。6）在可能进 
入的方向的半球上进行积分。在恒定均匀照明的假设下，辐照度 （以 
及因此，出射辐射）不依赖于表面位置或法线，并且在物体上是恒 
定的。这导致平坦的外观。公式 11.6没有考虑任何可见性。某些方 
向可能被对象的其他部分或场景中的其他对象阻挡。这些方向将具 
有不同的入射辐射，而不是LA。为简单起见，我们假设来自阻塞方 
向的入射辐射是零。这会忽略可能从场景中的其他物体反弹并最终 
从这些被阻挡的方向到达点 p的所有光，但它极大地简化了推理。 
结果是，我们得到以下等式，首先由Cook和Torrance [285,286] 
----------------------- Page 481-----------------------
提出：E （p，n）=LAZl∈v （p，l）（n·l）+dl，（11.7）其中v 
 （p ，l）是一个可见度函数，如果在l方向上从p投射的光线被阻 
挡，则等于零，如果不是，则为 1。11.3。环境遮挡447图11.7。 
仅使用恒定环境光（左）和环境光遮挡（右）渲染的对象。即使光 
照恒定，环境遮挡也会带出物体细节。 （Delatronic的 “Dragon” 
模型，BenediktBitterli渲染资源，在CCBY3.0[149]下获得许可。 
使用Mitsuba渲染器渲染。）可见性函数的归一化余弦加权积分称 
为环境遮挡：kA （p）=1πZl∈v （p，l）（n·1）+dl。（11.8） 
它代表未被遮挡的半球的余弦加权百分比。对于完全遮挡的表面点， 
值的范围为零，对于没有遮挡的位置，值为 1。值得注意的是，诸 
如球体或盒子之类的凸起物体不会对自身造成遮挡。如果场景中不 
存在其他对象，则凸对象的环境遮挡值将为 1。如果对象有任何凹 
陷，则在这些区域中遮挡将小于 1。一旦定义了kA，在存在闭塞时 
的环境辐照度的等式是E （p，n）=kA （p）πLA。 （11.9）注意， 
现在辐照度确实随表面位置而变化，因为 kA确实如此。这样可以 
产生更加真实的结果，如右图 11.7所示。由于kA的值较低，因此 
尖锐折痕中的表面位置将是暗的。比较图11.8中的表面位置p0和 
p1。表面取向也具有效果，因为可视性函数v （p，l）在积分时由 
余弦因子加权。比较图左侧的p1到p2。两者都具有大约相同尺寸 
的未被遮挡的立体角，但是p1的大部分未被遮挡的区域围绕其表 
面法线，因此余弦因子相对较高，如箭头的亮度所示。相反，p2的 
大部分未被遮挡区域偏离表面法线的一侧，相应地较低的余弦因子 
----------------------- Page 482-----------------------
值。因此，kA的值在p2处较低。从现在开始，为简洁起见，我们 
将停止明确表示对表面位置p的依赖性。448 11.全局照明p0p1p2 
p0p1p2图11.8。环境照明下的物体。显示了三个点 （p0，p1和 
p2）。在左侧，被阻挡的方向显示为以交叉点 （黑色圆圈）结尾的 
黑色光线。未阻挡的方向显示为箭头，根据余弦因子着色，因此更 
接近表面法线的那些更亮。在右侧，每个蓝色箭头显示平均未被遮 
挡的方向或弯曲的法线。除了kA之外，Landis[974]还计算平均未 
被遮挡的方向，称为弯曲法线。该方向矢量被计算为未被遮挡的光 
方向的余弦加权平均值：nbent=Rl∈lv （1） （n·1）+dlkRlllv 
 （l）（n·1）+dlk。（11.10）符号kxk表示向量x的长度。积分 
的结果除以其自身长度以产生归一化结果。请参见图11.8的右侧。 
在着色期间，可以使用得到的矢量代替几何法线，以提供更准确的 
结果，而无需额外的性能成本 （第 11.3.7节）。11.3.2可见性和不 
足性需要仔细定义用于计算环境遮挡因子 kA （公式11.8）的可见 
度函数v （l）。对于诸如角色或车辆的对象，基于从方向l上的表 
面位置投射的光线是否与同一对象的任何其他部分相交，可以直接 
定义v （l）。但是，这并不能解释其他附近物体的遮挡。通常，可 
以假设物体被放置在平面上以用于照明目的。通过在可见度计算中 
包括该平面，可以实现更真实的遮挡。另一个好处是物体对地平面 
的遮挡可以用作接触阴影[974]。不幸的是，对于封闭几何体，可见 
性函数方法失败想象一个由包含各种物体的封闭房间组成的场景。 
所有曲面的 kA值都为零，因为来自曲面的所有光线都会碰到某些 
----------------------- Page 483-----------------------
东西。经验方法，试图重现环境遮挡的外观而不必模拟 11.3。环境 
遮挡449图11.9。环境遮挡和遮挡之间的差异。使用无限长度的光 
线计算左侧飞船的遮挡。右侧的图像使用有限长度的光线。 
 （“4060.b太空船”模型由thecali，BenediktBitterli渲染资源， 
根据CC BY3.0 [149]许可。使用 Mitsuba渲染器渲染。）物理可 
视性，通常对这样的场景更好。这些方法中的一些受到米勒的可访 
问性着色概念[1211]的启发，该概念模拟表面中的角落和缝隙如何 
捕获污垢或腐蚀。朱可夫等人。[1970]引入了障碍的概念，它通过 
用距离映射函数ρ （l）代替可见度函数v （l）来修改环境遮挡计算： 
kA =1πZl∈ρ （l）（n·l） +DL。（11.11）与v （l）不同，v （l） 
只有两个有效值，1表示无交叉，0表示交点，ρ （l）是基于光线在 
交叉表面之前行进的距离的连续函数。对于任何大于指定距离 
dmax的交叉点距离，或者根本没有交叉点时，ρ （l）的值在0和 1 
的交叉距离处为0。不需要测试超过dmax的交叉点，这可以显着 
加速kA的计算。图11.9显示了环境遮挡和环境遮挡之间的差异。 
请注意使用环境遮挡渲染的图像是如何显着更暗。这是因为即使在 
很远的距离也能检测到交叉点，因此会影响 kA的值。尽管试图在 
物理上证明它是合理的，但是障碍在物理上是不正确的。然而，它 
通常会给出符合观众期望的合理结果。一个缺点是需要手动设置 
dmax的值以获得令人满意的结果。这种类型的妥协通常是计算机 
图形学中的情况，其中技术没有直接的物理基础，但是 “感知上令 
人信服。”目标通常是可信的图像，因此这种技术可以很好地使用。 
----------------------- Page 484-----------------------
也就是说，基于理论的方法的一些优点是它们可以自动工作，并且 
可以通过推理现实世界的工作方式进一步改进。450 11.全球照明图 
11.10。没有和有反射的环境遮挡之间的差异。左侧图像仅使用有关 
可见性的信息。右侧的图像也使用一次间接照明反弹。（ “维多利 
亚风格的房子”模型由 MrChimp2313，BenediktBitterli渲染资 
源，根据CCBY3.0[149]许可。使用 Mitsuba渲染器渲染。）11.3.3 
相互反射的计算即使环境遮挡产生的结果在视觉上令人信服，比全 
全局照明模拟产生的颜色更暗。比较图 11.10中的图像。环境遮挡 
和全局照明之间差异的重要来源是相互反射。公式 11.8假设阻塞方 
向的辐射亮度为零，而实际上，相反的反射将从这些方向引入非零 
辐射。与右侧的模型相比，图 11.10中左侧模型的折痕和凹坑中的 
效果可以看作是变暗的。可以通过增加 kA的值来解决这种差异。 
使用遮蔽距离映射函数而不是可见性函数 （第 11.3.2节）也可以缓 
解这个问题，因为对于被阻挡的方向，遮蔽函数通常具有大于零的 
值。以更准确的方式跟踪互反射是昂贵的，因为它需要解决递归问 
题。遮蔽一点，其他点必须首先加阴影，依此类推。计算 kA的值 
比执行全局照明计算要便宜得多，但通常希望以某种形式包括这种 
缺失的光，以避免过度硬化。斯图尔特和兰格[1699]提出了一种廉 
价但令人惊讶的精确方法来近似反射反射。它基于以下观察：对于 
漫射照明下的朗伯场景，从给定位置可见的表面位置倾向于具有类 
似的辐射。通过假设来自被阻挡方向的辐射亮度 Li等于来自当前阴 
影点的出射辐射率 Lo，递归被破坏并且可以找到解析表达式：E = 
----------------------- Page 485-----------------------
πkA1。ρss （1.kA）Li， （11.12）其中ρss是地下反照率或漫反射 
率。这相当于取代 11.3。环境遮挡451环境遮挡因子kA具有新因 
子k'A：k'A =kA 1。ρss （1.kA）。（11.13）该等式将倾向于使 
环境遮挡因子变亮，使其在视觉上更接近完整全局照明解决方案的 
结果，包括相互反射。效果高度依赖于ρss的值。基础近似假设表 
面颜色在阴影点附近是相同的，以产生类似于颜色渗色的效果。 
Hoffman 和 Mitchell [755]使用这种方法用天光照亮地形。 
Jimenez等人提出了一种不同的解决方案。[835]。它们对许多场景 
执行完整的离线路径追踪，每个场景都由均匀的白色点亮，无限远 
的环境贴图，以获得适当考虑插入反射的遮挡值。基于这些示例， 
它们拟合三次多项式以近似函数f，该函数f从环境遮挡值kA和次 
表面反照率ρss映射到遮挡值k'A，遮挡值k'A由相互反射的光照亮。 
他们的方法还假设反照率是局部恒定的，并且可以基于给定点处的 
反照率导出入射反射光的颜色。11.3.4预先计算的环境遮挡环境遮 
挡因子的计算可能非常耗时，并且通常在渲染之前离线执行。预先 
计算任何与照明相关的信息 （包括环境遮挡）的过程通常称为烘焙。 
预先计算环境遮挡的最常用方法是通过蒙特卡罗方法。投射光线并 
检查场景的交叉点，并以数字方式评估公式 11.8。例如，假设我们 
在正常 n周围的半球上选择均匀分布的 N个随机方向 l，并在这些 
方向上跟踪光线。基于交叉点结果，我们评估可见度函数v。然后 
可以将环境遮挡计算为kA =1NXN iv （li）（n·li）+。（11.14） 
在计算环境遮挡时，可以将投射光线限制在最大距离，并且v的值 
----------------------- Page 486-----------------------
基于找到的交叉距离。环境遮挡或遮蔽因子的计算包括余弦加权因 
子。虽然它可以直接包括在内，如公式 11.14所示，合并这个加权 
因子的更有效方法是通过重要性抽样。不是在半球上均匀地投射光 
线而是对结果进行余弦加权，而是对光线方向的分布进行余弦加权。 
换句话说，光线更可能被投射到更接近表面法线的方向，因为来自 
这些方向的结果可能更重要。这种抽样方案称为 Malley方法。452 
11.全局照明环境光遮挡预计算可以在CPU或GPU上执行。在这两 
种情况下，都可以使用加速光线投射以复杂几何体的库。两个最受 
欢迎的是用于CPU的Embree[1829]和用于GPU的OptiX[951]。 
过去，来自GPU管道的结果，例如深度图[1412]或遮挡查询[493]， 
也被用于计算环境遮挡。随着GPU上更普遍的射线投射解决方案的 
日益普及，它们的使用在今天不太常见。大多数商业上可用的建模 
和渲染软件包提供预先计算环境遮挡的选项。遮挡数据对于对象上 
的每个点都是唯一的。它们通常存储在纹理，体积或网格顶点上。 
无论存储的信号类型如何，不同存储方法的特征和问题都是相似的。 
相同的方法可用于存储环境遮挡，定向遮挡或预先计算的照明，如 
第 11.5.4节中所述。预计算数据还可用于对对象的环境遮挡效果进 
行建模。Kontkanen和 Laine[924，925]在立方体图中将对象的环 
境遮挡效果存储在其周围环境中，称为环境遮挡场。它们模拟环境 
遮挡值如何随着距离物体的距离而变化，并具有二次多项式的倒数。 
其系数存储在立方体图中，以模拟遮挡的方向变化。在运行时，遮 
挡对象的距离和相对位置用于获取适当的系数并重建遮挡值。 
----------------------- Page 487-----------------------
Malmer等人。[1111]通过将环境遮挡因子和可选的弯曲法线存储 
在称为环境遮挡体积的三维网格中来显示改进的结果。计算要求较 
低，因为环境遮挡因子直接从纹理读取，而不是计算。与 Kontkanen 
和 Laine的方法相比，存储的标量更少，并且两种方法中的纹理都 
具有低分辨率，因此整体存储要求相似。Hill[737]和 Reed[1469] 
描述了 Malmer等人在商业游戏引擎中的方法的实现。他们讨论了 
算法的各种实际方面以及有用的优化。这两种方法都适用于刚性物 
体，但它们可以扩展到具有少量活动部件的铰接物体，其中每个部 
件都被视为一个单独的物体。无论我们选择哪种方法来存储环境遮 
挡值，我们都需要知道我们正在处理连续信号。当我们从空间中的 
特定点拍摄光线时，我们进行采样，并且当我们在着色之前从这些 
结果中插值时，我们重建。信号处理领域的所有工具都可用于提高 
采样重建过程的质量。Kavan等人。[875]提出了一种他们称为最小 
二乘法烘焙的方法。在网格上均匀地采样遮挡信号。接下来，导出 
顶点的值，以便在最小方位意义上最小化内插和采样的总差异。他 
们特别在顶点处存储数据的上下文中讨论该方法，但是相同的推理 
可用于导出要存储在纹理或体积中的值。11.3。环境遮挡453 图 
11.11。Destiny在其间接照明计算中使用预先计算的环境遮挡。该 
解决方案用于两代不同硬件的游戏版本，提供高质量和高性能。（图 
片c 2013 Bungie，保留所有权利。）Destiny是一个广受好评的 
游戏的例子，它使用预先计算的环境遮挡作为其间接照明解决方案 
的基础（图11.11）。游戏在两代控制台硬件的过渡期间发布，需 
----------------------- Page 488-----------------------
要一种解决方案，以平衡新平台上预期的高质量与旧版本的性能和 
内存使用的限制。该游戏具有动态的时间，因此任何预先计算的解 
决方案都必须正确考虑这一点。开发人员选择了环境遮挡，因为它 
具有可信的外观和低成本。由于环境遮挡将可见度计算与照明分离， 
因此无论何时何时都可以使用相同的预计算数据。Sloan等人描述 
了完整的系统，包括基于GPU的烘烤管道。[1658]。来自 Ubisoft 
的刺客信条[1692]和 FarCry [1154]系列也使用一种预先计算的环 
境遮挡形式来增强它们的间接照明解决方案。它们从自上而下的视 
图渲染世界，并处理生成的深度图以计算大规模遮挡。使用各种启 
发法来基于相邻深度样本的分布来估计该值。生成的世界空间AO 
贴图通过将其世界空间位置投影到纹理空间来应用于所有对象。他 
们称这种方法为世界AO。Swoboda [1728]也描述了类似的方法。 
11.3.5环境遮挡的动态计算对于静态场景，可以预先计算环境遮挡 
因子kA和弯曲的正常遮挡。但是，对于物体移动或改变形状的场 
景，通过动态计算这些因素可以获得更好的结果。这样做的方法454 
11.全局照明可以分为在对象空间中操作的那些，以及在屏幕空间中 
操作的那些。用于计算环境遮挡的离线方法通常涉及从每个表面点 
投射大量数十到数百条光线到场景中并检查交叉点。这是一项代价 
高昂的操作，实时方法专注于近似或避免大部分计算的方法。 
Bunnell [210]通过将表面建模为放置在网格顶点处的盘形元素的 
集合来计算环境遮挡因子 kA并弯曲正常 nbent。选择磁盘是因为 
可以分析地计算一个磁盘与另一个磁盘的遮挡，从而避免了投射光 
----------------------- Page 489-----------------------
线的需要。简单地将所有其他磁盘的磁盘的遮挡因子相加会导致由 
于双阴影导致的过暗结果。也就是说，如果一个磁盘位于另一个磁 
盘后面，则两个磁盘都将被视为遮挡表面，即使两个磁盘中的较近 
者应该也是如此。Bunnell使用巧妙的双通方法来避免这个问题。 
第一遍计算环境遮挡，包括双阴影。在第二遍中，每个磁盘的贡献 
通过其从第一遍的遮挡而减少。这是一个近似值，但在实践中它产 
生了令人信服的结果。计算每对元素之间的遮挡是O （n2）阶的操 
作，这对于除了最简单的场景之外的所有场所来说都太昂贵了。通 
过对远距离表面使用简化表示可以降低成本。Bunnell构造一个元 
素的分层树，其中每个节点都是一个磁盘，表示树中它下面的磁盘 
的聚合。执行磁盘间遮挡计算时，更高级别的节点用于更远的表面。 
这将计算减少到O （nlogn），这更加合理。Bunnell的技术非常 
高效，可以产生高质量的结果。例如，它被用于加勒比海盗电影的 
最终渲染[265]。Hoberock[751]提出了对 Bunnell算法的若干修 
改，以更高的计算成本提高质量。他还提出了一个距离衰减系数， 
其结果与Zhukov等人提出的阻塞系数相似。[1970]。Evans[444] 
描述了一种基于带符号距离场（SDF）的动态环境遮挡近似方法。 
在此表示中，对象嵌入在三维网格中。网格中的每个位置都存储到 
对象最近表面的距离。对于任何对象内的点，此值为负，对于所有 
对象内的点，该值为正。Evans为体积纹理中的场景创建并存储 
SDF。为了估计对象上某个位置的遮挡，他使用一种启发式方法， 
该方法将在某些点处采样的值组合在一起，沿着法线逐渐远离表面。 
----------------------- Page 490-----------------------
当分析地表示SDF （第 17.3节）而不是存储在三维纹理中时，也可 
以使用相同的方法，如Qu'.lez [1450]所述。虽然该方法是非物理 
的，但结果在视觉上令人愉悦。Wright [1910]进一步扩展了使用符 
号距离场进行环境遮挡。而不是使用临时启发式来生成遮挡值， 
11.3。环境遮挡455图11.12。通过在场景几何和半径增大的球体 
之间执行一系列交叉来近似锥形跟踪。球体的大小对应于距离迹线 
原点给定距离处的锥体半径。在每个步骤中，锥角减小，以解决场 
景几何体的遮挡。最终遮挡因子被估计为被修剪的锥体所对应的立 
体角与原始锥体的立体角的比率。赖特执行锥形追踪。锥体起源于 
被遮蔽的位置，并且针对交叉点进行测试，场景表示在距离场中编 
码。通过沿轴执行一组步骤并在每一步检查SDF与半径增大的球的 
交点来近似锥跟踪。如果到最近的封堵器的距离（从SDF采样的值） 
小于球体的半径，则锥体的那部分被遮挡（图 11.12）。追踪单个 
锥体是不精确的，并且不允许结合余弦项。出于这些原因，赖特追 
踪一组覆盖整个半球的锥体，以估计环境遮挡。为了提高视觉保真 
度，他的解决方案不仅使用场景的全局SDF，还使用本地SDF，代 
表单个对象或逻辑连接的对象集。Crassin等人描述了类似的方法。 
[305]在场景的体素表示的上下文中。他们使用稀疏的体素八叉树 
 （第13.10节）来存储场景的体素化。他们用于计算环境遮挡的算 
法是用于渲染全局照明效果的更通用方法的特例（第 11.5.7节）。 
456 11.全球照明图 11.13。环境遮挡效果模糊，并且不会显示遮挡 
物的细节。AO计算可以使用更简单的几何表示，并且仍然可以实 
----------------------- Page 491-----------------------
现合理的效果。犰狳模型（左）用一组球体（右）近似。模型在其 
后面的墙壁上施加的遮挡几乎没有差别。（模型由斯坦福计算机图 
形实验室提供。）Renetal。[1482]将闭塞几何近似为球体集合 （图 
11.13）。使用球谐函数表示由单个球体遮挡的表面点的可见度函数。 
由一组球体遮挡的聚合可见度函数是将各个球体可见度函数相乘的 
结果。不幸的是，计算球谐函数的乘积是一项昂贵的操作。他们的 
关键思想是将各个球谐函数可见函数的对数相加，并对结果进行取 
幂。这产生与乘以可见度函数相同的最终结果，但是球面谐波函数 
的总和比乘法要便宜得多。本文表明，通过正确的近似，可以快速 
执行对数和取幂，从而产生整体加速。该方法不仅计算环境遮挡因 
子，而且计算全球面可见度函数，用球谐函数表示 （第 10.3.2节）。 
第一 （0阶）系数可以用作环境遮挡因子 kA，并且接下来的三个 （阶 
数 1）系数可以用于计算弯曲的正常nbent。高阶系数可用于阴影 
环境地图或圆形光源。由于几何体近似为边界球体，因此不会对折 
痕和其他小细节进行遮挡。斯隆等人。[1655]在屏幕空间中执行由 
Ren描述的可见度函数的累积。对于每个遮挡物，它们考虑一组像 
素，这些像素在距离其中心的某个规定的世界空间内。可以通过渲 
染球体并在着色器中执行距离测试或使用模板测试来实现此操作。 
对于所有受影响的屏幕区域，将适当的球谐值添加到屏幕外缓冲区。 
在累积所有遮挡物的可见性之后，将缓冲器中的值取幂以获得最终 
的组合可见度函数11.3。环境遮挡457图11.14。Crytek的环境遮 
挡方法应用于三个表面点（黄色圆圈）。为清楚起见，该算法以二 
----------------------- Page 492-----------------------
维方式示出，其中相机（未示出）在图上方。在该示例中，十个样 
本分布在每个表面点周围的盘上（实际上，它们分布在球体上）。 
未通过z测试的样本，即超出存储的z缓冲区值的样本，显示为红 
色，样品通过显示为绿色。kA的值是通过样品与总样品的比率的函 
数。为简单起见，我们在此处忽略变量样本权重。左边的点在总共 
10个中有6个通过的样本，导致比率为0.6，从中计算kA。中间点 
有三个通过的样本。上e更多是在对象之外但是没有通过z测试， 
如红色箭头所示。这给出了0.3的kA。右边的点有一个通过的样本， 
所以kA是0.1。对于每个屏幕像素。Hill[737]使用相同的方法，但 
将球谐函数可见度函数限制为仅二阶系数。有了这个假设，球谐函 
数只是少数几个标量乘法，甚至可以通过GPU的固定功能混合硬件 
来执行。这使我们甚至可以在性能有限的控制台硬件上使用该方法。 
因为该方法使用低阶球谐函数，所以它不能用于生成具有更多定义 
边界的硬阴影，而是仅用于主要是无方向遮挡。11.3.6屏幕空间方 
法对象空间方法的费用与场景复杂度成正比。然而，关于遮挡的一 
些信息可以纯粹从已经可用的屏幕空间数据推导出来，例如深度和 
法线。这些方法具有恒定的成本，与场景的详细程度无关，而只与 
用于渲染的分辨率有关.1Crytek开发了一种在Crysis [1227]中使 
用的动态屏幕空间环境遮挡 （SSAO）方法。他们使用zbuffer作为 
唯一输入，在全屏通道中计算环境遮挡。通过测试分布在像素位置 
周围的球体中的一组点对齐z缓冲器来估计每个像素的环境遮挡因 
子kA。kA的值是z缓冲区中相应值前面的样本数的函数。较少数 
----------------------- Page 493-----------------------
量的通过样本导致kA值较低。见图 11.14。样本的权重随着与像素 
的距离而减小，类似于遮蔽因子[1970]。请注意，由于样本未按（n·l） 
+因子加权，因此产生的环境遮挡为1在实践中，执行时间将取决 
于深度或正常缓冲区中数据的分布，因为这种分散会影响有效性遮 
挡计算逻辑使用GPU缓存。458 11.全局照明图 11.15。屏幕空间 
环境遮挡的效果显示在左上角。右上角显示没有环境遮挡的反照率 
 （漫反射颜色）。在左下方，两者显示为组合。右下角为最终图像 
添加了镜面着色和阴影。 （来自Crytek的 “孤岛危机”图片。）不 
正确。所有这些都被计算并计算在内，而不是只考虑表面位置上方 
的半球中的那些样本。这种简化意味着表面以下的样本在它们不应 
该被计算时计算。这样做会使平坦的表面变暗，边缘比周围环境更 
亮。尽管如此，结果往往在视觉上令人愉悦。见图 11.15。 
Shanmugam和Arikan [1615]同时开发了一种类似的方法。他们 
在论文中描述了两种方法。一个从附近的小细节产生精细的环境遮 
挡。另一个从较大的对象生成粗略的环境遮挡。将两者的结果组合 
以产生最终的环境遮挡因子。他们的精细环境遮挡方法使用访问z 
缓冲区的全屏通道，以及包含可见像素的表面法线的第二缓冲区。 
对于每个阴影像素，从z缓冲区采样附近的像素。采样的像素表示 
为球体，并且计算阴影像素的遮挡项，将其法线考虑在内。不考虑 
双阴影，因此结果有点暗。他们的粗略遮挡方法类似于 Ren等人的 
物空间方法。[1482]，在第456页讨论，其中遮挡几何形状近似为 
球体集合。然而，Shanmugam和Arikan使用覆盖 11.3的屏幕对 
----------------------- Page 494-----------------------
齐广告牌在屏幕空间中累积遮挡。环境遮挡459每个遮挡球体的“效 
果区域”。与 Ren等人的方法不同，在粗略遮挡方法中也没有考虑 
双阴影。这两种方法的极端简单性很快被业界和学术界注意到，并 
产生了许多后续工作。许多方法，例如 Filion等人在游戏 “星际争 
霸 II”中使用的方法。[471]和 McGuire等人的可扩展环境障碍。 
[1174]，使用特设启发法来生成遮挡因子。这些方法具有良好的性 
能特征并且暴露一些可以手动调整的参数以实现期望的艺术效果。 
其他方法旨在提供更有原则的计算遮挡的方法。Loos和 Sloan 
[1072]注意到Crytek的方法可以解释为蒙特卡洛积分。他们将计算 
值称为体积障碍并将其定义为vA =Zx∈Xρ （d （x））o （x）dx， 
 （11.15）其中X是点周围的三维球形邻域，ρ是距离映射函数，类 
似于公式 11.11中的，d是距离函数，o （x）是占用函数，如果x 
未被占用，则等于零，否则等于0。他们注意到ρ （d）函数对最终 
视觉质量影响很小，因此使用常数函数。鉴于这种假设，体积障碍 
是占据函数在一个点附近的积分。Crytek的方法随机对三维邻域进 
行采样以评估积分。Loos和Sloan通过随机采样像素的屏幕空间邻 
域来计算xy维数值积分。z维度通过分析整合。如果该点的球形邻 
域不包含任何几何，积分等于光线与表示X的球体之间的交点长度。 
在几何体存在的情况下，深度缓冲器用作占用函数的近似值，积分 
仅在每个未占用部分上计算。线段。请参见图 11.16的左侧。该方 
法生成的质量结果与Crytek相当，但使用的样本较少，因为在一个 
维度上的积分是精确的。如果表面法线可用，则可以扩展该方法以 
----------------------- Page 495-----------------------
将其考虑在内。在该版本中，线积分的评估被夹在由评估点处的法 
线限定的平面处。Szirmay-Kalos等。[1733]提出了另一种使用正 
常信息的屏幕空间方法，称为体积环境遮挡。公式 11。6在正常周 
围的半球上进行积分，并包括余弦项。他们提出可以通过从被积函 
数中去除余弦项并将积分范围与余弦分布钳位来近似这种类型的积 
分。这将积分转换为球体而不是半球，半球半径并沿着法线移动， 
半球完全封闭。其未占用部分的体积与 Loos和Sloan的方法一样， 
通过随机采样像素邻域并在z维度上对占用函数进行分析整合来计 
算。请参见图 11.16的右侧。460 11.全球照明图 11.16。体积障碍 
 （左）使用线积分估计该点周围未占用体积的积分。体积环境遮挡 
 （右）也使用线积分，但计算与阴影点相切的球体的占用率，该阴 
影点根据反射率方程对余弦项进行建模。在这两种情况下，积分是 
根据球体的未占用体积（用实线绿线标记）与球体总体积（未占用 
体积和占用体积之和，用红色虚线标记）之比来估算的。对于这两 
个数字，相机正在从上方观看。绿点表示从深度缓冲区读取的样本， 
黄色点是正在计算遮挡的样本。Bavoil等人提出了一种估算局部能 
见度问题的不同方法。[119]。他们从Max[1145]的地平线绘图技 
术中汲取灵感。他们的方法，称为基于地平线的环境遮挡 （HBAO）， 
假设z缓冲区中的数据代表连续的高度场。可以通过确定地平线角 
度来估计一点处的可见度，所述地平线角度是由邻域遮挡的切平面 
上方的最大角度。也就是说，给定一个点的方向，我们记录可见的 
最高物体的角度。如果我们忽略余弦项，则可以将环境遮挡因子计 
----------------------- Page 496-----------------------
算为地平线上未被遮挡部分的积分，或者，作为一个减去地平线下 
遮挡部分的积分：kA=1。12πZ？？=？Zh （？）？=t （？）W 
 （ω）cos （θ）dθdφ，（11.16）其中h （φ）是切平面上方的水 
平角，t （φ）是切平面之间的切线角视图矢量和W （ω）是衰减函 
数。见图 11。17.12？term将归一化归一化，使得结果在0和 1 
之间。通过使用到定义给定φ的水平点的距离的线性衰减，我们可 
以分析地计算内积分：kA =1。12πZ？？=？..sin （h （φ））。 
sin （t （φ））？W （φ）DΦ。 （11.17）通过对多个方向进行采样 
并找到水平角度，以数字方式计算剩余积分。11.3。环境遮挡461 
图11.17。基于地平线的环境遮挡（左）找到切线平面上方的水平 
角 h，并整合它们之间的未遮挡角度。切平面和视图矢量之间的角 
度表示为t。地面实况环境遮挡 （右）使用相同的地平线角度h1和 
h2，但也使用法线和视图矢量γ之间的角度，将余弦项合并到计算 
中。在这两个图中，相机正在从上方观看场景。图中示出了横截面， 
并且水平角是φ的函数，即围绕视图方向的角度。绿点表示从深度 
缓冲区读取的样本。黄点是计算遮挡的样本。Jimenez等人也使用 
基于地平线的方法。[835]在一种方法中，他们称之为地面实况环境 
遮挡（GTAO）。他们的目标是实现地面实况结果，匹配从光线追 
踪获得的结果，假设唯一可用的信息是由z缓冲区数据形成的高度 
场。基于地平线的环境光遮挡在其定义中不包括余弦项。它还增加 
了公式衰减，在公式 11.8中没有，所以它的结果，即使接近光线跟 
踪的那些，也不一样。GTAO引入了缺失的余弦因子，去除了衰减 
----------------------- Page 497-----------------------
函数，并在视图矢量周围的参考系中制定了遮挡积分。遮挡因子定 
义为kA =1πZ？0Z h2 （？）h1 （？）cos （θ.γ）+|sin （θ）|d 
θdφ， （11.18）其中h1 （φ）和h2 （φ）是给定φ的左右水平角， 
γ是法线方向和视角方向之间的角度。标准化术语 1？与HBAO不 
同，因为包括余弦项。这使得开放半球整合到π。不包括公式中的余 
弦项使其整合到2π。考虑到高度场假设，该公式与公式11.8完全 
匹配。见图11.17。内部积分仍然可以通过分析解决，所以只有外 
部需要用数字计算。通过对给定像素周围的多个方向进行采样，以 
与HBAO中相同的方式执行该积分。基于地平线的方法中最昂贵的 
过程部分是沿着屏幕空间线对深度缓冲区进行采样以确定地平线角 
度。Timonen [1771]提出了一种专门用于改善性能特征的方法46。 
11.该步骤的全局照明。他指出，用于估计给定方向的地平线角度的 
样本可以在屏幕空间中沿直线放置的像素之间重复使用。他将遮挡 
计算分为两个步骤。首先，他在整个z缓冲区中执行线迹。在跟踪 
的每一步，他在沿着线移动时更新地平线角度，考虑规定的最大影 
响距离，并将该信息写入缓冲区。为水平映射中使用的每个屏幕空 
间方向创建一个这样的缓冲区。缓冲区不需要与原始深度缓冲区的 
大小相同。它们的大小取决于线之间的间距，以及沿线的台阶之间 
的距离，并且在选择这些参数时有一定的灵活性。不同的设置会影 
响最终质量。第二步是根据存储在缓冲区中的水平信息计算遮挡因 
子。Timonen使用由 HBAO定义的遮挡因子 （公式 11.17），但也 
可以使用其他遮挡估计，例如GTAO （公式11.18）。深度缓冲区 
----------------------- Page 498-----------------------
不是场景的完美表现，因为只有最近的对象被记录在一个给定的方 
向上，我们不知道它背后发生了什么。许多方法使用各种启发法来 
尝试推断关于可见对象的厚度的一些信息。这些近似值足以满足许 
多情况，并且眼睛可以容忍不准确。虽然有些方法使用多层深度来 
缓解问题，但由于与渲染引擎的复杂集成和高运行时成本，它们从 
未获得更广泛的普及。屏幕空间方法依赖于重复采样z缓冲区以形 
成围绕给定点的几何的简化模型。实验表明，为了获得高视觉质量， 
需要多达几百个样本。但是，为了可用于交互式渲染，可以采集不 
超过 10到20个样本，往往甚至更少。Jimenez等。[835]报告说， 
为了适应60FPS游戏的性能预算，他们可以负担得起每个像素只使 
用一个样本！为了弥合理论与实践之间的差距，屏幕空间方法通常 
采用某种形式的空间抖动。在最常见的形式中，每个屏幕像素使用 
稍微不同的随机样本集，径向旋转或移位。在AO计算的主要阶段 
之后，执行全屏滤波通过。联合双边滤波 （第 12.1.1节）用于避免 
跨越表面不连续性并保留锐边。它使用有关深度或法线的可用信息 
来限制过滤，以仅使用属于同一表面的样本。一些方法使用随机变 
化的采样模式和实验选择的过滤内核;其他人使用固定大小的屏幕 
空间图案（例如，4×4像素）的重复样本集，以及限制于该邻域的 
过滤器。环境遮挡计算通常也经常被超采样[835,1660,1916]。该过 
程通常通过每帧应用不同的采样模式并对遮挡因子进行指数平均来 
完成。使用最后一帧的z缓冲区，摄像机变换和有关动态对象运动 
的信息，将前一帧中的数据重新投影到当前视图。然后将其与当前 
----------------------- Page 499-----------------------
帧结果混合。基于深度，法线或速度的启发式 11.3。环境遮挡463 
通常用于检测来自最后一帧的数据不可靠并且应该被丢弃的情况 
 （例如，因为有些新对象已经出现了。第5.4.2节在更一般的设置 
中解释了时间超级采样和抗锯齿技术。时间过滤的成本很小，实现 
起来很简单，即使它并不总是完全可靠，实际上大多数问题都不明 
显。这主要是因为环境遮挡永远不会直接可视化，它只是作为照明 
计算的输入之一。将此效果与法线贴图，反照率纹理和直接照明相 
结合后，任何微小的工件都会被遮挡掉并且不再可见。11.3.7使用 
环境遮挡进行着色尽管我们在恒定，远距离照明的环境中导出了环 
境遮挡值，但我们也可以将其应用于更复杂的照明场景。再次考虑 
反射方程：Lo （v）=Zl∈f （l，v）Li （1）v （1） （n·1）+d1。 （11.19） 
上述表格包含可见性函数v （l），如第 11.3.1节所述。如果我们处 
理漫反射曲面，我们可以用朗伯 BRDF替换f （l，v），它等于地下 
反照率ρss除以π。我们得到Lo =Zl∈ρssπLi （1）v （1）（n·1） 
+dl=ρssπZl∈Li （1）v （1） （n·1）+dl。 （11.20）我们可以重 
新拟合上述方程得到 Lo =ρssπZl∈Li （l）v （l）（n·l）+dl =ρss 
πRl∈Li （l）v （l）（n· l）+dlRl∈v （l）（n·l）+dlZl∈v （l） （n·l） 
+dl=ρssπZl∈Li （l）v （l） （n·l ）+Rl∈v （l） （n·1）+dldlZl 
∈v （1） （n·1）+dl。 （11.21）如果我们使用来自公式 11.8的环 
境遮挡的定义，则上述简化为 Lo=kAρssZl∈Li （1）K （n，l）dl， 
 （11.22）其中K （n，l）=v （1） （n·1）+Rl∈v （l） （n·1）+ 
dl。（11。23）这个表格为我们提供了一个关于这个过程的新视角。 
----------------------- Page 500-----------------------
公式 11.22中的积分可以被认为是将方向滤波核K应用于入射辐射 
Li。464 11.全局照明过滤器 K以复杂的方式在空间和方向上发生变 
化，但它具有两个重要特性。首先，由于夹点产品，它最多覆盖了 
点p处法线周围的半球。其次，由于分母中的归一化因子，它在半 
球上的积分等于 1。为了执行着色，我们需要计算两个函数的乘积 
的积分，即入射辐射Li和滤波函数 K.在某些情况下，可以以简化的 
方式描述滤波器并在a处计算该双积积分。相当低的成本，例如， 
当使用球谐函数表示Li和 K时（第10.3.2节）。处理该等式的复 
杂性的另一种方法是使用具有类似属性的更简单的过滤器来近似过 
滤器。最常见的选择是归一化余弦核 H：H （n，l）= （n·1）+Rl 
∈ （n·1）+dl。（11.24）当没有任何东西阻挡入射光时，这种近 
似是准确的。它还覆盖了与我们近似的滤波器相同的角度范围。它 
完全忽略了可见性，但环境遮挡kA项仍然存在于公式 11.22中， 
因此在阴影表面上会出现一些与可见度相关的变暗。通过这种滤波 
核的选择，等式 11.22变为 Lo =kAρssZl∈Li （1）（n·1）+Rl∈ 
 （n·1）+dldl=kAπρssE。 （11.25）这意味着，以最简单的形式， 
可以通过计算辐照度并将其乘以环境遮挡值来执行具有环境遮挡的 
阴影。辐照度可以来自任何来源。例如，它可以从辐照度环境图中 
采样 （第 10.6节）。该方法的准确性仅取决于近似滤波器表示正确 
滤波器的程度。对于在球体上平滑变化的光照，近似得到合理的结 
果。如果 Li在所有可能的方向上是恒定的，即，好像场景被表示照 
明的全白环境地图照亮，那么它也是完全准确的。这个公式还让我 
----------------------- Page 501-----------------------
们深入了解为什么环境遮挡对于准时或小面积光源的可见度差。它 
们仅在表面上对着一个小的立体角 - 在准时光的情况下无限小 - 
并且可见度函数对照明积分的值具有重要影响。它以几乎二进制的 
方式控制光的贡献，即，它完全启用或禁用它。忽略可见性，正如 
我们在公式 11.25中所做的那样，是一个重要的近似值，并且通常 
不会产生预期的结果。阴影缺乏定义，并且没有表现出任何预期的 
方向性，也就是说，似乎不是由特定灯光产生的。环境遮挡不是建 
模这种灯的可见度的好选择。应该使用其他方法，例如阴影贴图。 
然而，值得注意的是，有时使用小的局部灯来模拟间接照明。在这 
种情况下，用环境遮挡值调制它们的贡献是合理的。11.4。定向遮 
挡465到目前为止，我们假设我们正在对朗伯表面进行着色。当处 
理更复杂的非常数 BRDF时，该函数不能从积分中拉出，如公式 
11.20所示。对于镜面反射材料，K不仅取决于能见度和法线，还 
取决于观察方向。典型的微平面 BRDF的叶片在整个域中发生显着 
变化。用单个预定形状对其进行近似是太粗糙而不能产生可信的结 
果。这就是为什么使用环境遮挡进行着色对于漫反射 BRDF最有意 
义的原因。在接下来的章节中讨论的其他方法对于更复杂的材料模 
型更好。使用弯曲法线 （见公式 11。第448页的 10可以看作是更 
精确地近似滤波器 K的一种方法。可见性项在滤波器中仍然不存在， 
但其最大值与平均未被遮挡的方向匹配，这使得它与公式 11.23整 
体略微更接近。在几何法线和弯曲法线不匹配的情况下，使用后者 
将得到更准确的结果。Landis[974]不仅将它用于环境贴图的阴影， 
----------------------- Page 502-----------------------
而且还用于某些直接光源，而不是常规的阴影技术。对于使用环境 
贴图进行着色，Pharr[1412]提供了一种使用GPU纹理过滤硬件动 
态执行过滤的替代方案。过滤器K的形状在运行中确定。它的中心 
是弯曲法线的方向，其大小取决于kA的值。这提供了与公式 11.23 
中的原始滤波器更精确的匹配。11.4定向遮挡尽管单独使用环境遮 
挡可以极大地提高图像的视觉质量，但它是一个大大简化的模型。 
当处理甚至大面积光源时，它给出了可见度差的近似值，更不用说 
小的或准时的光源。它也无法正确处理有光泽的 BRDF或更复杂的 
照明设置。考虑由远处穹顶灯照亮的表面，穹顶上的颜色从红色变 
为绿色。这可能代表了来自天空的光所照亮的地面 - 给定的颜色， 
可能在某个遥远的星球上。见图11.18。即使环境遮挡会使点a和b 
处的光线变暗，它们仍然会被天空的红色和绿色部分照亮。使用弯 
曲法线有助于减轻这种影响，但它也不完美。我们之前提出的简单 
模型不够灵活，无法处理这种情况。一种解决方案是以更具表现力 
的方式描述可见性。我们将重点关注编码整个球形或半球形可见度 
的方法，即描述哪些方向阻挡入射辐射的方法。虽然这些信息可以 
用于遮蔽准时灯，但这不是它的主要目的。针对那些特定类型的灯 
的方法 - 在第7章中进行了广泛讨论 - 能够实现更好的质量，因 
为它们需要对源的单个位置或方向的可见性进行编码。此处描述的 
解决方案主要用于为大面积灯光或环​ ​ 境照明提供遮挡，其中 
466 11.全局照明环境遮挡方向遮挡弯曲正常图 11.18。在复杂光照 
条件下，点a和b的辐照度的近似颜色。环境遮挡不会模拟任何方 
----------------------- Page 503-----------------------
向性，因此两个点的颜色相同。使用弯曲法线有效地将余弦波瓣移 
向天空中未被遮挡的部分，但由于积分范围不受任何限制，因此仅 
提供准确的结果是不够的。定向方法能够正确地消除来自天空遮挡 
部分的光线。生成的阴影是柔和的，并且由近似可见性引起的伪像 
不明显。另外，在常规阴影技术不可行的情况下，这些方法也可用 
于提供遮挡，例如凹凸贴图细节的自阴影以及阴影贴图没有足够分 
辨率的极大场景的阴影。11.4.1预先计算的方向遮挡 Max[1145] 
引入了水平映射的概念来描述高度场表面的自遮挡。在水平映射中， 
对于表面上的每个点，确定地平线的高度角，用于一组方位角方向， 
例如，八个：北，东北，东，东南，周围。代替存储某些给定罗盘 
方向的水平角度，整组的未被遮挡的三维方向可以被建模为椭圆形 
[705,866]或圆形[1306,1307]孔径。后一种技术称为环境光圈照明 
 （图11.19）。这些技术比水平地图具有更低的存储要求，但是当 
未被遮挡的方向的集合不像椭圆或圆形时，可能导致不正确的阴影。 
例如，高穗以规则间隔突出的平面应该具有星形方向设置，其不能 
很好地映射到方案。闭塞技术有许多变化。王等人。[1838]使用球 
形有符号距离函数 （SSDF）来表示可见性。它编码到球体上遮挡区 
域边界的有符号距离。第 10.3节中讨论的任何球形或半球形基座也 
可用于编码能见度[582,632,805,1267]。就像环境遮挡一样方向可 
见性信息可以存储在纹理，网格顶点或体积中[1969]。11.4。定向 
遮挡467图11.19。环境光圈照明用锥形近似于阴影点上方的未被 
遮挡区域的实际形状。在左侧，区域光源显示为黄色，表面位置的 
----------------------- Page 504-----------------------
可见水平显示为蓝色。在右侧，地平线被简化为圆形，圆形是从表 
面位置向上和向右突出的圆锥的边缘，用虚线表示。然后通过使其 
锥体与遮挡锥相交来估计区域光的遮挡，产生以红色显示的区域。 
11.4.2定向遮挡的动态计算许多用于生成环境遮挡的方法也可用于 
生成定向可见性信息。Ren等人的球谐函数指数。[1482]，以及Sloan 
等人的屏幕空间变体。[1655]以球面谐波矢量的形式产生可见性。 
如果使用多于一个SH波段，则这些方法本身提供方向信息。使用 
更多频段可以更精确地编码可见性。锥形追踪方法，如Crassin等 
人的方法。[305]和Wright [1910]，为每条迹线提供一个遮挡值。 
出于质量原因，甚至使用多条迹线执行环境遮挡估计，因此可用信 
息已经是定向的。如果需要在特定方向上的可见性，我们可以追踪 
更少的锥体。Iwanicki[806]也使用锥形追踪，但他将其限制在一个 
方向。结果用于生成由静态几何体投射到静态几何体上的柔和阴影， 
动态角色用一组球体近似，类似于Ren等人。[1482]和Sloan等人。 
[1655]。在此解决方案中，使用AHD编码存储静态几何体的照明 
 （第10.3.3节）。可以独立处理环境和方向组件的可见性。通过分 
析计算环境部分的遮挡。跟踪单个锥体并与球体相交以计算方向分 
量的衰减因子。还可以扩展许多屏幕空间方法以提供定向遮挡信息。 
Klehm等人。[904]使用z缓冲区数据来计算屏幕空间弯曲锥体，其 
实际上是圆形孔径，非常类似于由Oat和Sander离线预先计算的 
那些[1307]。当对像素的邻域进行采样时，它们对未被遮挡的方向 
求和。得到的矢量的长度可用于468 11.全局照明估计可见锥的顶 
----------------------- Page 505-----------------------
角，其方向定义该锥的轴。Jimenez等。[835]基于地平线角度估计 
锥轴方向，并从环境遮挡因子导出角度。11.4.3使用定向遮挡进行 
着色使用如此多的不同编码方向遮挡的方法，我们无法为如何执行 
着色提供单一处方。解决方案取决于我们想要达到的特定效果。让 
我们再次考虑反射率方程，在一个版本中，入射辐射分裂为远光 Li 
及其可见度v：Lo （v）=Zl∈f （l，v）Li （l）v （l） （n·l） ）+DL。 
 （11。26）我们可以做的最简单的操作是使用可见性信号来遮蔽准 
时光。由于大多数编码可见性方式的简单性，结果的质量通常不能 
令人满意，但它将允许我们在基本示例上遵循推理。此方法也可用 
于传统阴影方法由于分辨率不足而失败的情况，并且结果的精度不 
如完全实现任何形式的遮挡重要。此类情况的示例包括极大的地形 
模型或用凹凸贴图表示的小表面细节。按照第9.4节的讨论，当处 
理准时光时，公式 11.26变为 Lo （v）=πf （lc，v）clightv （lc） 
 （n·lc）+，（11.27）其中clight是从白色反射的辐射，朗伯表面 
朝向光线，而lc是朝向光线的方向。我们可以将上述等式解释为计 
算材料对未被遮挡的光的响应并将结果乘以可见度函数的值。如果 
光线方向落在地平线下（当使用水平线测绘时），在能见度锥体外 
 （使用环境光圈照明时），或者在SSDF的负区域内，可见度函数 
等于零，因此任何来自光线的贡献不应该考虑到。值得一提的是， 
即使可见性被定义为二元函数，但是许多表示可以返回整个值范围， 
而不仅仅是零或一。这些值传达部分遮挡。由于振铃，球谐波或H 
基甚至可以重建负值。这些行为可能是不受欢迎的，但只是编码的 
----------------------- Page 506-----------------------
固有属性。我们可以用区域灯进行类似的照明推理。在这种情况下， 
Li在任何地方都等于零，除了在光所对的立体角内，2在大多数情 
况下，至少。在某些情况下，我们希望可见性函数采用非零或一的 
值，但仍在该范围内。例如，当编码由半透明材质引起的遮挡时， 
我们可能想要使用分数遮挡值。11.4。定向遮挡469图11.20。可 
以将黄色多边形光源投射到阴影点上方的单位半球上以形成球形多 
边形。如果使用水平映射描述可见性，则可以对该多边形进行剪裁。 
剪切的余弦加权积分，红色多边形可以使用Lambert公式进行分析 
计算。它等于该源发出的辐射。我们将它称为 L1，并假设它在光的 
立体角上是恒定的。我们可以替换整个球体上的积分，并且在光的 
立体角上积分，l：Lo （v）=LlZl∈lv （l）f （l，v）（n·1）+dl。 
 （11.28）如果我们假设BRDF是常数 - 所以我们处理朗伯表面 - 
它也可以从积分下面拉出：Lo （v）=ρssπLlZl∈lv （l） （n· 1）+DL。 
 （11.29）为了确定遮挡的光照，我们需要计算可见度函数的积分乘 
以余弦项乘过光所对应的立体角。有时可以通过分析方式完成此操 
作。Lambert [967]推导出一个公式来计算余弦在球面多边形上的 
积分。如果我们的区域光是多边形的，我们可以将它与可见性表示 
相对应，那么我们只需要使用Lambert公式来获得精确的结果 （图 
11.20）。例如，当我们选择地平线角度作为我们的可见性表示时， 
这是可能的。但是，如果由于任何原因我们选择了另一种编码，例 
如弯曲的锥体，剪切将产生圆形片段，我们不能再使用 Lambert的 
公式。如果我们想要使用非多边形区域灯，则同样适用。另一种可 
----------------------- Page 507-----------------------
能性是假设余弦项的值在整个域中是恒定的。如果区域光的大小很 
小，则这种近似是相当精确的。为简单起见我们可以使用在区域光 
的中心方向上评估的余弦值。这使得我们在光的立体角上具有可见 
度项的积分。我们关于如何进行的选择同样取决于我们的全球照明 
选择能见度表示和区域光的类型。如果我们使用球形灯和用弯曲锥 
体表示的可见度，积分值是可见锥和灯所对应的锥的交点的立体角。 
它可以通过分析计算，如Oat和Sander所示[1307]。虽然确切的 
公式很复杂，但它们提供了一种在实践中运作良好的近似值。如果 
可见性用球谐函数编码，则积分也可以通过分析计算。对于环境照 
明，我们不能限制集成范围，因为照明来自各个方向。我们需要找 
到一种方法来计算公式 11.26中的完整积分。让我们首先考虑朗伯 
BRDF：Lo （v）=ρssπZl∈Li （1）v （l）（n·1）+dl。（11.30） 
该等式中的积分类型称为三积积分。如果以某些方式表示各个函数 
- 例如，作为球谐函数或小波 - 它可以通过分析计算。不幸的是， 
这对于典型的实时应用来说太昂贵了，尽管已经示出这种解决方案 
在简单设置中以交互式帧速率运行[1270]。然而，我们的特殊情况 
稍微简单一点，因为其中一个功能是余弦。我们可以将公式 11.30 
写为 Lo （v）=ρssπZl∈Li （1）v （l）dl （11。31）或 Lo （v）=ρ 
ssπZl∈Li （1）v （l）dl，（11.32）其中Li （1）=Li （1）（n·1） 
+，v （1）=v （l）（n·l）+。Li （1）和v （1）都是球形函数， 
如 Li （1）和v （1）。我们首先将余弦乘以Li （公式11.31）或vi 
 （公式11.32），而不是尝试计算三元积积分。这样做使得被积函 
----------------------- Page 508-----------------------
数只是两个函数的乘积。虽然这可能只是一个数学技巧，但它大大 
简化了计算。如果使用诸如球谐函数的标准正交基来表示因子，则 
可以简单地计算双积积分。它是系数向量的点积（第 10.3.2节）。 
我们仍然需要计算 Li （l）或v （l），但因为它们涉及余弦，所以这 
比完全一般的情况更简单。如果我们使用球谐函数表示函数，则余 
弦投影到带状谐波 （ZH），这是球谐波的子集，其中每个波段只有 
一个系数非零 （第 10.3.2节）。该投影的系数具有简单的分析公式 
[1656]。SH和ZH的乘积比SH和另一个SH的乘积更有效。11.4。 
定向遮挡471如果我们决定首先将余弦乘以v （公式11.32），我 
们可以离线进行，而只是存储可见性。这是一种预先计算的辐射传 
递形式，如Sloan等人所述。[1651] （第 11.5.3节）。然而，在这 
种形式中，我们不能应用法线的任何精细尺度修改，因为由法线控 
制的余弦项已经与可见性融合。如果我们想要对精细尺度的正常细 
节进行建模，我们可以首先将余弦乘以 Li （公式11.31）。由于我 
们不知道前面的法线方向，我们可以预先计算此产品的不同法线 
[805]或在运行时执行乘法[809]。预先计算Li和余弦的产品离线意 
味着，反过来，对照明的任何改变都受到限制，并且允许照明在空 
间上改变将需要大量的存储器。另一方面，在运行时计算产品在计 
算上是昂贵的。Iwanicki和Sloan [809]描述了如何降低这个成本。 
在它们的情况下，可以在较低粒度的顶点上计算产品。结果与余弦 
项一致，投影到更简单的表示 （AHD），然后用每像素法线进行插 
值和重构。这种方法允许他们在性能要求高达60FPS的游戏中使用 
----------------------- Page 509-----------------------
该方法。Klehm等人。[904]呈现用环境地图表示的照明解决方案和 
用锥体编码的可见性。他们使用不同大小的内核过滤环境地图，这 
些内核代表不同锥形开口的可见性和照明产品的整体。它们存储结 
果以增加纹理的mip级别中的锥角。这是可能的，因为大锥角的预 
滤波结果在球体上平滑地变化，并且不需要以高角度分辨率存储。 
在预过滤期间，他们假设可见锥的方向与法线对齐，这是近似值， 
但实际上给出了合理的结果。他们提供了这种近似如何影响最终质 
量的分析。如果我们处理有光泽的 BRDF和环境照明，情况就更复 
杂了。我们不能再从积分下拉 BRDF，因为它不是常数。为了解决 
这个问题，格林等人。[582]建议用一组球面高斯近似BRDF本身。 
这些是径向对称函数，其可以仅用三个参数紧凑地表示：方向（或 
平均值）d，标准偏差μ和幅度w。近似BRDF定义为球面高斯的总 
和：f （l，v）≈Xkwk （v）G （dk （v），μk （v），l）， （11.33） 
其中G （d，μ， l）是球面高斯波瓣，沿方向d定向，具有锐度μ 
 （第10.3.2节），并且第k波瓣的振幅为wk。对于各向同性 BRDF， 
凸起的形状仅取决于法线方向和视线方向之间的角度。近似可以存 
储在一维查找表中并进行插值。472 11.全局照明通过这种近似，我 
们可以将公式 11.26写成Lo （v）≈Zl∈Xkwk （v）G （dk （v）， 
μk （v），l）Li （l）v （l ） （n·1）+dl =X kwk （v）Zl∈G （dk 
 （v），μk （v），l）Li （1）v （1）（n·1）+d1。（11.34）格林 
等人。还假设可见度函数在每个球形高斯的整个支撑上是恒定的， 
这允许它们从积分下面拉出它。他们评估了在叶片中心方向上的能 
----------------------- Page 510-----------------------
见度函数：Lo （v）≈Xkwk （v）vk （dk （v））Zl∈G （dk （v）， 
μk （v），l）Li （l）（n·l）+dl。（11。35）剩余的积分表示与 
在给定方向上具有给定标准偏差的球形高斯卷积的入射光。这种卷 
积的结果可以预先计算并存储在环境地图中，较大μ的卷积存储在较 
低的mip级别中。可见性采用低阶球谐函数编码，但也可以使用任 
何其他表示，因为它仅进行点评估。王等人。[1838]以类似的方式 
近似 BRDF，但以更精确的方式处理可见性。它们的表示允许它们 
在可见度函数的支持下计算单个球面高斯的积分。他们使用这个值 
来引入一个新的球形高斯，一个具有相同的方向和标准偏差但具有 
不同的幅度。他们在照明计算过程中使用这个新功能。对于某些应 
用，这种方法可能太昂贵。它需要来自预过滤环境贴图的多个样本， 
并且纹理采样通常已经是渲染期间的瓶颈。Jimenez等。[835]和 
ElGarawany[414]提出了更简单的近似。为了计算遮挡因子，它们 
用单个圆锥表示整个 BRDF波瓣，忽略了它对视角的依赖性，仅考 
虑材料粗糙度等参数（图 11.21）。它们将能见度近似为锥形，并 
计算可见度和 BRDF锥体交点的立体角，就像环境光圈照明一样。 
标量结果用于衰减照明。尽管这是一个显着的简化，但结果是可信 
的。11。5漫反射全局照明下一节将介绍不仅可以模拟遮挡，还可 
以实时模拟全光反射的各种方法。它们大致可以分为几种算法，这 
些算法假设在到达眼睛之前，光线从漫反射或镜面反射回来。11.5。 
漫反射全局照明473图11.21。出于计算遮挡的目的，光泽材料的 
镜面凸角可以表示为锥形。如果可见度近似为另一个锥体，则可以 
----------------------- Page 511-----------------------
将遮挡因子计算为两者相交的立体角，与环境光圈照明相同（图 
11.19）。该图显示了用锥体表示 BRDF波瓣的一般原理，但仅作为 
说明。在实践中，为了产生合理的遮挡结果，锥体需要更宽。相应 
的光路可以分别写成L （D|S）.DE或 L （D|S）.SE，许多方法对 
早期反弹的类型设置了一些约束。第一组中的解决方案假设入射光 
在阴影点上方的半球上平滑变化，或完全忽略该变化。第二组算法 
假设事件方向的变化率很高。它们依赖于这样的事实，即照明将仅 
在相对较小的立体角内进入。由于这些极为不同的约束，分别处理 
这两组是有益的。我们将在本节介绍漫反射全局照明的方法，下一 
步是镜面反射，然后是最后一节中有希望的统一方法。11.5。1表 
面预处理光能传递和路径跟踪都是为离线使用而设计的。虽然已经 
努力在实时环境中使用它们，但结果仍然太不成熟，无法用于生产。 
目前最常见的做法是使用它们来预先计算与照明相关的信息。昂贵 
的离线过程提前运行，其结果被存储并随后在显示期间使用以提供 
高质量的照明。如第 11.3.4节所述，以这种方式对静态场景进行预 
计算称为烘焙。这种做法有一定的限制。如果我们提前进行光照计 
算，我们无法在运行时更改场景设置。所有场景几何体，灯光和材 
质都需要保持不变。我们不能改变时间或在墙上吹洞。在许多情况 
下，这种限制是可接受的权衡。架构可视化可以假设用户仅在虚拟 
环境中行走。游戏也限制了玩家的行为。在这些应用程序中，我们 
可以将几何分类为静态和动态对象。静态对象用于预计算过程，并 
且它们与照明完全交互。静态墙474 11.全局照明=图11.22。给定 
----------------------- Page 512-----------------------
具有已知法线的朗伯表面，其辐照度可以预先计算。在运行时，该 
值乘以实际表面颜色（例如，从纹理）乘以获得反射辐射。根据表 
面颜色的确切形式，可能需要额外除以π以确保节能。投下阴影和静 
态红色地毯反射红光。动态对象仅充当接收器。它们不会阻挡光线， 
并且不会产生间接照明效果。在这种情况下，动态几何体通常被限 
制为相对较小，因此其对其余照明的影响可以忽略或用其他技术建 
模，质量损失最小。例如，动态几何可以使用屏幕空间方法来生成 
遮挡。一组典型的动态对象包括角色，装饰几何体和车辆。可以预 
先计算的最简单形式的照明信息是辐照度。对于平坦的朗伯曲面， 
再加上表面颜色，它完全描述了材料对光照的响应。因为照明源的 
效果是独立的，可以在预先计算的辐照度之上添加动态光源（图 
11.22）。1996年的Quake和 1997年的Quake II是第一个利用 
预先计算的辐照度值的商业交互式应用程序。Quake正在预先计算 
静态灯的直接贡献，主要是为了提高性能。Quake II还包括一个间 
接组件，使其成为第一款使用全局照明算法生成更逼真照明的游戏。 
它使用基于光能传递的算法，因为这种技术非常适合计算朗伯环境 
中的辐照度。此外，时间的记忆约束将照明限制为相对较低的分辨 
率，这与光能传递解决方案典型的模糊，低频阴影很好地匹配。预 
计算的辐照度值通常乘以存储在单独纹理集中的漫反射颜色或反照 
率图。虽然退出（辐照度乘以漫反射颜色）理论上可以预先计算并 
存储在单个纹理集中，但在大多数情况下，许多实际考虑因素排除 
了这个选项。色彩图通常频率很高，它们使用各种类型的平铺，它 
----------------------- Page 513-----------------------
们的各个部分经常在模型中重复使用，所有这些都是为了保持内存 
使用的合理性。辐照度值通常低得多，并且不易重复使用。保持照 
明和表面颜色分离会消耗更少的内存。11.5。漫反射全局照明475 
除了最严格的硬件平台外，今天很少使用预计算辐照度。根据定义， 
对于给定的法线方向计算辐照度，我们不能使用法线贴图来提供高 
频细节。这也意味着辐照度只能预先计算平面。如果我们需要在动 
态几何体上使用烘焙照明，我们需要其他方法来存储它。这些限制 
促使人们寻找用定向组件存储预先计算的照明的方法。11.5.2定向 
表面预照明要在朗伯表面上使用预照明和法线贴图，我们需要一种 
方法来表示辐照度随表面法线的变化。为动态几何体提供间接照明， 
我们还需要每个可能的表面方向的值。令人高兴的是，我们已经拥 
有了代表这些功能的工具。在第 10节。在图3中，我们描述了根 
据法线方向确定照明的各种方法。这些包括针对功能域为半球形并 
且球体下半部分的值无关紧要的情况的专用解决方案，如不透明表 
面的情况。最通用的方法是存储全球面辐照度信息，例如通过使用 
球面谐波。该方案首先由Good和Taylor [564]在加速光子映射的 
背景下呈现，并由Shopf等人在实时设置中使用。[1637]。在两种 
情况下，定向辐照度都存储在纹理中。如果使用九个球谐系数（三 
阶SH），则质量非常好，但存储和带宽成本很高。仅使用四个系数 
 （二阶SH）成本更低，但许多细微之处都会丢失，光线对比度较低， 
法线贴图不太明显。Chen [257]使用 Halo3的方法的变型，开发 
以降低成本实现三阶SH的质量。他从球形信号中提取出最主要的 
----------------------- Page 514-----------------------
光，并将其分别存储为颜色和方向。使用二阶SH编码残基。这将 
系数从27减少到 18，质量损失很小。Hu[780]描述了如何进一步 
压缩这些数据。Chen和Tatarchuk [258]提供了有关其生产中使用 
的基于GPU的烘烤管道的更多信息。Habel等人的 H基础。[627] 
是另一种替代解决方案。由于它仅对半球形信号进行编码，因此较 
少的系数可以提供与球谐波相同的精度。只用六个系数就可以获得 
与三阶SH相当的质量。因为基础仅针对半球定义，所以我们需要 
在表面上使用一些局部坐标系来正确定位它。通常，由uv参数化产 
生的切线框架用于此目的。如果 H基础分量存储在纹理中，则其分 
辨率应足够高，以适应下面切线空间的变化。如果具有显着不同的 
切线空间的多个三角形覆盖相同的纹素，则重建的信号将不精确。 
476 11.全球照明图 11.23。使命召唤：第二次世界大战使用AHD 
表示来编码光照地图中照明的方向变化。网格用于在调试模式下可 
视化光照贴图密度。每个方块对应于单个光照贴图。（图片由 
Activision Publishing，Inc。2018提供。）球谐函数和 H基的一 
个问题是它们可以表现出振铃 （第 10.6.1节）。虽然预过滤可以减 
轻这种影响，但它也可以平滑照明，这可能并不总是令人满意的。 
另外，即使是较便宜的变体在存储和计算方面仍然具有相对高的成 
本。在限制性更强的情况下，例如在低端平台或渲染虚拟现实时， 
此费用可能会过高。成本是简单替代品仍然流行的原因。半条命2 
使用自定义的半球形基础 （第 10.3.3节），存储三个颜色值，每个 
样本总共九个系数。环境/高光/方向（AHD）基础（第10.3节）。 
----------------------- Page 515-----------------------
3）尽管简单，但也是一种流行的选择。它已被用于诸如使命召唤 
[809,998]系列和 The Last of Us [806]等游戏中。见图 11.23。 
Crytek在 FarCry[1227]游戏中使用了一种变体。Crytek表示由切 
线空间中的平均光方向，平均光颜色和标量方向性因子组成。最后 
一个值用于在环境和方向组件之间进行混合，两者都使用相同的颜 
色。这将每个样本的存储减少到六个系数：颜色的三个值，方向的 
两个值和方向性因子的一个值。Unity引擎在其一种模式中也使用 
类似的方法[315]。这种类型的表示是非线性的，这意味着，从技术 
上讲，在纹素或顶点之间线性插值单个分量，不是 11.5。漫反射全 
局照明477图11.24。命令：1886将入射辐射投射到其光照图中投 
射到一组球形高斯波瓣上。在运行时，辐射与余弦波瓣进行卷积以 
计算漫反应（左）并使用适当形状的各向异性球面高斯来生成镜面 
响应 （右）。 （图片由ReadyatDawnStudios提供，索尼互动娱 
乐公司版权所有。）严格正确。如果主导光的方向快速变化，例如 
在阴影边界上，则可能在阴影中出现视觉伪像。尽管存在这些不准 
确之处，但结果看起来仍然令人愉悦。由于环境和定向照明区域之 
间的高对比度，正常地图的效果更加突出，这通常是期望的。另外， 
在计算 BRDF的镜面响应时，可以使用方向分量，以便为低光泽材 
料提供低成本的环境贴图替代方案。在光谱的另一端是为高视觉质 
量而设计的方法。Neubelt和 Pettineo[1268]在游戏The Order： 
1886 （图11.24）中使用存储球形高斯系数的纹理贴图。它们存储 
入射辐射，而不是辐照度，投射到一组高斯波瓣（第 10.3.2节）， 
----------------------- Page 516-----------------------
在一个切线框架中定义。它们使用5到9个波瓣，具体取决于特定 
场景中照明的复杂程度。为了产生漫反应，球面高斯与沿表面法线 
取向的余弦波瓣卷积。表示也足够精确，以提供低光泽的镜面反射 
效果，通过将高斯人与镜面 BRDF波瓣进行卷积。Pettineo详细描 
述了完整的系统[1408]。他还为能够烘焙和渲染不同光照表示的应 
用程序提供源代码。如果我们需要有关任意方向照明的信息，而不 
仅仅是在表面上方的半球内（例如，为动态几何提供间接照明）， 
我们可以使用编码全球面信号的方法。球谐波在这里很自然。当记 
忆不那么重要时，三阶SH （每个颜色通道九个系数）是最受欢迎的 
选择;否则，使用二阶（每个颜色通道有四个系数，它与 RGBA纹 
理中的分量数相匹配，因此单个地图可以存储一个颜色通道的系 
数）。球面高斯也可以在完全球形的环境中工作，因为凸起可以分 
布在整个球体上或仅围绕法线的半球上。然而，自从478 11.全局 
照明后，需要被叶片覆盖的立体角是球形技术的两倍，我们可能需 
要使用更多的叶片来保持相同的质量。如果我们想避免处理振铃， 
但不能使用大量的波瓣，环境立方体[1193] （第 10.3.1节）是一个 
可行的替代方案。它由六个夹紧的cos2瓣组成，沿主轴定向。余弦 
叶每个只覆盖一个半球，因为它们具有局部支撑，这意味着它们仅 
在其球形域的子集上具有非零值。为此原因，在重建期间仅需要六 
个存储值中的三个可见波瓣。这限制了照明计算的带宽成本。重建 
质量类似于二阶球谐函数。环境骰子[808] （也是第10.3.1节）可 
用于比环境立方体更高的质量。该方案使用沿二十面体顶点定向的 
----------------------- Page 517-----------------------
十二个波瓣，它们是cos2和cos4波瓣的线性组合。在重建期间使 
用存储的十二个中的六个值。质量可与三阶球谐波相媲美。这些和 
其他类似的表示（例如，由三个cos2波瓣和余弦波瓣组成的基础， 
扭曲覆盖整个球体）已被用于许多商业上成功的游戏，例如Half-Life 
2 [1193]，Callof职责系列[766,808]，孤岛惊魂3[533]，汤姆克 
兰西的分部[1694]和刺客信条4：黑旗[1911]，仅举几例。11.5.3 
预先计算的转移虽然预先计算的照明看起来令人惊叹，但它本身也 
是静态的。对几何体或光照的任何更改都可能使整个解决方案无效。 
就像在现实世界中一样，打开窗帘（场景中几何形状的局部变化） 
可能会使整个房间充满光线（全局变化的照明）。许多研究工作都 
花在寻找允许某些类型变化的解决方案上。如果我们假设场景的几 
何不会改变，只有光照，我们可以预先计算光与模型的交互方式。 
可以在一定程度上分析诸如互反射或次表面散射之类的物体间效应 
并存储结果，不对实际辐亮度值进行操作。获取入射光并将其转换 
为整个场景中辐射分布的描述的功能称为传递函数。预先计算的解 
决方案称为预计算传输或预计算辐射传输（PRT）方法。与离线完 
全烘焙照明相反，这些技术确实具有明显的运行时成本。在屏幕上 
显示场景时，我们需要计算特定照明设置的辐亮度值。为此，将实 
际的直射光量 “注入”到系统中，然后应用传递函数将其传播到场 
景中。一些方法假设这种直接照明来自环境地图。其他方案允许照 
明设置是任意的并且以灵活的方式改变。11.5。漫反射全局照明479 
图11.25。使用预计算辐射传输进行渲染的示例。来自三个监视器 
----------------------- Page 518-----------------------
中的每一个的完全传输的照明被单独预先计算，从而获得 “单元” 
响应。由于光传输的线性，这些单独的解决方案可以乘以屏幕的颜 
色（在此示例中为粉色，黄色和蓝色）以获得最终照明。Sloan等 
人将预计算辐射传递的概念引入图形。[1651]。他们用球谐函数描 
述它，但该方法不必使用SH。基本思路很简单。如果我们使用一些 
 （最好是低数量）“积木”灯描述直接照明，我们可以预先计算每 
一个场景是如何点亮的。想象一下，里面有三个电脑显示器的房间， 
并假设每个房间只能显示一种颜色，但强度各不相同。将每个屏幕 
的最大亮度视为等于1，标准化的 “单位”亮度。我们可以独立预 
先计算每个监视器对房间的影响。可以使用第 11.2节中介绍的方法 
完成此过程。因为光传输是线性的，所以三个监视器照亮场景的结 
果将等于来自每个监视器的光的直接或间接的总和。来自每个监视 
器的照明不会影响其他解决方案，因此如果我们将其中一个屏幕设 
置为亮度的一半，那么这样做只会改变其对整个照明的贡献。这使 
我们能够快速计算整个房间内完整的反射光。我们采用每个预先计 
算的光解决方案，将其乘以屏幕的实际亮度，并对结果求和。我们 
可以打开和关闭显示器，使它们更亮或更暗，甚至改变颜色，获得 
最终照明所需的一切都是这些倍增和增加 （图11.25）。480 11.全 
局照明我们可以写出 L （p）=XiLi （p）wi， （11.36）其中 L （p） 
是点 p的最终辐射，Li （p）是来自屏幕i的预计算单位贡献，而 
wi是它目前的亮度。该等式定义了数学意义上的向量空间，其中 Li 
是该空间的基础向量。任何可能的照明都可以通过灯光贡献的线性 
----------------------- Page 519-----------------------
组合来创建。Sloan等人的原始 PRT论文。[1651]使用相同的推理， 
但是在使用球谐函数表示的无限远照明环境的背景下。它们不是存 
储场景如何响应监视器屏幕，而是存储它如何响应周围的光，其分 
布由球谐基函数定义。通过对一些SH波段执行此操作，它们可以 
渲染由任意照明环境照亮的场景。他们将这种照明投射到球谐波上， 
将每个得到的系数乘以其各自的归一化 “单位”贡献，并将它们全 
部加在一起，就像我们对监视器一样。注意，用于将光 “注入”场 
景的基础的选择与用于表示最终照明的表示无关。例如，我们可以 
描述如何使用球面谐波照亮场景，但是选择另一个基础来存储在任 
何给定点到达多少辐射。假设我们使用环境立方体进行存储。我们 
将计算从顶部到达多少辐射度以及从侧面到达多少。这些方向中的 
每一个的传输将单独存储，而不是表示总传输的单个标量值。Sloan 
等人的 PRT论文。[1651]分析了两个案例。第一种是接收器基础只 
是表面的标量辐照度值。为此，接收器需要是一个完全漫反射的表 
面，具有预定的法线，这意味着它不能使用法线贴图来获得精细的 
细节。传递函数采用输入光照的SH投影和预先计算的传递矢量之 
间的点积的形式，其在场景中在空间上变化。如果我们需要渲染非 
朗伯材料或允许法线贴图，我们可以使用所呈现的第二个变体。在 
这种情况下，周围照明的SH投影被转换为给定点的入射辐射的SH 
投影。因为这个操作为我们提供了球体（或半球，如果我们处理静 
态不透明物体）的完整辐射分布，我们可以正确地将它与任何 BRDF 
卷积。传递函数将SH矢量映射到其他SH矢量，并且具有矩阵乘法 
----------------------- Page 520-----------------------
的形式。这种乘法运算在计算和存储方面都很昂贵。如果我们对源 
和接收器使用三阶SH，我们需要为场景中的每个点存储9×9矩阵， 
这些数据仅用于单色传输。如果我们想要颜色，我们需要三个这样 
的矩阵 - 每点需要大量的内存。Sloan等人解决了这个问题。[1652] 
一年后。不是直接存储传递矢量或矩阵，而是使用主成分分析（PCA） 
技术分析它们的整个集合。传递系数可以被认为是多维空间中的点 
 （例如，在9×911.5的情况下为81维。漫反射全局照明481矩阵）， 
但是它们的集合不是均匀地分布在该空间中。它们形成具有较低维 
度的簇。这种聚类就像沿着一条线分布的三维点一样，有效地，所 
有这些都在三维空间的一维子空间中。PCA可以有效地检测这种统 
计关系。一旦发现子空间，就可以使用更少数量的坐标来表示点， 
因为我们可以使用减少的维数来存储子空间中的位置。使用线类比， 
我们可以只使用三个坐标存储一个点的完整位置，而不是沿线存储 
它的距离。斯隆等人。使用此方法将传递矩阵的维数从625维 （25 
×25传递矩阵）减少到256维。虽然这对于典型的实时应用来说仍 
然太高，但是许多后来的光传输算法已经将 PCA作为压缩数据的一 
种方式。这种类型的降维本质上是有损的。在极少数情况下，数据 
形成一个完美的子空间，但大多数情况下它是近似的，所以将数据 
投射到它上会导致一些退化。为了提高质量，Sloan等人。将传输 
矩阵集划分为簇并分别对每个传输矩阵执行 PCA。该过程还包括优 
化步骤，确保群集边界上没有不连续性。还提出了允许对象的有限 
变形的扩展，称为局部可变形预计算辐射传递（LDPRT）[1653]。 
----------------------- Page 521-----------------------
PRT已在多个游戏中以各种形式使用。它在游戏中主要关注时间和 
天气条件动态变化的户外区域的游戏中特别受欢迎。 “孤岛惊魂3” 
和 “孤岛惊魂4”使用PRT，其中源基础是二阶SH，接收器基础是 
自定义的四向基础[533,1154]。刺客信条4：黑旗使用一个基础功 
能作为源（太阳色），但是预先计算一天中不同时间的转移。该表 
示可以被解释为具有在时间维度而不是方向上定义的源基函数。接 
收器基础与FarCry标题中使用的基础相同。关于预计算辐射传输 
的 SIGGRAPH 2005课程[870]提供了该领域研究的良好概述。 
Lehtinen[1019,1020]给出了一个数学框架，可用于分析各种算法 
之间的差异并开发新的算法。原始的 PRT方法假设周围的照明无限 
远。虽然这样可以很好地模拟室外场景的照明，但它对室内环境的 
限制性太强。然而，正如我们前面提到的，这个概念与照明的初始 
来源完全无关。克里斯滕森等人。[941]描述了一种方法，其中针对 
散布在整个场景中的一组光计算 PRT。这对应于具有大量 “源”基 
函数。接下来将灯组合成簇，并将接收几何体分割成区域，每个区 
域受不同光源子集的影响。该过程导致传输数据的显着压缩。在运 
行时，通过插入预先计算的组中最近的灯的数据来近似由任意放置 
的灯产生的照明。Gilabert和Stefanov[533]使用该方法在 FarCry 
3游戏中生成间接照明。这种方法的基本形式只能处理点光源。而 
482 11.全局照明图 11.26。Geomerics的Enlighten可以实时生成 
全局照明效果。该图显示了它与 Unity引擎集成的示例。用户可以 
自由地改变一天中的时间以及打开和关闭灯。所有间接照明都相应 
----------------------- Page 522-----------------------
地实时更新。 （庭院演示cUnityTechnologies，2015。）它可以 
扩展到支持其他类型，成本随着每个灯的自由度数呈指数增长。到 
目前为止讨论的PRT技术预先计算了来自一些元素的传递，然后用 
于模拟光。另一种流行的方法预先计算表面之间的转移。在这种类 
型的系统中，实际的照明源变得无关紧要。可以使用任何光源，因 
为这些方法的输入是来自某些曲面组的传出辐射（或一些其他相关 
数量，如辐照度，如果该方法假设仅弥散表面）。这些直接照明计 
算可以使用阴影 （第7章），辐照度环境图 （第 10.6节），或本章 
前面讨论的环境和定向遮挡方法。通过将其出射辐射度设置为期望 
值，将其转变为区域光源，也可以使任何表面平滑地发光。根据这 
些原则工作的最流行的系统是Geomerics的Enlighten（图11.26）。 
虽然该算法的确切细节从未完全公开，但许多演讲和演示都能准确 
描述该系统的原理[315,1101,1131,1435]。该场景被假定为朗伯 
 （Lambertian），但仅用于光传输。使用 Heckbert的符号，处理 
的路径集是LD。（D|S）E，因为眼睛之前的最后一个表面不需要 
仅扩散。系统定义了一组 “源”元素和另一组 “接收器”元素。源 
元素存在于曲面上，并共享它们的一些属性，例如漫反射颜色和法 
线。11.5。漫反射全局照明483预处理步骤计算光源如何在源元件 
和接收器之间传输。这些信息的确切形式取决于源元素是什么以及 
用于在接收器处收集照明的基础。在最简单的形式中，源元素可以 
是点，然后我们有兴趣在接收位置产生辐照度。在这种情况下，传 
递系数只是源和接收器之间的相互可见性。在运行时，所有源元素 
----------------------- Page 523-----------------------
的传出辐射都提供给系统。根据这些信息，我们可以使用预先计算 
的可见性和有关源和接收器位置和方向的已知信息，数值积分反射 
方程 （公式 11.1）。以这种方式，执行单次反射光。由于大部分间 
接照明来自第一次反弹，单独执行一次反弹就足以提供合理的照明。 
但是，我们可以使用此灯并再次运行传播步骤以产生第二次反射光。 
这通常在几帧的过程中完成，其中一帧的输出用作下一帧的输入。 
使用点作为源元素将导致大量连接。为了提高性能，表示相似法线 
和颜色的区域的点簇也可以用作源集。在这种情况下，传递系数与 
光能传递算法中的形状因子相同 （第 11.2.1节）。注意，尽管相似， 
但算法与经典光能传递不同，因为它一次只计算一次反射光并且不 
涉及求解线性方程组。它借鉴了渐进式光能传递的概念[275,1642]。 
在该系统中，单个补丁可以在迭代过程中确定从其他补丁接收多少 
能量。将辐射传递到接收位置的过程称为收集。接收元件的辐射可 
以以不同的形式收集。转移到接收元件可以使用我们之前描述的任 
何方向基。在这种情况下，单个系数成为值的向量，维度等于接收 
基础中的函数数量。使用方向表示执行收集时，结果与第 11.5.2节 
中描述的离线解决方案相同，因此可以与法线贴图一起使用或提供 
低光泽镜面响应。在许多变体中使用相同的一般想法。为了节省内 
存，Sugden和 Iwanicki[1721]使用SH传递系数，量化它们，并 
间接地将它们存储为调色板中条目的索引。Jendersie等。[820]构 
建源补丁的层次结构，并且当子对象的立体角太小时，存储对该树 
中的较高元素的引用。Stefanov[1694]介绍了一个中间步骤，其中 
----------------------- Page 524-----------------------
来自表面元素的辐射首先传播到场景的体素化表示，后者充当传输 
源。（在某种意义上）表面到源补丁的理想分离取决于接收器的位 
置。对于远程元素，将它们视为单独的实体会产生不必要的存储成 
本，但在近距离查看时应单独处理它们。源补丁的层次结构在某种 
程度上缓解了这个问题，但并没有完全解决它。可以组合用于特定 
的某些补丁484 11.全局照明控制器可以相隔足够远以防止这种合 
并。Silvennoinen和 Lehtinen[1644]提出了一种解决该问题的新 
方法。他们的方法没有明确地创建源补丁，而是为每个接收位置生 
成不同的一组。对象将渲染到散布在场景周围的稀疏环境贴图集。 
每张地图都投射到球面谐波，这个低频版本 “虚拟”投射回环境。 
接收点记录了他们可以看到多少这个预测，并且这个过程分别为每 
个发送者的SH基函数完成。这样做会根据来自环境探测器和接收 
器点的可见性信息为每个接收器创建一组不同的源元素。因为源基 
础是从投射到SH的环境贴图生成的，所以它自然地组合了更远的 
表面。要选择要使用的探测器，接收器使用有利于附近探测器的启 
发式，这使接收器以类似的规模 “看到”环境。要限制必须存储的 
数据量，传输信息将使用群集 PCA进行压缩。Lehtinen等人描述 
了另一种形式的预计算转移。[1021]。在这种方法中，源和接收元 
素都不存在于网格上，而是体积的并且可以在三维空间中的任何位 
置查询。这种形式便于提供静态和动态几何之间的照明一致性，但 
该方法在计算上相当昂贵。Loos等。[1073]在模块化单元电池内的 
预计算转移，具有不同的侧壁配置。然后缝合多个这样的单元并弯 
----------------------- Page 525-----------------------
曲以近似场景的几何形状。辐射首先传播到细胞边界，它们充当接 
口，然后使用预先计算的模型充当相邻的单元。该方法足够快，即 
使在移动平台上也能有效运行，但由此产生的质量可能不足以满足 
更苛刻的应用需求。11.5.4存储方法无论我们是想使用完整的预计 
算照明还是预先计算传输信息并允许光照发生一些变化，结果数据 
都必须以某种形式存储。GPU友好的格式是必须的。光照贴图是存 
储预计算照明的最常用方式之一。这些是存储预先计算信息的纹理。 
虽然有时诸如辐照度图之类的术语用于表示存储的特定类型的数 
据，但术语光图用于共同描述所有这些。在运行时，使用GPU的内 
置纹理机制。值通常是双线性过滤的，对于某些表示可能不完全正 
确。例如，当使用AHD表示时，经过滤波的 D （方向）分量将不 
再是插值后的单位长度，因此需要重新归一化。使用插值也意味着 
A （环境）和H （高亮）不完全是我们在采样点直接计算它们时的 
情况。也就是说，即使表示是非线性的，结果通常也是可以接受的。 
11.5。漫反射全局照明485图11.27。灯光烘焙到场景中，以及应 
用于曲面的光照贴图。光照贴图使用独特的参数化。场景分为扁平 
元素和打包成常见纹理的元素。例如，左下方的部分对应地平面， 
显示立方体的两个阴影。 （来自three.js示例webgl材质光照贴图 
[218]。）在大多数情况下，光照贴图不使用mipmapping，这通 
常是不需要的，因为与典型的反照率地图或法线贴图相比，光贴图 
的分辨率较小。即使在高质量的应用中，单个光照贴图也会覆盖至 
少大约20×20厘米的区域，通常更多。使用这种尺寸的纹素，几乎 
----------------------- Page 526-----------------------
不需要额外的mip级别。要在纹理中存储光照，对象需要提供唯一 
的参数化。将漫反射颜色纹理映射到模型时，网格的不同部分通常 
可以使用纹理的相同区域，特别是如果模型使用常规重复图案进行 
纹理处理。重复使用光照图很难。光照对于网格上的每个点都是唯 
一的，因此每个三角形都需要在光照贴图上占据自己独特的区域。 
创建参数化的过程首先将网格划分为较小的块。这可以使用一些启 
发法[1036]自动完成，或者在创作工具中手动完成。通常，使用已 
经存在用于映射其他纹理的分割。接下来，每个块被独立地参数化， 
确保其部分在纹理空间中不重叠[1057,1617]。纹理空间中的结果元 
素称为图表或壳。最后，所有图表都打包成一个共同的纹理（图 
11.27）。必须注意确保图表不仅不重叠，而且它们的过滤尺寸必须 
保持分开。渲染给定图表时可以访问的所有纹素（双线性过滤访问 
四个相邻纹素）应标记为已使用，因此其他图表不会重叠。否则， 
可能会出现图表之间的流血，并且其中一个的照明可能在另一个上 
可见。尽管光映射系统为光照图表之间的间隔提供用户控制的 “装 
订线”量是相当普遍的，但这种分离不是必需的。图表486的正确 
过滤足迹 11.全局照明图 11.28。要准确确定图表的过滤足迹，我们 
需要找到在渲染过程中可以访问的所有纹素。如果图表与跨越四个 
相邻纹素的中心之间的正方形相交，则所有这些都将在双线性过滤 
期间使用。纹素网格用实线标记，纹理中心用蓝点标记，图表用粗 
实线标记（左）。我们首先保守地将图表栅格化为移动了纹理像素 
大小一半的网格，标记为虚线（中心）。触摸标记单元格的任何纹 
----------------------- Page 527-----------------------
理元素都被视为已占用（右侧）。可以通过使用一组特殊规则在光 
照贴图空间中对其进行栅格化来自动确定。见图 11.28。如果以这 
种方式栅格化的贝壳不重叠，我们保证不会发生流血。避免出血是 
为什么mipmapping很少用于光照贴图的另一个原因。图表过滤足 
迹需要在所有 mip级别上保持分离，这将导致shell之间的间距过 
大。将图表最佳地打包到纹理中是一个 NP完全问题，这意味着没 
有已知的算法可以生成具有多项式复杂度的理想解。由于实时应用 
程序可能在单个纹理中包含数十万个图表，因此所有实际解决方案 
都使用经过微调的启发式算法和精心优化的代码来快速生成打包 
[183,233,1036]。如果光照贴​ ​ 图稍后进行了块压缩 （见第6.2.6 
节），为了提高压缩质量，可能会在封隔器中添加其他约束，以确 
保单个块仅包含相似的值。光照贴图的一个常见问题是接缝（图 
11.29）。因为网格被分割成图表并且每个网格都是独立参数化的， 
所以不可能确保沿着分割边缘的光照在两侧完全相同。这表现为视 
觉上的不连续性。如果手动拆分网格，可以通过在不直接可见的区 
域中拆分网格来避免这个问题。但是，这样做是一个费力的过程， 
并且在自动生成参数化时无法应用。Iwanicki[806]在最终光照贴图 
上执行后处理，该处理沿着分割边缘修改纹理像素以最小化两侧的 
插值值之间的差异。刘和弗格森等人。[1058]通过等式约束强制沿 
边缘匹配的内插值，并求解最佳保持平滑度的纹素值。另一种方法 
是在创建参数化和打包图表时考虑此约束。雷等人。[1467]示出了 
如何使用网格保留参数化来创建不受缝线伪影影响的光照贴图。 
----------------------- Page 528-----------------------
11.5。漫反射全局照明487图11.29。要为圆环创建唯一的参数化， 
需要将其切割和展开。左侧的圆环使用简单的映射，在不考虑切割 
如何定位在纹理空间中的情况下创建。请注意左侧表示纹素的网格 
的不连续性。使用更高级的算法，我们可以创建一个参数化，确保 
纹素网格线在三维网格上保持连续，如右图所示。这种展开方法对 
于光映射是完美的，因为所得到的照明不会出现任何不连续性。预 
计算照明也可以存储在网格的顶点。缺点是照明质量取决于网格细 
分的精细程度。因为这个决定通常是在创作的早期阶段做出的，很 
难确保网格上有足够的顶点，以便在所有预期的光照条件下都能看 
起来很好。此外，曲面细分可能很昂贵。如果网格被精细细分，则 
照明信号将被过采样。如果使用存储照明的定向方法，则整个表示 
需要由GPU在顶点之间插值并传递到像素着色器阶段以执行照明 
计算。在顶点和像素着色器之间传递如此多的参数是相当不常见的， 
并且会生成未针对现代GPU进行优化的工作负载，这会导致效率低 
下和性能降低。由于所有这些原因，很少使用在顶点上存储预先计 
算的照明。即使表面上需要有关入射辐射的信息（除了进行体积渲 
染时，在第14章讨论，我们可以预先计算和存储它。这样，可以在 
空间中的任意点处查询照明，从而在预计算阶段期间为场景中不存 
在的对象提供照明。但请注意，这些对象无法正确反射或遮挡光照。 
格雷格等人。[594]呈现辐照体积，其表示具有辐照环境图的稀疏空 
间采样的五维（三个空间和两个方向）辐照度函数。也就是说，在 
空间中存在三维网格，并且在每个网格点处是辐照度环境地图。动 
----------------------- Page 529-----------------------
态对象从最近的地图插入辐照度值。格雷格等人。使用两级自适应 
网格进行空间采样，但其他体数据结构，如八叉树[1304,1305]，可 
以使用。在最初的辐照量中，Greger等人。存储在小纹理中的每个 
采样点处的辐照度，但是该表示不能在GPU上有效地过滤。今天， 
体积照明数据通常存储在三维488 11.全局照明纹理中，因此采样 
体积可以使用GPU的加速过滤。样本点辐照度函数的最常见表示包 
括：。二阶和三阶的球谐波 （SH），前者更常见，因为单个颜色通 
道所需的四个系数可方便地打包成四个典型纹理格式的通道。。球 
面高斯。。环境立方体或环境骰子。即使在技术上能够表示球面辐 
照度，AHD编码也会产生令人分心的伪影。如果使用SH，球谐波 
梯度[54]可以进一步提高质量。所有上述表示已成功用于许多游戏 
[766,808,1193,1268,1643]。Evans [444]描述了 LittleBigPlanet 
中用于辐照度的技巧。代替完整的辐照度图表示，在每个点存储平 
均辐照度。根据辐照度场的梯度，即场变化最快的方向计算近似方 
向性因子。不是明确地计算梯度，而是通过取两个辐照度场样本来 
计算梯度和表面法线n之间的点积，一个在表面点p处，另一个在 
n方向上略微位移的点处，并且减去一个来自另一个。这种近似表 
示的动机是LittleBigPlanet中的辐照度量是动态计算的。辐照度也 
可用于为静态表面提供照明。这样做的优点是不必为光照贴图提供 
单独的参数化。该技术也不会产生接缝。静态和动态对象都可以使 
用相同的表示，使两种几何类型之间的光照保持一致。体积表示便 
于在延迟着色 （第20.1节）中使用，其中所有照明都可以在一次通 
----------------------- Page 530-----------------------
过中执行。主要缺点是内存消耗。光照使用的内存量随着分辨率的 
平方而增长;对于规则的体积结构，它随着立方体而增长。为此原因， 
相当低的分辨率用于网格体积表示。自适应的分层形式的照明体积 
具有更好的特性，但它们仍然存储比光照更多的数据。它们也比具 
有常规间距的网格慢，因为额外的间接在着色器代码中创建了负载 
依赖性，这可能导致停顿和执行速度变慢。在体积结构中存储表面 
照明有点棘手。多个表面，有时具有截然不同的照明特性，可以占 
据相同的体素，使得不清楚应该存储什么数据。当从这样的体素采 
样时，照明经常是不正确的。这种情况经常发生在明亮的室外和室 
内黑暗之间的墙壁附近，并导致外面的暗斑或内部的明亮斑块。对 
此的补救措施是使体素尺寸足够小以至于不会跨越这样的边界，但 
这通常是不切实际的，因为 11.5。漫反射全局照明489图11.30。 
Unity引擎使用四面体网格来插入来自一组探针的光照。（死亡之 
书cUnityTechnologies，2018。）所需的数据量。处理问题的最 
常见方法是将采样位置沿法线移动一定量，或者调整插值期间使用 
的三线性混合权重。这通常是不完美的，可能需要对几何体进行手 
动调整以掩盖问题。Hooker[766]为辐照度体积增加了额外的剪裁 
平面，这限制了它们对凸多面体内部的影响。Kontkanen和 Laine 
[926]讨论了各种减少出血的策略。保持照明的体积结构不必是规则 
的。一种流行的选择是将其存储在不规则的点云中，然后将其连接 
起来形成Delaunay四面体化 图（11.30）。这种方法由Cupisz[316] 
推广。为了查看照明，我们首先找到采样位置所在的四面体。这是 
----------------------- Page 531-----------------------
一个迭代过程，可能有些昂贵。我们遍历网格，在相邻的单元格之 
间移动。查找点相对于当前四面体角的重心坐标用于选择下一步要 
访问的邻居（图 11.31）。因为典型的场景可以包含存储照明的数 
千个位置，所以该过程可能是耗时的。要加速它，我们可以在前一 
帧中记录用于查找的四面体（如果可能），或者使用简单的体积数 
据结构，为场景中的任意点提供良好的 “起始四面体”。一旦找到 
了正确的四面体，使用已经可用的重心坐标对存储在其角上的光照 
进行插值。GPU不会加速此操作，但它只需要四个插值值，而不是 
网格上三线性插值所需的八个值。490 11.全局照明图 11.31。以二 
维图示的四面体网格中的查找过程。步骤从左到右，从上到下显示。 
给定一些起始单元格（标记为蓝色），我们评估查找点（蓝点）相 
对于单元格角的重心坐标。在下一步中，我们朝着邻居移动，越过 
与负角坐标相对的角落边缘。照明得到预先计算和存储的位置可以 
手动放置[134,316]或自动放置[809,1812]。它们通常被称为照明探 
针或光探针，因为它们探测 （或采样）照明信号。该术语不应与 “光 
探测器” （第 10.4.2节）混淆，后者是环境地图中记录的远距离照 
明。从四面体网格采样的照明质量高度依赖于网格的结构，而不仅 
仅是探针的整体密度。如果它们分布不均匀，则生成的网格可能包 
含细长的四面体，会产生视觉伪影。如果用手放置探针，问题很容 
易纠正，但它仍然是一个手动过程。四面体的结构与场景几何结构 
无关，因此如果处理不当，照明将在墙壁上插入并产生出血伪像， 
就像辐照度一样。在手动探针放置的情况下，可以要求用户插入其 
----------------------- Page 532-----------------------
他探针以防止这种情况发生。当使用探针的自动放置时，可以将某 
种形式的可见性信息添加到探针或四面体中，以将它们的影响限制 
到仅相关区域[809,1184,1812]。对于静态和动态几何使用不同的照 
明存储方法是常见的做法。例如，静态网格物体可以使用光照贴图， 
而动态物体可以从体积结构中获取光照信息。虽然很受欢迎此方案 
可能会在不同类型的几何体的外观之间产生不一致。通过正则化可 
以消除这些差异中的一些，其中照明信息在表示中被平均。11.5。 
漫反射全局照明491烘烤照明时，需要注意仅在它们真正有效的情 
况下计算其值。网格通常是不完美的。一些顶点可以放置在几何体 
内，或者网格的一些部分可以自相交。如果我们计算这些有缺陷的 
位置的入射辐射，结果将是不正确的。它们会导致不必要的变暗或 
不正确的照明出血。Kontkanen和 Laine [926]以及 Iwanicki和 
Sloan[809]讨论了可用于丢弃无效样本的不同启发式方法。环境和 
方向遮挡信号共享漫射照明的许多空间特征。如第 11.3.4节所述， 
所有上述方法也可用于存储它们。11.5.5动态漫反射全局照明尽管 
预先计算的照明可以产生令人印象深刻的结果，但它的主要优势也 
是它的主要弱点 - 它需要预先计算。这种离线过程可能很漫长。对 
于典型的游戏关卡来说，点燃烘焙花费很多时间并不罕见。由于照 
明计算需要很长时间，艺术家通常被迫同时在多个级别上工作，以 
避免在等待烘焙完成时停机。反过来，这通常会导致用于渲染的资 
源过度负载，并导致烘焙时间更长。这种循环会严重影响生产力并 
导致挫败感。在某些情况下，甚至无法预先计算照明，因为几何体 
----------------------- Page 533-----------------------
在运行时更改或由用户在某种程度上创建。已经开发了几种方法来 
模拟动态环境中的全局照明。要么它们不需要任何预处理，要么准 
备阶段足够快以便每帧执行。在全动态环境中模拟全局照明的最早 
方法之一是基于 “即时光能传递”[879]。尽管名称如此，该方法与 
光能传递算法几乎没有共同之处。在其中，光线从光源向外投射。 
对于光线照射的每个位置，放置光，表示来自该表面元素的间接照 
射。这些源称为虚拟点光源 （VPL）。根据这一想法，Tabellion和 
Lamorlette[1734]开发了一种在制作史瑞克2期间使用的方法，该 
方法执行场景表面的直接光照通过并将结果存储在纹理中。然后， 
在渲染过程中，该方法会跟踪光线并使用缓存的光照来创建单反射 
间接照明。Tabellion和 Lamorlette表明，在许多情况下，单次反 
弹足以创造可信的结果。这是一种离线方法，但它启发了 
Dachsbacher和 Stamminger [321]的方法，称为反射阴影贴图 
 （RSM）。与常规阴影贴图（第7.4节）类似，从光的角度渲染反 
射阴影贴图。除了深度之外，它们还存储有关可见表面的其他信息， 
例如它们的反照率，正常，和直接照明（通量）。在执行最终着色 
时，RSM的纹素被视为点光源，以提供单次反射的间接照明。因为 
典型的 RSM包含数十万个像素，所以使用重要性驱动的492仅选 
择其中的一部分。全局照明图 11.32。Uncharted4游戏使用反射 
阴影贴图来提供玩家手电筒的间接照明。左侧的图像显示没有间接 
贡献的场景。右侧的图像已启用。插图显示了在没有 （顶部）和 （底 
部）时间过滤的情况下渲染的帧的特写。它用于增加用于每个图像 
----------------------- Page 534-----------------------
像素的VPL的有效数量。（UNCHARTED4AThief's Endc/ TM 
2016 SIE。由 Naughty Dog LLC创建和开发。） 启发式。 
Dachsbacher和Stamminger [322]后来展示了如何通过逆转过程 
来优化方法。不是从每个阴影点的 RSM中选择相关的纹素，而是根 
据整个 RSM创建一些数量的灯并在屏幕空间中绘制 （第 13.9节）。 
该方法的主要缺点是它不为间接照明提供遮挡。虽然这是一个重要 
的近似值，但结果看似合理，并且对于许多应用来说是可接受的。 
为了在光线移动期间获得高质量的结果并保持时间稳定性，需要产 
生大量的间接光。如果创建的太少，它们会在RSM重新生成时迅速 
改变其位置，并导致闪烁伪影。另一方面，从性能的角度来看，有 
太多间接灯是很有挑战性的。Xu [1938]描述了如何在游戏 
Uncharted4中实现该方法。为了保持在性能限制范围内，他每个 
像素使用少量（16）个灯光，但是在几个帧中循环通过它们的不同 
组合并过滤结果暂时的（图 11.32）。已经提出了不同的方法来解 
决间接遮挡的缺乏。Laine等人。[962]对于间接光使用双抛物面阴 
影贴图，但是以增量方式将它们添加到场景中，因此在任何单个帧 
中仅渲染少量阴影贴图。Ritschel等。[1498]使用场景的简化的基 
于点的表示来渲染大量不完美的阴影图。这些地图很小，直接使用 
时包含许多缺陷，但经过简单的过滤后，可提供足够的保真度，为 
间接照明提供适当的遮挡效果。11.5。漫反射全局照明493有些游 
戏使用了与这些解决方案相关的方法。灰尘514呈现世界的自上而 
下的视图，在需要时具有多达四个独立的层[1110]。这些结果纹理 
----------------------- Page 535-----------------------
用于执行间接照明的采集，就像Tabellion和 Lamorlette的方法一 
样。类似的方法用于在风筝演示中提供来自地形的间接照明，展示 
虚幻引擎[60]。11.5.6光传播体积辐射传递理论是对电磁辐射如何 
通过介质传播进行建模的一般方法。它解释了散射，发射和吸收。 
尽管实时图形努力显示所有这些效果，但除了最简单的情况之外， 
用于这些模拟的方法的数量级太大，无法直接应用于渲染。然而， 
该领域中使用的一些技术已经证明在实时图形中是有用的。由 
Kaplanyan[854]引入的光传播体积 （LPV）从辐射传递中的离散纵 
坐标方法中汲取灵感。在他的方法中，场景被离散化为三维单元的 
规则网格。每个细胞将保持流过它的辐射的方向分布。他对这些数 
据使用二阶球谐函数。在第一步中，将光照注入包含直接照亮表面 
的单元。访问反射阴影贴图以找到这些细胞，但也可以使用任何其 
他方法。注入的照明是从被照亮的表面反射的辐射。因此，它形成 
围绕法线的分布，背离表面，并从材料的颜色中获得其颜色。接下 
来，传播照明。每个单元分析其邻居的辐射场。然后它修改自己的 
分布以考虑从所有方向到达的辐射。在一个步骤中，辐射在仅一个 
单元的距离上传播。需要多次迭代才能进一步分发它 （图11.33）。 
该方法的重要优点是它为每个单元生成完整的辐射场。这意味着我 
们可以使用任意 BRDF进行着色，甚至如图 11.33所示。通过体积 
网格传播光分布的三个步骤。左图显示了由定向光源照射的几何反 
射的光的分布。请注意，只有与几何图形直接相邻的单元格才具有 
非零分布。在随后的步骤中，来自相邻小区的光被收集并通过网格 
----------------------- Page 536-----------------------
传播。494 11.全局照明虽然使用二阶球谐波时光泽 BRDF的反射质 
量相当低。Kaplanyan展示了漫反射和反射表面的例子。为了允许 
光在更远的距离上传播，以及增加体积覆盖的面积，同时保持内存 
使用合理，Kaplanyan和 Dachsbacher[855]开发了该方法的级联 
变体。而不是使用具有统一大小的单元的单个体积，他们使用一组 
具有逐渐变大的细胞，彼此嵌套。照明被注入所有级别并独立传播。 
在查找期间，他们选择可用于给定位置的最详细级别。最初的实施 
没有考虑间接照明的任何遮挡。修改后的方法使用来自反射阴影贴 
图的深度信息以及来自摄像机位置的深度缓冲区，以将关于光阻挡 
剂的信息添加到卷中。此信息不完整，但场景也可以在预处理期间 
进行体素化，因此使用更精确的表示。该方法存在其他体积方法的 
问题，其中最大的方法是出血。不幸的是，增加网格分辨率来修复 
它会导致其他问题。当使用较小的单元尺寸时，需要更多的迭代来 
在相同的世界 - 空间距离上传播光，使得该方法成本更高。在网格 
分辨率和性能之间找到平衡并非易事。该方法还存在混叠问题。网 
格的有限分辨率与辐射的粗略方向表示相结合，导致信号在相邻单 
元之间移动时的劣化。多次迭代后，解决方案中可能会出现空间伪 
影，例如对角线条纹。通过在传播通过之后执行空间滤波，可以消 
除这些问题中的一些。11.5.7基于体素的方法由Crassin[304]引入， 
体素锥跟踪全局照明 （VXGI）也基于体素化场景表示。几何体本身 
以稀疏体素八叉树的形式存储，如第13.10节所述。关键概念是该 
结构提供了类似于mipmap的场景表示，例如，可以快速测试一定 
----------------------- Page 537-----------------------
量的空间以进行遮挡。体素还包含有关从它们所代表的几何体反射 
的光量的信息。它以方向形式存储，因为辐射在六个主要方向上反 
射。使用反射阴影贴图，直接光照首先注入八度树的最低层。然后 
它在层次结构中向上传播。八叉树用于估计入射辐射。理想情况下， 
我们会追踪光线以估计来自特定方向的辐射。但是，这样做需要很 
多光线，因此，它们的整个束被近似于在其平均方向上跟踪的锥体， 
仅返回单个值。准确地测试锥体与八叉树的交叉点并非易事，因此 
该操作通过沿锥体轴的树的一系列查找来近似。每次查找都会读取 
11.5。漫反射全局照明495图11.34。体素锥跟踪通过一系列经过 
滤波的查找来近似精确的锥形轨迹到体素树中。左侧显示了三维迹 
线的二维模拟。体素化几何的分层表示显示在右侧，每列显示树的 
级别越来越粗糙。每行显示用于为给定样本提供覆盖的层次结构的 
节点。选择使用的级别，以便较粗级别中的​ ​ 节点大小大于查找 
大小，并且更精细级别更小。类似于三线性滤波的过程用于在这两 
个选定的级别之间进行内插。树的水平，其节点大小对应于给定点 
处的圆锥的横截面。查找提供在锥体原点方向上反射的滤波辐射度， 
以及几何体占据的查找覆盖区的百分比。该信息用于以类似于α混合 
的方式衰减后续点的光照。跟踪整个锥体的闭塞。在每个步骤中， 
它被减少以考虑几何体占据的当前样本的百分比。积累光辉时，它 
首先乘以组合的遮挡因子（图 11.34）。该策略无法检测到多个部 
分结果导致的完全遮挡，但结果仍然可信。为了计算漫射光，可以 
跟踪许多锥体。生成和投射的数量是性能和精度之间的折衷。追踪 
----------------------- Page 538-----------------------
更多的锥体可以提供更高质量的结果，但代价是花费更多的时间。 
假设余弦项在整个锥上是恒定的，因此该项可以从反射方程积分中 
计算出来。这样做使得漫反射光的计算与计算锥形轨迹返回的值的 
加权和一样简单。该方法在虚幻引擎的原型版本中实现，如 Mittring 
[1229]所述。他给出了一些优化，开发人员需要将其作为完整渲染 
管道的一部分运行。这些改进包括以较低分辨率执行迹线并在空间 
上分布锥体。完成该过程使得每个像素仅跟踪单个锥体。通过在屏 
幕空间中过滤结果来获得漫反应的完整辐亮度。496 11.全局照明使 
用稀疏八叉树存储照明的一个主要问题是查找成本高。查找包含给 
定位置的叶节点对应于一系列内存查找，与确定要遍历哪个子树的 
简单逻辑交织。典型的存储器读取可以采用几百个周期的量级。GPU 
试图通过并行执行多组着色器线程（warp或wavefronts）来隐藏 
此延迟 （第3章）。即使只有一个组在任何给定时间执行ALU操作， 
当它需要等待内存读取时，另一个组取代它。可以同时处于活动状 
态的warp数量由不同的因素决定，但所有这些因素都与单个组使 
用的资源数量相关 （第23.3节）。遍历分层数据结构时，大部分时 
间都花在等待从内存中提取下一个节点上。但是，在此等待期间将 
执行的其他warp很可能也会执行内存读取。由于与内存访问次数 
相比，ALU工作量很少，并且由于飞行中的经线总数有限，所有组 
都在等待内存并且没有执行实际工作的情况很常见。具有大量停滞 
的扭曲会产生次优的性能，并且已经开发出试图减轻这些低效率的 
方法。McLaren[1190]用一组级联的三维纹理取代八叉树，非常类 
----------------------- Page 539-----------------------
似于级联光传播体积[855] （第 11.5.6节）。它们具有相同的尺寸， 
但覆盖的区域越来越大。通过这种方式，仅使用常规纹理查找即可 
完成数据读取 - 无需依赖读取。存储在纹理中的数据与稀疏体素八 
叉树中的数据相同。它们包含六个方向的反照率，占用率和反射光 
照信息。因为级联的位置随着相机的移动而变化，物体不断进出高 
分辨率区域。由于内存限制，不可能始终保持这些体素化版本驻留， 
因此在需要时可根据需要对它们进行体素化。迈凯轮还描述了一些 
优化技术，使这项技术可以用于30 FPS的游戏 “明日儿童” （图 
11.35）。11.5.8屏幕空间方法就像屏幕空间环境光遮挡 （第 11.3.6 
节）一样，可以仅使用存储在屏幕位置的表面值来模拟一些漫反射 
全局照明效果[1499]。这些方法不像SSAO那样流行，主要是因为 
可用数据量有限而产生的伪影更加明显。诸如颜色渗色之类的效果 
是强烈的直接光照射大面积相当恒定颜色的结果。像这样的表面通 
常不可能完全适合视图。这种情况使得反射光的强烈程度取决于当 
前的取景，并随着相机的移动而波动。出于这个原因，屏幕空间方 
法仅用于以精细尺度增加一些其他解决方案，超出主算法可实现的 
分辨率。这种类型的系统用于游戏Quantum Break[1643]。辐照 
度用于模拟大规模全局照明效果，屏幕空间解决方案为有限距离提 
供反射光。11.6。镜面全局照明497图11.35。游戏TheTomorrow 
Children使用体素锥体追踪来渲染间接照明效果。（c2016Sony 
InteractiveEntertainmentInc.TheTomorrowChildren是Sony 
InteractiveEntertainmentAmerica LLC的商标。）11.5.9其他方 
----------------------- Page 540-----------------------
法 Bunnell计算环境遮挡的方法[210] （第11.3.5节）也允许动态 
计算全局照明效果。通过存储关于每个磁盘的反射辐射的信息来增 
强场景的基于点的表示 （第 11.3.5节）。在收集步骤中，不是仅收 
集遮挡，而是可以在每个聚集位置构建完整的入射辐射功能。与环 
境遮挡一样，必须执行后续步骤以消除来自遮挡磁盘的光照。11.6 
镜面全局照明前面部分介绍的方法主要用于模拟漫反射全局照明。 
我们现在将看看可用于渲染视图相关效果的各种方法。对于光面材 
料，镜面波瓣比用于漫射照明的余弦波瓣更紧密。如果我们想要显 
示一种非常光亮的材料，一种具有薄镜面光斑的材料，我们需要能 
够提供如此高频细节的光度表示。或者，这些条件还意味着反射率 
方程的评估仅需要从有限立体角入射的光照，这与反映来自整个半 
球的照明的朗伯 BRDF不同。这与漫射材料强加的要求完全不同。 
这些全局照明特征解释了为什么需要进行不同的权衡以实时提供这 
样的效果。存储事件辐射的方法可用于提供粗略的视图相关效果。 
当使用AHD编码或 HL2基础时，我们可以计算镜面响应，好像光 
照来自于从编码方向到达的定向光 （或者在HL2基础的情况下是三 
个方向）。这种方法确实提供了间接照明的一些镜面高光，但它们 
相当不精确。使用这种想法对于AHD编码尤其成问题，其中方向 
分量可以在小距离上剧烈变化。方差导致镜面高光以不自然的方式 
变形。通过在空间上过滤方向可以减少伪影[806]。如果相切空间在 
相邻三角形之间快速变化，则在使用 HL2基础时可以观察到类似的 
问题。通过以更高的精度表示入射光照也可以减少伪像。Neubelt 
----------------------- Page 541-----------------------
和 Pettineo在游戏The Order：1886[1268]中使用球形高斯波瓣 
来表示事件辐射。为了呈现镜面效果，他们使用Xu等人的方法。 
[1940]，他开发了一种有效近似于典型微平面 BRDF的镜面响应（第 
9.8节）。如果用一组球面高斯表示光照，并且假设菲涅耳项和掩蔽 
阴影函数在它们的支撑上是恒定的，那么反射方程可以用Lo （v）≈ 
Xk来近似。M （lk，v）（n·lk）+Zl∈D （l，v）Lk （l）dl？，（11.37） 
其中 Lk是表示入射辐射的第 k个球面高斯，M是组合菲涅耳和掩 
蔽阴影函数的因子，D是 NDF。徐等人。引入各向异性球面高斯 
 （ASG），它们用于模拟NDF。它们还为计算SG和ASG乘积的 
积分提供了有效的近似，如公式 11.37所示。Neubelt和 Pettineo 
使用9到 12个高斯波瓣来表示照明，这使得他们只能模拟中等光 
泽的材料。他们能够使用这种方法代表大部分游戏照明，因为游戏 
发生在 19世纪的伦敦，高度抛光的材料，玻璃和反射表面很少见。 
11.6.1本地化环境地图到目前为止讨论的方法不足以令人信服地渲 
染抛光材料。对于这些技术，辐射场太粗糙，无法精确编码入射辐 
射的精细细节，这使得反射看起来很暗淡。产生的结果也与分析灯 
的镜面高光不一致，如果在同一材料上使用。一种解决方案是使用 
更多球形高斯或更高阶SH来获得我们需要的细节。这是可能的， 
但我们很快就面临性能问题：SH和SG都有全球支持。每个基函数 
在整个球体上都是非零的，这意味着我们需要所有基函数来评估 
11.6中的光照。镜面全局照明499图11.36。设置了本地化反射探 
针的简单场景。反射球体代表探针位置。黄线描绘了盒形反射代理。 
----------------------- Page 542-----------------------
注意代理如何接近场景的整体形状。给定方向。这样做会变得非常 
昂贵，基本功能少于渲染锐利反射所需的基本功能，因为我们需要 
数千个。在通常用于漫射照明的分辨率下存储那么多数据也是不可 
能的。在实时设置中为全局照明提供镜面反射分量的最流行的解决 
方案是本地化环境地图。他们解决了我们之前的两个问题。传入的 
辐亮度表示为环境图，因此只需要少量的值来评估辐射度。它们也 
稀疏地分布在整个场景中，因此交易辐射的空间精度被交换以增加 
角分辨率。在场景中的特定点处渲染的此类环境贴图通常称为反射 
探针。有关示例，请参见图 11.36。环境贴图非常适合渲染完美的 
反射，这是镜面间接照明。已经开发了许多方法，使用纹理来提供 
广泛的镜面反射效果 （第 10.5节）。所有这些都可以与局部环境贴 
图一起使用，以呈现对间接照明的镜面反应。将环境地图与空间中 
的特定点联系起来的第一个标题之一是 “半条命2”[1193,1222]。 
在他们的系统中，艺术家首先将采样位置放在 500以上11.全局照 
明场景。在预处理步骤中，从这些位置中的每一个渲染立方体图。 
然后，对象在镜面反射计算期间使用最近位置的结果作为入射辐射 
的表示。可能会发生相邻对象使用不同的环境贴图，这会导致视觉 
不匹配，但艺术家可以手动覆盖立方体贴图的自动分配。如果对象 
很小并且环境贴图从其中心渲染（隐藏对象以使其不出现在纹理 
中），则结果相当精确。不幸的是，这种情况很少见。大多数情况 
下，相同的反射探针用于多个对象，有时具有显着的空间范围。镜 
面表面位置离环境地图中心越远，结果与实际情况的差异越大。 
----------------------- Page 543-----------------------
Brennan[194]和 Bjorke[155]提出了解决这个问题的一种方法。它 
们不是将入射光照度视为来自无限远的周围球体，而是假设它来自 
具有有限大小的球体，半径是用户定义的。查找传入的辐亮度时， 
方向不会直接用于索引环境贴图，而是被视为源自评估的表面位置 
并与该球体相交的射线。接下来，计算新方向，一个从环境地图的 
中心到交叉点位置。该向量用作查找方向。见图11.37。该过程具 
有在空间中 “固定”环境地图的效果。这样做通常被称为视差校正。 
相同的方法可以与其他基元一起使用，例如方框[958]。用于光线交 
叉的形状通常称为反射代理。使用的代理对象应表示渲染到环境贴 
图中的几何体的一般形状和大小。虽然通常不可能，但如果它们完 
全匹配 - 例如当一个盒子用于表示矩形房间时 - 该方法提供完美 
的局部反射。这种技术在游戏中获得了极大的普及。它易于实现， 
在运行时快速，并且可以在前向和延迟渲染方案中使用。艺术家可 
以直接控制外观和内存使用情况。如果某些区域需要更精确的照明， 
他们可以放置更多的反射探头并更好地安装代理。如果使用太多内 
存来存储环境贴图，则很容易删除探针。使用光泽材质时，着色点 
与具有代理形状的交点之间的距离可用于确定要使用的预过滤环境 
贴图的哪个级别（图 11.38）。当我们离开阴影点时，这样做模拟 
了BRDF叶片的不断增长的足迹。当多个探针覆盖相同区域时，可 
以建立关于如何组合它们的直观规则。例如，探针可以具有用户设 
置的优先级参数，使得具有较高值的​ ​ 那些优先于较低的值，或 
者它们可以平滑地相互融合。不幸的是，该方法的简单性质导致各 
----------------------- Page 544-----------------------
种伪像。反射代理很少与底层几何完全匹配。这使得反射在某些区 
域以不自然的方式伸展。这是一个主要针对高反射性抛光材料的问 
题。此外，反射对象渲染到envi 11.6中。镜面全局照明501prrr 
图11.37。使用反射代理在空间上本地化环境贴图（EM）的效果。 
在这两种情况下，我们都希望渲染黑色圆圈表面上的环境反射。左 
边是常规环境映射，由蓝色圆圈表示（但可以是任何表示，例如立 
方体图）。通过使用反射视图方向 r访问环境地图来确定黑色圆圈 
上的点的效果。通过使用这个方向，蓝色圆圈EM被视为无限大且 
远离。对于黑色圆圈上的任何点，就好像 EM在那里居中。在右边， 
我们希望 EM将周围的黑色房间表示为本地，而不是无限远。蓝色 
圆圈EM从房间的中心生成。为了访问该 EM，就好像它是一个房 
间一样，来自位置p的反射光线沿着反射的视图方向被跟踪，并在 
着色器中与一个简单的代理对象相交，房间周围是红色框。然后使 
用该交叉点和 EM的中心来形成方向r'，其通常仅通过方向用于访 
问EM。通过找到r'，此过程将EM视为具有物理形状（红色框）。 
由于代理形状与实际房间的几何形状不匹配，因此该代理框假设将 
在两个较低角落的这个房间中分解。图11.38。点a和b处的 BRDF 
是相同的，并且视图矢量v和v'是相等的。因为从点a到反射代理 
的距离d比距离b的距离d'短，所以 BRDF波瓣在反射代理侧 （用 
红色标记）的覆盖区较小。在对预过滤的环境地图进行采样时，该 
距离可以与反射点处的粗糙度一起使用以影响mip级别。50211。 
全局照明设备地图从地图的位置评估其 BRDF。访问环境贴图的曲 
----------------------- Page 545-----------------------
面位置将不具有这些对象的完全相同的视图，因此纹理的存储结果 
不完全正确。代理也会导致（有时是严重的）漏光。通常，查找将 
从环境贴图的明亮区域返回值，因为简化的光线投射错过了应该导 
致遮挡的局部几何体。有时通过使用定向遮挡方法可以缓解此问题 
 （第11.4节）。另一种减轻此问题的流行策略是使用预先计算的漫 
反射光照，通常以更高的分辨率存储。首先将环境贴图中的值除以 
渲染它的位置处的平均漫反射光照。这样做可以有效地消除环境贴 
图中平滑，漫反射的影响，只留下更高频率的成分。当执行着色时， 
反射与阴影位置处的漫反射光相乘[384,999]。这样做可以部分地减 
轻反射探针缺乏空间精度。已经开发出使用由反射探针捕获的几何 
形状的更复杂表示的解决方案。Szirmay-Kalos等。[1730]存储每 
个反射探针的深度图，并在查找时对其执行光线跟踪。这可以产生 
更准确的结果，但需要额外的费用。麦圭尔等人。[1184]提出了一 
种更有效的跟踪探针深度缓冲的光线的方法。他们的系统存储多个 
探针。如果最初选择的探测器不包含足够的信息来可靠地确定命中 
位置，则选择回退探测并使用新的深度数据继续跟踪。当使用光泽 
BRDF时，环境贴图通常是预滤波的，并且每个mipmap存储与逐 
渐变大的内核卷积的事件辐射。预过滤步骤假设该内核是径向对称 
的 （第 10.5节）。然而，当使用视差校正时，BRDF波瓣在反射代 
理的形状上的覆盖区根据阴影点的位置而改变。这样做会使预过滤 
略有不正确。Pesce和 Iwanicki分析了这个问题的不同方面，并讨 
论了潜在的解决方案[807,1395]。反射代理不必是封闭的，凸起的 
----------------------- Page 546-----------------------
形状。简单，也可以使用平面矩形来代替或增加具有高质量细节的 
盒子或球体代理[1228,1640]。11.6.2环境映射的动态更新使用本地 
化反射探测器需要渲染和过滤每个环境映射。这项工作通常是脱机 
完成的，但有些情况下可能需要在运行时完成。如果开放世界的游 
戏具有不断变化的时间，或者动态生成世界几何体，则离线处理所 
有这些地图可能需要太长时间并影响生产力。在极端情况下，当需 
要许多变体时，甚至可能无法将它们全部存储在磁盘上。在实践中， 
一些游戏在运行时渲染反射探测器。需要仔细调整这种类型的系统， 
以免显着影响性能。11。6.镜面全局照明503除了微不足道的情况 
之外，不可能每帧重新渲染所有可见探测器，因为现代游戏中的典 
型帧可以使用数十甚至数百个。幸运的是，这不是必需的。我们很 
少需要反射探头始终准确地描绘它们周围的所有几何形状。大多数 
情况下，我们确实希望它们能够对一天中的时间变化做出适当的反 
应，但我们可以通过其他方法近似动态几何体的反射，例如后面描 
述的屏​ ​ 幕空间方法 （第 11.6.5节）。这些假设允许我们在加载 
时呈现一些探针，其余的一次一个，一次一个，当它们进入视图时。 
即使我们确实希望在反射探针中渲染动态几何体，我们几乎可以肯 
定能够以较低的帧速率更新探针。我们可以定义我们想要花费多少 
帧时间来渲染反射探测器并且每帧更新一些固定数量的帧探测器。 
基于每个探测器与摄像机的距离，自上次更新以来的时间以及类似 
因素的启发式算法可以确定更新顺序。在时间预算特别小的情况下， 
我们甚至可以在多个帧上分割单个环境地图的渲染。例如，我们可 
----------------------- Page 547-----------------------
以在每帧中仅渲染立方体贴图的单个面。离线执行卷积时通常使用 
高质量过滤。这种过滤涉及多次对输入纹理进行采样，这在高帧速 
率下是不可能的。Colbert和 Kriv'anek[279]开发了一种方法，使 
用重要性采样，以相对较低的样本计数 （大约64）实现可比较的过 
滤质量。为了消除大部分噪声，他们从具有完整 mip链的立方体图 
中进行采样，并使用启发式方法确定每个样本应读取哪个mip级别。 
他们的方法是环境地图的快速，运行时预滤波的流行选择 
[960,1154]。Manson和Sloan[1120]用基函数构造所需的滤波内 
核。必须在优化过程中获得构造特定内核的确切系数，但对于给定 
的形状，它只发生一次。卷积分两个阶段进行。首先，对环境贴图 
进行下采样，并使用简单内核同时进行过滤。接下来，组合来自所 
得到的mip链的样本以构建最终的环境图。要限制照明通道中使用 
的带宽以及内存使用情况，压缩生成的纹理是有益的。Narkowicz 
[1259]描述了一种将高动态范围反射探针压缩为 BC6H格式的有效 
方法（第6.2.6节），该方法能够存储半精度浮点值。渲染复杂场 
景，即使是一次一个立方体贴图面，也可能对CPU来说太昂贵。一 
种解决方案是为离线环境贴图准备G缓冲区，并仅计算（远低于CPU 
要求）的光照和卷积[384,1154]。如果需要，我们甚至可以在预生 
成的G缓冲区之上渲染动态几何体。11.6.3基于体素的方法在性能 
最受限的场景中，本地化环境贴图是一种很好的解决方案。然而， 
它们的质量往往有些令人不满意。在504 11.全球照明实践中，必 
须使用变通方法来掩盖由于探针空间密度不足或代理过于粗糙而导 
----------------------- Page 548-----------------------
致的实际几何近似问题。当每帧有更多时间可用时，可以使用更精 
细的方法。体素锥跟踪 - 在稀疏八叉树[307]以及级联版本[1190] 
 （第11.5.7节）中 - 也可用于镜面反射分量。该方法对存储在稀 
疏体素八叉树中的场景的表示执行锥形跟踪。单个锥形轨迹仅提供 
一个值，表示来自锥体所对应的立体角的平均辐射亮度。对于漫射 
照明，我们需要跟踪多个锥体，因为只使用一个锥体体素锥跟踪 - 
在稀疏八叉树[307]以及级联版本[1190] （第11.5.7节）中 - 也可 
用于镜面反射分量。该方法对存储在稀疏体素八叉树中的场景的表 
示执行锥形跟踪。单个锥形轨迹仅提供一个值，表示来自锥体所对 
应的立体角的平均辐射亮度。对于漫射照明，我们需要跟踪多个锥 
体，因为只使用一个锥体体素锥跟踪 - 在稀疏八叉树[307]以及级 
联版本[1190] （第11.5.7节）中 - 也可用于镜面反射分量。该方 
法对存储在稀疏体素八叉树中的场景的表示执行锥形跟踪。单个锥 
形轨迹仅提供一个值，表示来自锥体所对应的立体角的平均辐射亮 
度。对于漫射照明，我们需要跟踪多个锥体，因为只使用一个锥体表 
示来自锥体所对应的立体角的平均辐射亮度。对于漫射照明，我们 
需要跟踪多个锥体，因为只使用一个锥体表示来自锥体所对应的立 
体角的平均辐射亮度。对于漫射照明，我们需要跟踪多个锥体，因 
为只使用一个锥体准确。将锥形跟踪用于光泽材料明显更有效。在 
镜面照明的情况下，BRDF波瓣很窄，只需要考虑来自小立体角的 
辐射。我们不再需要追踪多个锥体;在很多情况下只需一个即可。只 
有粗糙材料的镜面效果可能需要跟踪多个锥体，但由于这种反射模 
----------------------- Page 549-----------------------
糊，通常足以回退到这些情况的局部反射探针而根本不跟踪锥体。 
光谱的另一端是高度抛光的材料。这些镜面反射几乎像镜子一样。 
这使得锥体变薄，类似于单个射线。通过这种精确的轨迹，底层场 
景表示的体素性质在反射中可能是显而易见的。它将显示由体素化 
过程产生的立方体，而不是多边形几何体。这种神器在实践中很少 
成为问题，因为几乎从未直接看到反射。它的贡献由纹理修改，纹 
理通常会掩盖任何缺陷。当需要完美的镜像反射时，可以使用其他 
方法以较低的运行时成本提供它们。11.6.4平面反射另一种方法是 
重复使用场景的常规表示并重新渲染它以创建反射图像。如果存在 
有限数量的反射表面并且它们是平面的，我们可以使用常规GPU渲 
染管道来创建从这些表面反射的场景的图像。这些图像不仅可以提 
供精确的镜面反射，但也可以通过对每个图像进行一些额外处理来 
呈现合理的光泽效果。理想的反射器遵循反射定律，其表明入射角 
等于反射角。也就是说，入射光线与法线之间的角度等于反射光线 
与法线之间的角度。见图11.39。该图还显示了反射物体的 “图像”。 
由于反射定律，物体的反射图像仅仅是物体本身，通过平面物理反 
射。也就是说，我们可以通过反射器跟踪入射光线而不是跟随反射 
光线，然后击中相同的点，但是在反射的物体上。11.6。镜面全局 
照明505图11.39。在平面上反射，显示入射角和反射角，反射几 
何形状，和反射器。这导致我们可以通过创建对象的副本，将其转 
换为反射位置并从那里渲染来渲染反射的原理。为了实现正确的照 
明，光源也必须相对于位置和方向在平面中反射[1314]。相反的方 
----------------------- Page 550-----------------------
法是通过镜子将观察者的位置和方向反射到反射器的相对侧。这种 
反射可以通过对投影矩阵的简单修改来实现。位于反射器平面远侧 
 （即后面）的物体不应被反射。这个问题可以通过使用反射器的平 
面方程来解决。最简单的方法是在像素着色器中定义剪裁平面。放 
置剪切平面，使其与反射器的平面重合[654]。在渲染反射场景时使 
用此剪切平面将剪切掉与视点位于同一侧的所有反射几何体，即最 
初位于镜子后面的所有对象。11.6.5屏幕空间方法与环境光遮挡和 
漫反射全局照明一样，某些镜面反射效果只能在屏幕空间中计算。 
由于镜面波瓣的清晰度，这样做比在漫射情况下稍微精确一些。有 
关辐射的信息仅需要围绕反射视图矢量的有限立体角，而不是来自 
整个半球，因此屏幕数据更有可能包含它。这种方法首先由Sousa 
等人提出。[1678]并由其他开发人员同时发现。整个方法系列称为 
屏幕空间反射 （SSR）。50611.全局照明给定阴影点，视图矢量和 
法线的位置，我们可以沿着法线上反射的视图矢量跟踪光线，测试 
与深度缓冲区的交点。通过沿着光线迭代移动，将位置投影到屏幕 
空间，并从该位置检索z缓冲深度来完成该测试。如果光线上的点 
距离相机比深度缓冲区表示的几何图形更远，则表示光线位于几何 
体内并检测到命中。然后可以读取来自颜色缓冲器的对应值以获得 
从跟踪方向入射的辐射的值。该方法假设射线击中的表面是朗伯 
 （Lambertian），但这种情况是许多方法常见的近似值，在实践中 
很少是约束。可以在世界空间中以均匀的步长跟踪光线。该方法相 
当粗略，因此当检测到命中时，可以执行细化传递。在有限的距离 
----------------------- Page 551-----------------------
上，二进制搜索可用于精确定位交叉点位置。McGuire和 Mara 
[1179]注意到，由于透视投影，踩在均匀的世界 - 空间间隔中会在 
屏幕空间中沿着光线产生不均匀的采样点分布。接近相机的光线部 
分未被采样，因此可能会遗漏一些命中事件。那些更远的地方被过 
采样，所以相同的深度缓冲像素被多次读取，产生不必要的内存流 
量和冗余计算。他们建议使用数字差分分析仪 （DDA）在屏幕空间 
中执行光线行进，这是一种可用于栅格化线条的方法。首先，要跟 
踪的光线的起点和终点都投影到屏幕空间。沿着这条线的像素依次 
被检查，保证了统一的精度。这种方法的一个结果是交叉测试不需 
要为每个像素完全重建视图空间深度。视图空间深度的倒数，即在 
典型透视投影的情况下存储在z缓冲区中的值，在屏幕空间中线性 
变化。这意味着我们可以在实际跟踪之前根据屏幕空间x和y坐标 
计算其导数，然后使用简单的线性插值来获取屏幕空间段的任何值。 
可以直接将计算值与来自深度缓冲器的数据进行比较。屏幕空间反 
射的基本形式仅跟踪单个光线，并且只能提供镜面反射。然而，完 
美的镜面表面是相当罕见的。在现代的，基于物理的渲染管道中， 
需要更频繁地进行光泽反射，并且SSR也可用于渲染这些反射。在 
简单的临时方法[1589,1812]中，沿着反射方向仍然用单个光线跟踪 
反射。结果存储在屏幕外缓冲区中，该缓冲区在后续步骤中处理。 
应用了一系列过滤内核，通常与对缓冲区进行下采样相结合，以创 
建一组反射缓冲区，每个反射缓冲区都被模糊到不同的程度。计算 
光照时，BRDF波瓣的宽度决定采样哪个反射缓冲区。尽管通常选 
----------------------- Page 552-----------------------
择滤波器的形状以匹配 BRDF波瓣的形状，但这样做仍然只是粗略 
的近似，因为在不考虑不连续性的情况下执行屏幕空间滤波，表面 
11.6。镜面全局照明507方向，以及对结果精度至关重要的其他因 
素。最后添加了自定义启发式扫描，使光滑的屏幕空间反射在视觉 
上与其他来源的镜面反射相匹配。即使它是近似值，结果仍然令人 
信服。Stachowiak[1684]以更有原则的方式解决问题。计算屏幕空 
间反射是光线跟踪的一种形式，就像光线追踪一样，它可以用来执 
行适当的蒙特卡罗积分。他不是仅使用反射的视图方向，而是使用 
BRDF的重要性采样并随机拍摄光线。由于性能限制，跟踪以半分 
辨率完成，并且每个像素（1到4之间）跟踪少量光线。这是太少 
的光线以产生无噪声的图像，因此交叉结果在相邻像素之间共享。 
假设对于某个范围内的像素，可以认为局部可见性相同。如果从方 
向d0的点p0射出的光线与点i0中的场景相交，我们可以假设如 
果我们从点p1射出一条光线，在方向d1上射频，使得它也通过i0， 
它也会在i0中击中几何体。并且之前不会有任何交叉点。这让我们 
可以通过适当地修改它对邻居积分的贡献来使用光线，而无需实际 
跟踪光线。形式上，当相对于当前像素的 BRDF的概率分布函数计 
算时，从相邻像素拍摄的光线的方向将具有不同的概率。为了进一 
步增加有效射线数量，结果在时间上过滤。通过离线执行与场景无 
关的部分并将其存储在由 BRDF参数索引的查找表中，也可以减少 
最终积分的方差。在屏幕空间中可以获得反射光线所需的所有信息 
的情况下，这些策略使我们能够获得精确，无噪声的结果，接近路 
----------------------- Page 553-----------------------
径追踪的地面实况图像（图 11.40）。在屏幕空间中跟踪光线通常 
很昂贵。它包括重复采样深度缓冲区，可能多次，并对查找结果执 
行一些操作。因为读取相当不连贯，所以缓存利用率可能很差，导 
致在着色器执行期间从等待内存事务完成到长时间停顿。需要非常 
谨慎地尽可能快地实施。屏幕空间反射通常以降低的分辨率 
[1684,1812]计算，并且时间滤波用于弥补降低的质量。Uludag 
[1798]描述了一种使用分层深度缓冲区 （第 19.7.2节）加速跟踪的 
优化。首先，创建层次结构。深度缓冲器逐步下采样，每个步骤在 
每个方向上减少两倍。较高级别的像素存储较低级别的四个对应像 
素之间的最小深度值。接下来，通过层次结构执行跟踪。如果在给 
定的步骤中光线没有碰到它所经过的单元中存储的几何体，则它会 
前进到单元的边界，并且在下一步中使用较低分辨率的缓冲区。如 
果光线遇到当前单元格中的命中，则它将前进到命中位置，并在下 
一步中使用更高分辨率的缓冲区。当注册最高分辨率缓冲区时，跟 
踪终止（图 11.41）。50811.全球照明图 11.40。使用随机屏幕空 
间反射算法[1684]渲染该图像中的所有镜面反射效果。注意垂直拉 
伸，来自microfacet模型的反射特征。图片（ 由TomaszStachowiak 
提供。场景由Joacim Lunde建模和纹理。）该方案特别适用于长 
迹线，因为它确保不会遗漏任何特征，同时允许光线以较大的增量 
前进。它还可以很好地访问缓存，因为深度缓冲区不是在随机的远 
程位置读取，而是在本地邻域中读取。Grenier[599]介绍了实施这 
种方法的许多实用技巧。图11.41。通过分层深度缓冲区跟踪光线。 
----------------------- Page 554-----------------------
如果光线在通过像素时未达到几何体，则下一步使用较粗糙的分辨 
率。如果注册了匹配，则后续步骤使用更精细的分辨率。此过程允 
许光线以较大的步长穿过空白区域，从而提供更高的性能。11.7。 
统一方法509其他人避免完全追踪光线。Drobot[384]重用交叉点 
与反射代理的位置，并从那里查找屏幕空间辐射。Cichocki [266] 
假设平面反射器，而不是跟踪光线，反转过程并运行全屏通道，其 
中每个像素将其值写入应该被反射的位置。与其他屏幕空间方法一 
样，反射也可能受到可用数据有限造成的伪影的影响。反射光线通 
常在注册命中之前离开屏幕区域，或者击中几何体的背面，没有可 
用的照明信息。这种情况需要优雅地处理，因为即使对于相邻像素， 
迹线的有效性通常也是不同的。空间滤波器可用于部分填充跟踪缓 
冲区[1812,1913]中的间隙。SSR的另一个问题是缺少有关深度缓冲 
区中对象厚度的信息。因为只存储了一个值，所以无法判断光线在 
深度数据描述的表面后面是否会发生任何影响。Cupisz [315]讨论 
了各种低成本方法，以减轻因不知道深度缓冲区中物体厚度而产生 
的伪影。玛拉等人。[1123]描述深G-缓冲器，其存储多层数据，因 
此具有关于表面和环境的更多信息。屏幕空间反射是一种很好的工 
具，可以提供一组特定的效果，例如大多数平面上附近物体的局部 
反射。它们大大提高了实时高光照明的质量，但它们并没有提供完 
整的解决方案。本章中描述的不同方法通常堆叠在一起，以提供完 
整而强大的系统。屏幕空间反射用作第一层。如果无法提供准确的 
结果，则使用局部反射探针作为后备。如果在给定区域中没有应用 
----------------------- Page 555-----------------------
任何探针，则使用全局默认探针[1812]。这种类型的设置提供了一 
种一致且稳健的方式来获得合理的间接镜面贡献，这对于可信的外 
观尤其重要。11.7统一方法到目前为止所提出的方法可以组合成一 
个能够呈现精美图像的连贯系统。然而，它们缺乏路径追踪的优雅 
和概念简洁性。渲染方程的每个方面都以不同的方式处理，每个方 
面都做出各种妥协。即使最终图像看起来很逼真，但在很多情况下， 
这些方法都会失败并且幻觉会中断。由于这些原因，实时路径追踪 
一直是重要研究工作的重点。通过路径跟踪渲染具有可接受质量的 
图像所需的计算量远远超过甚至快速CPU的能力，因此使用GPU。 
它们极高的速度和计算单元的灵活性使它们成为这项任务的理想选 
择。实时路径跟踪的应用包括架构 510 11.全局照明演练和电影渲 
染的预可视化。对于这些用例，较低和变化的帧速率是可接受的。 
渐进细化（第 13.2节）等技术可用于在相机静止时改善图像质量。 
高端系统可以使用多个GPU。相比之下，游戏需要以最终质量渲染 
帧，并且他们需要在时间预算内始终如一地进行渲染。GPU可能还 
需要执行除呈现自身之外的任务。例如，通常将诸如粒子模拟之类 
的系统卸载到GPU以释放一些CPU处理能力。所有这些元素相结 
合，使得路径追踪在今天渲染游戏时不切实际。在图形社区中有一 
种说法： “光线跟踪是未来的技术，它永远都是！”这句话暗示问 
题是如此复杂，即使硬件速度和算法都有所提高，总是有更有效的 
方法来处理渲染管道的特定部分。支付额外费用并仅使用光线投射 
 （包括初级可见性）可能很难证明。目前有相当多的事实，因为GPU 
----------------------- Page 556-----------------------
从未被设计为执行有效的光线跟踪。他们的主要目标一直是光栅化 
三角形，他们已经非常擅长这项任务。虽然可以将光线跟踪映射到 
GPU，但是当前的解决方案没有固定功能硬件的任何直接支持。在 
GPU的计算单元上运行的软件解决方案实际上总是超越硬件光栅 
化是很困难的。更合理，不太纯粹的方法是使用路径跟踪方法来处 
理在光栅化框架内难以处理的效果。栅格化从相机可见的三角形， 
但不依赖于近似反射代理或不完整的屏幕空间信息，而是跟踪计算 
反射的路径。而不是试图用ad hoc模糊模拟区域光阴影，跟踪光 
源到源并计算正确的遮挡。发挥GPU的优势，使用更通用的解决方 
案，解决无法在硬件中高效处理的元素。这样的系统仍然有点拼凑， 
并且缺乏路径追踪的简单性，但实时渲染一直是妥协。如果一些优 
雅必须放弃几毫秒，这是正确的选择 - 帧速率是不可协商的。虽然 
我们可能永远无法将实时渲染称为 “已解决的问题， “更多地使用 
路径追踪将有助于将理论和实践更紧密地结合在一起。随着GPU每 
天变得更快，这种混合解决方案应该适用于不久的将来最苛刻的应 
用。基于这些原则构建的系统的初始示例已经开始出现[1548]。光 
线跟踪系统依赖于加速方案，例如使用边界体积层次结构（BVH） 
来加速可见性测试。有关该主题的更多信息，请参见第 19.1.1节。 
BVH的简单实现不能很好地映射到GPU。如第3章所述，GPU本 
身执行线程组，称为warp或wavefronts。以锁步方式处理warp， 
每个线程执行相同的操作。如果某些线程不执行 11.7的特定部分。 
统一方法511图11.42。时空方差引导滤波可用于对每像素一个样 
----------------------- Page 557-----------------------
本的路径跟踪图像进行去噪（左），以创建平滑的无伪影图像（中 
心）。质量与每像素2048个样本（右）呈现的参考相当。（图片 
由NVIDIA公司提供。）代码，它们暂时被禁用。出于这个原因， 
GPU代码应该以最小化同一波前内的线程之间的发散流控制的方 
式编写。假设每个线程处理一条射线。该方案通常导致线程之间的 
大的分歧。不同的光线将执行遍历代码的分支分支，沿途与不同的 
边界体积相交。有些光线会比其他光线更早地完成树遍历。这种行 
为使我们远离理想，warp中的所有线程都使用GPU的计算功能。 
为了消除这些低效率，已经开发了遍历方法，以尽量减少早期完成 
的分歧和重用线程[15,16,1947]。每个像素可能需要跟踪数百或数 
千条光线以生成高质量图像。即使使用最佳的BVH，有效的树遍历 
算法和快速GPU，这样做对于除了最简单的场景之外的任何现实都 
不可能实现。我们可以在可用的性能约束内生成的图像非常嘈杂， 
不适合显示。但是，它们可以用去噪算法处理，以产生大多数无噪 
声的图像。请参见图 11.42以及第1044页的图24.2。最近在该领 
域取得了令人瞩目的进展，已经开发出的算法可以创建视觉上接近 
高质量的图像，通过跟踪甚至每个像素的单个路径生成的输入的路 
径跟踪参考[95,200,247,1124,1563]。2014年，PowerVR宣布了 
他们的向导GPU[1158]。除了典型功能外，它还包含在硬件中构造 
和遍历加速结构的单元（第23.11节）。该系统证明了既有兴趣也 
有能力定制固定功能单元以加速射线投射。看到未来将会是多么令 
人兴奋！51211.全局照明进一步阅读和资源 Pharr等人的书 “基于 
----------------------- Page 558-----------------------
物理的渲染”[1413]是非交互式全局照明算法的优秀指南。他们的 
工作特别有价值的是他们深入描述了他们的工作。Glassner （现在 
免费）数字图像合成原理[543,544]讨论了光与物质相互作用的物理 
方面。Dutr'e等人的高级全局照明。[400]为解决Kajiya渲染方程 
的辐射测量和 （主要是离线）方法提供了基础。McGuire的图形编 
码[1188]是一个电子参考，它包含大量与计算机图形有关的方程和 
算法。Dutr'e的全球照明纲要[399]参考作品相当陈旧，但是免费。 
雪莉的一系列短书[1628]是了解光线追踪的廉价而快捷的方法。第 
12章图像空间效应 “世界不再轮流了。它非常清晰明亮，并且倾向 
于在边缘模糊。“- 欧内斯特海明威制作图像比参与描绘物体更多。 
使图像看起来像照片般逼真的一部分就是让它看起来像一张照片。 
就像摄影师调整他们的最终结果一样，我们也可能希望修改颜色平 
衡。为渲染图像添加胶片颗粒，渐晕和其他细微变化可以使渲染看 
起来更具说服力。另外，镜头光晕和绽放等更具戏剧性的效果可以 
传达出戏剧感。描绘景深和运动模糊可以增加真实感并用于艺术效 
果。GPU可用于有效地采样和操纵图像。在本章中，我们首先讨论 
使用图像处理技术修改渲染图像。其他数据，例如，可以使用诸如 
深度和法线来增强这些操作，例如，通过允许在保持锐边的同时平 
滑噪声区域。重投影方法可用于保存着色计算，或快速创建丢失的 
帧。最后，我们提出了各种基于样本的技术，以产生镜头光晕，绽 
放，景深，运动模糊和其他效果。12.1图像处理图形加速器通常一 
直关注从几何和阴影描述创建人工场景。图像处理是不同的，我们 
----------------------- Page 559-----------------------
采用输入图像并以各种方式对其进行修改。可编程着色器的组合以 
及使用输出图像作为输入纹理的能力为使用GPU提供各种图像处 
理效果开辟了道路。这些效果可以与图像合成相结合。通常，生成 
图像，然后对其执行一个或多个图像处理操作。渲染后修改图像513 
51412.图像空间效果0,0 1,00,1 1,10,02,00,2图12.1。在左侧， 
填充屏幕四边形，显示（u，v）纹理坐标。在右侧，一个三角形填 
充屏幕，其纹理坐标适当调整以提供相同的映射。被称为后处理。 
在渲染单个帧时，可以执行大量的传递，访问图像，深度和其他缓 
冲区[46,1918]。例如，游戏 “战地4”具有超过五十种不同类型的 
渲染通道[1313]，但并非所有渲染通道都在单个帧中使用。使用 
GPU进行后处理有几个关键技术。场景以某种形式呈现到屏幕外缓 
冲区，例如彩色图像，z深度缓冲区或两者。然后将得到的图像视 
为纹理。此纹理应用于屏幕填充四边形。通过渲染该四边形来执行 
后处理，因为将针对每个像素调用像素着色器程序。大多数图像处 
理效果依赖于在相应像素处检索每个图像纹素的信息。根据系统限 
制和算法，这可以通过从GPU检索像素位置或通过将范围[0,1]中的 
纹理坐标分配到四边形并按输入图像大小缩放来完成。在实践中， 
屏幕填充三角形可以比四边形更有效。例如，由于更好的高速缓存 
一致性，当使用单个三角形而不是由两个三角形形成的四边形时， 
AMD GCN架构上的图像处理速度提高了近 10％[381]。三角形足 
够大以填满屏幕[146]。见图 12.1。无论使用什么原始对象，意图都 
是相同的：为屏幕上的每个像素评估像素着色器。这种类型的渲染 
----------------------- Page 560-----------------------
称为全屏传递。如果可用，您还可以使用计算着色器执行图像处理 
操作。这样做有几个优点，稍后描述。12.1。图像处理515使用传 
统流水线，现在为像素着色器设置舞台以访问图像数据。检索所有 
相关的相邻样本并对其应用操作。邻居的贡献由取决于其与被评估 
像素的相对位置的值加权。诸如边缘检测之类的一些操作具有固定 
大小的邻域（例如，3×3像素），其具有针对每个邻居的不同权重 
 （有时为负）和像素的原始值本身。每个纹素的值乘以其相应的权 
重，并将结果相加，从而产生最终结果。如第 5.4.1节所述，各种 
滤波器内核可用于重建信号。以类似的方式，滤镜内核可用于模糊 
图像。旋转不变滤波器内核对于分配给每个贡献纹素的权重不依赖 
于径向角度。那是，这种滤波器内核完全由纹素与中心像素的距离 
进行描述，用于滤波操作。sinc滤波器（如第 135页的公式 5.22 
所示）就是一个简单的例子。高斯滤波器，众所周知的钟形曲线的 
形状，是一种常用的核：高斯 （x）=？1σ√2π？即r22？2，（12.1） 
其中r是纹素的中心距离，σ是标准差;σ2称为方差。较大的标准偏 
差会产生更宽的钟形曲线。一个粗略的经验法则是将支撑，滤波器 
尺寸，3σ像素宽或更大，作为开始[1795]。更广泛的支持会增加模 
糊，代价是更多的内存访问。e前面的术语使连续曲线下的面积保 
持等于 1。然而，当形成离散滤波器内核时，该术语无关紧要。将 
每个纹素元素计算的值在该区域上相加在一起，然后将所有值除以 
该总和，使得最终权重总和为 1。由于这种规范化过程，常量项没 
有用处，因此通常不会在过滤器内核描述中显示。图12.2所示的高 
----------------------- Page 561-----------------------
斯二维和一维滤波器就是这样形成的。sinc和Gaussian滤波器的 
一个问题是函数会永远存在。一种权宜之计是将这种过滤器夹紧到 
特定的直径或方形区域，并简单地将任何东西都处理为具有零值。 
其他过滤内核设计用于各种属性，例如易于控制，平滑或评估简单。 
Bjorke[156]和 Mitchell等人。[1218]提供一些常见的旋转不变滤 
波器和其他有关GPU上图像处理的信息。任何全屏滤波操作都将尝 
试从显示边界外部采样像素。例如，如果您为屏幕上的左上角像素 
收集3×3个样本，则表示您正在尝试检索不存在的纹素。一个基本 
的解决方案是将纹理采样器设置为夹到边缘。当请求屏外的，不存 
在的纹素时，而是检索最近的边纹素。这导致图像边缘的滤波错误， 
但这些通常不明显。另一种解决方案是以略高于显示区域的分辨率 
生成要滤波的图像，从而存在这些屏幕外纹素。516 12.图像 - 空 
间效应0.05450.05450.24420.24420.05450.05450.24420。 
2442 0.0545 0.0545 0.2442 0.2442 0.0545 0.0545 0.2442 
0.2442 0.4026 0.4026 0.4026 0.4026 0.0545 0.2442 0.4026 
0.2442 0.0545 0.2442 0.4026 0.2442 0.0545 0.0545 0.2442 
0.4026 0.2442 0.0545 0.0545 0.2442 0.4026 0.2442 0.0545 
0.0545 0.0030 0.0030 0.0030 0.0030 0.0133 0.0133 0.0133 
0.0133 0.0133 0.0133 0.0133 0.0133 0.0133 0.0133 0.0133 
0.0133 0.0133 0.0219 0.0219 0.0219 0.0219 0.0596 0.0596 
0.0596 0.0596 0.0596 0.0983 0.0983 0.0983 0.0983 0.1621 
0.0545 0.0545 0.2442 0.2442 0.0545 0.2442 0.4026 0.2442 
----------------------- Page 562-----------------------
0.05450.4026 （a） （b） （c）图12.2。执行高斯模糊的一种方法 
是对5×5区域进行采样，对每个贡献进行加权并对它们求和。图的 
 （a）部分显示了σ=1的模糊核的这些权重。第二种方法是使用可 
分离的滤波器。两个一维高斯模糊，（b）和（c），串联执行，具 
有相同的净结果。对于 5个单独的行，在（b）中示出的第一遍使 
用其行中的5个样本水平地使每个像素模糊。第二遍 （c）将 5样本 
垂直模糊滤波器应用于 （b）的结果图像，以给出最终结果。将 （b） 
中的权重乘以（c）中的权重给出与（a）中相同的权重，表明该过 
滤器是等效的，因此是可分离的。如 （a）中所示， （b）和 （c）中 
的每一个有效地每个使用5个像素，而不是需要25个样本，总共 
10个样本。12.1。图像处理517图12.3。在左侧，通过执行九个 
纹理样本并将贡献平均在一起来应用盒式过滤器。在中间，使用五 
个样本的对称图案，外部样本每个代表两个纹素，因此，每个的重 
量是中心样品的两倍。这种类型的模式可用于其他滤波器内核，其 
中通过在两个纹素之间移动外部样本，可以改变每个纹素的相对贡 
献。在右侧，使用更有效的四样本模式。左上角的样本在四个纹素 
的值之间进行插值。右上角和左下角的每个都插入两个纹素的值。 
每个样品的重量与其代表的纹素数量成比例。使用GPU的一个优点 
是可以使用内置插值和 mipmapping硬件来帮助最小化所访问的 
纹素数量。例如，假设目标是使用盒式过滤器，即获取围绕给定纹 
理元素形成3×3网格的九个纹素的平均值，并显示该模糊结果。然 
后，这些九个纹理样本将被像素着色器加权并加在一起，然后像素 
----------------------- Page 563-----------------------
着色器将模糊结果输出到像素。但是，不需要九个显式的样本操作。 
通过对纹理使用双线性插值，单个纹理访问可以检索多达四个相邻 
纹素的加权和[1638]。使用这种想法，可以仅使用四次纹理访问对 
3×3网格进行采样。见图12.3。对于重量相等的盒式过滤器，可以 
将单个样本放置在四个纹素之间的中间位置，从而获得四个纹素的 
平均值。对于像Gaussian这样的滤波器，其中权重的差异使得四 
个样本之间的双线性插值可能不准确，每个样本仍然可以放置在两 
个纹素之间，但偏移的距离比另一个更接近。例如，假设一个纹素 
的权重为0.01，其邻居为0.04。可以放置样品，使其与第一个相距 
0.8，距邻居0.2，使每个纹素具有适当的比例。该单个样本的权重 
将是两个纹素的权重之和0.05。或者，可以通过对每四个纹素使用 
双线性插值样本来近似高斯，找到给出最接近理想权重的偏移。一 
些过滤内核是可分离的。两个例子是高斯和盒式滤波器。这意味着 
它们可以应用于两个单独的一维模糊。这样做总体上需要更少的纹 
素访问。费用从d2到2d，其中d是核直径或支持[815,1218,1289]。 
例如，假设盒式滤波器应用于图像中每个像素的5×5区域。首先， 
图像可以水平过滤：左边的两个相邻纹素和518 12.每个像素右边 
两个的图像空间效果，以及像素的值本身，均等加权0.2并求和。 
然后，所得到的图像垂直模糊，其中上方和下方的两个相邻纹素与 
中心像素平均。例如，不必在一次通过中访问25个纹素，而是在两 
次通过中访问总共 10个纹素。见图 12.2。更广泛的过滤器内核将 
受益更多。圆形磁盘过滤器，对散景效果很有用 （第 12.4节），计 
----------------------- Page 564-----------------------
算通常很昂贵，因为它们在实数域中是不可分的。但是，使用复数 
打开了一系列广泛的功能。Wronski [1923]讨论了这种可分离滤波 
器的实现细节。计算着色器适用于过滤，内核越大，与像素着色器 
相比性能越好[1102,1710]。例如，线程组存储器可用于在不同像素 
的滤波器计算之间共享图像访问，从而减少带宽[1971]。通过使用 
带有计算着色器的分散写入，可以以恒定成本执行任何半径的盒式 
过滤器。对于水平和垂直通道，计算行或列中第一个像素的内核。 
通过在内核的前沿添加下一个样本并减去留下的远端的样本来确定 
每个连续像素的结果。这种 “移动平均”技术可用于在恒定时间内 
近似任何大小的高斯模糊[531,588,817]。下采样是模糊时常用的另 
一种GPU相关技术。想法是制作要操纵的较小版本的图像，例如， 
沿两个轴将分辨率减半以制作四分之一屏幕图像。根据输入数据和 
算法的要求，原始图像可以按尺寸过滤或仅以较低的分辨率创建。 
当访问该图像以混合到最终的全分辨率图像时，纹理的放大将使用 
双线性插值来在样本之间进行混合。这给出了进一步的模糊效果。 
对较小版本的原始图像执行操作会显着减少所访问的纹素的总数。 
此外，应用于此较小图像的任何滤镜都具有增加滤镜内核的相对大 
小的净效果。例如，将宽度为5的内核（即，中心像素的每一侧的 
两个纹理像素）应用于较小的图像实际上类似于将宽度为9的内核 
应用于原始图像。质量会更低，但是对于模糊相似颜色的大面积， 
许多眩光效果和其他现象的常见情况，大多数工件将是最小的 
[815]。减少每像素的位数是另一种可以降低存储器访问成本的方 
----------------------- Page 565-----------------------
法。下采样可用于其他缓慢变化的现象，例如，许多粒子系统可以 
半分辨率渲染[1391]。下采样的这种想法可以扩展到创建图像的 
mipmap和从多个层采样以增加模糊处理的速度[937,1120]。 
12.1.1双边滤波使用某种形式的双边滤波器可以改善上采样结果和 
其他图像处理操作[378,1355]。想法是放弃或降低影响力 12.1。图 
像处理 5190.00300.00300.00300.00300.01330.01330.0133 
0.0133 0.0133 0.0133 0.0133 0.0133 0.0219 0.0219 0.0219 
0.0219 0.0596 0.0596 0.0596 0.0596 0.0983 0.0983 0.0983 
0.09830.1621图12.4。双边过滤器。左上角是原始图像。在左下 
方，我们模糊并仅使用非红色像素的样本。在右边，显示了一个像 
素的滤波器内核。计算高斯模糊时忽略红色像素。其余像素的颜色 
乘以相应的滤波器权重并求和，并且还计算这些权重的总和。对于 
这种情况，权重总和为0.8755，因此计算的颜色除以该值。与我们 
中心样本表面无关的样本。此过滤器用于保留边缘。想象一下，您 
将相机聚焦在远处蓝色物体前面的红色物体上，背景为灰色。蓝色 
物体应该模糊，红色锐利。简单的双边滤波器将检查像素的颜色。 
如果是红色，则不会出现模糊 - 对象保持清晰。否则，像素模糊。 
所有非红色样本都将用于模糊像素。见图12.4。对于这个例子，我 
们可以通过检查它们的颜色来确定要忽略的像素。关节或交叉双边 
滤波器使用附加信息，例如深度，法线，识别值，速度或其他数据 
来确定是否使用相邻样本。例如，Ownby等人。[1343]显示当仅使 
用几个样本进行阴影映射时如何发生模式。模糊这些结果看起来要 
----------------------- Page 566-----------------------
好得多。但是，一个对象上的阴影不应影响另一个不相关的模型， 
并且模糊将使阴影在对象的边缘外渗出。他们使用双边滤波器，通 
过比较给定像素的深度与其邻居的深度来丢弃不同表面上的样本。 
以这种方式减少区域的可变性称为去噪，并且通常用于屏幕空间环 
境遮挡算法 （第 11.3.6节），例如[1971]。仅使用相机的距离来找 
到边缘通常是不够的。例如，穿过两个立方体面之间形成的边缘的 
柔和阴影可能落在520上。图像空间仅影响一个面，另一个面向远 
离光的面。仅使用深度可能会导致阴影在模糊时从一个面渗到另一 
个面，因为不会检测到此边缘。我们可以通过仅使用深度和表面法 
线与中心样本的相邻的邻居来解决这个问题。这样做会限制跨越共 
享边缘的样本，因此这种双边滤波器也称为边缘保留滤波器。确定 
是否以及减少或忽略相邻样本的影响取决于开发人员，并且取决于 
诸如模型，渲染算法和查看条件之类的因素。除了花费在检查邻居 
和总和权重上的额外时间之外，双边过滤还有其他性能成本。诸如 
双通可分离滤波和双线性插值加权采样之类的滤波优化更难以使 
用。我们事先不知道哪些样本应该被忽视或削弱影响，因此我们不 
能使用GPU在单个 “tap”中收集多个图像纹素的技术。也就是说， 
可分离双通滤波器的速度优势导致近似方法[1396,1971]。巴黎等 
人。[1355]讨论了双边滤波器的许多其他应用。双边滤波器应用于 
必须保留边缘的任何地方，但样本可以重复使用以减少噪声。它们 
还用于将着色频率与渲染几何体的频率分离。例如，杨等人。[1944] 
以较低分辨率执行阴影，然后使用法线和深度，在上采样期间执行 
----------------------- Page 567-----------------------
双边滤波以形成最终帧。替代方案是最近深度滤波，其中检索低分 
辨率图像中的四个样本并且使用深度最接近高分辨率图像深度的样 
本[816]。Hennessy[717]和 Pesce[1396]对比并比较了这些和其 
他方法来对图像进行上采样。低分辨率渲染的一个问题是可能会丢 
失精细的细节。Herzog等。[733]通过利用时间相干性和重投影进 
一步提高质量。注意，双边滤波器是不可分离的，因为每个像素的 
采样数可以变化。Green[589]指出，将其视为可分离的工件可以被 
其他阴影效果隐藏。实现后处理管道的常用方法是使用乒乓缓冲区 
[1303]。这只是在两个屏幕外缓冲区之间应用操作的想法，每个缓 
冲区用于保存中间或最终结果。对于第一次传递，第一个缓冲区是 
输入纹理，第二个缓冲区是输出的位置。在下一次传递中，角色是 
相反的，第二个角色现在充当输入纹理，第一个被重复用于输出。 
在第二次传递中，第一个缓冲区的原始内容被覆盖 - 它是瞬态的， 
用作处理传递的临时存储。管理和重用瞬态资源是设计现代渲染系 
统的关键要素[1313]。从架构的角度来看，使每个单独的传递执行 
特定效果是方便的。然而，为了提高效率，最好在一次通过中尽可 
能多地结合[1918]。在前面的章节中，访问其邻居的像素着色器用 
于形态抗锯齿，软阴影，屏幕空间环境遮挡和其他技术。后处理效 
果通常在最终图像上运行，并且可以模仿 12.1。图像处理521图 
12.5。使用像素着色器的图像处理。左上角的原始图像以各种方式 
处理。右上角显示高斯差分运算，左下边缘检测，右下角是与原始 
图像混合的边缘检测的合成。（图片由NVIDIA公司提供。）热成 
----------------------- Page 568-----------------------
像[734]，再现胶片颗粒[1273]和色差[539]，进行边缘检测 
[156,506,1218]，产生热闪烁[1273]和涟漪[58]，将图像分类[58]， 
帮 助 渲 染 云 [90] ， 并 执 行 大 量 其 他 操 作 
[156,539,814,1216,1217,1289]。第 15.2.3节介绍了一些用于非真 
实感渲染的图像处理技术。有关示例，请参见图 12.5。这些都使用 
彩色图像作为唯一输入。52212.图像空间效应我们在本章结尾处使 
用各种广告牌和图像处理技术实现了一些效果，而不是继续使用所 
有可能算法的详尽（和令人筋疲力尽）。12。2重投影技术重投影 
基于重用先前帧中计算的样本的想法。顾名思义，这些样本可以从 
新的查看位置和方向重复使用。重投影方法的一个目标是在几个帧 
上分摊渲染成本，即利用时间一致性。因此，这也与时间抗锯齿有 
关，见 5.4.2节。如果应用程序未能及时完成当前帧的渲染，则另 
一个目标是形成近似结果。这种方法在虚拟现实应用中尤为重要， 
可避免模拟器病 （第21.4.1节）。重投影方法分为反向重投和向前 
重投。反向重投影的基本思想[1264,1556]如图 12.6所示。在时间 
t渲染三角形时，计算当前帧（t）和前一帧（t.1）的顶点位置。使 
用来自顶点着色的z和w，像素着色器可以计算t和t的内插值z/ 
w。1，如果它们足够接近，可以在前一个颜色缓冲区中完成pt.1i 
的双线性查找，并且可以使用该阴影值而不是计算新的阴影值。对 
于之前被遮挡的区域，然后变为可见区域 （例如，图12.6中的深绿 
色区域），没有可用的阴影像素。这称为缓存未命中。在这样的事 
件中，我们计算新的像素着色来填充这些洞。由于重复使用t - 1 
----------------------- Page 569-----------------------
pt-10 pt0 pt-11pt1t图12.6。在时间t的绿色和蓝色三角形。 
1和在时间t之后的帧。两个像素中心的绿色三角形上的三维点pti， 
与像素区域一起被反向重投影到点pt.1i。可以看出，pt.0被遮挡而 
pt0可见，在这种情况下，没有阴影结果可以重复使用。但是，p1 
在两个t都可见。1和t，因此可以在该点重复使用阴影。 （Nehab 
等人[1264]之后的插图。）12.2。阴影值的重投影技术523假设它 
们独立于任何类型的运动（物体，相机，光源），明智的做法是不 
在太多帧上重复使用阴影值。Nehab等人。[1264]建议在几次重用 
帧之后应始终进行自动刷新。一种方法是将屏幕分成n组，其中每 
组是2×2像素区域的伪随机选择。每个帧，单个组都会更新，这样 
可以避免重复使用像素值太长时间。反向重投影的另一种变体是存 
储速度缓冲区并在屏幕空间中执行所有测试，这避免了顶点的双重 
变换。为了获得更好的质量，还可以使用运行平均滤波器 
[1264,1556]，逐渐淘汰较旧的值。这些特别推荐用于空间抗锯齿， 
柔和阴影和全局照明。滤波器由cf（pt）=αc（pt）+（1.α）c（pt.1）， 
 （12.2）描述，其中c （pt）是 pt处的新阴影像素值，c （pt.1）是 
前一帧的反向重投影颜色，cf（pt）是应用滤镜后的最终颜色。Nehab 
等人。对某些用例使用α=3/5，但建议根据渲染的内容尝试不同的 
值。相反，前向重投影来自帧t的像素。1并将它们投射到第t帧， 
因此不需要双顶点着色。这意味着来自帧t的像素。图1中所示的 
方法散布在帧t上，而反向重投影方法从帧t收集像素值。1到框架 
t。这些方法还需要处理变得可见的遮挡区域，并且这通常使用不同 
----------------------- Page 570-----------------------
的启发式填孔方法来完成，即，从周围像素推断缺失区域中的值。 
Yu等人。[1952]使用前向重投影以便宜的方式计算景深效应。而不 
是经典的孔填充，Didyk等。通过在帧t上自适应地生成网格来避 
免空洞。1基于运动矢量。该网格使用深度测试进行渲染，投影到 
帧t，这意味着遮挡和折叠是作为使用深度测试栅格化自适应网格三 
角形的一部分来处理的。迪迪克等人。使用他们的方法从左眼重新 
投影到右眼，以便为虚拟现实生成立体对，其中两个图像之间的相 
干性通常很高。后来，Didyk等人。[351]呈现了用于执行时间上采 
样的感知激励方法，例如，将帧速率从40Hz增加到 120Hz。Yang 
和 Bowles[185,1945,1946]提出了从t和t +1的两个帧投射到这 
两个帧之间的t +δt的帧中的方法，即δt∈[0,1]。这些方法更有可 
能更好地处理遮挡情况，因为它们使用两个框架而不是一个框架。 
这些方法在游戏中用于将帧速率从30 FPS提高到60 FPS，这是可 
能的，因为他们的方法在不到 1毫秒的时间内运行。我们推荐他们 
的课程笔记[1946]和 Scherzer等人对时间相干方法的广泛调查。 
[1559]。Valient [1812]也使用重投影来加速杀戮地带中的渲染：暗 
影坠落。有关使用重投影进行时间抗锯齿的实现细节，请参见第 
5.4.2节末尾附近的众多参考文献。52412.图像空间效果12.3镜头 
光斑和绽放镜头光晕是由光线通过间接反射或其他非预期路径穿过 
镜头系统或眼睛引起的现象。耀斑可以通过几种现象分类，最明显 
的是晕和睫状冠。光晕是由透镜晶体结构的径向纤维引起的。它看 
起来像一个环绕光线的环，外边缘带红色，内部带紫色。无论光源 
----------------------- Page 571-----------------------
的距离如何，光晕都具有恒定的表观尺寸。睫毛冠来自镜片中的密 
度波动，并且表现为从一个点辐射的光线，其可以延伸超过光晕 
[1683]。当镜头的某些部分在内部反射或折射光线时，相机镜头也 
会产生次要效果。例如，由于相机的光圈叶片，可能会出现多边形 
图案。由于玻璃中的小凹槽，也可以看到条纹在挡风玻璃上涂抹 
[1303]。绽放是由镜头和眼睛的其他部分散射引起的，在灯光周围 
产生光晕，在场景的其他地方产生对比度变暗。摄像机通过使用电 
荷耦合器件 （CCD）将光子转换为电荷来捕获图像。当CCD中的充 
电点饱和并溢出到相邻站点时，在摄像机中发生绽放。作为一个类， 
晕，coronae和绽放被称为眩光效果。实际上，随着相机技术的改 
进，大多数此类工件越来越少。更好的设计，镜头罩和抗反射涂层 
可以减少或消除这些杂散重影伪影[598,786]。然而，现在这些效果 
通常以数字形式添加到真实照片中。由于计算机显示器产生的光强 
度有限，我们可以通过在我们的图像中添加这些效果来给人一种场 
景或物体亮度增加的印象[1951]。由于它们的共同使用，在照片， 
电影和交互式计算机图形中，绽放效果和镜头光晕几乎是陈词滥调。 
尽管如此，如果熟练使用，这样的效果可以给观众带来强烈的视觉 
提示。为了提供令人信服的效果，镜头眩光应随光源的位置而变化。 
King[899]创建了一组具有不同纹理的正方形来表示镜头光晕。然 
后将它们定向在从屏幕上的光源位置到屏幕中心的一条线上。当光 
线远离屏幕中心时，这些方块较小且更透明，随着光线向内移动而 
变得更大且更不透明。Maughan[1140]通过使用GPU计算屏幕区 
----------------------- Page 572-----------------------
域光源的遮挡来改变镜头光斑的亮度。他生成单像素强度纹理，然 
后用于衰减效果的亮度。Sekulic [1600]将光源渲染为单个多边形， 
使用遮挡查询硬件给出可见区域的像素数 （第 19.7.1节）。为了避 
免GPU停顿等待查询将值返回到CPU，结果将在下一帧中用于确 
定衰减量。由于强度可能以相当连续和可预测的方式变化，因此单 
帧延迟导致很少的感知混淆。Gj.l和Svendsen[539]首先生成深度 
缓冲区（它们也用于其他效果）并以螺旋形 12.3对其进行32次采 
样。Lens Flareand Bloom525图12.7。镜头光晕，星光眩光和 
绽放效果，以及景深和运动模糊[1208]。注意由于累积单独的图像 
而在一些移动的球上的选通伪像。（图片来自“Rthdribl”，由Masaki 
Kawase撰写。）在镜头眩光出现的区域中的图案，使用该结果来 
减弱光斑纹理。可见性采样在顶点着色器中完成，同时渲染光斑几 
何，从而避免硬件遮挡查询引起的延迟。通过绘制半透明广告牌或 
对明亮像素本身执行后处理过滤，可以以类似的方式执行场景中明 
亮物体或灯光的条纹。诸如侠盗猎车手V等游戏使用一组纹理应用 
于广告牌以实现这些和其他效果[293]。Oat[1303]讨论了使用可操 
纵滤波器来产生条纹效应。这种类型的滤波器不是在一个区域上对 
称地过滤，而是给出一个方向。沿该方向的Texel值相加在一起， 
产生条纹效应。使用下采样到宽度和高度的四分之一的图像，和使 
用乒乓缓冲区的两次传球，给出了令人信服的条纹效果。图12.7显 
示了这种技术的一个例子。526 12.图像空间效应图12.8。在游戏 
TheWitcher 3中产生太阳耀斑的过程。首先，将高对比度校正曲 
----------------------- Page 573-----------------------
线应用于输入图像以隔离未遮挡的太阳部分。接下来，以太阳为中 
心的径向模糊应用于图像。如左图所示，模糊系列执行，每个模糊 
操作在前一个输出上。这样做可以创建平滑，高质量的模糊，同时 
在每个过程中使用有限数量的样本来提高效率。所有模糊均以半分 
辨率执行以降低运行时成本。耀斑的最终图像与原始场景渲染相加。 
 （CD PROJEKTR，Witcher R是CD PROJEKTCapitalGroup的 
注册商标。Witcher游戏 c CD PROJEKTSA 由CD PROJEKTSA 
开发。保留所有权利。巫师的游戏是基于AndrzejSapkowski的散 
文。所有其他版权和商标均为其各自所有者的财产。）存在许多其 
他变体和技术，远远超出了广告牌。Mittring[1229]使用图像处理 
来隔离明亮的部分，对它们进行缩减采样，并在几个纹理中模糊它 
们。然后通过复制，缩放，镜像和着色在最终图像上再次合成它们。 
使用这种方法，艺术家不可能独立地控制每个耀斑源的外观：对每 
个耀斑应用相同的过程。但是，图像的任何明亮部分都会产生镜头 
眩光，例如镜面反射或表面的发光部分，或明亮的火花颗粒。 
Wronski [1919]描述了变形镜头光斑，它是20世纪50年代使用的 
电影摄影设备的副产品。Hullin等。[598,786]提供了各种重像伪影 
的物理模型，跟踪光束以计算效果。它提供了基于镜头系统设计的 
合理结果，以及精度和性能之间的权衡。Lee和 Eisemann[1012] 
在这项工作的基础上，使用避免昂贵的预处理的线性模型。 
Hennessy[716]给出了实现细节。图 12.8显示了生产中使用的典 
型镜头光晕系统。通过组合已经呈现的几种技术来执行布隆效应， 
----------------------- Page 574-----------------------
其中极亮区域溢出到相邻像素上。主要思想是12.4。景深527创建 
仅由 “过度曝光”的明亮物体组成的绽放图像，使其模糊，然后将 
其合成回正常图像。使用的模糊通常是高斯[832]，尽管最近与参考 
镜头的匹配表明分布具有更多的尖峰形状[512]。制作此图像的常用 
方法是通过滤镜：保留任何明亮像素，并使所有暗淡像素变为黑色， 
通常在转换点处进行一些混合或缩放[1616,1674]。为了仅在几个小 
物体上绽放，可以计算屏幕边界框以限制后处理模糊和复合通过的 
程度[1859]。该绽放图像可以以低分辨率渲染，例如，原始的宽度 
和高度的一半到八分之一的任何地方。这样做可以节省时间，并有 
助于提高过滤效果。这种低分辨率图像模糊并与原始图像组合。分 
辨率的降低用于许多后处理效果，如压缩或以其他方式降低颜色分 
辨率的技术[1877]。可以对绽放图像进行多次下采样，并从所生成 
的图像集中重新采样，从而在最小化采样成本的同时提供更宽的模 
糊效果[832,1391,1918]。例如，在屏幕上移动的单个亮像素可能导 
致闪烁，因为它可能在某些帧中不被采样。由于目标是在明亮的地 
方看起来过度曝光的图像，因此该图像的颜色会根据需要进行缩放 
并添加到原始图像中。添加剂混合使颜色饱和，然后变为白色，这 
通常是所需的。一个例子如图 12.9所示。Alpha混合可用于更多的 
艺术控制[1859]。可以过滤高动态范围图像而不是阈值处理，以获 
得更好的结果[512,832]。可以分别计算低动态范围和高动态范围的 
大小，并以更有说服力的方式捕获不同的现象[539]。其他变体是可 
能的，例如，前一帧的结果也可以添加到当前帧，为动画对象提供 
----------------------- Page 575-----------------------
条纹发光[815]。12.4景深对于给定设置下的相机镜头，存在物体聚 
焦的范围，其景深。超出此范围的物体是模糊的 - 更远的外部，模 
糊。在摄影中，这种模糊性与光圈大小和焦距有关。减小孔径尺寸 
会增加景深，即更广泛的深度是聚焦，但减少了形成图像的光量（第 
9.2节）。在室外白天场景拍摄的照片通常具有大的景深，因为光量 
足以允许小孔径尺寸，理想地是针孔照相机。在光线昏暗的房间内， 
景深明显变窄。因此，控制景深效果的一种方法是将其与色调映射 
联系起来，使得当光级降低时，离焦对象变得模糊。另一个是允许 
手动艺术控制，改变焦点和增加景深以获得所需的戏剧效果。请参 
见图 12.10中的示例。528 12.图像 - 空间效果双通道模糊添加原 
始和放大的模糊色调映射亮通滤波器和下采样图 12.9。高动态范围 
色调映射和绽放。通过使用色调映射并向原始图像添加后处理绽放 
来产生较低图像[1869]。（图片来自 “孤岛惊魂”，由Ubisoft提 
供。）12.4。景深529图12.10。景深取决于相机的焦点。（用G3D 
渲染的图像，由MorganMcGuire[209,1178]提供。）积累缓冲区 
可用于模拟景深[637]。见图 12.11。通过改变镜头上的视图位置并 
保持焦点固定，相对于它们与该焦点的距离，物体将变得模糊。然 
而，与其他累积效果一样，该方法以每个图像多次渲染的高成本来 
实现。也就是说，它确实会收敛到正确的地面实况 530 12.图像空 
间效果观察者焦平面图12.11。通过积累的景深。观察者的位置移 
动很小，使视图方向指向焦点。将每个渲染图像相加在一起，并显 
示所有图像的平均值。图像，可用于测试。通过改变光线在光圈上 
----------------------- Page 576-----------------------
的位置，光线跟踪也可以收敛到物理上正确的结果。为了提高效率， 
许多方法可以在失焦的对象上使用较低级别的细节。虽然对于交互 
式应用是不切实际的，但是在镜头上移动视图位置的累积技术提供 
了考虑应该在每个像素处记录什么的合理方式。表面可以分为三个 
区域：聚焦在焦点距离附近的焦点 （焦点场或中场），超出 （远场） 
和近距离（近场）的区域。对于焦距处的表面，每个像素显示清晰 
焦点的区域，因为所有累积的图像具有大致相同的结果。聚焦场是 
一定深度范围，其中对象仅略微失焦，例如，小于半个像素 
[209,1178]。这个范围是摄影师所说的景深。在交互式计算机图形 
学中，我们默认使用具有完美聚焦的针孔相机，因此景深指的是模 
糊近场和远场内容的效果。平均图像中的每个像素是在不同视图中 
看到的所有表面位置的混合，从而模糊了离焦区域，其中这些位置 
可以显着变化。该问题的一个有限解决方案是创建单独的图像层。 
渲染一个只有焦点对象的图像，其中一个对象超出，和其中一个更 
接近的对象。这可以通过改变近/远剪切平面位置来完成。近 12.4。 
景深531和远场图像模糊，然后所有三个图像以从前到后的顺序合 
成在一起[1294]。这种2.5维方法，因为二维图像被赋予深度并组 
合，因此在某些情况下提供了合理的结果。当物体跨越多个图像时， 
该方法会发生故障，从模糊到焦点突然发生。此外，所有过滤的对 
象都具有均匀的模糊性，没有任何由于距离引起的变化[343]。查看 
过程的另一种方法是考虑景深如何影响表面上的单个位置。想象一 
下表面上的一个小点。当表面处于焦点时，通过单个像素看到点。 
----------------------- Page 577-----------------------
如果表面没有焦点，根据不同的视图，点将出现在附近的像素中。 
在极限处，点将在像素网格上定义实心圆。这被称为混乱的圈子。 
在摄影中，焦点领域外的区域的美学质量被称为散景，来自日语单 
词 “blur”。 （这个单词发音为 “bow-ke”， “bow”表示 “bow 
andarrow”和 “bow”通过孔径的光通常均匀分布，而不是一些 
高斯分布[1681]。混淆区域的形状与光圈叶片的数量和形状以及尺 
寸有关。廉价的相机会产生五角形而不是完美圆形的模糊。目前大 
多数新相机有七个刀片，高端型号有九个或更多。更好的相机有圆 
形刀片，这使得散景圆形[1915]。对于夜间拍摄，光圈尺寸更大并 
且可以具有更圆形的图案。Simila如果镜头光晕和花朵的放大效果 
如何，我们有时会为混乱的圆圈呈现六边形，暗示我们正在用物理 
相机拍摄。六角形结果是一种特别容易的形状，可以在一个可分离 
的两次后过程模糊中产生，因此在许多游戏中使用，正如 
Barr'e-Brisebois[107]所解释的那样。计算景深效果的一种方法是 
将每个像素的位置放在曲面上，并将其着色值散布到此圆或多边形 
内的邻居。请参见图12.12的左侧。散射的想法不能很好地映射到 
像素着色器功能。像素着色器可以有效地并行操作，因为它们不会 
将结果传播给邻居。一种解决方案是为每个近场和远场像素 
[1228,1677,1915]渲染精灵 （第 13.5节）。每个精灵都渲染到一个 
单独的场图层，精灵的大小由混淆圆的半径决定。每个图层存储所 
有重叠精灵的平均混合和，然后在下一个图层上合成一个图层。这 
种方法有时被称为前向映射技术[343]。即使使用图像下采样，这种 
----------------------- Page 578-----------------------
方法也可能很慢，更糟糕的是，需要花费不同的时间，特别是当焦 
点场很浅时[1517,1681]。性能的可变性意味着难以管理帧预算，即， 
分配用于执行所有渲染操作的时间量。不可预测性可能导致错过帧 
和不均衡的用户体验。考虑混淆圈的另一种方法是假设像素周围的 
局部邻域具有大约相同的深度。有了这个想法，就可以进行收集操 
作。见图 12.12的右侧。Pixel532 12.图像空间效果图12.12。散 
射操作采用像素的值并将其传播到相邻区域，例如通过渲染圆形精 
灵。在聚集中，对相邻值进行采样并用于影响像素。GPU的像素着 
色器经过优化，可通过纹理采样执行收集操作。着色器已针对从先 
前渲染过程收集结果进行了优化。因此，执行景深效果的一种方法 
是根据每个像素的深度模糊表面[1672]。深度定义了一个混乱的圆 
圈，即应该采样的区域的宽度。这种聚集方法称为反向映射或反向 
映射方法。大多数实用算法都从一个视点的初始图像开始。这意味 
着，从一开始，一些信息就会丢失。场景的其他视图将在此单个视 
图中看到部分曲面不可见。正如Pesce所指出的那样，我们应该尽 
可能地利用我们所拥有的可见样本[1390]。多年来，收集技术不断 
发展，每项技术都在以前的工作中得到改进。我们提出了 Bukowski 
等人的方法。[209,1178]及其遇到的问题的解决方案。他们的方案 
基于深度为每个像素生成表示混淆半径圆的带符号值。这个半径可 
以从相机设置和特征中得出，但是艺术家经常喜欢控制效果，所以 
近距离，焦点的范围，可以指定远场和远场。半径'符号指定像素是 
在近场还是远场中，其中.0.5 <r<0.5在焦点场中，其中半像素模 
----------------------- Page 579-----------------------
糊被认为是焦点。然后使用包含混淆圆半径的该缓冲器将图像分成 
两个图像，近场和其余图像，并且每个图像被下采样并且在具有可 
分离滤波器的两次通过中模糊。执行该分离以解决关键问题，即近 
场中的对象应具有模糊边缘。如果我们基于其半径模糊每个像素并 
输出到单个图像，则前景对象可能是模糊的但具有锐边。例如，当 
从前景对象穿过轮廓边到焦点对象时，样本半径将下降到零，因为 
焦点对象不需要模糊。这将导致前景对象对其周围像素的影响突然 
下降，从而产生锐边。见图 12.13。12.4。景深533图12.13。近 
场模糊。左侧是原始图像，没有景深效果。在中间，近场中的像素 
是模糊的，但是在焦点场附近具有锐边。右侧显示了使用在更远的 
内容上合成的单独的近场图像的效果。 （使用G3D[209,1178]生成 
的图像。）我们想要的是让近场中的物体平滑地模糊并产生超出其 
边界的效果。这是通过在单独的图像中写入和模糊近场像素来实现 
的。此外，为该近场图像的每个像素分配一个α值，表示其混合因子， 
这也很模糊。在创建两个单独的图像时使用联合双边过滤和其他测 
试;有关详细信息，请参阅文章[209,1178]和其中提供的代码。这些 
测试提供若干功能，例如，对于远场模糊，丢弃比采样像素更远的 
相邻对象。在基于混淆半径的圆圈执行分离和模糊之后，完成合成。 
混淆圆半径用于在原始对焦图像和远场图像之间进行线性插值。该 
半径越大，使用的模糊远场结果越多。然后使用近场图像中的α覆盖 
值来在该内插结果上混合近图像。通过这种方式，近场的模糊内容 
适当地扩散到幕后的场景上。见图 12.10和 12.14。该算法有几个 
----------------------- Page 580-----------------------
简化和调整，使其看起来合理。可以以其他方式更好地处理粒子， 
并且透明度可能导致问题，因为这些现象涉及每个像素多个z深度。 
尽管如此，由于唯一的输入是颜色和深度缓冲，并且仅使用三个后 
处理过程，因此该方法简单且相对稳健。基于混淆圆和将近场和远 
场分离成单独图像（或图像集）的采样思想是为了模拟景深而开发 
的各种算法中的共同主题。我们将讨论视频游戏中使用的一些新方 
法（如前面的方法所示），因为这些方法需要高效，健壮且具有可 
预测的成本。53412。图像空间效应图12.14。 “巫师”中的景深 
3.近场和远场模糊令人信服地融入焦点场。 （CDPROJEKTR，The 
Witcher R是CDPROJEKTCapitalGroup的注册商标.Witcher游 
戏 c CD PROJEKT SA 由 CD PROJEKT SA 开发。保留所有权 
利.Witcher游戏基于AndrzejSapkowski的散文。所有其他版权和 
商标是他们各自所有者的财产。）第一种方法使用我们将在下一节 
重新审视的方法：运动模糊。为了回到混淆圆的想法，想象一下将 
图像中的每个像素转换成相应的混淆圆，其强度与圆的面积成反比。 
按排序顺序渲染这组圆圈将为我们提供最佳结果。这让我们回到了 
分散的想法，所以通常是不切实际的。正是这种心理模型在这里很 
有价值。给定像素，我们想要确定与位置重叠的所有混淆圆并按排 
序顺序将它们混合在一起。见图 12.15。使用场景的最大混淆半径 
圆圈，对于每个像素，我们可以检查该半径内的每个邻居并找出其 
混淆圈是否包括我们当前的位置。然后对影响像素的所有这些重叠 
相邻样本进行分类和混合[832,1390]。这种方法是理想的，但是对 
----------------------- Page 581-----------------------
发现的碎片进行排序在GPU上会过于昂贵。相反，使用了一种称为 
 “聚集时分散”的方法，我们通过查找哪些邻居会分散到像素的位 
置来收集。选择具有最低z深度（最近距离）的重叠邻居来表示更 
近的图像。在z深度上相当接近的任何其他重叠邻居都添加了α混合 
贡献，取平均值，并且颜色和alpha存储在 “前景”层中。这种混 
合不需要排序。类似地对所有其他重叠邻居求和并求平均，并将结 
果放在单独的 “背景”层中。前景层和背景层不对应于近场和远场， 
它们是每个像素区域发现的任何内容。然后在背景 12.4上合成前景 
图像。景深535图12.15。重叠的圈子混乱。左边是一个有五个点 
的场景，全部都是焦点。想象一下，红点最接近观众，在近场，接 
着是橙色点;绿点在焦点领域;蓝色和紫色的点在远场中，按此顺序 
排列。右图显示了应用景深导致的混淆圆圈，较大的圆圈每个像素 
的影响较小。绿色没有变化，因为它是焦点。中心像素仅与红色和 
橙色圆圈重叠，因此它们混合在一起，红色与橙色混合，以提供像 
素颜色。图像，产生近场模糊效果。虽然这种方法听起来很复杂， 
但应用各种采样和过滤技术可以提高效率。有关几种不同的实现， 
请参阅 Jimenez [832] ，Sousa [1681] ，Sterna [1698]和 
Courr`eges [293,294]的演示文稿，并查看图12.16中的示例。在 
一些较旧的视频游戏中使用的另一种方法基于计算热扩散的想法。 
该图像被认为是向外扩散的热分布，每个混淆圆表示该像素的热导 
率。聚焦区域是完美的绝缘体，没有扩散。卡斯等人。[864]描述了 
如何将一维热扩散系统视为三对角矩阵，其可以在每个样本的恒定 
----------------------- Page 582-----------------------
时间内求解。存储和求解这种类型的矩阵在计算着色器上很好地工 
作，因此从业者已经开发了几种实现，其中图像沿着每个轴分解成 
这些一维系统[612,615,1102,1476]。混乱圈子的可见性问题仍然存 
在，通常通过基于深度生成和合成单独的层来解决。如果有的话， 
这种技术并不能很好地处理混乱圈中的不连续性，因此今天的好奇 
心主要是好奇心。特定的景深效果是由明亮的光源或帧中的反射引 
起的。光的或镜面反射的混淆圆可以比框架中靠近它的物体明亮得 
多，即使它的调光效果散布在一个区域上。虽然将每个模糊像素渲 
染为精灵是昂贵的，但这些明亮的光源具有更高的对比度，因此更 
清晰地显示出孔径形状。53612.图像空间效应图12.16。近和远的 
景深与五角形散景在前景中明亮的反射杆上。 （使用BakingLab演 
示生成的图像，由 MattPettineo[1408]提供。）其余的像素差别 
较小，因此形状不太重要。有时， “散景”一词（错误地）用于描 
述这些明亮的区域。检测高对比度的区域并将这些少数明亮像素渲 
染为精灵，同时对其余像素使用聚集技术，给出具有定义的散景的 
结果，同时也是有效的[1229,1400,1517]。见图12.16。计算着色 
器也可以承受，创建高质量的总面积表，用于收集景深和有效的散 
景[764]。我们已经介绍了渲染景深和明亮散景效果的众多方法中的 
一些，描述了一些用于使过程高效的技术。随机光栅化，光场处理， 
和其他方法也已探索过。Vaidyanathan等人的文章。[1806]总结 
了先前的工作，并且McGuire[1178]给出了一些实现的概述。12.5 
运动模糊为了呈现令人信服的图像序列，重要的是具有稳定且足够 
----------------------- Page 583-----------------------
高的帧速率。平滑且连续的运动是优选的，并且帧速率太低而表现 
为不平稳的运动。电影以24FPS显示，但是剧院是黑暗的，并且眼 
睛的时间响应对昏暗光线中的闪烁不太敏感。此外，电影放映机以 
24FPS更改图像，但通过在显示下一个图像之前重新显示每个图像 
2-4次来减少闪烁。也许最重要的是，每个电影帧通常都是运动模 
糊的图像;默认情况下，交互式图形图像不是。在电影里运动模糊 
来自物体在帧期间或从相机运动中穿过屏幕的运动。效果来自相机 
12.5的时间。运动模糊537图12.17。在左侧，相机固定，汽车模 
糊。在右侧，摄像头跟踪汽车，然后背景模糊。（图片由 Morgan 
McGuire等人[1173]提供。）在该帧上花费 1/24秒的时间内，快 
门打开1/40至 1/60秒。我们习惯于在电影中看到这种模糊，并认 
为它是正常的，所以我们希望在视频游戏中看到它。快门打开 1/500 
秒或更短时间可以产生多动效果，首先出现在角斗士和拯救大兵瑞 
恩等电影中。快速移动的物体看起来没有运动模糊，在帧之间 “跳 
跃”许多像素。这可以被认为是一种类似于锯齿的混叠，但在时间 
上是时间而不是空间。运动模糊可以被认为是时域中的抗锯齿。正 
如提高显示分辨率可以减少锯齿而不是消除它们一样，提高帧速率 
并不能消除对运动模糊的需求。视频游戏的特点是相机和物体的快 
速运动，因此运动模糊可以显着改善其视觉效果。实际上，在没有 
[51,437,584]的情况下，具有运动模糊的30 FPS通常看起来比60 
FPS更好。运动模糊取决于相对运动。如果对象在屏幕上从左向右 
移动，则它在屏幕上水平模糊。如果相机正在跟踪移动的物体，则 
----------------------- Page 584-----------------------
物体不会模糊 - 背景会移动。见图12.17。这是真实世界相机的工 
作原理，一位优秀的导演知道要拍摄一张照片，以便感兴趣的区域 
成为焦点而且不会模糊。与景深类似，累积一系列图像提供了一种 
创建运动模糊的方法[637]。当快门打开时，帧具有持续时间。在此 
跨度中的不同时间渲染场景，并为每个场景重新定位相机和对象。 
将得到的图像混合在一起，得到模糊的图像，其中物体相对于相机 
的视图移动。对于实时渲染，这样的过程通常会适得其反，因为它 
可以显着降低帧速率。此外，如果对象快速移动，则只要各个图像 
变得可辨别，就会看到伪影。第 525页的图 12.7也显示了此问题。 
随机光栅化可以避免混合多个图像时出现的重影伪影，反而产生噪 
音[621,832]。如果需要的是移动的建议而不是纯粹的现实主义，那 
么积累概念可以巧妙地使用。想象一下，生成了一个运动模型的八 
个帧并将其求和到一个高精度缓冲区，然后对其进行平均和显示。 
在第九帧，再次渲染模型并且ac 53812.图像空间效果累积，但此 
时第一帧的渲染再次执行并从求和结果中减去。缓冲区现在有八帧 
模糊模型，第2帧到第9帧。在下一帧，我们减去第2帧并在第10 
帧中添加，再次给出8帧的总和，3到 10.这给出了高度模糊的艺术 
效果，代价是每帧渲染两次场景[1192]。实时图形需要比多次渲染 
帧更快的技术。可以通过平均一组视图来呈现该景深和运动模糊， 
从而显示两种现象之间的相似性。为了有效地渲染这些效果，两种 
效果都需要将其样本分散到相邻像素，但我们通常会收集。他们还 
需要处理多层不同的模糊，并在给定单个起始帧的内容的情况下重 
----------------------- Page 585-----------------------
建遮挡区域。有一些不同的运动模糊源，每种都有可以应用于它的 
方法。这些可以按照大致递增的复杂度顺序分类为相机方向变化， 
相机位置变化，对象位置变化和对象方向变化。如果相机保持其位 
置，整个世界可以被认为是观众周围的天空盒 （第 13.3节）。正好 
方向的变化会在整个图像上产生模糊的方向。给定方向和速度，我 
们沿着这个方向对每个像素进行采样，速度决定滤波器的宽度。这 
种定向模糊称为线积分卷积（LIC）[219,703]，它也用于可视化流 
体流动。Mitchell[1221]讨论了给定运动方向的运动模糊三次环境 
贴图。如果相机沿其视轴旋转，则使用圆形模糊，每个像素的方向 
和速度相对于旋转中心变化[1821]。如果相机的位置正在改变，则 
视差开始发挥作用，例如，远处的物体移动得较慢，因此模糊较少。 
当相机向前移动时，视差可能会被忽略。径向模糊可能是足够的并 
且可以夸大以获得显着效果。图 12.18显示了一个示例。为了增加 
真实感，比如说比赛游戏，我们需要一个模糊来正确计算每个物体 
的运动。如果向前看时向前移动，称为计算机图形中的平移，1深 
度缓冲区通知我们每个对象应该模糊多少。物体越近，越模糊。如 
果向前移动，运动量会更复杂。Rosado[1509]描述了使用前一帧 
的相机视图矩阵来动态计算速度。我们的想法是将像素的屏幕位置 
和深度转换回世界空间位置，然后使用前一帧的相机将此世界点转 
换为屏幕位置。这些屏幕空间位置之间的差异是速度矢量，其用于 
模糊该像素的图像。合成对象可以按四分之一屏幕尺寸渲染，既可 
以节省像素处理，又可以滤除采样噪声[1428]。如果物体彼此独立 
----------------------- Page 586-----------------------
地移动，情况会更复杂。一种简单但有限的方法是模拟和渲染模糊 
本身。这个 1Incinematographypan意味着向左或向右旋转相机 
而不改变位置。侧向移动是 “卡车”，垂直移动到 “基座”.12.5。 
运动模糊539图12.18。径向模糊，增强运动感。（图片来自 “刺 
客信条”，由Ubisoft提供。）是绘制线段以表示移动粒子的基本 
原理。该概念可以扩展到其他对象。想象一把剑在空中划过。在刀 
片前后，沿其边缘添加两个多边形。这些可以在运行中建模或生成。 
这些多边形使用每个顶点的alpha不透明度，因此多边形与剑相遇 
时，它是完全不透明的，并且在多边形的外边缘，alpha是完全透 
明的。这个想法是模型在运动方向上具有透明度，模拟剑在（假想 
的）快门打开的部分时间内覆盖这些像素的效果。此方法适用于简 
单模型，例如摆动剑刀，但纹理，高光和其他特征也应模糊。每个 
移动的表面都可以被认为是单独的样本。我们想分散这些样本，早 
期的运动模糊方法就这样做了，通过在运动方向上扩展几何形状 
[584,1681]。这种几何操作是昂贵的，因此已经开发了分散即聚集 
的方法。对于景深，我们将每个样本扩展到其混淆圆的半径。对于 
移动样本，我们改为 540 12.图像空间效应外部内部不透明内部外 
部图12.19。在左侧，水平移动的单个样本提供透明结果。在右侧， 
七个样品产生逐渐变细的效果，因为较少的样品覆盖外部区域。中 
间的区域是不透明的，因为在整个框架期间它总是被一些样品覆盖。 
 （在Jimenez之后[832]。）沿着框架中行进的路径拉伸每个样本， 
类似于 LIC。快速移动的样本覆盖更多区域，因此每个位置的效果 
----------------------- Page 587-----------------------
较差。理论上，我们可以在场景中获取所有样本，并按排序顺序将 
它们绘制为半透明线段。可视化如图12.19所示。随着拍摄的样本 
越来越多，生成的模糊在其前缘和后缘上都有一个平滑的透明渐变， 
就像我们的剑示例一样。要使用这个想法，我们需要知道每个像素 
表面的速度。广泛采用的工具是使用速度缓冲器[584]。要创建此缓 
冲区，请在模型的每个顶点处插入屏幕空间速度。可以通过将两个 
建模矩阵应用于模型来计算速度，一个用于前一帧，一个用于当前。 
顶点着色器程序计算位置差异并将此向量转换为相对屏幕空间坐 
标。可视化如图 12.20所示。Wronski [1912]讨论了导出速度缓冲 
并将运动模糊与时间抗锯齿相结合。Courr`eges [294]简要介绍了 
DOOM （2016）如何实现这种组合，比较结果。一旦形成速度缓 
冲器，就知道每个像素处的每个物体的速度。还会渲染不模糊的图 
像。请注意，我们遇到与运动模糊类似的问题，就像我们对景深一 
样，计算效果所需的所有数据都不能从单个图像中获得。对于景深， 
理想的是将多个视图平均在一起，其中一些视图将包括其他视图中 
未见的对象。对于交互式运动模糊，我们从定时序列中取出一个帧 
并将其用作代表图像。我们尽可能地使用这些数据，但重要的是要 
意识到所需的所有数据并不总是存在，这可能会产生伪影。给定此 
帧和速度缓冲区，我们可以使用散射即聚集系统来重建影响每个像 
素的对象，以进行运动模糊。我们从 McGuire等人描述的方法开始。 
[208,1173]，由 Sousa [1681]和 Jimenez [832]进一步发展 
 （Pettineo[1408]提供代码）。在第一遍中，计算屏幕的每个部分 
----------------------- Page 588-----------------------
的最大速度，例如，每个8×8像素块（第23.1节）。结果是每个 
瓦片具有最大速度的缓冲器，具有方向和幅度的矢量。在第二遍中， 
针对每个图块检查该图块结果缓冲区的3×3区域，以便找到最高的 
最大值。这个过程确保 12.5。运动模糊541图12.20。由于物体和 
相机移动导致的运动模糊。嵌入深度和速度缓冲区的可视化。（图 
片由MorganMcGuire等人[1173]提供。）瓷砖中快速移动的物体 
将由相邻的瓷砖来计算。也就是说，我们对场景的初始静态视图将 
变为对象模糊的图像。这些模糊可以重叠到相邻的瓷砖中，因此这 
些瓷砖必须检查足够宽的区域以找到这些移动的物体。在最后一遍 
中，计算运动模糊图像。与景深类似，检查每个像素的邻域以寻找 
可能快速移动并与像素重叠的样本。不同之处在于每个样本都有自 
己的速度，沿着自己的路径。已经开发了不同的方法来过滤和混合 
相关样品。一种方法使用最大速度的大小来确定核的方向和宽度。 
如果该速度小于半个像素，则不需要运动模糊[1173]。否则，沿最 
大速度方向采样图像。请注意，遮挡在这里很重要，因为它与景深 
有关。静态对象背后的快速移动模型不应该在此对象顶部出现模糊 
效果。如果发现相邻样本的距离足够接近像素的z深度，则认为它 
是可见的。这些样本混合在一起形成前景的贡献。在图 12.19中， 
运动模糊对象有三个区域。不透明区域完全被前景对象覆盖，因此 
无需进一步混合。外部模糊区域有，在原始图像（七个蓝色像素的 
顶行）中，可以在前景可以混合的那些像素处获得背景颜色。但是， 
内部模糊区域不包含背景，因为原始图像仅显示前景。对于这些像 
----------------------- Page 589-----------------------
素，通过对邻居542进行滤波来估计背景。图像空间效果采样的像 
素不在前景中，理由是背景的任何估计都优于无。一个例子如图 
12.20所示。有几种采样和过滤方法可用于改善这种方法的外观。 
为了避免重影，样本位置随机抖动半个像素[1173]。在外部模糊区 
域，我们有正确的背景，但这有点模糊，避免了内部模糊估计背景 
的刺耳不连续性[832]。像素处的对象可以在与其3×3块的集合的 
主导速度不同的方向上移动，因此在这种情况下可以使用不同的滤 
波方法[621]。Bukowski等人。[208]提供其他实现细节并讨论针对 
不同平台扩展方法。这种方法对于运动模糊效果相当好，但其他系 
统肯定是可能的，在质量和性能之间进行权衡。例如，Andreev [51] 
使用速度缓冲和运动模糊，以便在以30 FPS渲染的帧之间进行插 
值，有效地提供60FPS的帧速率。另一个概念是将运动模糊和景深 
组合到单个系统中。关键思想是将速度矢量和混淆圆相结合，以获 
得统一的模糊核[1390,1391,1679,1681]。已经研究了其他方法， 
随着GPU的功能和性能的提高，研究将继续进行。例如，Munkberg 
等人。[1247]使用随机和交织采样以低采样率渲染景深和运动模糊。 
在随后的过程中，他们使用快速重建技术[682]来减少采样伪像并恢 
复运动模糊和景深的平滑属性。在视频游戏中，玩家的体验通常不 
像观看电影，而是直接控制，观点以不可预测的方式改变。在这些 
情况下，如果以纯粹基于摄像机的方式进行，则运动模糊有时会很 
难应用。例如，在第一人称射击游戏中，一些用户发现旋转分散的 
模糊或晕动病的来源。在 “使命召唤：高级战争”中，有一个选项 
----------------------- Page 590-----------------------
可以消除由于相机旋转引起的运动模糊，因此效果仅应用于移动物 
体。艺术团队在游戏过程中消除旋转模糊，为一些电影序列打开它。 
仍然使用平移运动模糊，因为它有助于在跑步时传达速度。或者， 
艺术方向可用于修改运动模糊的内容，以物理胶片相机无法模仿的 
方式。假设宇宙飞船进入用户的视野并且摄像机不跟踪它，即玩家 
没有转过头。使用标准运动模糊，即使玩家的眼睛跟随它，船也将 
模糊不清。如果我们假设玩家将跟踪一个物体，我们可以相应地调 
整我们的算法，在观察者的眼睛跟随它时模糊背景并保持物体不模 
糊。眼动追踪设备和更高的帧速率可能有助于改善运动模糊的应用 
或完全消除它。然而，这种效果引起了电影的感觉，因此它可能继 
续以这种方式或其他原因（例如含有疾病或头晕）找到用途。运动 
模糊可能会继续使用，应用它可以像科学一样多的艺术。12.5。运 
动模糊543进一步阅读和资源有几本教科书专门用于传统的图像处 
理，如冈萨雷斯和伍兹[559]。特别是，我们想要注意Szeliski的计 
算机视觉：算法和应用[1729]，因为它讨论了图像处理和许多其他 
主题以及它们与合成渲染的关系。本书的电子版可免费下载;请访问 
我们的网站realtimerendering.com获取链接。巴黎等人的课程笔 
记。[1355]提供双边过滤器的正式介绍，也提供了许多使用它们的 
例子。McGuire等人的文章。[208,1173]和Guertin等人。[621] 
清楚地阐述了他们各自关于运动模糊的工作;代码可用于其实现。纳 
瓦罗等人。[1263]提供关于交互式和批量应用的运动模糊的全面报 
告。Jimenez [832]给出了详细的，详细说明的过滤和采样问题以及 
----------------------- Page 591-----------------------
散景，运动模糊，绽放和其他电影效果中涉及的解决方案。Wronski 
[1918]讨论了重构一个复杂的后处理管道以提高效率。有关模拟一 
系列光学镜头效果的更多信息，请参阅 Gotanda [575]组织的 
SIGGRAPH课程中的讲座。第 13章超越多边形 “风景画实际上只 
是一个空气中没有任何痕迹的空气，告诉你空气中的物体有多远。” 
-LennartAnderson用三角形建模表面通常是解决描绘问题最直接 
的方法场景中的对象。然而，三角形只有一点是好的。用图像表示 
对象的一个​ ​ 很大的优点是渲染成本与渲染的像素数成比例，而 
不是与几何模型中的顶点数成比例。所以，使用基于图像的渲染是 
一种更有效的渲染模型的方法。然而，图像采样技术具有比这更广 
泛的用途。许多物体，如云和毛皮，很难用三角形表示。分层半透 
明图像可用于显示此类复杂曲面在本章中，首先对基于图像的渲染 
进行比较，并与传统的三角渲染进行对比，并给出了算法概述。然 
后，我们描述了常用的技术，如精灵，广告牌，冒名顶替者，粒子， 
点云和体素，以及更多的实验方法。13.1渲染光谱渲染的目标是在 
屏幕上描绘一个对象;我们如何实现这一目标是我们的选择。渲染场 
景没有一种正确的方法。每种渲染方法都是现实的近似，至少如果 
照片写实是目标。三角形具有以任何视图以合理的方式表示对象的 
优点。当相机移动时，对象的表示不必改变。然而，为了提高质量， 
我们可能希望在观察者更接近物体时替换更高度详细的模型。相反， 
如果距离较远，我们可能希望使用模型的简化形式。这些被称为等 
级54554613.超越多边形空间路径和射线追踪图 13.1。渲染光谱。 
----------------------- Page 592-----------------------
 （Lengyel之后[1029]。）详细技术 （第 19.9节）。它们的主要目 
的是使场景显示更快。当对象从观看者退回时，其他渲染和建模技 
术可以起作用。通过使用图像而不是三角形来表示对象，可以获得 
速度。使用可以快速发送到屏幕的单个图像来表示对象通常更便宜。 
表示渲染技术连续体的一种方法来自 Lengyel [1029]，如图13.1 
所示。我们将首先从光谱的左侧返回到右侧更熟悉的区域。13.2固 
定视图效果对于复杂几何体和着色模型，以交互速率重新渲染整个 
场景可能会很昂贵。可以通过限制观看者的移动能力来执行各种形 
式的加速。最严格的情况是相机根本不移动。在这种情况下，可以 
只进行一次渲染。例如，想象一个带栅栏的牧场作为场景的静态部 
分，一匹马穿过它。牧场和围栏渲染一次，然后将颜色和z缓冲区 
存储起来。每个帧，这些缓冲区用于初始化颜色和z缓冲区。然后 
马本身就需要渲染以获得最终图像。如果马在围栏后面，存储和复 
制的z深度值将使马模糊不清。请注意，在这种情况下，马不会投 
下阴影，因为场景是不变的。可以进行进一步的细化，例如，可以 
确定马的阴影的影响区域，然后仅需要在存储的缓冲区的顶上评估 
静态场景的这个小区域。关键点在于对图像中每个像素的颜色何时 
或如何设置没有限制。对于固定视图，通过将复杂几何模型转换为 
可以重复使用多个帧的简单缓冲区集，可以节省大量时间。在计算 
机辅助设计（CAD）应用程序中常见的是，所有建模对象都是静态 
的，并且在用户执行各种操作 13.3时视图不会改变。Skyboxes547 
ations。一旦用户移动到所需视图，就可以存储颜色和z缓冲区以 
----------------------- Page 593-----------------------
便立即重用，然后每帧绘制用户界面和突出显示的元素。这允许用 
户快速注释，测量或以其他方式与复杂的静态模型交互。通过在缓 
冲器中存储附加信息，可以执行其他操作。例如，一个三维绘图程 
序也可以通过存储对象 ID，法线，和给定视图的纹理坐标，并将用 
户的交互转换为纹理本身的更改。与静态场景相关的概念是黄金线 
程，也不那么诗意地称为自适应细化或渐进细化。这个想法是，当 
观看者和场景是静态的时，计算机可以随着时间的推移产生更好和 
更好的图像。可以使场景中的对象看起来更逼真。这种更高质量的 
渲染可以突然交换或在一系列帧中混合。该技术在CAD和可视化应 
用中特别有用。可以进行许多不同类型的改进。可以随时间生成每 
个像素内的不同位置处的更多样本，并且沿途显示平均结果，从而 
提供抗锯齿[1234]。这同样适用于景深，其中样本在镜片和像素上 
随机分层[637]。可以使用更高质量的阴影技术来创建更好的图像。 
我们还可以使用更多涉及的技术，例如光线或路径跟踪，然后淡入 
新图像。一些应用程序进一步采用固定视图和静态几何的概念，以 
允许在胶片质量图像内交互式编辑照明。称为重新点亮，其想法是 
用户选择场景中的视图，然后使用其数据进行离线处理，从而将场 
景表示为一组缓冲区或更复杂的结构。例如，Ragan-Kelley等。 
[1454]将阴影样本与最终像素分开。这种方法允许它们执行运动模 
糊，透明效果和抗锯齿。他们还使用自适应细化来改善图像质量。 
Pellacini等。[1366]扩展基本重新点亮以包括间接全局照明。这些 
技术非常类似于延迟着色方法 （在第20.1节中描述）。主要区别在 
----------------------- Page 594-----------------------
于，这些技术用于分摊多帧上昂贵渲染的成本，延迟着色使用它们 
来加速帧内的渲染。13.3Skyboxes环境地图 （第 10.4节）表示本 
地空间体积的入射辐射。虽然这些地图通常用于模拟反射，但它们 
也可以直接用于表示周围环境。一个例子如图 13.2所示。任何环境 
地图表示（例如全景图或立方体图）都可用于此目的。它的网格足 
够大，可以包含场景中的其他对象。这个网格称为天空盒。拿起这 
本书，看看它的左边或右边是否超出它。只用你的右眼看，然后你 
的左眼。书中边缘的转变比较54813.超越多边形图 13.2。Mission 
Dolores的全景，底部有三个视图。请注意视图本身如何不失真。 
 （图片由KenTurkowski提供。）背后的内容称为视差。这种效果 
对附近物体很重要，有助于我们在移动时感知相对深度。然而，对 
于远离观察者的物体或物体组，并且彼此足够靠近，当观察者改变 
位置时几乎不能检测到任何视差效果。例如，如果你移动一米，甚 
至一千米，一座遥远的山本身通常看起来并不明显。当您移动时， 
它可能会被附近的物体挡住，但是带走那些物体，山脉及其周围环 
境看起来一样。天空盒的网格通常以观察者为中心，随着它们一起 
移动。天空盒网格不必很大，因为通过保持相对位置，它看起来不 
会改变形状。对于如图 13.2所示的场景，观察者可能只有一小段距 
离才能发现它们并未真正相对于周围建筑物移动。对于更大规模的 
内容，例如星场或遥远的景观，用户通常不会移动得足够快，以至 
于物体大小，形状，或视差打破幻觉。Skyboxes通常在框网格上呈 
现为立方体贴图，因为每个面上的纹理像素密度相对相等。为了使 
----------------------- Page 595-----------------------
天空盒看起来很好，立方体贴图纹理分辨率必须足够，即每个屏幕 
像素的纹理像素[1613]。公式13.4。用于必要分辨率的光场渲染549 
是近似纹理分辨率=屏幕分辨率tan （fov/2）， （13.1）其中 “fov” 
是摄像机的视场。较低的视野值意味着立方体贴图必须具有更高的 
分辨率，因为立方体面的较小部分占据相同的屏幕尺寸。该公式可 
以通过观察立方体图的一个面的纹理必须覆盖90度的视野（水平和 
垂直）来导出。除了世界各地的盒子之外的其他形状也是可能的。 
例如，Gehling[520]描述了一种系统，其中使用扁平圆顶来表示天 
空。这种几何形状被发现最适合模拟在头顶移动的云。云本身通过 
组合和动画化各种二维噪声纹理来表示。因为我们知道天空盒落后 
于所有其他物体，所以我们可以进行一些小而有价值的优化。天空 
盒永远不必写入z缓冲区，因为它永远不会阻塞任何东西。如果首 
先绘制，则天空盒也不必从z缓冲区读取，然后网格可以是任何所 
需的大小，因为深度是无关紧要的。但是，在透明之前，在不透明 
对象之后绘制天空盒具有以下优点：场景中的对象已经覆盖了几个 
像素，降低渲染天空盒时所需的像素着色器调用次数[1433,1882]。 
13.4光场渲染辐射可以在不同的时间和不断变化的光照条件下从不 
同的位置和方向捕获。在现实世界中，计算摄影领域探索从这些数 
据中提取各种结果[1462]。可以使用对象的纯粹基于图像的表示来 
进行显示。例如，Lumigraph[567]和光场渲染[1034]技术试图从 
一组视点捕获单个对象。给定新视点，这些技术在存储的视图之间 
执行插值过程以便创建新视图。这是一个复杂的问题，需要高数据 
----------------------- Page 596-----------------------
来存储所有需要的视图。这个概念类似于全息术，其中二维视图数 
组表示对象。这种渲染形式的诱人方面是捕获真实对象并能够从任 
何角度重新显示它的能力。无论表面和照明复杂程度如何，任何对 
象都可以以几乎恒定的速率显示。有关此主题的更多信息，请参阅 
Szeliski[1729]一书。近年来，人们对光场渲染有了新的研究兴趣， 
因为它可以让眼睛使用虚拟现实显示器正确地调整焦点 
[976,1875]。这些技术目前在交互式渲染中的使用有限，但它们划 
分了计算机图形领域的可能性。550 13.超越多边形图 13.3。来自 
动画ChickenCrossing的静止图片，使用Talisman模拟器渲染。 
在这个场景中，使用了80层精灵，其中一些概述并显示在左侧。由 
于鸡翼部分位于后挡板的前方和后方，因此两者都被放置在一个精 
灵中。 （经微软公司许可转载。）13.5精灵和图层最简单的基于图 
像的渲染图元之一是精灵[519]。精灵是在屏幕上移动的图像，例如 
鼠标光标。精灵不必具有矩形形状，因为一些像素可以呈现为透明。 
对于简单的精灵，存储的每个像素将被复制到屏幕上的像素。可以 
通过显示一系列不同的精灵来生成动画。更通用的精灵类型是渲染 
为应用于始终面向观察者的多边形的图像纹理。这允许精灵大小调 
整和扭曲。图像的alpha通道可以为精灵的各个像素提供全部或部 
分透明度，从而也为边缘提供抗锯齿效果（第 5.5节）。这种类型 
的精灵可以有一个深度，因此在场景中也是一个位置。思考场景的 
一种方式是作为一系列层，如通常对二维cel动画所做的那样。例 
如，在图 13.3中，后挡板位于鸡的前面，它位于卡车驾驶室的前面， 
----------------------- Page 597-----------------------
位于道路和树木的前面。13.6。Billboarding551此分层适用于大 
量视点。每个精灵图层都有一个与之相关的深度。通过以画家的算 
法的前后顺序渲染，我们可以在不需要z缓冲区的情况下构建场景。 
相机缩放只会使对象变大，使用相同的sprite或关联的mipmap可 
以很容易地处理它。移入或移出相机实际上会改变前景和背景的相 
对覆盖范围，这可以通过更改每个精灵层的覆盖范围和位置来处理。 
当观察者侧向或垂直移动时，层可以相对于它们的深度移动。一组 
精灵可以表示一个对象，一个单独的精灵可以表示不同的视图。如 
果对象在屏幕上足够小，那么即使对于动画对象，存储大量视图也 
是可行的策略[361]。视角的微小变化也可以通过扭曲精灵的形状来 
处理，但最终近似值会中断，并且需要生成新的精灵。具有不同表 
面的物体可以从小旋转中显着改变，随着新多边形变得可见而其他 
多边形被遮挡。这种图层和图像变形过程是微软在20世纪90年代 
后期[1672,1776]所支持的Talisman硬件架构的基础。虽然这个特 
定的系统由于多种原因而消失，但是已经发现通过一个或多个基于 
图像的表示来表示模型的想法是富有成效的。使用各种容量的图像 
可以很好地映射到GPU强度，而基于图像的技术可以与基于三角形 
的渲染相结合。以下部分讨论冒名顶替者，深度精灵以及使用图像 
代替多边形内容的其他方法。13.6Billboarding基于视图方向定向 
纹理矩形称为广告牌，矩形称为广告牌[1192]。随着观点的变化， 
作为响应，修改矩形的方向。Billboarding结合alpha纹理和动画， 
可以代表许多没有光滑固体表面的现象。草，烟，火，雾，爆炸， 
----------------------- Page 598-----------------------
能量盾，蒸气痕迹和云只是这些技术可以表示的一些对象 
[1192,1871]。见图13.4。本节描述了一些流行的广告牌形式。在 
每一个中，找到表面法线和向上方向以定向矩形。这两个矢量足以 
为表面创建标准正交基。换句话说，这两个向量描述了将四边形旋 
转到其最终方向所需的旋转矩阵（第4.2.4节）。然后使用四边形 
上的锚定位置（例如，其中心）来确定其在空间中的位置。通常， 
期望的表面法线n和向上矢量u不垂直。在所有广告牌技术中，这 
两个矢量中的一个被建立为必须在给定方向上保持的固定矢量。该 
过程总是相同的，以使另一个向量垂直于该固定向量。首先，创建 
一个 “右”向量55213.超越多边形图 13.4。代表雪，表面和字符 
的小广告牌。（来自three.js示例程序[218]。）r，指向四边形右 
边缘的向量。这是通过取u和n的叉积来完成的。归一化该向量r， 
因为它将用作旋转矩阵的标准正交基的轴。如果向量r的长度为零， 
那么u和n必须是并行的，并且可以使用第4.2.4节中描述的技术 
[784]。如果r的长度不是很零，但几乎是如此，则u和n几乎是平 
行的，并且可能发生精度误差。从（非并行）n和u向量计算r和 
新的第三个向量的过程如图 13.5所示。如果正常n保持不变，对于 
大多数广告牌技术来说都是如此，那么新的向上矢量u'是u'=n×r。 
 （13.2）相反，如果向上方向是固定的（对于轴向对齐的广告牌， 
例如横向上的树木，则为真），则新的法线向量n'为n'=r×u。（13.3） 
然后对新矢量进行归一化，并使用三个矢量来形成旋转矩阵。例如， 
对于固定的法线n和调整的向量u'，矩阵是 M=..r，u'，n？。13.4（ ） 
----------------------- Page 599-----------------------
13.6。Billboarding553图13.5。对于具有法线方向n和近似向上 
矢量方向u的广告牌，我们想要创建一组三个相互垂直的向量来定 
向广告牌。在中图中，通过取u和 n的叉积来找到 “右”向量r， 
因此它们都垂直于它们。在右图中，固定矢量n与r交叉以给出相 
互垂直的向上矢量u'。该矩阵在xy平面中转换四边形，其中+y指 
向其顶部边缘，并以其锚定位置为中心，以正确的方向。然后应用 
平移矩阵将四边形的锚点移动到所需位置。有了这些预备，剩下的 
主要任务是决定使用什么表面法线和向上矢量来定义广告牌的方 
向。以下各节将讨论构建这些向量的几种不同方法。13。6.1屏幕 
对齐广告牌最简单的广告牌形式是屏幕对齐的广告牌。此形式与二 
维精灵相同，因为图像始终与屏幕平行并具有恒定的向上矢量。相 
机将场景渲染到与近平面和远平面平行的视平面上。我们经常在近 
平面的位置可视化这个假想的平面。对于这种类型的广告牌，所需 
的曲面法线是视平面法线的否定，其中视平面的法线vn指向远离视 
图位置。向上矢量u来自相机本身。它是视图平面中的矢量，用于 
定义摄像机的向上方向。这两个矢量已经是垂直的，因此所需要的 
只是 “右”方向矢量 r，以形成广告牌的旋转矩阵。由于n和u是 
相机的常量，因此对于此类型的所有广告牌，此旋转矩阵都是相同 
的。除了粒子效果之外，屏幕对齐的广告牌对于注释文本和地图地 
标等信息非常有用，因为文本将始终与屏幕本身对齐，因此名称为 
 “广告牌”。请注意，对于文本注释，对象通常会保留屏幕上的固 
定大小。这意味着如果用户从广告牌的位置缩放或推车，广告牌将 
----------------------- Page 600-----------------------
增加世界空间大小。因此，对象的大小取决于视图，这可能使截头 
剔除等方案复杂化。554 13.超越多边形 13.6.2面向世界的广告牌 
我们希望广告牌的屏幕对齐，例如，显示玩家身份或位置名称。但 
是，如果相机侧向倾斜，例如，在飞行模拟中进入曲线，我们希望 
广告牌云在响应中倾斜。如果一个精灵代表一个物理对象，它通常 
是相对于世界的向上方向而不是相机的方向。圆形精灵不受倾斜影 
响，但其他广告牌形状也会受到影响。我们可能希望这些广告牌保 
持面向观众，但也沿着他们的视轴旋转以保持世界导向。对于这样 
的精灵，渲染这些精灵的一种方法是使用这个世界向上矢量来导出 
旋转矩阵。在这种情况下，法线仍然是视平面法线的否定，它是固 
定矢量，并且从世界的向上矢量导出新的垂直向上矢量，如前所述。 
与屏幕对齐的广告牌一样，此矩阵可以重复用于所有精灵，因为这 
些矢量在渲染场景中不会改变。对所有精灵使用相同的旋转矩阵存 
在风险。由于透视投影的性质，与视轴有一定距离的物体会发生翘 
曲。请参见图 13.6中的底部两个球体。由于投影到平面上，球体变 
成椭圆形。如果观看者的眼睛距离屏幕适当的距离和位置，则这种 
现象不是错误并且看起来很好。也就是说，如果虚拟相机的几何视 
场与眼睛的显示视野匹配，则这些球体看起来没有扭曲。观众不会 
注意到视野中高达 10％-20％的轻微不匹配[1695]。然而，通常的 
做法是为虚拟相机提供更宽的视野，以便向用户呈现更多的世界。 
也，只有当观看者在给定距离处在显示器前面居中时，匹配视野才 
有效。几个世纪以来，艺术家们已经意识到这个问题并在必要时得 
----------------------- Page 601-----------------------
到补偿。预期圆形的物体，如月亮，被绘制成圆形，无论它们在画 
布上的位置如何[639]。当视野或精灵很小时，可以忽略这种扭曲效 
果，并且单个方向与所使用的视平面对齐。否则，所需的法线需要 
等于从广告牌中心到观众位置的矢量。我们称之为面向观点的广告 
牌。见图 13.7。使用不同比对的效果如图13.6所示。可以看出， 
视平面对准具有使广告牌没有失真的效果，无论它在屏幕上的何处。 
视点方向通过将场景投影到平面上，以与真实球体扭曲相同的方式 
扭曲球体图像。面向世界的广告牌可用于呈现许多不同的现象。 
Guymon [624]和 Nguyen[1273]都在讨论制造令人信服的火焰， 
烟雾和爆炸。一种技术是以随机和混乱的方式聚集和重叠动画精灵。 
这样做有助于隐藏动画序列的循环模式，同时还避免使每次火灾或 
爆炸看起来都一样。剪切纹理中的透明纹理像素对最终图像没有影 
响，但必须由GPU处理并在光栅化管道的后期丢弃，因为alpha 
13.6。Billboarding555图13.6。四个球体的视图，具有宽视野。 
左上角是球体的广告牌纹理，使用视图平面对齐。右上方的广告牌 
是面向观点的。下排显示两个真实的球体。图13.7。两种广告牌对 
齐技术的俯视图。五个广告牌面对的方式不同，具体取决于方法。 
556 13.超越多边形图 13.8。云精灵包含一个大的透明边缘。使用 
凸包，以绿色显示，更紧密的四个和八个顶点多边形（红色）被发 
现包含更少的透明纹理像素。与最左边的原始方形颗粒相比，这样 
做可以使整体面积分别减少40％和48％。（图片由EmilPersson 
提供[1382]。）为零。一组动画切割纹理通常具有特别大的透明纹 
----------------------- Page 602-----------------------
理边缘区域的框架。我们通常会考虑将纹理应用于矩形基元。 
Persson注意到一个更紧密的多边形，调整后的纹理坐标可以更快 
地渲染一个精灵，因为处理的纹理更少[439,1379,1382]。见图 
13.8。他发现只有四个顶点的新多边形可以显着提高性能，并且使 
用超过八个顶点的新多边形会达到收益递减点。用于查找此类多边 
形的 “粒子剪切”工具是虚幻引擎4的一部分，例如[512]。广告牌 
的一个常见用途是云渲染。Dobashi等。[358]模拟云并用广告牌渲 
染它们，并通过渲染同心半透明壳来创建光轴。Harris和 Lastra 
[670]也使用冒名顶替者模拟云。见图 13.9。王[1839，1840]详细 
介绍了微软飞行模拟器产品中使用的云建模和渲染技术。每个云由 
5到400个广告牌组成。只需要 16种不同的基础精灵纹理，因为 
可以使用非均匀缩放和旋转来修改这些纹理，以形成各种各样的云 
类型。基于距云中心的距离修改透明度用于模拟云的形成和消散。 
为了节省处理，远处的云都被渲染为围绕场景的一组八个全景纹理， 
类似于天空盒。平面广告牌不是唯一可能的云渲染技术。例如， 
Elinas和Stuerzlinger[421]通过渲染嵌套椭圆体组来生成云，这些 
椭圆体在观察轮廓周围变得更加透明。Bahnassi和 Bahnassi[90] 
渲染椭圆体，他们称之为 “巨型粒子”，然后使用模糊和屏幕空间 
湍流纹理来提供令人信服的云状外观。Pallister[1347]讨论了在程 
序上生成云图像并在头顶天空网格上制作动画。Wenzel [1871]在 
观察者的上方使用了一系列飞机来遥远的云层。我们将重点放在广 
告牌和其他基元的渲染和混合上。云广告牌的阴影方面将在第 
----------------------- Page 603-----------------------
14.4.2 节和第 14.4.2 节中的真实体积方法中讨论。13.6。 
Billboarding557图13.9。由一组面向世界的冒名顶替者创造的云。 
 （图片由UNC-ChapelHill的MarkHarris提供。）558 13.超越 
多边形图 13.10。在左边，圈出的区域显示边缘和条带，因为尘云 
广告牌与物体相交。在右边，广告牌淡出它们靠近物体的地方，避 
免了这个问题。在底部，下方圆圈区域被缩放以进行比较。（图片 
来自 NVIDIASDK 10 [1300]样本 “Soft Particles”，由NVIDIA 
公司提供。）如第 5.5和6.6节所述，为了正确执行合成，重叠的 
半透明广告牌应按排序顺序呈现。烟雾或雾广告牌在与实体对象相 
交时会产生伪影。见图 13.10。幻觉被打破了，因为应该是一个体 
积被看作是一组层。一种解决方案是让像素着色器程序在处理每个 
广告牌时检查底层对象的z深度。广告牌测试这个深度，但不要用 
它们自己替换它，即不要写一个z深度。如果底层对象接近广告牌 
在像素处的深度，则广告牌片段变得更加透明。通过这种方式，广 
告牌被视为更像一个卷，并且图层工件消失。当达到最大渐变距离 
时，与深度线性褪色会导致不连续。S曲线淡出功能避免了这个问 
题。佩尔森[1379]指出，观察者与粒子的距离将改变设置淡入淡出 
范围的最佳方式。Lorach[1075,1300]提供了更多信息和实现细节。 
以这种方式修改透明胶片的广告牌称为软颗粒。使用软粒子的淡出 
解决了广告牌与固体物体相交的问题，如图 13.10所示。当爆炸移 
动 13.6时，可能会发生其他伪影。Billboarding559通过场景或观 
众在云层中移动。在前一种情况下，广告牌可以在动画期间从后面 
----------------------- Page 604-----------------------
移动到对象前面。如果广告牌从完全不可见变为完全可见，则会导 
致明显的弹出。类似地，当观察者在广告牌中移动时，广告牌可以 
在其在近平面前方移动时完全消失，从而导致所看到的突然变化。 
一个快速解决方案是让广告牌变得越来越透明，越来越淡，以避免 
 “流行”。更现实的解决方案是可能的。Umenhoffer等。[1799,1800] 
介绍了球形广告牌的概念。广告牌对象被认为实际上定义了空间中 
的球形体积。广告牌本身被忽略z深度读取;广告牌的目的纯粹是为 
了使像素着色器程序在球体可能存在的位置执行。像素着色器程序 
计算此球形体积上的入口和出口位置，并使用实体对象根据需要更 
改出口深度，并使用近剪裁平面更改入口深度。通过这种方式，每 
个广告牌的球体可以通过基于来自相机的光线在被剪裁的球体内行 
进的距离增加透明度而适当地淡化。在Crysis [1227,1870]中使用 
了稍微不同的技术，使用盒形体积而不是球体来降低像素着色器成 
本。另一个优化是让广告牌代表卷的前端，而不是后面。这使得使 
用z缓冲区测试可以跳过固体对象后面的部分卷。只有当已知体积 
完全位于观察者前方时，这种优化才是可行的，因此广告牌不会被 
近视平面剪切。13.6.3轴向广告牌最后一种常见类型称为轴向广告 
牌。在该方案中，纹理对象通常不直视观察者。相反，它允许围绕 
某个固定的世界空间轴旋转并使其自身对齐以在该范围内尽可能地 
面向观察者。这种广告牌技术可用于显示远处的树木。不使用第6.6 
节中描述的表示具有实体表面的树，或甚至使用一对树轮廓，而是 
使用单个树广告牌。世界向上矢量被设置为沿树干的轴。当观察者 
----------------------- Page 605-----------------------
移动时，树面向观察者，如图 13.11所示。此图像是一个面向摄像 
机的广告牌，与第203页的图6.28中所示的 “交叉树”不同。对 
于这种形式的广告牌，世界向上矢量是固定的，视点方向用作第二 
个可调节矢量。一旦形成该旋转矩阵，树就被转换到它的位置。这 
种形式与面向世界的广告牌的区别在于固定的和允许旋转的内容。 
面向世界，广告牌直接面向观察者，并可沿该视轴旋转。旋转使得 
广告牌的向上方向尽可能与世界的向上方向对齐。使用轴向广告牌， 
世界向上方向定义固定轴，并且广告牌围绕它旋转，以使其尽可能 
地面向观察者。例如，如果观察者差不多是 560 13.超越多边形图 
13.11。当观察者在场景中移动时，布什广告牌旋转以面向前方。在 
此示例中，衬套从南方照亮，以便改变视图使整体阴影随旋转而变 
化。在每种类型的广告牌上方，面向世界的版本将完全面对它，而 
轴向版本将更加贴在现场。由于这种行为，轴向广告牌的问题在于， 
如果观众飞过树木向下看，那么幻觉就会被破坏，因为树木几乎会 
出现在边缘上，看起来就像是它们的切口。一种解决方法是添加树 
的水平横截面纹理 （不需要广告牌）来帮助改善问题[908]。另一种 
技术是使用细节水平技术从基于图像的模型改变为基于网格的模型 
[908]。第13.6.5节讨论了将树模型从三角形网格转换为多组广告 
牌的自动方法。Kharlamov等。[887]呈现相关的树渲染技术，并 
且 Klint [908]解释了大量植被的数据管理和表示。第857页的图 
19.31显示了商用SpeedTree软件包中用于渲染远处树木的轴向广 
告牌技术。正如屏幕对齐的广告牌有利于表示对称的球形物体一样， 
----------------------- Page 606-----------------------
轴向广告牌也可用于表示具有圆柱对称性的物体。例如，激光束效 
果可以用轴向广告牌来呈现，因为它们的外观从围绕轴的任何角度 
看起来都是相同的。有关此示例和其他 billbo的示例，请参见图 
13.12急性呼吸窘迫综合征。第913页的图20.15显示了更多示例。 
这些类型的技术说明了这些算法和随后的算法的一个重要思想，即 
像素着色器的目的是评估真实几何，丢弃在表示的对象边界之外找 
到的片段。对于广告牌，当图像纹理完全透明时，可以找到这样的 
片段。如将看到的，可以评估更复杂的像素着色器以找到模型存在 
的位置。任何这些方法中的几何函数都是为了对像素着色器进行评 
估，并对z深度进行粗略估计，这可以通过像素着色器进行细化。 
我们希望避免浪费时间来评估模型外部的像素，但我们也不希望使 
几何体如此复杂以至于顶点处理和不需要 13.6。Billboarding561 
图13.12。广告牌的例子。平视显示器（HUD）图形和星形射弹是 
屏幕对齐的广告牌。右图中的大型泪珠爆炸是面向观点的广告牌。 
弯曲梁是由连接的四边形组成的轴向广告牌。为了形成连续光束， 
这些四边形在其角落处连接，因此不再是完全矩形的。（图片由 
MaximGarber，MarkHarris，VincentScheib，StephanSherman 
和 Andrew Zaferakis 提供，来自 “BHX ：Beamrunner 
Hypercross。”）每个三角形外的像素着色器调用 （由于沿边缘产 
生2×2个四边形;见第 18.2节） .3）成为重大成本。13.6.4冒名顶 
替者冒名顶替者是通过将复杂对象从当前视点渲染为图像纹理而创 
建的广告牌，它被映射到广告牌上。冒名顶替者可以用于对象的几 
----------------------- Page 607-----------------------
个实例或几帧，从而分摊生成它的成本。在本节中，将介绍更新冒 
名顶替者的不同策略。Maciel和Shirley [1097]在 1995年确定了 
几种不同类型的冒名顶替者，包括本节中提到的那些冒名顶替者。 
从那时起，冒名顶替者的定义已经缩小到我们在这里使用的[482]。 
冒充者图像在物体存在的地方是不透明的;在其他地方，它是完全透 
明的。它可以用几种方法来代替几何网格。例如，冒名顶替的图像 
可以表示由小静态物体组成的杂波[482,1109]。由于复杂模型被简 
化为单个图像，因此冒充者可用于快速渲染远程对象。另一种方法 
是使用最小级别的细节模型 （第 19.9节）。然而，这种简化的模型 
经常会丢失形状和颜色信息。冒充者没有这个缺点，因为可以使生 
成的图像大致匹配显示器的分辨率[30,1892]。可以使用冒名顶替者 
的另一种情况是位于观察者附近的物体，当它们移动时将相同的一 
侧暴露给观察者[1549]。在渲染对象以创建冒名顶替者图像之前， 
将查看器设置为查看对象边界框的中心，并选择冒名顶替矩形，使 
其直接指向视点 （图13.13中的左侧）。56213.超越多边形的大小 
图13.13。在左边，通过观察平截头体从侧面观察的对象创建冒名 
顶替者。视图方向朝向对象的中心c，并且渲染图像并将其用作冒 
名顶替者纹理。这显示在右侧，纹理应用于四边形。冒名顶替者的 
中心等于物体的中心，法线（从中心发出）直接指向视点。冒名顶 
替者的四边形是包含对象投影边界框的最小矩形。Alpha被清除为 
零，无论在何处呈现对象，alpha都设置为 1.0。然后将图像用作面 
向视点的广告牌。请参见图13.13的右侧。当相机或冒名顶替物体 
----------------------- Page 608-----------------------
移动时，纹理的分辨率可能会被放大，这可能会打破幻觉。Schaufler 
和St¨urzlinger[1549]提出了确定何时需要更新冒名顶替者图像的 
启发式方法。Forsyth[482]给出了许多在游戏中使用冒名顶替者的 
实用技巧。例如，更接近观察者或鼠标光标的对象的更频繁更新可 
以改善感知质量。当冒充者被用于动态物体时，他描述了一种预处 
理技术，该技术确定了在整个动画过程中任何顶点移动的最大距离 
d。这个距离除以动画中的时间步数，那么？=d/帧。如果冒充者 
已被用于n帧而没有更新，那么？。n投影到图像平面上。如果该 
距离大于用户设定的阈值，则更新冒名顶替者。将纹理映射到面向 
观察者的矩形并不总能产生令人信服的效果。问题是冒名顶替者本 
身没有厚度，因此在与真实几何结合时会出现问题。请参见图 13.16 
中的右上角图像。Forsyth建议将纹理沿着视图方向投射到对象的 
边界框上[482]。这至少使冒名顶替者有一点几何存在感。通常最好 
只在对象移动时渲染几何体，并在对象静止时切换到冒名顶替者 
[482]。Kavan等人。[874]引入聚合物，其中人的模型由一组冒名 
顶替者表示，每个肢体 13.6。Billboarding563图13.14。一种冒 
名顶替者技术，其中每个单独的动画元素由一组图像表示。它们在 
一系列掩蔽和合成操作中呈现，这些操作结合起来形成给定视图的 
令人信服的模型。（图片由Alejandro Beacco提供，版权所有c 
2016JohnWiley＆Sons，Ltd。[122]。）和行李箱。该系统试图 
在纯冒名顶替者和纯几何体之间取得平衡。Beacco等。[122]描述 
了聚合物和各种其他与冒名顶替者相关的人群渲染技术，提供了每 
----------------------- Page 609-----------------------
种技术的优势和局限的详细比较。有关示例，请参见图 13.14。13.6.5 
广告牌表示冒名顶替者的一个问题是渲染图像必须继续面向观察 
者。如果远处的物体正在改变其方向，则必须重新计算冒名顶替者。 
为了模拟更像他们所代表的三角形网格的远处物体，D'ecoret等。 
[338]提出广告牌云的想法。复杂的模型通常可以由一小部分重叠的 
切口广告牌来表示。可以将附加信息（例如法线或位移贴图和不同 
材料）应用于其表面，以使这些模型更具说服力。找到一组平面的 
想法比纸质镂空类比可能暗示的更为普遍。广告牌可以相交，切口 
可以任意复杂。例如，一些研究人员将广告牌与树模型相匹配 
[128,503,513,950]。从 564开始13.超越多边形图 13.15。在左侧， 
树模型由20,610个三角形组成。在中间，树上有78个广告牌。重 
叠的广告牌显示在右侧。（图片由犹他大学 Dylan Lacewell提供 
[950]。）具有数万个三角形的模型，它们可以创建令人信服的广告 
牌云，由不到一百个纹理四边形组成。见图 13.15。使用广告牌云 
会导致大量的透支，这可能很昂贵。质量也会受到影响，因为交叉 
切口可能意味着无法实现严格的从后到前的绘制顺序。Alpha到 
coverage （第6.6节）可以帮助渲染复杂的alpha纹理集[887]。 
为避免过度绘制，SpeedTree等专业软件包代表并简化了具有大型 
网格纹理的叶子和四肢组合的模型。虽然几何处理需要更多时间， 
但这可以通过较低的透支成本来抵消。第857页的图 19.31显示了 
示例。另一种方法是用体积纹理表示这些对象，并将它们渲染为一 
系列形成垂直于眼睛视图方向的层，如第 14.3节[337]中所述。13.7 
----------------------- Page 610-----------------------
位移技术如果使用深度分量增强冒名顶替者的纹理，则定义称为深 
度精灵或指甲板的渲染基元[1550]。因此，纹理图像是用？增强的 
RGB图像。每个像素的参数，形成 RGB？质地。的？将深度精灵矩 
形的偏差存储到深度精灵所代表的几何体的正确深度。这个 ？ 
channel是视图空间中的高度域。因为深度精灵包含深度信息，所 
以它们优于冒名顶替者，因为它们可以更好地与周围物体合并。当 
深度精灵矩形穿透附近的几何体时，这尤其明显。这种情况如图 
13.16所示。像素着色器能够通过改变每个像素的z深度来执行该 
算法。13.7。位移技术565图13.16。左上角的图像显示了使用几 
何体渲染的简单场景。右上角的图像显示了创建冒充者并将其用于 
立方体，圆柱体和圆锥体时会发生什么。底部图像显示了使用深度 
精灵时的结果。左图中的深度子画面使用2位进行深度偏差，而右 
侧的深度子画面使用8位。图片（ 由GernotSchaufler提供[1550]。） 
Shade等。[1611]还描述了深度精灵原语，其中它们使用变形来考 
虑新的视点。他们引入了一个称为分层深度图像的原语，每个像素 
有几个深度。多个深度的原因是避免在翘曲期间由于去除遮挡 （即， 
隐藏区域变得可见）而产生的间隙。Schaufler[1551]和 Meyer和 
Neyret[1203]也提出了相关技术。为了控制采样率，Chang等人 
提出了一种称为 LDI树的分层表示。[255]。与深度精灵相关的是由 
Oliveira等人引入的浮雕纹理映射。[1324]。浮雕纹理是具有高度 
场的图像，其表示表面的真实位置。与深度精灵不同，图像不是在 
广告牌上渲染，而是在世界空间的四边形上。对象可以通过一组在 
----------------------- Page 611-----------------------
其接缝处匹配的浮雕纹理来定义。使用GPU，高度场可以映射到曲 
面上，射线行进可以用来渲染它们，如第6.8.1节中所述。浮雕纹 
理映射也类似于称为栅格化边界体积层次结构的技术[1288]。566 
13.超越多边形图 13.17。通过将四个高度场纹理应用于曲面并使用 
浮雕映射进行渲染来建模编织曲面。（图片由 FabioPolicarpo和 
ManuelM.Oliveira [1425]提供。）Policarpo和Oliveira [1425] 
在单个四边形上使用一组纹理来保持高度场，并且每个都依次渲染。 
作为一个简单的类比，在注塑机中形成的任何物体都可以由两个高 
度场形成。每个高度场代表模具的一半。可以通过额外的高度场重 
建更精细的模型。鉴于模型的特定视图，所需高度场的数量等于与 
任何像素重叠的最大表面数量。与球形广告牌一样，每个基础四边 
形的主要目的是通过像素着色器评估高度场纹理。此方法还可用于 
为曲面创建复杂的几何细节;见图13.17。Beacco等。[122]使用救 
援冒名顶替人群场景。在此表示中，生成模型的颜色，法线和高度 
场纹理，并将其与框的每个面相关联。渲染面部时，执行光线行进 
以找到每个像素处可见的表面（如果有）。框与模型的每个刚性部 
分（ “骨骼”）相关联，以便可以执行动画。在假设角色很远的情 
况下，没有进行蒙皮。纹理提供了一种简单的方法来降低原始模型 
的细节水平。见图13.18。顾等人。[616]介绍几何图像。我们的想 
法是将不规则网格转换为保持位置值的方形图像。图像本身代表 
13.8。粒子系统567图13.18。救济冒名顶替者。角色的表面模型 
分为多个框，然后用于为每个框面创建高度场，颜色和法线纹理。 
----------------------- Page 612-----------------------
使用浮雕映射渲染模型。（图片由Alejandro Beacco提供，版权 
所有c2016JohnWiley＆Sons，Ltd。[122]。）规则网格，即形 
成的三角形是从网格位置隐含的。也就是说，图像中的四个相邻纹 
素形成两个三角形。形成这种图像的过程很困难而且很复杂;这里感 
兴趣的是对模型进行编码的结果图像。图像可以清楚地用于生成网 
格。关键特征是几何图像可以进行mipmap。不同级别的mipmap 
金字塔形成了更简单的模型版本。网格和图像之间的顶点和纹素数 
据之间的线条模糊，是一种考虑建模的迷人和诱人的方式。几何图 
像也被用于具有特征保留图的地形以模拟悬垂[852]。在本章的这一 
点上，我们留下用图像表示整个多边形对象，因为讨论转向使用粒 
子系统和点云中的断开的单个样本。13.8粒子系统粒子系统[1474] 
是使用某种算法设置为运动的单独小物体的集合。应用包括模拟火 
灾，烟雾，爆炸，水流，旋转星系和其他现象。因此，粒子系统控 
制动画和渲染。用于在生命周期内创建，移动，更改和删除粒子的 
控件是系统的一部分。与本章相关的是对这些粒子进行建模和渲染 
的方式。每个粒子可以是从粒子的先前位置到其当前位置绘制的单 
个像素或线段，但通常由广告牌表示。如第 13.6.2节所述，如果粒 
子是圆形的，则向上矢量与其显示无关。568 13.超越多边形图 
13.19。粒子系统：类似烟雾的模拟 （左），流体 （中间）和与星系 
天空盒 （右）相对的流星路径。（WebGL节目“精神”由EdanKwan 
编写，DavidLi的 “流体颗粒”和 IanWebster的 “SouthernDelta 
Aquariids流星雨”。换句话说，所需要的只是粒子定位它的位置。 
----------------------- Page 613-----------------------
图13.19显示了一些粒子系统示例。每个粒子的广告牌可以通过几 
何着色器调用生成，但实际上使用顶点着色器生成精灵可能会更快 
[146]。除了表示粒子的图像纹理之外，还可以包括其他纹理，例如 
法线贴图。轴向广告牌可以显示更粗的线条。有关使用线段的降雨 
示例，请参见第609页的图 14.18。如果烟雾等现象由半透明的广 
告牌颗粒表示，则必须解决正确渲染透明物体的挑战。可能需要进 
行前后排序，但可能很昂贵。Ericson[439]提供了一系列有效渲染 
粒子的建议;我们在这里列出一些，以及相关文章：。用厚厚的镂空 
纹理制作烟雾;避免半透明意味着不需要分类和混合。。如果需要半 
透明，可以考虑加法或减法混合，不需要排序[987,1971]。。使用 
一些动画粒子可以提供与许多静态粒子相似的质量和更好的性能。。 
要保持帧速率，请对渲染的粒子数使用动态上限值。。不同的粒子 
系统使用相同的着色器来避免状态变化成本[987,1747] （第18.4.2 
节）。。包含所有粒子图像的纹理图集或数组避免了纹理变化调用 
[986]。。将平滑变化的粒子 （如烟雾）绘制到较低分辨率的缓冲区 
并合并[1503]，或在解析MSAA后绘制。13.8。粒子系统569最 
后一个想法由Tatarchuk等人进一步提出。[1747]。它们将烟雾渲 
染到相当小的缓冲区，十六分之一的大小，并使用方差深度图来帮 
助计算粒子效果的累积分布函数。详情请参阅其演示文稿对于大量 
粒子，完全排序可能是昂贵的。艺术方向可以指示渲染顺序以正确 
地分层不同的效果，从而改善问题。对于小对比度或低对比度的粒 
子，可能不需要排序。颗粒有时也可以按某种程度排序[987]。加权 
----------------------- Page 614-----------------------
混合透明技术，不需要排序，如果粒子是相当透明的，可以使用 
[394,1180]。更精细的与订单无关的透明系统也是可能的。例如，K？ 
ohler [920]将渲染粒子概述为存储在纹理数组中的九层深度缓冲 
区，然后使用计算着色器执行排序排序。13.8.1阴影粒子对于阴影， 
它取决于粒子。诸如火花之类的发射器不需要遮挡，并且为了简单 
起见通常使用添加剂混合。Green[589]描述了如何将流体系统渲染 
为深度图像的球形粒子，随后的步骤是模糊深度，从中导出法线， 
并将结果与​ ​ 场景合并。诸如灰尘或烟雾的小颗粒可以使用每个 
基元或每顶点值进行着色[44]。然而，这种照明可以使具有不同表 
面的颗粒看起来平坦。为粒子提供法线贴图可以给出适当的表面法 
线以照亮它们，但是以额外的纹理访问为代价。对于圆形颗粒，在 
颗粒的四个角处使用四个发散法线可能就足够了[987,1650]。烟雾 
粒子系统可以有更精细的光散射模型[1481]。光能传递法线贴图（第 
11.5.2节）或球谐函数[1190,1503]也被用于照射粒子。曲面细分可 
用于较大的粒子，使用域着色器[225,816,1388,1590]在每个顶点累 
积光照。可以评估每个顶点的光照并在粒子四边形上插值[44]。这 
很快但是对于大颗粒产生低质量，相距较远的顶点可能会错过小灯 
的贡献。一种解决方案是在每个像素的基础上对粒子进行着色，但 
分辨率低于用于最终图像的分辨率。为此，每个可见粒子在光图纹 
理中分配瓦片[384,1682]。可以根据屏幕上的粒度调整每个区块的 
分辨率，例如，根据屏幕上的投影区域，在 1×1和32×32之间。 
一旦分配了切片，就会为每个切片渲染粒子，将像素的世界位置写 
----------------------- Page 615-----------------------
入辅助纹理。然后调度计算着色器以评估到达从次纹理读取的每个 
位置的辐射。通过对场景中的光源进行采样来收集辐射，使用加速 
结构以便仅评估潜在的贡献源，如第20章所述。然后可以将得到的 
辐射亮度作为简单颜色或球谐函数写入光照贴图。当每个粒子最终 
在屏幕上渲染时，除了多边形之外，通过将每个瓦片映射到粒子四 
边形上并使用纹理提取对每个像素的辐射进行采样来应用光照。还 
可以通过为每个发射器分配瓦片来应用相同的原理[1538]。在这种 
情况下，具有深度光照贴图纹理将有助于为具有许多粒子的效果提 
供照明的体积。值得注意的是，由于通常与观察者对齐的颗粒的扁 
平性质，如果视点围绕任何粒子发射器旋转，则本节中呈现的每个 
照明模型将产生可见的闪烁伪影。与照明并行，粒子体积阴影的产 
生和自我遮蔽需要特别小心。为了接收来自其他遮挡物的阴影，通 
常可以仅在它们的顶点而不是每个像素上对阴影贴图测试小粒子。 
因为粒子是呈现为简单的面向相机的四边形的散射点，所以使用阴 
影贴图中的光线行进无法实现阴影投射到其他对象上。但是，可以 
使用喷溅方法 （第 13.9节）。为了在太阳的其他场景元素上投射阴 
影，可以将粒子喷射到纹理中，将它们的每像素透射率乘以Tr =1。 
缓冲区中的α首先清除为 1。纹理可以包括用于灰度的单个通道或用 
于彩色透射的三个通道。这些纹理在阴影级联级别之后，通过将此 
透射率与常规不透明阴影级联产生的可见性相乘，应用于场景，如 
第7.4节所示。这种技术有效地提供了单层透明阴影[44]。这种技 
术的唯一缺点是粒子可能会错误地将阴影投射回粒子和太阳之间存 
----------------------- Page 616-----------------------
在的不透明元素。这通常通过仔细的水平设计来避免。为了实现粒 
子的自阴影，必须使用更先进的技术，例如傅里叶不透明度映射 
 （FOM）[816]。见图13.20。首先从光的角度渲染粒子，有效地将 
它们的贡献添加到表示为傅里叶系数的透射率函数中到不透明度图 
中。当从该视点渲染粒子时，可以通过从傅里叶系数采样不透明度 
图来重建透射率信号。该表示适用于表达平滑透射率函数。然而， 
由于它使用具有有限数量系数的傅立叶基以维持纹理存储器要求， 
因此对于透射率的大变化而言，它会受到振铃。这可能导致渲染粒 
子四边形上的亮区或暗区不正确。FOM非常适合颗粒，但也可以使 
用具有不同优点和缺点的其他方法。这些包括第 14.3节中描述的自 
适应体积阴影贴[1531]。2 （类似于深阴影贴图[1066]），GPU优 
化的粒子阴影贴图[120] （类似于不透明阴影贴图[894]，但仅适用 
于面向相机的粒子，因此它不适用于色带或运动拉伸粒子）和透射 
率函数映射[341] （类似于 FOM）。另一种方法是将含有消光系数σ 
t的体积中的粒子体素化[742]。这些体积可以定位在相机周围，类 
似于剪贴图[1739]。这种方法是统一体积shad 13.8评估的一种方 
法。粒子系统571图13.20。粒子使用傅立叶不透明度映射投射体 
积阴影。在左边，傅立叶不透明度图包含从其中一个聚光灯的角度 
来看的函数系数。在中间，粒子渲染时没有阴影。在右边，体积阴 
影投射在场景的粒子和其他不透明表面上。（图片由 NVIDIA提供 
[816]。）同时来自粒子和参与媒体，因为它们都可以在这些共同体 
积中被体素化。生成从这些 “消光体积”存储每个体素Tr的单个深 
----------------------- Page 617-----------------------
阴影贴图[894]将自动导致从两个源投射的体积阴影。产生了许多相 
互作用：粒子和参与媒体可以相互投射阴影，以及自阴影;请参见第 
613页的图 14.21。由此产生的质量与体素大小相关，为了实现实 
时性能，可能会很大。这将导致粗糙但视觉上柔和的体积阴影。更 
多详细信息，请参见第14.3.2节。13.8。2粒子模拟使用粒子的物 
理过程的高效和令人信服的近似是超出本书意图的广泛主题，因此 
我们将向您介绍一些资源。GPU可以为精灵生成动画路径，甚至可 
以执行碰撞检测。流输出可以控制粒子的诞生和死亡。这是通过将 
结果存储在顶点缓冲区中并在GPU [522,700]上每帧更新该缓冲区 
来完成的。如果无序访问视图缓冲区可用，则粒子系统可以完全基 
于GPU，由顶点着色器[146,1503,1911]控制。VanderBurg的文 
章[211]和 Latta的概述[986,987]快速介绍了模拟的基础知识。 
Bridson的关于计算机图形流体模拟的书[197]深入讨论了理论，包 
括用于模拟各种形式的水，烟和火的基于物理的技术。一些从业者 
已经在交互式渲染器中介绍了粒子系统。Whitley [1879]详细介绍 
了为Destiny2开发的粒子系统。有关示例图像，请参见图 13.21。 
Evans和 Kirczenow [445]讨论了他们从 Bridson的文本中实现流 
体流动算法。Mittring[1229]给出了关于粒子如何为572的简要细 
节.13。超越多边形图 13.21。在虚幻引擎4 中控制的游戏Destiny2 
 （图像c2017Bungie，Inc。保留所有权利。）中使用的粒子系统 
示例.Vainio [1808]深入研究了在第二个儿子中为游戏设计和渲染 
粒子效果。Wronski [1911]提出了一种有效地产生和降雨的系统。 
----------------------- Page 618-----------------------
GJ。l和Svendsen [539]讨论了烟雾和火焰效应，以及许多其他基 
于样本的技术。Thomas [1767]运行了一个基于计算着色器的粒子 
模拟系统，该系统包括碰撞检测，透明度排序和高效的基于图块的 
渲染。肖等人。[1936]提出了一种交互式物理流体模拟器，其还计 
算用于显示的等值面。Skillman和 Demoreuille[1650]贯穿他们的 
粒子系统和其他基于图像的效果，用于将游戏的音量调高到 11。 
13.9点渲染 1985年，Levoy和Whitted编写了一份开创性的技术 
报告[1033]，其中他们建议使用点作为用于渲染一切的新原语。一 
般的想法是使用大量的点来表示表面并渲染这些点。在随后的传球 
中，执行高斯滤波以填充渲染点之间的间隙。高斯滤波器的半径取 
决于表面上的点密度以及屏幕上的投影密度。Levoy和Whitted在 
VAX-11/780上实现了该系统。然而，直到大约 15年后，基于点的 
渲染再次引起了人们的兴趣。这种复苏的两个原因是计算能力达到 
13.9。点渲染573是可以交互速率进行基于点的渲染的级别，并且 
从激光范围扫描仪获得的非常详细的模型变得可用[1035]。从那时 
起，用于探测距离的各种 RGB-D （深度）设备已经可用，从用于地 
形测绘的航空 LIDAR（光检测和测距）仪器，到微软 Kinect传感器， 
iPhoneTrueDepth相机和Google的Tango设备用于短距离数据 
采集。自动驾驶汽车上的激光雷达系统每秒可记录数百万点。通过 
摄影测量或其他计算摄影技术处理的二维图像也用于提供数据集。 
这些不同技术的原始输出是一组具有附加数据的三维点，通常是强 
度或颜色。还可以获得额外的分类数据，例如，点是来自建筑物还 
----------------------- Page 619-----------------------
是路面[37]。可以以各种方式操纵和渲染这些点云。这些模型最初 
表示为未连接的三维点。见 Berger等。[137]深入概述点云过滤技 
术和将这些技术转化为网格的方法。Kotfis和Cozzi[930]提出了一 
种以交互速率处理，体素化和渲染这些体素的方法。在这里，我们 
讨论直接渲染点云数据的技术。QSplat[1519]是一个有影响力的基 
于点的渲染器，于2000年首次发布。它使用球体层次来表示模型。 
压缩此树中的节点以允许渲染由数亿个点组成的场景。点被渲染为 
具有半径的形状，称为splat。可以使用的不同splat形状是正方形， 
不透明圆形和模糊圆形。换句话说，splats是粒子，虽然渲染的目 
的是表示连续的表面。有关示例，请参见图13.22。渲染可能会停 
在树中的任何级别。该级别的节点将呈现为与节点的球体半径相同 
的splats。因此，构造边界球体层次结构，使得在任何级别都不可 
见孔。由于树的遍历可以在任何级别停止，因此可以通过在时间用 
完时停止遍历来获得交互式帧速率。当用户停止移动时，可以重复 
细化渲染的质量，直到到达层次结构的叶子。大约在同一时间， 
Pfister等人。[1409]呈现了表面 - 表面元素。它也是一个基于点的 
基元，用于表示对象表面的一部分，因此总是包含法线。八叉树 （第 
19.1.3节）用于存储采样的表面：位置，法线和滤波纹素。在渲染 
过程中将表面投影到屏幕上，然后使用可见性喷溅算法填充所创建 
的任何孔。QSplat和surfels论文确定并解决了点云系统的一些关 
键问题：管理数据集大小并从给定的点集渲染令人信服的表面。 
QSplat使用层次结构，但是一个层次结构细分到单个点的级别，其 
----------------------- Page 620-----------------------
中内部父节点是边界球体，每个节点包含一个点，该点是其子节点 
的平均值。Gobbetti和 Marton[546]引入了分层点云，这种分层 
结构可以更好地映射到GPU，并且不会创建人为的 “平均”数据点。 
每个内部和子节点包含大约相同的 574 13. Beyond Polygons图 
13.22。使用圆形splats，使用基于点的渲染渲染这些模型。左图显 
示了一个名为露西的天使的完整模型，有 1000万个顶点。但是， 
渲染中仅使用了大约300万个splats。中间和右侧图像放大头部。 
中间图像在渲染过程中使用了大约40,000个splats。当观察者停止 
移动时，结果会收敛到右边显示的图像，并有600,000个splats。 
 （由Szymon Rusinkiewicz在QSplat程序中生成的图像.Lucy的 
模型由斯坦福图形实验室创建。）点数，称为 n，在单个API调用 
中呈现为集合。我们通过从整个集合中取n个点来形成根节点，作 
为模型的粗略表示。选择其中点之间的距离大致相同的集合给出比 
随机选择更好的结果[1583]。法线或颜色的差异也可用于聚类选择 
[570]。其余的点在空间上划分为两个子节点。在每个节点重复该过 
程，选择 n个代表点并将其余节点分成两个子集。这种选择和细分 
继续进行，直到每个孩子有n个或更少的分数。见图 13.23。Botsch 
等人的工作。[180]是现有技术的一个很好的例子，GPU加速技术 
使用延迟着色（第20.1节）和高质量滤波。在显示期间，可见图 
13.23。分层点云。在左侧，根节点包含从子项的数据中获取的稀疏 
子集。接下来显示一个子节点，然后显示与根注释中的点相结合如 
何更多地填充子区域。最右边是全点云，根和所有孩子。（图片来 
----------------------- Page 621-----------------------
自Potree[1583]的文档，开源软件，potree.org。图片介绍Adorjan 
[12]。）13.9。点渲染575个节点被加载并呈现，直到满足某个限 
制。节点的相对屏幕大小可用于确定点集的加载重要程度，并可提 
供所呈现的广告牌大小的估计值。通过不为父节点引入新点，内存 
使用量与存储的点数成比例。这种方案的一个缺点是，当放大单个 
子节点时，所有父节点必须沿着管道发送，即使每个节点中只有几 
个点可见。在当前的点云渲染系统中，数据集可能很庞大，包含数 
千亿个点。因为这样的集合无法完全加载到内存中，更不用说以交 
互速率显示，几乎每个点云渲染系统都使用分层结构来加载和显示。 
所使用的方案可以受到数据的影响，例如，四叉树通常比八叉树更 
适合地形。关于点云数据结构的有效创建和遍历已经进行了大量研 
究。Scheiblauer [1553]提供了该领域的研究摘要，以及表面重建 
技术和其他算法。Adorjan [12]概述了几个系统，重点是共享由摄 
影测量产生的建筑点云。理论上，splats可以提供单独的法线和半 
径来定义表面。在实践中，这样的数据需要太多的内存，并且只有 
在相当多的预处理工作后才可用，所以通常使用固定半径的广告牌。 
由于分拣和混合成本，适当地为这些点渲染半透明啪啪广告牌既昂 
贵又又有人工负担。不透明的广告牌 - 正方形或切口圆圈 - 通常 
用于保持交互性和质量。见图 13.24。如果点没有法线，则可以采 
用各种提供阴影的技术。一种基于图像的方法是计算某种形式的屏 
幕空间环境遮挡 （第 11.3.6节）。通常，所有点首先渲染到深度缓 
冲区，具有足够宽的半径以形成连续表面。在随后的渲染过程中， 
----------------------- Page 622-----------------------
每个点的阴影与靠近观察者的相邻像素的数量成比例地变暗。眼罩 
照明（EDL）可以进一步突出表面细节[1583]。EDL的工作原理是 
检查相邻像素的屏幕深度，并找到比当前像素更接近观察者的屏幕 
深度。对于每个这样的邻居，计算并求和深度与当前像素的差异。 
然后将这些差值的平均值（否定）乘以强度因子，并用作指数函数 
exp的输入。见图13.25。如果每个点都有颜色或强度，则照明已 
经烘焙，因此可以直接显示，但光泽或反射物体不会响应视图中的 
变化。其他非图形属性（如对象类型或高程）也可用于显示点。我 
们仅涉及管理和渲染点云的基础知识。Schuetz [1583]讨论了各种 
渲染技术并提供了实现细节，以及高品质的开源系统。点云数据可 
以与其他数据源结合使用。例如，Cesium程序可以将点云与高分 
辨率地形，图像，矢量地图数据和摄影测量生成的模型相结合。另 
一种与扫描相关的技术 576 13.超越多边形图 13.24。选择500万 
点来提供 1.45亿点的小城镇数据集。通过检测深度差异来增强边 
缘。数据稀疏或广告牌半径太小的地方会出现间隙。当图像预算分 
别为500,000,100万和500万点时，底部的行显示所选区域。 （使 
用 Potree[1583]，开源软件，potree.org生成的图像。奥地利 Retz 
模型，由RIEGL提供，riegl.com。）图13.25。在左边，在一次传 
递中渲染法线的点。在中间，没有法线的点云的屏幕空间环境遮挡 
渲染;在右边，眼球灯照明也一样。最后两种方法都需要首先执行传 
递以在图像中建立深度。（使用 CloudCompare，GPL软件， 
cloudcompare.org生成的图像。足迹模型由EugeneLiscio提供。） 
----------------------- Page 623-----------------------
13.9。点渲染577图13.26。每个像素都有深度的环境。对于固定 
视图位置（但不是方向），用户可以在世界空间位置和位置虚拟对 
象之间进行测量，并且正确处理遮挡。 （使用Autodesk ReCapPro 
生成的图像，由Autodesk，Inc。提供）nique是从环境中捕获环 
境到天空盒，同时保存颜色和深度信息，因此，使场景捕捉具有物 
理存在感。例如，用户可以将合成模型添加到场景中并使它们与此 
类型的天空盒正确合并，因为周围图像中的每个点都可以使用深度。 
见图 13.26。现有技术已经取得了相当大的进步，并且这些技术正 
在数据捕获和显示领域之外使用。作为一个例子，我们简要总结了 
Evans[446]为游戏Dreams提供的基于点的实验渲染系统。每个模 
型由聚类的边界体积层次 （BVH）表示，其中每个聚类为256个点。 
这些点是通过有符号距离函数生成的 （第 17.3节）。对于详细程度 
支持级别，将为每个详细级别生成单独的 BVH，群集和点。要从高 
细节过渡到低细节，较高密度子集群中的点数随机减少到25％，然 
后交换低细节父集群.578 13.Beyond Polygons渲染器基于计算 
着色器，使用原子将点扩展到帧缓冲区以避免冲突。它实现了几种 
技术，例如随机透明度，景深 （使用基于混淆圆的抖动的splats）， 
环境遮挡和不完美的阴影贴图[1498]。为了消除伪像，执行时间抗 
锯齿（第 5.4.2节）。点云代表空间中的任意位置，因此渲染具有 
挑战性，因为点之间的间隙通常是未知的或不易获得的。Kobbelt 
和 Botsch[916]调查了这个问题以及与点云相关的其他研究领域。 
在本章结束时，我们转向非多边形表示，其中样本与其邻居之间的 
----------------------- Page 624-----------------------
距离始终相同。13.10体素正如像素是 “图像元素”而纹理像素是 
 “纹理元素”，体素是 “体积元素”。每个体素代表一个均匀的三 
维网格中的空间体积，通常是立方体。体素是存储体积数据的传统 
方式，可以表示从烟雾到3D打印模型，从骨骼扫描到地形表示的 
对象。可以存储单个位，表示体素的中心是在对象内部还是外部。 
对于医学应用，可以获得密度或不透明度以及可能的体积流速。一 
种颜色，也可以存储法线，有符号距离或其他值以便于渲染。每个 
体素不需要位置信息，因为网格中的索引确定其位置。13.10.1应用 
程序模型的体素表示可用于许多不同的目的。规则的数据网格适用 
于与完整对象有关的各种操作，而不仅仅是其表面。例如，由体素 
表示的对象的体积仅仅是体内的体素的总和。网格的规则结构和体 
素明确定义的局部邻域意味着诸如烟雾，侵蚀或云形成的现象可以 
通过细胞自动机或其他算法来模拟。有限元分析利用体素来确定物 
体的抗拉强度。雕刻或雕刻模型成为减去体素的问题。相反，可以 
通过将多边形模型放置到体素网格中并确定其重叠的体素来完成建 
立精细模型。与必须处理奇点和精度问题的更传统的多边形工作流 
程相比，这种构造实体几何建模操作是高效的，可预测的并且保证 
可以工作。基于体素的系统，例如 OpenVDB [1249,1336]和 
NVIDIAGVDBVoxels [752,753]，用于电影制作，科学和医学可视 
化，3D打印和其他应用。见图13.27。13.10。体素 579图13.27。 
体素应用。在左侧，流体模拟直接在稀疏体素网格上计算并呈现为 
体积。在右边，将多边形兔子模型体素化为带符号的距离场，然后 
----------------------- Page 625-----------------------
用噪声函数对其进行扰动，并渲染等值面。（左图由 NVIDIAR提 
供，基于Wu等人的研究[1925]。使用 NVIDIARGVDBVoxels渲 
染的正确图像，由NVIDIA公司提供。）13.10.2体素存储体素存储 
具有显着的内存要求，因为数据根据体素分辨率按O （n3）增长。 
例如，每个维度中分辨率为 1000的体素网格产生十亿个位置。像 
Minecraft这样基于体素的游戏可以拥有巨大的世界。在该游戏中， 
数据以每个 16×16×256个体素的块进行流式传输，在每个玩家周 
围的某个半径范围内。每个体素存储标识符和附加方向或样式数据。 
然后每个块类型都有自己的多边形表示，是否是使用立方体显示的 
坚固石块，使用带有alpha的纹理的半透明窗口，或者由一对切口 
广告牌代表的草。有关示例，请参见第529页的图 12.10和第842 
页的图 19.19。存储在体素网格中的数据通常具有很大的一致性， 
因为相邻位置可能具有相同或相似的值。根据数据源，绝大多数网 
格可能是空的，这被称为稀疏卷。连贯性和稀疏性导致紧凑的表示。 
例如，可以在网格上施加八叉树 （第 19.1.3节）。在最低八叉树水 
平，每个2×2×2组体素样本可以全部相同，这可以在八叉树中注 
意并且丢弃体素。可以在树上检测到相似性，并丢弃相同的子八叉 
树节点。只有在数据不同的地方才需要存储它们。该稀疏体素八叉 
树（SVO）表示[87,304,308,706]导致自然水平的细节表示，即 
mipmap的三维体积等效物。见图 13.28和 13.29。Laine和 Karras 
[963]为SVO数据结构提供了大量的实现细节和各种扩展。58013. 
超越多边形图 13.28。稀疏的体素八叉树，呈二维形式。给定左侧 
----------------------- Page 626-----------------------
的一组体素，我们在树上注意哪些父节点中有哪些体素。右侧是最 
终八叉树的可视化，显示为每个网格位置存储的最深节点。（图中 
Laine和 Karras[963]之后。）图13.29。体素射线追踪在不同的细 
节水平。从左到右，分辨率为256,512，沿着包含模型的体素网格 
的每个边缘和1024。（使用Optix和 NVIDIARGVDBVoxels渲 
染的图像，由NVIDIACorporation提供[753]。）13.10.3体素的 
生成体素模型的输入可以来自各种来源。例如，许多扫描设备在任 
意位置生成数据点。GPU可以加速体素化，即将点云[930]，多边 
形网格或其他表示转换为一组体素的过程。对于网格，Karabassi 
等人的一种快速但粗略的方法。[859]是从六个正交视图渲染对象： 
顶部，底部和四个侧面。每个视图生成深度缓冲区，因此每个像素 
保持第一个可见体素从该方向的位置。如果体素的位置超出了六个 
缓冲区中每个缓冲区的深度，它不可见，因此标记为在对象内。此 
方法将错过在六个视图中的任何一个中都看不到的任何特征，导致 
一些体素被不正确地标记为内部。但是，对于简单模型，这种方法 
就足够了。受视觉船体的启发[1139]，Loop等人。[1071]使用甚至 
更简单的系统来创建现实世界中的人的体素。捕获一组人物的图像 
并提取轮廓。每个轮廓用于雕刻一组体素，只考虑其相机位置像素， 
您可以看到该人将具有与之相关的体素。13.10。体素 581图13.30。 
球体以三种不同方式进行体素化，并显示其横截面。在左边是一个 
固体体素，通过测试每个体素的中心与球体的关系来确定。中间是 
保守的体素化，选择球体表面触及的任何体素。该表面被称为26 
----------------------- Page 627-----------------------
分离体素化，其中在其3×3×3邻域中没有内部体素紧邻外部体素。 
换句话说，内部和外部体素永远不会共享面部，边缘或顶点。右侧 
是6分离的体素化，其中边缘和角落可以在内部和外部体素之间共 
享。（在Schwarz和Seidel之后的图[1594]。）也可以从一组图 
像中创建体素网格，例如生成切片然后堆叠的医学图像设备。沿着 
相同的线，可以逐片地渲染网格模型，并且适当地记录在模型内部 
找到的体素。调整近平面和远平面以限制每个切片，检查内容。 
Eisemann和 D'ecoret[409]介绍了切片图的概念，其中32位目标 
被认为是32个独立的深度，每个深度都有一个位标志。渲染到此体 
素网格的三角形的深度将转换为其等效位并存储。然后可以在渲染 
过程中渲染32个图层，如果使用更宽的通道图像格式和多个渲染目 
标，则可以使用更多的体素层用于通过。森林等。[480]给出了实现 
细节，并指出在现代GPU上，一次传递最多可以渲染 1024层。请 
注意，此切片算法仅识别模型的表面及其边界表示。上面的六视图 
算法还识别（尽管有时是错误分类）完全在模型内部的体素。有关 
三种常见类型的体素化，请参见图 13.30。Laine[964]提供了对术 
语，各种体素化类型以及生成和使用它们所涉及的问题的彻底处理。 
借助现代GPU中的新功能，可以实现更高效的体素化。Schwarz 
和 Seidel [1594,1595]和 Pantaleoni [1350]提出体素化系统 582 
13. Beyond Polygonstems使用计算着色器，它提供直接构建 
SVO的能力。Crassin和Green [306,307]描述了他们用于常规网 
格体素化的开源系统，该系统利用从OpenGL4.2开始可用的图像 
----------------------- Page 628-----------------------
加载/存储操作。这些操作允许对纹理存储器进行随机读写访问。通 
过使用保守光栅化（第23.1.2节）确定与体素重叠的所有三角形， 
他们的算法有效地计算体素占用率，以及平均颜色和正常。他们还 
可以使用此方法创建SVO，从上到下构建并在下降时仅对非空节点 
进行体素化，然后使用自下而上的过滤mipmap创建来填充结构。 
Schwarz [1595]给出了光栅化和计算内核体素化系统的实现细节， 
解释了每个系统的特征。Rauwendaal和 Bailey[1466]包括其混合 
系统的源代码。它们提供了并行化体素化方案的性能分析，以及正 
确使用保守光栅化以避免误报的细节。Takeshige [1737]讨论了如 
果可接受少量误差，MSAA如何成为保守光栅化的可行替代方案。 
Baert等人。[87]提出了一种用于创建SVO的算法，该算法可以有 
效地运行在核外，即，可以将场景高精度地体素化，而不需要将整 
个模型驻留在存储器中。鉴于对场景进行体素化所需的大量处理， 
动态对象（移动或以其他方式动画化）对基于体素的系统来说是一 
个挑战。Gaitatzes和 Papaioannou [510]通过逐步更新他们的场 
景的体素表示来解决这个任务。他们使用场景摄像机的渲染结果和 
生成的任何阴影贴图来清除和设置体素。对深度缓冲区进行体素测 
试，发现这些深度缓冲区比记录的z深度更接近。然后将缓冲区中 
的深度位置视为一组点并转换为世界空间。如果之前没有标记，则 
确定并设置这些点的相应体素。这个清晰的设置过程取决于视图， 
这意味着没有相机当前看到的场景部分实际上是未知的，因此可能 
是错误的来源。然而，这种快速近似方法使计算基于体素的全局照 
----------------------- Page 629-----------------------
明效果在动态环境中以交互速率执行（第11.5.6节）。13.10.4渲 
染体素数据存储在三维数组中，三维数组也可以被认为是三维纹理， 
并且实际上存储为三维纹理。这些数据可以以多种方式显示。下一 
章讨论了可视化半透明体素数据的方法，例如雾，或者放置切片平 
面以检查数据集的位置，例如超声图像。在这里，我们将专注于渲 
染表示实体对象的体素数据。想象一下最简单的体积表示，其中每 
个体素包含一点，指出它是在对象内部还是外部。有几种常见的方 
法可以显示这些数据[1094]。一种方法是直接将体积[752,753,1908] 
射线投射到 13.10。体素583图13.31。立方体剔除。在左侧，17074 
体素实心球由 102,444个四边形组成，每个体素六个。在中间，相 
邻固体体素之间的两个四边形被移除，将计数减少到4,770。外观 
与左侧相同，因为外壳未受影响。在右侧，快速贪婪算法合并面以 
形成更大的矩形，从而产生2,100个四边形。来自（ MikolaLysenko 
的剔除程序[1094]的图像。）确定每个立方体最近的击中面。另一 
种技术是将体素立方体转换为一组多边形。虽然使用网格进行渲染 
会很快，但这会在体素化过程中产生额外的成本，并且最适合静态 
体积。如果要将每个体素的立方体显示为不透明，那么我们可以剔 
除两个立方体相邻的任何面，因为它们之间的共享正方形是不可见 
的。这个过程给我们留下了一个正方形的船体，里面是空心的。简 
化技术 （第 16.5节）可以进一步减少多边形数量。见图 13.31。对 
于表示曲面的体素，对这组立方体面进行着色是不可信的。遮蔽立 
方体的常见替代方法是使用诸如行进立方体之类的算法创建更平滑 
----------------------- Page 630-----------------------
的网格表面[558,1077]。该过程称为表面提取或多边形化（也称为 
多边形化）。我们将其视为一个点样本，而不是将每个体素视为一 
个盒子。然后，我们可以使用2×2×2图案中的八个相邻样本形成 
立方体以形成角。这八个角的状态可以定义穿过立方体的表面。例 
如，如果立方体的顶部四个角在外部而底部四个在内部，则将立方 
体分成两半的水平方形是对表面形状的良好猜测。外侧的一个角和 
内侧的其余角产生三角形，该三角形由连接到外角的三个立方体边 
缘的中点形成。见图 13.32。将一组立方角转换为相应的多边形网 
格的过程是有效的，因为八个角位可以转换为0到255的索引，用 
于访问表格，该表格指定每种可能配置的三角形的数量和位置。渲 
染体素的其他方法，例如水平集[636]，更适合于平滑的曲面。想象 
一下，每个体素存储到被表示对象表面的距离，内部的正值和外部 
的负值。我们可以使用这些数据来调整所形成网格的顶点位置，以 
更准确地表示表面，如图 13.32右侧所示。或者，我们可以58413. 
BeyondPolygons0.10.3-0.60.0图13.32。行进的立方体。在左 
侧，四个底角是物体内部的体素中心，因此在底部和顶部四个角之 
间形成两个三角形的水平方形。在中间，一个角落在外面，所以形 
成一个三角形。在右边，如果有符号距离值存储在角落，那么我们 
可以将三角形顶点插入到每个边缘的0.0处。请注意，共享给定边 
的其他立方体将在该边沿的相同位置处具有顶点，以确保表面没有 
裂缝。直接对等值为零的水平集进行射线追踪。该技术称为水平集 
渲染[1249]。它特别擅长表示弯曲模型的曲面和法线而没有任何额 
----------------------- Page 631-----------------------
外的体素属性。表示密度差异的体素数据可以通过决定表面形状来 
以不同方式可视化。例如，一些给定的密度可以很好地代表肾脏， 
另一个密度可以显示任何肾结石。选择密度值定义等值面，一组具 
有相同值的位置。能够改变该值对于科学可视化特别有用。直接光 
线跟踪任何等值面值是水平集光线跟踪的一般化，其中目标值始终 
为零。或者，可以提取等值面并将其转换为多边形模型。在2008 
年，Olick[1323]进行了一次有影响力的讨论，讨论如何通过光线投 
射直接渲染稀疏的体素表示，激发了进一步的工作。针对规则化体 
素测试光线非常适合于GPU实现，并且可以以交互式帧速率完成。 
许多研究人员已经探索了这个渲染领域。有关该主题的介绍，请从 
Crassin的博士论文[304]和SIGGRAPH演示文稿[308]开始，其中 
介绍了基于体素的方法的优点。Crassin通过使用锥形跟踪来利用数 
据的类似mipmap的特性。一般的想法是使用体素表示的规则性和 
明确定义的局部性属性来定义几何和着色属性的预过滤方案，允许 
使用线性过滤器。单个光线在场景中被跟踪，但是能够通过从其起 
点发出的锥体收集近似的可见度。当光线穿过空间时，其感兴趣的 
半径增长，这意味着体素层次结构在链的较高位置采样，类似于当 
更多纹素落在单个像素内时，mipmap的采样方式更高。这种类型 
的采样可以快速计算13.10。体素585图13.33。锥形跟踪阴影。 
顶部：在20秒内在 Maya中渲染的光线跟踪球面区域光。底部： 
同一场景的体素化和锥形追踪耗时约20毫秒。模型使用多边形渲 
染，体素版本用于阴影计算。 （图片由Crytek[865]提供。）例如， 
----------------------- Page 632-----------------------
软阴影和景深，因为这些效果可以分解为锥形追踪问题。区域采样 
对于其他过程可能很有价值，例如抗锯齿和适当过滤不同的表面法 
线。Heitz和 Neyret[706]描述了以前的工作，并提出了一种用于 
锥形跟踪的新数据结构，可以提高可见度计算结果。Kasyan[865] 
使用体素锥跟踪区域光，讨论误差源。比较如图 13.33所示。有关 
最终结果，请参见第264页的图7.33。第11.5.7节讨论并说明了 
锥形跟踪用于计算全局照明效果的用途。58613.超越多边形最近的 
趋势探索GPU上超过八叉树的结构。八叉树的一个主要缺点是诸如 
光线跟踪之类的操作需要大量的树遍历跳，因此需要存储大量的中 
间节点。Hoetzlein[752]表明，VDB树的GPU光线跟踪（网格层 
次结构）可以在八叉树上实现显着的性能提升，并且更适合于体积 
数据的动态变化。Fogal等人。[477]证明了索引表而不是八叉树可 
以用于使用两遍方法实时渲染大量卷。第一遍标识可见的子区域（砖 
块），以及来自磁盘的那些区域中的流。第二遍渲染当前驻留在内 
存中的区域。Beyer等人提供了对大规模体积渲染的全面调查。 
[138]。13.10.5其他主题例如，表面提取通常用于可视化隐式曲面 
 （第17.3节）。基本算法有不同的形式，以及如何形成网格的一些 
细微之处。例如，如果发现立方体的每个其他角都在内部，那么这 
些角是应该在形成的多边形网格中连接在一起，还是保持分开？参 
见deAra'ujo等人的文章。[67]用于隐式曲面的多边形化技术的调 
查。奥斯汀[85]贯穿了各种一般多边形化方案的优点和缺点，找到 
了立方体行进方块以获得最理想的属性。当使用光线投射进行渲染 
----------------------- Page 633-----------------------
时，可以使用除完全多边形化之外的其他解例如，Laine和 Karras 
[963]将一组平行平面连接到接近表面的每个体素，然后使用后处理 
模糊来掩盖体素之间的不连续性。Heitz和 Neyret[706]以线性可 
过滤的表示方式访问带符号的距离，该表示允许重建平面方程并确 
定给定方向上的任何空间位置和分辨率的覆盖范围。Eisemann和 
D'ecoret[409]展示了对于半透明重叠表面投射阴影的情况，如何 
使用体素表示来执行深阴影映射（第7.8节）。正如K¨ampe，Sintorn 
等人[850,1647]所示，体素化场景的另一个优点是可以使用这一个 
表示来测试所有光的阴影光线，而不是为每个光源生成阴影贴图。 
与直接可见的表面渲染相比，眼睛对阴影和间接照明等次要效果中 
的小错误更加宽容，并且这些任务需要更少的体素数据。当仅跟踪 
体素的占用时，在许多稀疏体素节点之间可能存在极高的自相似性 
[849,1817]。例如，墙将形成在多个级别上相同的体素集。这意味 
着树中的各个节点和整个子树是相同的，因此我们可以将单个实例 
用于此类节点，并将它们存储在所谓的有向非循环图中（第 19.1.5 
节）。这样做通常会导致每个体素结构所需的内存量大幅减少。 
13.10。Voxels 587进一步阅读和资源Szeliski的计算机视觉中讨 
论了基于图像的渲染，光场，计算摄影和许多其他主题：算法和应 
用[1729]。请访问我们的网站realtimerendering.com，获取这个 
有价值的免费电子版的链接。Weier等人讨论了利用我们视觉感知 
系统的局限性的各种加速技术。[1864]在他们最先进的报告中。迪 
特里希等人。[352]在其关于大规模模型渲染的报告的侧边栏中提供 
----------------------- Page 634-----------------------
了基于图像的技术的概述。我们只涉及图像，粒子和其他非多边形 
方法用于模拟自然现象的一些方法。有关更多示例和详细信息，请 
参阅参考文章。一些文章讨论了广泛的技术。Beacco等人对人群渲 
染技术的调查。[122]讨论了冒名顶替者的各种变化，细节方法等等。 
GJ。l和Svendsen的演示文稿[539]提供了基于图像的采样和滤波 
技术，可用于各种效果，包括绽放，闪光，水效果，反射，雾，火 
和烟。第 14章体积和半透明渲染 “你想要的人应该看得最远，你必 
须按比例更蓝; 因此，如果一个是五倍的距离，那就让它变蓝五倍。 
 “-LeonardoDaVinci参与媒体是用来描述充满粒子的体积的术 
语。正如我们可以从名称中看出的那样，它们是参与光传输的媒体， 
换句话说它们会影响通过散射或吸收穿过它们的光。在渲染虚拟世 
界时，我们通常关注固体表面，简单而复杂。这些表面看起来是不 
透明的，因为它们是通过从密集的参与介质 （例如，通常使用 BRDF 
建模的电介质或金属）反射的光来定义的。密度较小的众所周知的 
介质是由稀疏分子组成的水，雾，蒸汽甚至空气。取决于其组成， 
介质将与穿过它的光和从其粒子反弹的光不同地相互作用，这种事 
件通常被称为光散射。颗粒的密度可以是均匀的（均匀的），如在 
空气或水的情况下。或者它可能是异质的（非均匀的，随着空间中 
的位置而变化），如云或蒸汽的情况。一些通常呈现为固体表面的 
致密材料表现出高水平的光散射，例如皮肤或蜡烛蜡。如第9.1节 
所示，漫反射表面着色模型是微观层面上光散射的结果。一切都在 
分散。14.1光散射理论在本节中，我们将描述参与媒体中光的模拟 
----------------------- Page 635-----------------------
和渲染。这是对物理现象，散射和吸收的定量处理，这在第9.1.1 
和9.1.2节中讨论过。许多作者[479,743,818,1413]在具有多次散 
射的路径追踪的背景下描述了辐射传递方程。在这里，我们将专注 
于单一散射，并建立一个关于它如何工作的良好直觉。单次散射仅 
考虑一次反射光 589590 14.体积和半透明渲染符号说明单位？a 
吸收系数m.1？s散射系数m.1？t消光系数m。1？反照率无单位 
p阶段函数sr.1表 14.1。用于散射和参与媒体的符号。这些参数中 
的每一个都可以取决于波长（即RGB）以实现有色光吸收或散射。 
相位函数的单位是逆梯度（第8.1.1节）。在构成参与媒体的粒子 
上。多次散射跟踪每个光路的许多反弹，因此更加复杂[243,479]。 
有和没有多次散射的结果可以在第 146页的图 14.51中看到。用于 
表示散射方程中参与介质属性的符号和单位如表 14.1所示。请注 
意，本章中的许多量，例如σa，σs，σt，p，ρ，v和Tr都是波长相 
关的，实际上这意味着它们是 RGB量。14.1.1参与媒体材料有四种 
类型的事件可以影响沿光线通过介质传播的辐射量。这些如图 14.1 
所示，并总结为：。吸收（σa的作用） - 光子被介质的物质吸收 
并转化为热量或其他形式的能量。。向外散射（σs的函数） - 光 
子通过在介质中反弹粒子而散开。这将根据描述光反射方向分布的 
相位函数p发生。。当介质达到高温时，例如火焰的黑体辐射，可 
以发射光。有关发射的更多详细信息，请参阅Fong等人的课程说 
明。[479]。。散射（σs的函数） - 来自任何方向的光子可以在反 
射粒子后散射到当前光路中并有助于最终的辐射。从给定方向散射 
----------------------- Page 636-----------------------
的光量也取决于该光方向的相位函数p。总结一下，将光子添加到 
路径是散射σ和发射的函数。去除光子是消光σt=σa+σs的函数，表 
示吸收和外散射。如辐射传递方程所解释的那样，14.1。光散射理 
论591......吸收散射发射入射散射dddd图14.1。不同的事件在参 
与媒体中沿着方向d改变辐射。系数组表示位置x处的辐射率和相 
对于 L（x，v）的方向v的导数。这就是为什么这些系数的值都在[0， 
+∞]范围内。参见 Fong等人的笔记。[479]有关详情。散射和吸收 
系数决定了介质的反照率ρ，定义为ρ=σsσs+σa=σsσt，（14。1） 
表示对于所考虑的每个可见光谱范围，即介质的总反射率，相对于 
介质中的吸收的散射的重要性。ρ的值在[0,1]范围内。接近0的值 
表示大部分光被吸收，导致黑暗的介质，例如黑暗的排气烟雾。接 
近 1的值表示大部分光被散射而不是被吸收，从而产生更明亮的介 
质，例如空气，云或地球的大气。如第9.1.2节所述，介质的外观 
是其散射和吸收特性的组合。已经测量和发布了真实世界参与媒体 
的系数值[1258]。例如，牛奶具有高散射值，产生混浊和不透明的 
外观。由于高反照率ρ>0.999，牛奶也呈现白色。另一方面，红葡 
萄酒几乎没有散射，而是高吸收，使其具有半透明和彩色的外观。 
请参见图 14.2中的渲染液体，并与第301页的图9.8中的拍摄液体 
进行比较。这些属性和事件均与波长有关。这种依赖意味着在给定 
的介质中，不同的光频率可以以不同的概率被吸收或散射。理论上， 
为了解释这一点，我们应该在渲染中使用光谱值。为了提高效率， 
在实时渲染中（以及在离线渲染中有一些例外[660]），我们使用 
----------------------- Page 637-----------------------
RGB值。在可能的情况，σa和σs等量的 RGB值应使用颜色匹配函 
数从光谱数据中预先计算（第8.1.3节）。在前面的章节中，由于 
没有参与媒体，我们可以假设进入相机的辐射与离开最近表面的辐 
射相同。更确切地说，我们假设 （在第310页）Li （c，.v）=Lo （p， 
v），其中c是摄像机位置，p是最近表面与视线的交点，v是单位 
视图向量从p指向c。一旦引入了参与媒体，这个假设就不再成立， 
我们需要考虑沿着视线的辐射变化。作为一个例子，我们将59214. 
体积和半透明渲染图 14.2。分别呈现葡萄酒和牛奶具有不同浓度的 
吸收和散射。 （图片由Narasimhan等人提供[1258]。）现在描述 
了评估来自准点光源的散射光的计算，即由单个无穷小点表示的光 
源 （第9.4节）：Li （c，.v） ）=Tr （c，p）Lo （p，v）+Zkp.ck 
t =0Tr （c，c.vt）Lscat （c.vt，v）σsdt， （14.2）其中Tr （c，x） 
是给定点x和摄像机位置c之间的透射率（第 14.1.2节），Lscat 
 （x，v）是在光线上给定点x沿视线 （第 14.1.3节）散射的光。计 
算的不同组成部分如图 14.3所示，并在以下小节中进行了解释。关 
于方程14.2如何从辐射传递方程导出的更多细节可以在Fong等人 
的课程笔记中找到。[479]。.... +1......，..l......t×..........，..........-1.... 
v ........cp图14.3。从准时光源进行单次散射积分的插图。沿视图 
射线的采样点以绿色显示，一个点的相位函数以红色显示，而不透 
明表面S的BRDF以橙色显示。这里，lc是光中心的方向矢量，plight 
是光的位置，p是相位函数，函数v是可见项。14.1。光散射理论 
59351015200.20.40.60.8 1.0图14.4。作为深度函数的透射 
----------------------- Page 638-----------------------
率，σt= （0.5,1.0,2.0）。正如所料，红色成分的消光系数越低，红 
色就越多。14.1。2透射率透射率Tr表示根据Tr （xa，xb）=e， 
能够通过介质超过一定距离的光的比率。，其中τ=Zxbx =xaσt 
 （x）kdxk。（14.3）这种关系也称为比尔 - 兰伯特定律。光学深 
度τ是无单位的并且表示光衰减量。消光或穿过的距离越高，光学深 
度越大，反过来，光通过介质的光越少。光学深度τ=1将消除大约 
60％的光。例如，如果 RGB中的σt= （0.5,1,2），那么通过深度d 
=1米的光将是Tr =ed？t≈ （0.61,0.37,0.14）。此行为如图 14.4 
所示。透射率需要应用于 （i）不透明表面的辐射亮度 Lo （p，v）， 
 （ii）辐射亮度Lscat （x，v）由散射事件产生，和（iii）从散射事 
件到光源的每条路径。在视觉上，（i）将导致一些雾状的表面遮挡， 
 （ii）将导致散射光的遮挡，给出关于介质厚度的另一视觉提示 （见 
图14.6），并且（iii）将导致体积自我 - 参与媒体的阴影（见图 
14.5）。由于σt=σa+σs，预期透射率受吸收和散射分量的影响。 
14.1.3散射事件对于给定位置x和方向v，对场景中的准点光源进 
行入射散射可以如下进行：Lscat （x，v）=πXni =1p （v，lci）v 
 （x，plighti）clighti （kx.plightik），（14.4）594 14.体积和半 
透明渲染图 14.5。由参与媒体制作的斯坦福兔子的体积阴影示例 
[744]。左：没有体积自阴影; 中间：自我遮蔽;右：在其他场景元素 
上投射阴影。（模型由斯坦福计算机图形实验室提供。）其中n是 
灯的数量，p （）是相位函数，v （）是可见度函数，lci是第i个光 
的方向向量，plighti是位置第i个光。此外，clighti （）是来自第 
----------------------- Page 639-----------------------
i个光的辐射，作为到其位置的距离的函数，使用第9.4节中的定义 
和第5.2.2节中的反平方衰减函数。可见度函数v （x，plighti）表 
示根据v （x，plighti）=shadowMap （x，plighti）·volShad （x， 
x），从光源到达光源的位置x的光的比率。plighti）， （14.5）其 
中volShad （x，plighti）=Tr （x，plighti）。在实时渲染中，阴 
影来自两种遮挡：不透明和体积。不透明物体（shadowMap）的 
阴影传统上是使用阴影映射或第7章中的其他技术计算出来的。公 
式 14.5的体积阴影项volShad（x，plighti）表示从光源位置plighti 
到采样点x的透射率，其值为范围[0,1]。体积产生的遮挡是体积渲 
染的关键组成部分，其中体积元素可以在其他场景元素上自阴影或 
投射阴影。见图14.5。这个结果通常是通过沿着主要射线从眼睛穿 
过体积到第一表面进行射线行进来实现的，然后沿着从这些样品中 
的每一个朝向每个光源的二次射线路径。 “射线行进”是指使用 n 
个样本对两点之间的路径进行采样的行为，沿途集成散射光和透射 
率。有关此采样方法的更多详细信息，请参见第6.8.1节，在这种 
情况下，用于渲染高度场。对于三维体积，射线行进是类似的，每 
条射线逐步进行，并在沿途的每个点处对体积材料或照明进行采样。 
请参见图 14.3，其中显示绿色主光线和蓝色辅助阴影光线上的采样 
点。许多其他出版物也详细描述了光线行进[479,1450,1908]。具有 
O （n2）复杂度，其中n是沿每条路径的样本数量，射线行进很快 
变得昂贵。作为质量和性能之间的权衡，可以使用特定的体积阴影 
表示技术来存储发送 14.1。光散射理论595图14.6。斯坦福龙随 
----------------------- Page 640-----------------------
着媒体集中度的提高。从左到右：0.1,1.0和 10.0，σs=（0.5,1.0,2.0）。 
 （模型由斯坦福计算机图形实验室提供。）从灯光的传出方向。这 
些技术将在本章其余部分的相应章节中进行说明。为了获得关于介 
质中光散射和消光行为的一些直觉，考虑σs= （0.5,1,2）和σa= 
 （0,0,0）。对于介质内的短光路，散射事件将主导消光，例如在这 
种情况下的散射，其中Tr≈1小的深度。材料看起来是蓝色的，因为 
该通道的σs值最高。光线穿透介质越深，由于灭绝，光子将越少。 
在这种情况下，消光的透射颜色将开始占主导地位。这可以解释为 
我们有σt=σs，因为σa= （0,0,0）。结果，使用公式 14.2，Tr =ed？ 
t将比作为光学深度dσs的函数的散射光的线性积分快得多地降低。 
对于这个例子，红光通道将不太可能通过介质消失，因为该通道的σ 
t值最低，因此它将占主导地位。这种行为如图 14.6所示，正是在 
大气和天空中发生的事情。当太阳高时 （例如，通过大气的短光路， 
垂直于地面），蓝光散射更多，给天空带来天然的蓝色。然而，当 
太阳落在地平线上时，由于穿过大气层有一条很长的光路，因为更 
多的红光传播，天空会显得更红。这导致了我们都知道的美丽的日 
出和日落过渡。有关大气材料成分的更多详细信息，请参见第 14.4.1 
节。有关此效果的另一个示例，请参见第299页的图9.6右侧的乳 
白玻璃.14.1.4相位功能参与介质由具有不同半径的粒子组成。这些 
粒子的大小分布将影响光相对于光的向前行进方向在给定方向上散 
射的概率。第9.1节解释了这种行为背后的物理特性。59614.体积 
和半透明渲染..........AB ..B..轻型前进行驶方向图 14.7。相位函数 
----------------------- Page 641-----------------------
 （红色）的图示及其对作为θ的函数的散射光 （绿色）的影响。在评 
估散射时，使用相位函数来描述宏观水平下散射方向的概率和分布， 
如公式 14.4所示。如图 14.7所示。红色的相位函数用参数θ表示为 
光的蓝色前向行进路径和绿色的方向v之间的角度。注意这个相位 
函数示例中的两个主瓣：在光路的相反方向上的小的后向散射波瓣 
和大的前向散射波瓣。摄像机 B朝向大前向散射波瓣的方向，因此， 
与摄像机A相比，它将获得更多的散射辐射。为了节能和保持，即 
没有能量增益或损失，相位函数在单位球面上的积分必须为 1.相位 
函数将改变根据到达该点的定向辐射信息在一点处的散射。最简单 
的功能是各向同性：光将在所有方向上均匀散射。这种完美但不切 
实际的行为表现为 p （θ）=14π，（14.6）其中θ是入射光和外向 
散射方向之间的角度，4π是单位球面积。基于物理的相位函数取决 
于根据sp =2πrλ的粒子的相对大小sp，（14.7）其中r是粒子半 
径而λ是所考虑的波长[743]:.当sp。1，存在瑞利散射（例如，空 
气）。。当sp≈1时，存在米氏散射。。当sp。1，有几何散射。 
Rayleigh散射 LordRayleigh （1842-1919）推导出来自空气中分 
子的光散射的术语。除了其他应用之外，这些表达式还用于描述地 
球大气中的光散射。该相位函数有两个波瓣，如图14.1所示。光散 
射理论 597-0.15 -0.10 -0.050.050.100.15 -0.10-0.050.05 
0.10图14.8。作为θ的函数的瑞利相位的极坐标图。光线从左侧水 
平传播，相对强度显示角度θ，从x轴逆时针测量。前向和后向散射 
的机会是相同的。在图 14.8中，称为向后和向前散射，相对于光线 
----------------------- Page 642-----------------------
方向。该函数在θ处进行评估，θ是入射光和向外散射方向之间的角 
度。函数是p （θ）=316π （1+cos2θ）。 （14.8）瑞利散射高度 
依赖于波长。当作为光波长λ的函数观察时，瑞利散射的散射系数σ 
s与波长的倒数四次方成比例：σs （λ）α1λ4。（14.9）这种关系 
意味着短波长的蓝光或紫光比长波红光散射得更多。可以使用光谱 
颜色匹配函数将公式 14.9的光谱分布转换为RGB （第8.1.3节）： 
σs= （0.490,1.017,2.339）。该值归一化为亮度1，并且应根据所 
需的散射强度进行缩放。第 14.4.1节解释了蓝光在大气中散射的视 
觉效果。MieScattering Mie散射[776]是当粒子的大小与光的波 
长大致相同时可以使用的模型。这种类型的散射不依赖于波长。 
MiePlot软件可用于模拟这种现象[996]。Mie相59814.体积和半 
透明渲染 0.2 0.4 0.6 0.8 - 0.15 - 0.10 - 0.05 0.05 0.10 0.15 图 
14.9。Henyey-Greenstein （蓝色）和Schlick近似（红色）相位 
的极坐标图作为θ的函数。光线从左侧水平传播。参数g从0增加 
到0.3和0.6，从而产生向右的强大波瓣，这意味着光将沿着其前向 
路径从左向右散射更多。用于特定粒度的函数通常是具有强且尖锐 
的方向波瓣的复杂分布，即，表示相对于光子行进方向在特定方向 
上散射光子的高概率。计算用于体积着色的这种相位函数在计算上 
是昂贵的，但幸运的是它很少需要。介质通常具有连续的粒度分布。 
对所有这些不同尺寸的Mie相位函数求平均导致整个介质的平滑相 
位函数。因此，可以使用相对平滑的相位函数来表示米氏散射。通 
常用于此目的的一相功能是Henyey-Greenstein （HG）相位函数， 
----------------------- Page 643-----------------------
其最初被提出用于模拟星际尘埃中的光散射[721]。该函数不能捕获 
每个真实世界散射行为的复杂性，但它可以很好地匹配表示相位函 
数波瓣之一[1967]，即朝向主散射方向。它可用于表示任何烟雾， 
雾或类似粉尘的参与媒体。这种介质可以表现出强烈的向后或向前 
散射，从而在光源周围产生大的视觉光晕。例如，雾中的聚光灯和 
太阳方向云层边缘的强烈银色效应。HG相位函数可以表示比瑞利 
散射更复杂的行为，并且使用phg （θ，g）=1来评估。g24π （1 
+g2.2gcosθ）1.5。（14.10）它可以产生各种形状，如图14.9所 
示。g参数可用于表示向后（g <0），各向同性（g =0）或向前 
 （g>0）散射，g在[.1,1]中。使用 HG相功能的散射结果示例如图 
14.10所示。获得与 Henyey-Greenstein相函数类似结果的更快方 
法是使用 Blasi等人提出的近似。[157]，通常以 14.1命名。光散射 
理论 599图14.10。参与媒体斯坦福兔子显示HG相功能影响，g 
从各向同性到强向前散射。从左到右：g=0.0,0.5,0.9,0.99和0.999。 
底行使用十倍密度的参与媒体。（模型由斯坦福计算机图形实验室 
提供。）第三作者作为Schlick相位函数：p （θ，k）=1。k24π 
 （1 +kcosθ）2，其中k≈1.55g。0.55g3。（14.11）它不包括任 
何复杂的幂函数，而只包括一个正方形，评估速度要快得多。为了 
将该函数映射到原始 HG相位函数，需要从g计算k参数。对于具 
有恒定g值的参与媒体，这只需要进行一次。实际上，Schlick相位 
函数是一种出色的节能近似，如图 14.9所示。还可以混合多个 HG 
或Schlick相位函数以表示更复杂的一般相位函数范围[743]。这允 
----------------------- Page 644-----------------------
许我们同时表示具有强前向和后向散射波瓣的相位函数，类似于云 
的行为方式，如第 14.4.2节中所述和所示。几何散射几何散射发生 
在明显大于光波长的粒子上。在这种情况下，光可以在每个粒子内 
折射和反射。此行为可能需要复杂的散射相位函数才能在宏级别上 
模拟它。光偏振也会影响这种散射。例如，一个真实的例子是视觉 
彩虹效果。它是由空气中水粒子内部的光的内部反射引起的，将太 
阳光在所产生的向后散射的小视角 （~3度）内分散成可见光谱。可 
以使用MiePlot软件[996]模拟这种复杂的相位函数。第 14.4.2节 
描​ ​ 述了这种相位函数的一个例子。60014.体积和半透明渲染图 
14.11。雾曾用来强调情绪。 （图片由NVIDIACorporation提供。） 
14。2专业体积渲染本节介绍以基本有限的方式渲染体积效果的算 
法。有些人甚至可能会说这些都是旧学校的伎俩，往往依赖于临时 
模型。使用它们的原因是它们仍能正常工作。14.2.1大型雾雾可以 
近似为基于深度的效果。它最基本的形式是根据与相机的距离在场 
景顶部对雾颜色进行Alpha混合，通常称为深度雾。这种效果是观 
众的视觉提示。首先，它可以提高现实主义和戏剧性的水平，如图 
14.11所示。其次，它是一个重要的深度提示，帮助场景的观察者 
确定物体的位置。见图 14.12。第三，它可以用作遮挡剔除的一种 
形式。如果物体在距离太远时被雾完全遮挡，则可以安全地跳过它 
们的渲染，从而提高应用程序性能。表示雾量的一种方法是使[0,1] 
中的f表示透射率，即f =0.1表示 10％的背景表面是可见的。假 
设表面的输入颜色为ci且雾颜色为cf，则最终颜色c由c =fci + 
----------------------- Page 645-----------------------
 （1.f）cf确定。 （14.12）可以用许多不同的方式评估值f。雾可以 
使用f =zend线性增加。zszend。zstart，（14.13）14.2。专业 
的体积渲染601图14.12。Fog用于来自Battlefield1 DICE（ 游戏） 
的一个级别的图像，以揭示游戏区域的复杂性。深度雾用于揭示风 
景的大规模性质。高雾，在地面右侧可见，显示从山谷中升起的大 
量建筑物。（由 DICE提供，c2018 ElectronicArts Inc.），其中 
zstart和zend是用户参数，用于确定雾的开始和结束位置（即变 
为完全模糊），zs是从观察者到表面的线性深度雾是要计算的。评 
估雾透过率的物理精确方法是使其随距离呈指数增长，因此遵循比 
尔 - 朗伯变换法则（第14.1.2节）。使用f =e.dfzs，（14.14） 
可以实现这种效果，其中标量df是控制雾密度的用户参数。这种传 
统的大尺度雾是对大气中光散射和吸收的一般模拟的粗略近似（第 
14.4.1节），但它仍然在今天的游戏中使用效果很好。见图 14.12。 
这就是传统OpenGL和 DirectXAPI中硬件雾的暴露方式。仍然值 
得考虑将这些模型用于移动设备等硬件上的简单用例。许多当前的 
游戏依赖于更高级的后处理来处理大气效应，例如雾和光散射。透 
视图中雾的一个问题是深度缓冲值是以非线性方式计算的 （第23.7 
节）。可以使用逆投影矩阵数学将非线性深度缓冲值转换回线性深 
度zs [1377]。然后可以使用像素着色器将雾应用为全屏通道，从而 
实现更高级的结果，例如依赖于高度的雾或水下阴影。高度雾表示 
具有参数化高度和厚度的单个参与介质板。对于屏幕上的每个像素， 
密度和散射光被评估为视线在击中表面之前穿过板的距离的函数。 
----------------------- Page 646-----------------------
Wenzel [1871]提出了一种封闭形式的解决方案，用于评估f中参与 
媒体在平板内的指数下降。这样做可以在板坯边缘附近产生平滑的 
雾过渡。这在图 14.12左侧的背景雾中可见。60214.体积和半透明 
渲染深度和高度雾可能有很多种变化。颜色cf可以是单一颜色，可 
以从使用视图矢量采样的立方体贴图中读取，或者甚至可以是复杂 
的大气散射的结果，其中每像素相位函数应用于方向颜色变化 
[743]。还可以使用f =fdfh组合深度fd和高度fh雾透射率，并且 
在场景中将两种类型的雾交错在一起。深度和高度雾是大规模的雾 
效应。人们可能想要渲染更多的局部现象，例如在洞穴中或在墓地 
中的几个墓穴周围的分离的雾区域。椭圆形或盒形等形状可用于在 
需要时添加局部雾[1871]。这些雾元素使用其边界框从后向前渲染。 
在像素着色器中评估沿着每个形状的视图矢量的前df和后db交 
点。使用体积深度为d =max （0，min （zs，db）。df），其中 
zs是表示最接近的不透明表面的线性深度，可以评估透射率Tr （第 
14.1.2节），覆盖范围为α=1.0。TR。然后可以将在顶部添加的散 
射光量计算为αcf。为了允许从网格评估更多变化的形状，Oat和 
Scheuermann [1308]给出了计算体积中最近入口点和最远出口点 
的巧妙单程方法。它们将表面距离ds保存到一个通道中的表面，以 
及 1。ds在另一个频道。通过设置alpha混合模式以保存找到的最 
小值，在渲染卷之后，第一个通道将具有最接近的值df，第二个通 
道将具有最远值db，编码为1。d，允许恢复d。水是一种参与媒 
介，因此，表现出相同类型的基于深度的颜色衰减。沿海水的透过 
----------------------- Page 647-----------------------
率约为每米 （0.3,0.73,0.63）[261]，因此使用公式14.23我们可以 
恢复σt= （1.2,0.31,0.46）。当使用不透明表面渲染暗水时，可以在 
相机位于水面下时启用雾逻辑，并在上方关闭时启用雾逻辑。 
Wenzel [1871]提出了一种更先进的解决方案。如果相机在水下， 
则会散射散射和透射率，直到撞击固体或水面。如果在水面之上， 
这些仅从水的顶部表面到海床的实心几何形状之间的距离整合。 
14.2.2简单的体积照明参与介质中的光散射可能很复杂，无法评估。 
值得庆幸的是，在许多情况下，有许多有效的技术可以令人信服地 
用于近似这种散射。获得体积效果的最简单方法是渲染在帧缓冲区 
上混合的透明网格。我们将此称为splatting方法（第 13.9节）。 
为了使光轴透过窗户，茂密的森林或聚光灯照射，一种解决方案是 
使用相机对齐的粒子，每个粒子都有纹理。每个纹理四边形在光轴 
方向上拉伸，同时始终面向相机（圆柱约束）。14.2。专业体积渲 
染603图14.13。光源的体积光散射使用第603页的代码片段中的 
分析积分进行评估。它可以作为假设均匀介质（左）或粒子的后效 
应应用，假设它们中的每一个都是具有深度的体积（右）。（图片 
由MilesMacklin提供[1098]。）网格喷溅方法的缺点是累积许多 
透明网格会增加所需的内存带宽，可能导致瓶颈，并且面向相机的 
纹理四边形有时可见。为了解决这个问题，已经提出了使用封闭形 
式的解决方案来解决单个散射的后处理技术。假设均匀且球形的均 
匀相位函数，可以沿着假定介质的恒定路径对散射光和正确的透射 
率进行积分。结果如图 14.13所示。此技术的示例实现在此处显示 
----------------------- Page 648-----------------------
在 GLSL 着色器代码片段[1098]中：float inScattering （vec3 
rayStart，vec3 rayDir，vec3 lightPos，float rayDistance）{// 
计算系数。vec3 q =rayStart-lightPos;float b =dot （rayDir， 
q）;floatc =dot （q，q）;float s =1.0f/ sqrt （c-b* b）;// 
对某些组件进行分解。float x =s * rayDistance;float y =s * 
b;returns*atan （（x）/ （1.0+ （x +y）*y））;其中rayStart 
是光线起始位置，rayDir是光线标准化方向，rayDistance是沿光 
线的积分距离，lightPos是光源 604 14.体积和半透明渲染图 
14.14。使用屏幕空间后处理渲染的光轴。 （图片由KennyMitchell 
提供[1225]。）位置。Sun等人的解决方案。[1722]另外考虑散射 
系数σs。它还描述了在撞击任何表面之前，光在非直线路径中会散 
射的事实应该如何影响从Lambertian和Phong表面反射的漫反射 
和镜面反射辐射。为了考虑透射率和相位函数，可以使用更多ALU 
重量的溶液[1364]。所有这些模型都有效，但无法考虑深度图或异 
构参与媒体的阴影。通过依赖称为bloom[539,1741]的技术，可以 
近似屏幕空间中的光散射。模糊帧缓冲并将其中的一小部分添加回 
自身[44]将使每个明亮物体在其周围泄漏辐射。此技术通常用于近 
似相机镜头中的缺陷，但在某些环境中，它是一种适用于短距离和 
非遮挡散射的近似值。第 12.3节更详细地描述了bloom。Dobashi 
等。[359]提出了一种使用对该体积进行采样的一系列平面来渲染大 
规模大气效应的方法。这些平面垂直于视图方向，并从后向前渲染。 
Mitchell[1219]也提出了相同的方法来渲染聚光灯轴，使用阴影贴 
----------------------- Page 649-----------------------
图来投射不透明物体的体积阴影。第 14.3.1节详细介绍了通过喷溅 
切片渲染体积。Mitchell [1225]和 Rohleder和Jamrozik [1507] 
提出了一种在屏幕空间中工作的替代方法;见图14.14。它可用于从 
远处的光线（如太阳）渲染光轴。第一，在清除黑色的缓冲区中， 
在远处的平面上围绕太阳渲染假的明亮物体，并且使用深度缓冲测 
试来接受非遮挡的像素。其次，在图像上应用方向模糊，以便从太 
阳向外泄漏先前累积的辐射。可以使用可分离滤波技术（第 12.1 
节），其中两个通道使用n个样本，以获得与 n2个样本相同的模 
糊结果，但渲染速度更快[1681]。要完成，可以将最终模糊缓冲区 
添加到场景缓冲区中。该技术是有效的，并且尽管仅在屏幕上可见 
的光源可以投射光轴的缺点，但是它以低成本提供了显着的视觉效 
果。14.3。一般体积渲染60514.3一般体积渲染在本节中，我们提 
出了基于物理的体积渲染技术，即试图表示介质材料及其与光源的 
相互作用 （第 14.1.1节）。一般体积渲染涉及空间变化的参与介质， 
通常使用体素（第 13.10节）表示，体积光相互作用导致视觉上复 
杂的散射和阴影现象。一般体积渲染解决方案还必须考虑具有其他 
场景元素的卷的正确组合，例如不透明或透明表面。空间变化的媒 
体属性可能是需要在游戏环境中渲染的烟雾和火焰模拟的结果，以 
及体积光和阴影的相互作用。交替，我们可能希望将固体材料表示 
为半透明体积，用于医学可视化等应用。14.3.1体数据可视化体数 
据可视化是一种用于显示和分析体数据的工具，通常是标量字段。 
计算机断层扫描（CT）和磁共振图像（MRI）技术可用于创建体内 
----------------------- Page 650-----------------------
结构的临床诊断图像。例如，数据集可以是2563个体素，每个位 
置保持一个或多个值。该体素数据可用于形成三维图像。体素渲染 
可以显示实体模型，或使各种材料（例如，皮肤和头骨）部分或完 
全透明。切割平面可用于仅显示子体积或源数据的一部分。除了用 
于医学和石油勘探等多种领域的可视化之外，体积渲染还可以产生 
逼真的图像。有许多体素渲染技术[842]。可以使用常规路径跟踪或 
光子映射在复杂照明环境下可视化体积数据。已经提出了几种较便 
宜的方法来实现实时性能。对于实体对象，隐式曲面技术可用于将 
体素转换为多边形曲面，如第 17.3节中所述。对于半透明现象，可 
以通过垂直于视图方向的层中的一组等间隔切片对体数据集进行采 
样。图 14.15显示了它的工作原理。用这种方法也可以渲染不透明 
表面[797]。在这种情况下，当密度大于给定阈值时，认为固体体积 
存在，并且可以将法线n评估为密度场的三维梯度。对于半透明数 
据，可以存储每个体素的颜色和不透明度。为了减少内存占用并使 
用户能够控制可视化，已经提出了传递函数。第一种解决方案是使 
用一维转移纹理将体素密度标量映射到颜色和不透明度。然而，这 
不允许使用单独的颜色独立地识别特定的材料过渡，例如，人类鼻 
窦骨 - 空气或骨 - 软组织。为了解决这个问题，Kniss606 14.体 
积和半透明渲染图 14.15。通过平行于视图平面的一系列切片呈现 
体积。一些切片及其与体积的交点显示在左侧。中间显示了渲染这 
些切片的结果。在右侧，当渲染和混合大量切片时显示结果。（数 
字由Christof Rezk-Salama，德国锡根大学提供。）等。[912]建 
----------------------- Page 651-----------------------
议使用基于密度d和密度场的梯度长度||▽d||索引的二维传递函数。 
变化区域具有高梯度幅度。该方法导致密度转变的更有意义的着色。 
见图14.16。图14.16。使用一维 （左）和二维 （右）传递函数[912] 
评估体积材料和不透明度。在第二种情况下，可以保持树干的棕色 
而不用覆盖代表叶子的较轻密度的绿色。图像的底部表示传递函数， 
x轴为密度，y轴为密度场||▽d||的梯度长度。 （图片由Joe Michael 
Kniss[912]提供。）14.3。一般体积渲染607图14.17。使用通过 
半角切片的光传播进行前向次表面散射的体积渲染。（图片由Ikits 
等人[797]提供。）Ikits等。[797]深入讨论这项技术和相关事宜。 
Kniss等人。[913]扩展该方法，而不是根据半角切片。切片仍然呈 
现在前面，但是朝向光线和视图方向的中间。使用这种方法，可以 
从光的视角渲染辐射和遮挡，并在视图空间中累积每个切片。切片 
纹理可以在渲染下一个切片时用作输入，使用来自光方向的遮挡来 
评估体积阴影，并使用辐射度来估计多个散射，即，在到达眼睛之 
前在介质内多次反射光。因为根据盘中的多个样本对先前切片进行 
采样，所以该技术仅能合成由锥内的前向散射产生的地下现象。最 
终的图像质量很高。见图 14.17。Schott等人已经扩展了这种半角 
方法。[1577,1578]评估环境遮挡和景深模糊效果，这改善了观看体 
素数据的用户的深度和体积感知。如图 14.17所示，半角切片可以 
呈现高质量的次表面散射。但是，必须为每个片支付由光栅化引起 
的存储器带宽成本。Tatarchuk和Shopf [1744]使用着色器中的光 
线行进来执行医学成像，因此仅支付光栅化带宽成本一次。可以按 
----------------------- Page 652-----------------------
照下一节中的描述实现照明和阴影。14.3.2参与媒体渲染实时应用 
程序可以通过渲染参与媒体来描绘更丰富的场景。当诸如时间608 
之类的因素呈现时，这些效果变得更加苛刻 14.体积和半透明渲染 
日，天气或环境变化（例如建筑物破坏）都涉及到。例如，如果是 
中午或黄昏，森林中的雾会看起来不同。在树木之间照射的光轴应 
该适应太阳变化的方向和颜色。光轴也应根据树木的运动进行动画 
处理。通过例如爆炸去除一些树木会导致该区域散射光的变化，因 
为封堵器和产生的灰尘较少。篝火，手电筒和其他光源也会在空中 
产生散射。在本节中，我们将讨论可以实时模拟这些动态视觉现象 
的影响的技术。一些技术专注于从单个源渲染阴影大规模散射。 
Yusov [1958]深入描述了一种方法。它基于沿着极线的入射散射， 
即在摄像机图像平面上投射到单条线上的光线。从光的角度来看深 
度图用于确定样本是否被遮蔽。该算法从相机开始执行光线游行。 
沿光线的最小/最大层次用于跳过空白空间，而仅在深度不连续处进 
行光线行进，即实际需要准确评估体积阴影的地方。不是沿着极线 
对这些不连续性进行采样，而是可以通过渲染从光空间深度图生成 
的网格来在视图空间中进行采样[765]。在视图空间中，仅需要前端 
背面之间的体积来评估最终的散射辐射。为此，通过将前面产生的 
散射辐射加到视图中并将其减去背面来计算内散射。这两种方法在 
再现具有由不透明表面遮挡引起的阴影的单散射事件时是有效的 
[765,1958]。然而，它们都不能代表异构参与媒体，因为它们都假 
设媒体是一种恒定的材料。此外，这些技术不能考虑来自非不透明 
----------------------- Page 653-----------------------
表面的体积阴影，例如，来自参与媒体的自阴影或来自粒子的透明 
阴影 （第 13.8节）。它们仍然在游戏中使用效果很好，因为它们可 
以以高分辨率渲染，并且由于空空间跳跃它们很快[1958]。已经提 
出了喷溅方法来处理异质介质的更一般情况，沿着射线对体积材料 
进行采样。没有考虑任何输入照明，Crane等人。[303]使用喷溅来 
渲染烟雾，火焰和水，所有这些都是由流体模拟产生的。在烟雾和 
火灾的情况下，在每个像素处产生射线穿过体积射线，从材料沿其 
长度以规则间隔收集颜色和遮挡信息。在水的情况下，一旦遇到射 
线与水面的第一个击中点，就终止体积采样。表面法线被评估为每 
个样本位置处的密度场梯度。为了确保水面光滑，使用三重插值来 
过滤密度值。使用这些技术的示例如图 14.18所示。考虑到太阳， 
点光源和聚光灯，Valient [1812]将一组边界体积渲染到半分辨率缓 
冲区中，其中每个源的散射都应该发生。每个光量都是光线行进的， 
每像素随机偏移应用于光线行进开始位置。这样做会增加一点14.3。 
一般体积渲染609图14.18。使用体积渲染技术结合GPU上的流体 
模拟渲染雾和水。（图片左侧是“Hellgate：London”，由Flagship 
Studios，Inc。提供;图片由NVIDIACorporation提供; [303]。） 
噪音，其优点是可以消除由于不断踩踏而产生的条带伪影。每帧使 
用不同的噪声值是隐藏伪像的手段。重新投影前一帧并与当前帧混 
合后，噪音将被平均，因此将消失。通过将平面粒子体素化为以屏 
幕分辨率的八分之一映射到相机平截头体上的三维纹理来呈现异质 
介质。在光线行进期间使用该体积作为材料密度。考虑到像素之间 
----------------------- Page 654-----------------------
的深度差异，可以首先使用双边高斯模糊然后使用双边上采样滤波 
器[816]在全分辨率主缓冲器上合成半分辨率散射结果。当深度增量 
与中心像素相比太高时，丢弃样本。这种高斯模糊在数学上是不可 
分的 （第 12.1节），但它在实践中很有效。该算法的复杂性取决于 
在屏幕上喷溅的光量的数量，作为其像素覆盖的函数。通过使用蓝 
噪声扩展了这种方法，蓝噪声更好地在帧像素上产生随机值的均匀 
分布[539]。这样做可以在使用双边滤镜在空间上对样本进行上采样 
和混合时产生更平滑的视觉效果。使用混合在一起的四个随机样本 
也可以实现对半分辨率缓冲器的上采样。结果仍然是噪声，但由于 
它提供了全分辨率的每像素噪声，因此可以通过时间抗锯齿后处理 
轻松解决（第5.4节）。所有这些方法的缺点在于，具有任何其他 
透明表面的体积元素的深度有序喷溅将永远不会给出结果的视觉上 
正确的排序，例如，具有大的非凸透明网格或大规模粒子效果。当 
在透明表面上应用体积照明时，所有这些算法都需要一些特殊的处 
理，例如包含体内散射和透射率的体积[1812]。那么，为什么不使 
用610中的基于体素的表示14.体积和半透明渲染开始，不仅代表 
空间变化的参与媒体属性，还代表光散射和透射率产生的辐射分 
布？这种技术长期以来一直用于电影工业[1908]。Wronski [1917] 
提出了一种方法，其中来自太阳的散射辐射和场景中的光被体素化 
为映射在视图剪辑空间上的三维体积纹理V0。评估每个体素中心世 
界空间位置的散乱辐射亮度，其中体积的x轴和y轴对应于屏幕坐 
标，而z坐标映射在相机平截头体深度上。该体积纹理的分辨率远 
----------------------- Page 655-----------------------
低于最终图像。该技术的典型实现使用体素分辨率，该分辨率是x 
轴和y轴中屏幕分辨率的八分之一。沿z坐标的细分取决于质量和 
性能权衡，64个切片是典型的选择。该纹理包含 RGB中的散射辐 
射Lscatin以及alpha中的消光σt。根据该输入数据，通过使用Vf [x， 
y，z] = （L'scat +T'r Lscatinds，TrsliceT'r），（14.15）在每个 
切片上从近到远迭代来生成最终散射体积Vf。 L'scat=V0 [x，y， 
z.1] rgb，T'r =V0 [x，y，z.1] a，并且Trslice =e.?tds。这将从 
世界空间切片深度ds上的先前切片z.1数据更新切片z。这样做将 
导致Vf包含到达观察者的散射辐射和在每个体素中的背景上的透 
射率。在公式 14.15中，注意到 Lscatin仅受先前切片T'r的透射率 
的影响。这种行为是不正确的，因为Lscatin也应该受到当前切片 
内σt导致的透射率的影响。Hillaire[742,743]讨论了这个问题。他 
提出了一种解析解 Lscatin在给定深度上恒定消光σt的积分：Vf [x， 
y，z] =？L'scat+Lscatin。LscatinTrsliceσt，TrsliceT'r？。（14.16） 
具有辐射 Ls的不透明表面的最终像素辐射率Lo将由 Lfat和Tr从 
Vf修改，使用剪辑空间坐标采样为 Lo =TrLs +Lscat。由于Vf很 
粗糙，因此会受到相机运动和高频明亮光线或阴影的混叠。可以使 
用指数移动平均值重新投影先前帧Vf并与新Vf组合[742]。在此框 
架的基础上，Hillaire[742]提出了一种基于物理的参与媒体材料定 
义方法，如下所示：散射σs，吸收σa，相位函数参数g和发射辐射 
率Le。该材料被映射到相机平截头体并存储到参与的媒体材料体积 
纹理Vpm中，其是存储不透明表面材料的G缓冲器的三维版本（第 
----------------------- Page 656-----------------------
20.1节）。仅考虑单个散射，尽管体素离散化，Hillaire表明，使 
用这种基于物理的材质表示会产生接近路径追踪的视觉效果。类似 
于网格，位于世界中的参与媒体卷被体素化为Vpm（参见图14.19）。 
在每个卷中，定义了一种材料并添加了变化，这要归功于 14.3。一 
般体积渲染611图14.19。由艺术家在一个关卡中放置并参与相机 
平截头体空间的参与媒体卷的示例[742,1917]。在左侧，在这种情 
况下，球体形状的三维纹理被映射到体积上。纹理定义体积的外观， 
类似于三角形上的纹理。在右侧，通过考虑其世界变换，将该体积 
体素化为相机平截头体。计算着色器将贡献累积到卷所包含的每个 
体素中。然后，所得材料可用于评估每个体素中的光散射相互作用 
[742]。请注意，当映射到相机剪辑空间时，体素采用小截头形状并 
被称为froxels。从三维输入纹理中采样的密度，导致异构参与媒体。 
结果如图 14.20所示。同样的方法也在虚幻引擎[1802]中实现，但 
是不使用盒体积作为参与介质的源，而是使用粒子，假设球形体积 
而不是盒子。也可以使用稀疏结构来表示材料体积纹理[1191]，使 
用最顶部的体积，每个体素为空或指向包含参与的媒体材料数据的 
更细粒度的体积。基于相机平截头体积的方法[742,1917]的唯一缺 
点是为了在功能较弱的平台上达到可接受的性能（并使用合理的内 
存量）所需的低屏幕空间分辨率。这是先前解释的喷溅方法优于其 
中的地方，因为它们产生清晰的视觉细​ ​ 节。如前所述，splatting 
需要更多的内存带宽并提供更少的统一解决方案，例如，在没有排 
序问题或参与媒体投射卷阴影本身的情况下，更难应用于任何其他 
----------------------- Page 657-----------------------
透明表面。不仅直射光，而且已经反弹或散射的照明也可以通过介 
质散射。与Wronski [1917]类似，虚幻引擎可以烘焙体积光照贴图， 
在体积中存储辐照度，并在视图体积中进行体素化时将其散射回媒 
体[1802]。为了在参与媒体中实现动态全局照明，还可以依赖光传 
播量[143]。一个重要的特征是使用体积阴影。如果没有它们，在雾 
气沉重的场景中的最终图像看起来应该比它应该更加明亮和平坦 
[742]。此外，阴影是一个重要的视觉线索。它们帮助观察者感知深 
度和体积[1846]，产生更逼真的图像，并且可以带来更好的效果.614 
14.体积和半透明渲染图 14.20。没有 （顶部）和 （底部）体积光照 
和阴影渲染的场景。场景中的每个灯光都与参与媒体互动。每个光 
的辐射亮度，IES轮廓和阴影图用于累积其散射光贡献[742]。（图 
片由Frostbite，2018年电子艺术公司提供）浸泡。Hillaire[742] 
提出了一种实现体积阴影的统一解决方案。根据剪贴图分配方案 
[1777]，将参与的媒体体积和粒子体素化为相邻级联的三个卷，称 
为消光体积。这些包含评估Tr所需的消光σt值，并表示要采样的单 
个统一数据源，以便使用不透明阴影贴图实现体积阴影[742,894]。 
见图 14.21。这样的解决方案使粒子和参与媒体能够自我阴影并相 
互投射阴影，以及场景中的任何其他不透明和透明元素。可以使用 
不透明阴影贴图表示体积阴影。但是，如果需要高分辨率来捕获细 
节，则使用体积纹理很快就会成为限制。因此，已经提出了替代表 
示以更有效地表示Tr，例如使用诸如傅立叶[816]或离散余弦变换 
[341]的函数的正交基。详情见第7.8节。14.4。天空渲染613图 
----------------------- Page 658-----------------------
14.21。在顶部，渲染场景时没有 （左）和 （右）体积阴影。在底部， 
调试体素化粒子消光（左）和体积阴影（右）的视图。更环保意味 
着更低的透射率[742]。（图片由Frostbite提供，c2018Electronic 
Arts Inc.）14。4天空渲染渲染世界本身就需要行星天空，大气效 
果和云彩。我们称之为地球上的蓝天是大气层参与媒体中阳光散射 
的结果。第 14.1.3节解释了白天天空呈蓝色而太阳落在地平线时红 
色的原因。气氛也是一个关键的视觉提示，因为它的颜色与太阳方 
向有关，这与一天中的时间有关。大气（有时）模糊的外观有助于 
观众了解场景中元素的相对距离，位置和大小。因此，准确渲染越 
来越多的游戏和其他应用程序所需的这些组件非常重要，这些应用 
程序具有动态时间，不断变化的天气影响云形状，以及大型开放世 
界，以便探索，驾驶，甚至飞过去。14.4.1天空和空中视角为了渲 
染大气效应，我们需要考虑两个主要组成部分，如图 14.22所示。 
首先，我们模拟太阳光与空气粒子的相互作用，从而产生波长依赖 
的瑞利散射。这将导致天空颜色和薄雾，也称为空中透视。其次， 
我们需要在地面附近集中的大颗粒对太阳光的影响。这些614的浓 
度 14.体积和半透明渲染图 14.22。两种不同类型的大气光散射：仅 
在顶部的瑞利和在底部具有规则的瑞利散射的米氏。从左到右：密 
度为0，如[203]中所述的规则密度，以及夸大的密度。（图片由 
Frostbite提供，c2018ElectronicArts Inc.[743]。）大颗粒取决 
于天气条件和污染等因素。大颗粒引起与波长无关的 Mie散射。这 
种现象会在太阳周围产生明亮的光环，特别是在颗粒浓度很高的情 
----------------------- Page 659-----------------------
况下。第一个基于物理的大气模型[1285]从空间渲染地球及其大气， 
模拟单一散射。使用O'Neil [1333]提出的方法可以获得类似的结 
果。在单通着色器中使用光线行进可以从地面到空间渲染地球。在 
渲染天空圆顶时，每个顶点完成昂贵的光线行进以集成米氏和瑞利 
散射。然而，在像素着色器中评估视觉高频相位函数。这使得外观 
平滑并且避免由于插值而暴露天空几何形状。通过将散射存储在纹 
理中并将评估分布在几个帧上，接受更新等待时间以获得更好的性 
能，也可以实现相同的结果[1871]。分析技术使用拟合的数学模型 
测量天空辐射[1443]或使用昂贵的大气光散射路径追踪产生的参考 
图像[778]。与参与的媒体素材相比，该组输入参数通常是有限的。 
例如，浊度表示导致米氏散射的粒子的贡献，而不是σs和σt系数。 
这种模型由 Preetham等人提出。[1443]使用浊度和太阳高度评估 
任何方向上的天空辐射。通过增加对光谱输出的支持，它得到了改 
进，对太阳周围散射辐射的更好的方向性，以及新的地面反照率输 
入参数[778]。分析天空模型很快就可以评估。然而，它们仅限于地 
面视图，并且不能改变大气参数来模拟外星球或实现特定的艺术驱 
动视觉效果。14.4。天空渲染615图14.23。使用查找表从地面（左） 
和空间 右（）实时渲染地球大气。图片由（   Bruneton和 Neyret[203] 
提供。）另一种渲染天空的方法是假设地球是完美的球形，周围有 
一层由异构参与媒体组成的大气层。Bruneton和 Neyret[203]以 
及Hillaire[743]给出了对大气成分的广泛描述。利用这些事实，预 
计算表可用于根据当前视图高度r，视角矢量角相对于天顶μv的余 
----------------------- Page 660-----------------------
弦，太阳方向角相对于天顶μs的余弦以及视图的余弦来存储透射率 
和散射在方位角平面ν中相对于太阳方向的矢量角。例如，从视点到 
大气边界的透射率可以通过两个参数r和μv参数化。在预计算步骤 
期间，透射率可以集成在大气中并存储在二维查找表（LUT）纹理 
Tlut中，其可以在运行时使用相同的参数化进行采样。该纹理可用 
于将大气透射率应用于诸如太阳，星星或其他天体的天空元素。考 
虑散射，Bruneton和 Neyret[203]描述了一种将它存储在由前一 
段中的所有参数参数化的四维 LUTSlut中的方法。它们还提供了一 
种通过迭代n次来评估n阶散射的方法：（i）评估单散射表Slut， 
 （ii）使用Sn.1lut评估Snlut，以及 （iii）将结果添加到Slut。做 
 （ii）和 （iii）n。1次。Bruneton和 Neyret[203]提供了有关该过 
程以及源代码的更多细节。有关结果的示例，请参见图 14.23。 
Bruneton和 Neyret的参数化有时会在地平线上展现出视觉效果。 
尤索夫[1957]提出了一种改进的转型。通过忽略ν[419]也可以使用 
仅三维 LUT。使用这种方案，地球不会在大气中投下阴影，这可以 
是一个可以接受的权衡。优点是该LUT将更小并且更新和采样成本 
更低。61614.体积和半透明渲染图 14.24。使用完全参数化模型的 
实时渲染可以模拟地球大气层（顶部）和其他行星的大气层，例如 
火星的蓝色日落 （底部）。 （Top图片由Bruneton和 Neyret[203] 
提供，底部图片由 Frostbite提供，电子艺术公司[201]电子艺术公 
司[743]。）这种最后的三维 LUT方法被许多电子艺术 Frostbite实 
时游戏使用，例如极品飞车，镜像边缘催化剂和FIFA[743]。在这 
----------------------- Page 661-----------------------
种情况下，艺术家可以驾驶基于物理的大气参数来达到目标​ ​ 天 
空视觉，甚至模拟外星大气。见图 14.24。当气氛参数改变时，必 
须重新计算LUT。为了更有效地更新这些LUT，还可以使用近似于 
大气中材料的积分而不是通过它的光线行进的函数[1587]。通过临 
时分布LUT的评估和多次散射，更新LUT的成本可以摊销至原始的 
6％。这可以通过仅针对给定散射次序n更新Sn lut的子部分来实 
现，同时内插最后两个求解的 LUT，接受几帧延迟。作为另一个优 
化，为了避免每个像素多次对不同LUT进行采样，Mie和 Rayleigh 
散射在相机平截头体映射的低分辨率体积纹理的体素中被烘焙。在 
像素着色器中评估视觉高频相位函数，以便在太阳周围产生平滑的 
散射光晕。使用这种类型的体积纹理还允许在场景中的任何透明对 
象上应用每个顶点的空中透视。14.4.2云彩云是天空中复杂的元素。 
它们在代表风暴时可能看起来很危险，或者看起来像是谨慎，史诗， 
薄或大规模。随着时间的推移，云的变化缓慢，大尺度的形状和小 
规模的细节都在不断变化。具有天气和时间变化的大型开放世界游 
戏是需要动态云渲染解决方案的更复杂案例。根据目标性能和视觉 
质量，可以使用不同的技术。云是由水滴组成的，具有高散射系数 
和复杂相位函数，可产生特定外观。它们通常使用参与介质进行模 
拟，如第 14.1节所述，并且它们的材料被测量为具有高单次散射反 
照率ρ=1和 14.4中的消光系数σt。SkyRendering617图14.25。 
不同类型的云在地球上。（图片由Valentin de Bruyn提供。）层 
云（低层水平云层）的范围[0.04,0.06]和积云[743]的[0.05,0.12]（孤 
----------------------- Page 662-----------------------
立的低层棉花状蓬松云层）。见图 14.25。考虑到ρ接近 1的事实， 
可以假设σs=σt。云渲染的经典方法是使用Alpha混合在天空上合 
成的单个全景纹理。渲染静态天空时这很方便。Guerrette[620]提 
出了一种视觉流动技术，该技术给出了受全球风向影响的天空中云 
运动的错觉。这是一种有效的方法，可以改善静态全景云纹理集的 
使用。但是，它无法代表云形状和照明的任何变化。云作为粒子哈 
里斯将云渲染为粒子和冒名顶替者[670]。请参见第55.61节和图 
13.9.另一种基于粒子的云渲染方法由Yusov [1959]提出。他使用称 
为体积粒子的渲染图元。这些中的每一个都由四维 LUT表示，允许 
在面向视图的四边形粒子上检索散射光和透射率，作为太阳光和视 
图方向的函数。见图14.26。这种方法非常适合渲染层积云。见图 
14.25。将云渲染为粒子时，通常可以看到离散化和弹出伪影，尤其 
是在云周围旋转时。使用卷感知混合可以避免这些问题。通过使用 
称为光栅化器顺序视图的GPU功能 （第3.8节），可以实现此功能。 
体积感知混合可以在每个基元的资源上同步像素着色器操作，从而 
允许确定性的自定义混合操作。最接近的n个粒子的深度层以与我 
们渲染的渲染目标相同的分辨率保存在缓冲区中。这个618 14.体 
积和半透明渲染图 14.26。云呈现为粒子的体积。（图片由 Egor 
Yusov [1959]提供）。读取缓冲区并用于通过考虑交叉点深度来混 
合当前渲染的粒子，然后最终再次写出要渲染的下一个粒子。结果 
如图 14.27所示。云作为参与媒体将云视为孤立元素，Bouthors 
等。[184]表示具有两个组件的云：网格，显示其整体形状和超纹理 
----------------------- Page 663-----------------------
[1371]，在网格表面下添加高频细节直到云内的某个深度。使用此 
表示，云边缘可以精细地进行射线游行 [184]表示具有两个组件的 
云：网格，显示其整体形状和超纹理[1371]，在网格表面下添加高 
频细节直到云内的某个深度。使用此表示，云边缘可以精细地进行 
射线游行 [184]表示具有两个组件的云：网格，显示其整体形状和 
超纹理[1371]，在网格表面下添加高频细节直到云内的某个深度。 
使用此表示，云边缘可以精细地进行射线游行为了收集细节，内部 
可以被认为是同质的。在光线行进云结构的同时集成辐射，并且根 
据散射顺序使用不同的算法来收集散射辐射。使用第 14.1节中描述 
的分析方法对单次散射进行积分。使用位于云表面的盘形光收集器 
的离线预计算转移表来加速多次散射评估。最终结果是高视觉质量， 
如图 14.28所示。图 14.27。在左侧，云粒子呈现通常的方式。在 
右侧，使用体积感知混合渲染的粒子。 （图片由EgorYusov [1959] 
提供。）14.4。天空渲染619图14.28。使用网格和超文本渲染的 
云。 （图片由Bouthors等人提供。[184]。）不是将云渲染为孤立 
元素，而是可以将它们建模为大气中的参与媒体层。依靠射线行进， 
施耐德和沃斯提出了一种以这种方式渲染云的有效方法[1572]。只 
需几个参数，就可以在动态时间照明条件下渲染复杂，动画和详细 
的云形状，如图 14.29 所示。该层如图 14.29 所示。使用 
Perlin-Worley噪声使用光线行进的云层渲染的云，并具有动态体 
积照明和阴影。结果（ 由Schneider和Vos [1572]，版权所有c2017 
GuerrillaGames。）620 14.体积和半透明渲染使用两级程序噪声 
----------------------- Page 664-----------------------
构建。第一级为云提供基本形状。第二级通过侵蚀这种形状来增加 
细节。在这种情况下，据报道，Perlin[1373]和W​ ​ orley[1907] 
噪声的混合物很好地代表了类似花椰菜的积云形状和类似的云。生 
成这种纹理的源代码和工具已经公开共享[743,1572]。通过使用沿 
着视线射线分布在云层中的样本来整合来自太阳的散射光来实现照 
明。体积阴影可以通过评估层内几个样品的透射率，朝向太阳 
[743,1572]测试作为二次射线行进来实现。可以为这些阴影样本采 
样噪声纹理的较低mipmap级别，以便获得更好的性能并消除仅使 
用少量样本时可见的伪像。避免每个样本进行二次射线行进的另一 
种方法是使用许多可用技术之一 （第 13.8节），在纹理中每帧一次 
对太阳的透射率曲线进行编码。例如，游戏 “最终幻想XV”[416] 
使用透射函数映射[341]。如果我们想要捕捉每一个细节，那么在光 
线行进的情况下以高分辨率渲染云会变​ ​ 得昂贵。为了获得更好 
的性能，可以以低分辨率渲染云。一种方法是仅更新每个4×4块内 
的单个像素，并重新投影先前的帧数据以填充其余的[1572]。 
Hillaire[743]提出了一种变化，它总是以固定的较低分辨率渲染并 
在视图光线行进开始位置上添加噪声。可以使用指数移动平均值重 
新投影先前帧结果并与新帧组合[862]。这种方法呈现较低的分辨 
率，但可以更快地收敛。云的相位函数很复杂[184]。在这里，我们 
提出了两种可用于实时评估它们的方法。可以将函数编码为纹理并 
基于θ对其进行采样。如果这样做需要太多的存储器带宽，则可以通 
过将第14.1.4节[743]中的两个Henyey-Greenstein相位函数组合 
----------------------- Page 665-----------------------
为pdual （θ，g0，g1，w）=pdual0+w （pdual1）来近似函数。 
pdual0），（14.17）其中两个主要的散射偏心率g0和g1，以及 
混合因子w，可以由艺术家创作。这对于表示主要的前向和后向散 
射方向很重要，当远离和朝向光源（例如太阳或月亮）看时，在云 
中显示细节。见图14.30。有不同的方法来近似云中环境照明的散 
射光。一个简单的解决方案是使用从天空渲染均匀集成到立方体贴 
图纹理中的单个辐射输入。自下而上的深色渐变也可用于缩放环境 
光照以近似于云本身的遮挡。也可以将此输入辐射分为底部和顶部， 
例如地面和天空[416]。然后，假设云层内的介质密度恒定，可以在 
分析上对两种贡献进行环境散射[1149]。14.4。天空渲染621图 
14.30。如Hillaire[743]所述，使用基于物理的参与媒体表示的动 
态照明和阴影使用光线行进的云层渲染的云。（图片由SERGoren 
Hesse （上图）和 BenMcGrath （下图）提供，来自 BioWare，2018 
年电子艺术公司。）多重散射近似云的明亮和白色外观是光散射在 
其中多次的结果。如果没有多次散射，厚厚的云层将大部分在其体 
积的边缘点亮，并且在其他任何地方都会显得很暗。多次散射是云 
不会看起来烟雾或模糊的关键组成部分。使用路径跟踪评估多次散 
射是非常昂贵的。Wrenninge [1909]提出了一种在射线行进时近似 
这种现象的方法。它集成了八度散射并将它们相加为Lmultiscat（x， 
v）=Xo.1 n =0 Lscat （x，v），（14.18），其中在评估Lscat 
时进行以下替换 （例如，使用σ'sinsteadofσs）：σ's=σsan，σ'e= 
σebn，p' （θ）=p （θcn），其中a，b和c是[0,1]中的用户控制 
----------------------- Page 666-----------------------
参数，它们将让光穿过参与的622 14.体积和半透明渲染图 14.31。 
使用公式 14.18渲染的云作为多次散射的近似值。从左到右，n设 
置为 1,2和3.这使得太阳光能够以可信的方式穿过云层。（图片由 
Frostbite提供，c2018ElectronicArts Inc.[743]。）媒体。当这 
些值接近0时，云看起来更柔和。为了确保在评估Lmultiscat时这 
种技术是节能的 （x，v），我们必须确保a≤b。否则，更多的光会 
散射，因为方程σt=σa+σs不会被尊重，因为σs最终可能大于σt。 
该解决方案的优点在于它可以在光线行进时动态地集成每个不同八 
度音阶的散射光。视觉改善如图 14.31所示。缺点是当光可以向任 
何方向散射时，它在复杂的多次散射行为中表现不佳。然而，云的 
外观得到了改善，这种方法允许照明艺术家通过一些参数轻松控制 
视觉效果并表达他们的视觉，这要归功于更广泛的可实现结果。通 
过这种方法，光可以穿透介质并显示更多内部细节。云和大气相互 
作用当渲染具有云的场景时，为了视觉一致性，考虑与大气散射的 
相互作用是很重要的。见图 14.32。由于云是大尺度元素，因此应 
该对它们应用大气散射。可以评估第 14.4.1节图 14.32中给出的大 
气散射。通过考虑大气来渲染完全覆盖天空的云[743]。左：没有施 
加在云上的大气散射，导致视觉上不连贯。中间：有大气散射，但 
环境看起来太亮而没有阴影。右：云遮挡天空，从而影响大气中的 
光散射，从而产生连贯的视觉效果。（图片由Frostbite提供，c2018 
ElectronicArts Inc.[743]。）14.5。通过云层采集的每个样品的半 
透明表面623，但这样做很快变得昂贵。相反，可以根据表示平均 
----------------------- Page 667-----------------------
云深度和透射率的单个深度在云上应用大气散射[743]。如果增加云 
覆盖以模拟阴雨天气，则应在云层下减少大气中的阳光散射。只有 
散落在云层中的光线才会散落在它们周围的大气层中。可以通过减 
少天空对空中透视的照明贡献并将散射光添加回大气来修改照明 
[743]。视觉改善如图 14.32所示。总之，可以使用先进的基于物理 
的材料表示和照明来实现云渲染。通过使用程序噪声可以实现逼真 
的云形状和细节。最后，如本节所述，同样重要的是要记住大局， 
例如云与天空的相互作用，以实现连贯的视觉效果。14.5半透明表 
面半透明表面通常是指具有高吸收和低散射系数的材料。这些材料 
包括玻璃，水或第 592页的图 14.2所示的酒。此外，本节还将讨 
论具有粗糙表面的半透明玻璃。许多出版物[1182,1185,1413]也详 
细介绍了这些主题。14.5.1覆盖率和透射率如第5.5节所述，透明 
表面可以被视为具有由α表示的覆盖范围，例如，不透明的织物或组 
织纤维隐藏了一定比例的背后。对于玻璃和其他材料，我们想要计 
算半透明度，其中固体体积允许每个光波长的百分比通过，作为透 
射率在背景上作为滤光器Tr （第14.1.2节）。利用输出颜色co， 
表面辐射亮度cs和背景颜色cb，透明度作为覆盖表面的混合操作 
是co =αcs+ （1.α）cb。（14.19）在半透明表面的情况下，混合 
操作将是co =cs +Trcb，（14.20）其中cs包含固体表面的镜面 
反射，即玻璃或凝胶。注意，Tr是三值透射颜色矢量。要实现有色 
半透明，可以使用任何现代图形API的双源颜色混合功能，以指定 
这两种输出颜色与目标缓冲颜色cb混合。Drobot [386]624 14. 
----------------------- Page 668-----------------------
体积和半透明渲染图 14.33。通过网格的多层具有不同吸收因子的 
半透明[115]。（图片由LouisBavoil提供[115]。）介绍了可以使 
用的不同混合操作，这取决于对于给定表面，反射和透射是否着色。 
在一般情况下，可以对共同指定的覆盖和半透明使用共同的混合操 
作[1185]。在这种情况下使用的混合函数是co =α （cs +Trcb）+ 
 （1.α）cb。（14.21）当厚度变化时，透射光量可用公式14.3计 
算，可以简化为Tr =e.?td， （14.22）其中d是穿过材料体积的距 
离。物理消光参数Δt表示光在通过介质时下落的速率。对于艺术家 
的直观创作，Bavoil[115]将目标颜色tc设置为某个给定距离d处 
的透射量。然后灭绝？t可以恢复为？t =.log （tc）d。（14.23） 
例如，目标透射率颜色tc = （0.3,0.7,0.1），距离d =4.0米，我 
们恢复Δt= 14 （.log 0.3，.log 0.7，.log 0.1）= （0.3010， 
0.0892,0.5756）。 （14.24）注意，透射率0需要作为特殊情况处 
理。一种解决方案是从Tr的每个分量中减去一个小的epsilon，例 
如0.000001。滤色效果如图 14.33所示。在空壳网格的情况下，其 
表面由单个半透明材料薄层组成，背景颜色应作为 14.5的函数被遮 
挡。半透明表面625ddvnt图14.34。从距离da视图射线v计算 
的彩色透射率已经在厚度为 t 的透明表面内行进。（右图由 
Activision Publishing，Inc。提供，2018。）光在介质中行进的路 
径长度d。因此，沿着法线或切线观察诸如表面将导致作为其厚度t 
的函数的不同量的背景遮挡，因为路径长度随角度而变化。Drobot 
[386]提出了这样一种方法，其中透射率Tr被评估为Tr =e.?td，其 
----------------------- Page 669-----------------------
中d=tmax （0.001，n·v）。 （14.25）图14.34显示了结果。有 
关薄膜和多层表面的更多详细信息，请参见第9.11.2节。在实心半 
透明网格的情况下，计算光线穿过传输介质的实际距离可以以多种 
方式完成。常见的方法是首先渲染视图射线离开体积的表面。该表 
面可以是水晶球的背面，或者可以是海底（即，水终止的地方）。 
存储该表面的深度或位置。然后渲染体积的表面。在着色器中访问 
存储的出口深度，并计算它与当前像素表面之间的距离。然后使用 
该距离计算要在背景上应用的透射率。如果保证音量是闭合和凸起 
的，即每个像素有一个入口和一个出口点，则此方法有效，和水晶 
球一样。我们的海床示例也有效，因为一旦我们离开水面，我们会 
遇到不透明的表面，因此不会发生进一步的透射。对于更复杂的模 
型，例如玻璃雕塑或具有凹陷的其他物体，两个或更多个单独的跨 
距可以吸收入射光。使用深度剥离，如第 5.5节所述，我们可以按 
照从前到后的精确顺序渲染体积表面。在渲染每个前面时，计算通 
过体积的距离并用于计算透射率。依次应用这些中的每一个都给出 
了适当的最终透射率。请注意，如果所有卷都是由626构成的 14. 
体积和半透明渲染图 14.35。考虑到透射率和反射率效应的水。往 
下看，因为透射率高而且蓝色，我们可以看到浅蓝色的水。由于菲 
涅耳效应，在海平面附近，由于较低的透射率（因为光必须远远地 
进入水体积）而海床变得不太明显，并且反射以传输为代价而增加。 
 （图片来自“孤岛危机”，由Crytek提供。）相同浓度的相同材料， 
如果表面没有反射成分，则可以使用总距离在末端计算一次透射率。 
----------------------- Page 670-----------------------
在单次通过中直接存储对象片段的缓冲器或 K缓冲器方法也可用于 
在最近的GPU上提高效率[115,230]。这种多层透射率的例子如图 
14.33所示。在大型海水的情况下，场景深度缓冲区可以直接用作 
背面海床的表示。渲染透明曲面时，必须考虑菲涅耳效应，如第9.5 
节所述。大多数传输介质的折射率明显高于空气。在掠射角度时， 
所有光线将从界面反弹回来，并且不会传输任何光线。图 14.35显 
示了这种效应，当水下物体直视水面时可以看到水下物体，但是在 
掠射角处看得更远，水面大部分隐藏在海浪下面。一些文章解释了 
处理大型水体的反射，吸收和折射[261,977]。14.5.2折射对于透射 
率，我们假设入射光直接来自网格体积之外的直线。当网格的前表 
面和后表面平行且厚度不大时 （例如，对于窗格 14.5），这是合理 
的假设。半透明表面627图14.36。作为入射角θi和透射角θt的函 
数的折射和透射辐射。玻璃对于其他透明介质，折射率起着重要作 
用。第9.5节描述了Snell定律，该定律描述了当遇到网格表面时光 
线如何改变方向。由于能量守恒，任何未反射的光都会被透射，因 
此传输的光通量与入射通量的比例为 1。f，其中f是反射光的量。 
然而，透射到入射辐射的比例是不同的。由于入射光线和透射光线 
之间的投影面积和立体角不同，辐射关系是 Lt= （1.F （θi））sin2 
θisin2θtLi。（14.26）这种行为如图14.36所示。Snell定律结合 
式 14.26得到了透射辐射的不同形式：Lt= （1.F （θi））n22n21Li。 
 （14.27）Bec[123]提出了一种计算折射矢量的有效方法。为了便 
于阅读 （因为n传统上用于Snell方程中的折射率），我们将 N定 
----------------------- Page 671-----------------------
义为表面法线，将 l定义为光的方向：t = （w.k）N。n1， （14.28） 
其中 n =n1/ n2是相对折射率，并且w =n （l·N），k =p 1 + 
 （w.n） （w +n）。 （14.29）62814.体积和半透明渲染图 14.37。 
左：由立方环境地图的玻璃天使折射，地图本身用作天空背景。对： 
具有色差的玻璃球的反射和折射。（左图来自three.js示例webgl 
材料立方体贴图折射[218]，Lucy模型来自斯坦福3D扫描库，纹理 
来自 Humus。右图由LeeStemkoski提供[1696]。）得到的折射 
矢量t返回归一化。水的折射率约为 1.33，玻璃的折射率约为 1.5， 
空气的有效折射率为 1.0。折射率随波长变化。也就是说，透明介质 
将以不同的角度弯曲每种颜色的光。这种现象称为色散，并解释了 
为什么棱镜将白光扩散到彩虹色光锥中以及为什么会出现彩虹。色 
散会导致镜头出现问题，称为色差。在摄影中，这种现象称为紫边， 
并且在日光下沿着高对比度边缘可以特别明显。在计算机图形学中， 
我们通常忽略这种效果，因为它通常是要避免的工件。需要额外的 
计算来适当地模拟效果，因为进入透明表面的每条光线产生一组必 
须随后被跟踪的光线。因此，通常使用单个折射光线。值得注意的 
是，一些虚拟现实渲染器应用逆色差变换来补偿耳机的镜头 
[1423,1823]。给出折射印象的一般方法是从折射对象的位置生成立 
方体环境贴图 （EM）。然后，当渲染该对象时，可以通过使用为前 
面表面计算的折射方向来访问 EM。一个例子如图 14.37所示。 
Sousa [1675]提出了一种屏幕空间方法，而不是使用 EM。首先， 
场景像往常一样被渲染，而没有任何折射物体进入场景纹理。其次， 
----------------------- Page 672-----------------------
将折射对象渲染到首先被清除为 1的α通道中。如果像素通过深度 
测试，则写入值0。最后，折射物体被完全渲染，并且在像素着色 
器中，根据屏幕上的像素位置对其进行采样，其具有来自 14.5的扰 
动偏移。半透明表面629图14.38。图像底部的透明玻璃具有基于 
粗糙度的背景散射。玻璃后面的元素或多或少地模糊，模拟折射光 
线的传播。（图片由Frostbite，2018年 ElectronicArts Inc.提供）， 
例如，缩放的表面法线切线xy分量，模拟折射。在这种情况下，只 
有当α=0时才考虑被扰动样本的颜色。这个测试是为了避免使用来 
自折射物体前面的表面的样本，因此将它们的颜色拉进来就像它们 
在后面一样它。注意，不是设置α=0，而是可以使用场景深度图来 
比较像素着色器深度与被扰动的场景样本的深度[294]。如果中心像 
素距离较远，则偏移样本更近;然后将其忽略并替换为常规场景样 
本，就好像没有折射一样。这些技术给人以折射的印象，但与物理 
现实几乎没有相似之处。当光线进入透明实体时，光线会被重定向， 
但光线不会再次弯曲，什么时候应该离开对象。这个退出界面永远 
不会发挥作用。这个缺陷有时无关紧要，因为人眼对正确的外表应 
该是宽容的[1185]。许多游戏通过单层进行折射。对于粗糙的折射 
表面，重要的是根据材料粗糙度模糊背景，以模拟由微观几何法线 
的分布引起的折射光线方向的扩散。在游戏 DOOM（2016）[1682] 
中，首先像往常一样渲染场景。然后将其下采样到半分辨率并进一 
步下降到四个mipmap级别。根据模仿GGX BRDF波瓣的高斯模 
糊对每个mipmap级别进行下采样。在最后一步中，折射网格在全 
----------------------- Page 673-----------------------
分辨率场景上渲染[294]。通过对场景的mipmapped纹理进行采 
样并将材质粗糙度映射到mipmap级别，背景在表面后合成。表面 
越粗糙，背景越模糊。使用一般材料表示，Drobot[386]提出了相 
同的方法。在 McGuire和 Mara[1185]的统一透明框架中也使用了 
类似的技术。在这种情况下，高斯点扩散函数用于在单次通过中对 
背景进行采样。见图 14.38。63014.体积和半透明渲染还可以通过 
多个层处理更复杂的折射情况。可以使用纹理中存储的深度和法线 
来渲染每个图层。然后可以使用浮雕映射（第6.8.1节）的过程来 
跟踪穿过层的光线。存储的深度被视为高度场，每条光线都会行走， 
直到找到交叉点。Oliveira和 Brauwers [1326]提出了这样一种框 
架来处理通过网格背面的折射。此外，附近的不透明物体可以转换 
为颜色和深度图，提供最后的不透明层[1927]。所有这些图像空间 
折射方案的局限性在于屏幕边界之外的内容不能折射或折射。 
14.5.3焦散和阴影评估由折射和衰减光产生的阴影和焦散是一项复 
杂的任务。在非实时环境中，可以使用多种方法（例如双向路径跟 
踪或光子映射[822,1413]）来实现此目标。幸运的是，许多方法实 
时提供了这种现象的近似。焦散是光从其直线路径发散的视觉结果， 
例如玻璃或水面。结果是光线将从某些区域散焦，产生阴影，并聚 
焦在其他一些区域，光线路径变得更加密集，从而产生更强的入射 
光。这些路径取决于光遇到的弯曲表面。反射的典型例子是在咖啡 
杯内看到的心形苛性碱。折射焦散更明显，例如，光通过水晶装饰 
物，透镜或一杯水聚焦。见图 14.39。由于光被上方和下方的弯曲 
----------------------- Page 674-----------------------
水面反射和折射，也可以产生焦散。会聚时，光会集中在不透明的 
表面上并产生焦散。在水面下时，会聚光路图 14.39。反射和折射 
的真实世界焦散。14.5。半透明表面631图14.40。演示水中的腐 
蚀作用。（图片来自 WebGL Water 演示由 EvanWallace 提供 
[1831]。）将在水量中显现。这将导致众所周知的光轴从光子散射 
通过水粒子。焦散是一个独立的因素，除了来自体积边界的菲涅耳 
相互作用的光减少和穿过它时的透射率。为了从水面生成焦散，可 
以应用离线生成的焦散的动画纹理作为应用在表面上的光照贴图， 
可能添加在通常光照贴图的顶部。许多游戏都利用了这种方法，例 
如在CryEngine上运行的孤岛危机3[1591]。水位的水域是用水量 
编写的。可以使用凹凸贴图纹理动画或物理模拟来动画化体积的顶 
部表面。当垂直投影在水面上方和下方时，可以使用由凹凸贴图产 
生的法线，以从它们的取向映射到辐射贡献产生焦散。使用艺术家 
创作的基于高度的最大影响距离来控制距离衰减。水面也可以被模 
拟，对世界中的物体运动作出反应，从而产生与环境中发生的事物 
相匹配的腐蚀性事件。一个例子如图 14.40所示。在水下时，相同 
的动画水面也可用于水介质中的焦散。Lanza[977]提出了一种生成 
光轴的两步法。第一，光的位置和折射方向从光的角度渲染并保存 
到纹理中。然后可以从水面开始光栅化光线并在视图中沿折射方向 
延伸。它们通过添加剂混合累积，并且最终的后处理模糊可用于模 
糊结果以掩盖少量线条。63214.体积和半透明渲染图 14.41。在左 
边，佛陀折射附近的物体和周围的天空箱[1927]。在右边，焦散是 
----------------------- Page 675-----------------------
通过类似于阴影贴图的分层图生成的[1929]。（图片由爱荷华大学 
的ChrisWyman提供。）Wyman [1928,1929]提出了一种用于腐 
蚀性渲染的图像空间技术。它的工作原理是首先通过透明物体的正 
面和背面折射后评估光子位置和入射方向。这是通过使用第 14.5.2 
节中介绍的背景折射技术[1927]来实现的。然而，代替存储折射辐 
射，纹理用于存储场景交叉位置，折射后入射方向和由菲涅耳效应 
引起的透射率。每个纹素都存储一个光子，然后可以将正确的强度 
喷射到视图中。为了实现这一目标，有两种可能性：在视图空间或 
光空间中将光子作为四边形，具有高斯衰减。一个结果如图 14.41 
所示。McGuire和 Mara[1185]通过根据透明表面的法线改变透射 
率，提出了一种更简单的苛性阴影方法，如果垂直于入射表面则传 
输更多，否则由于菲涅耳效应而传输更少。其他体积阴影技术在第 
7.8节中描述。14.6次表面散射次表面散射是在具有高散射系数的 
固体材料中发现的复杂现象（更多细节见9.1.4节）。这些材料包 
括蜡，人体皮肤和牛奶，如图 14.2在 592页所示。一般光散射理 
论已在第 14.1节中解释。在一些情况下，散射的尺度相对较小，对 
于具有高光学深度的介质，例如人体皮肤。散射光从接近其原始入 
口点的表面重新发射。这种位置偏移意味着无法对次表面散射建模 
14.6。次表面散射633图14.42。光线散射穿过物体。最初，透射 
到物体中的光在折射方向上传播，但是散射使其反复改变方向，直 
到它离开材料。通过材料的每条路径的长度决定了吸收光损失的百 
分比。与 BRDF （第9.9节）。也就是说，当散射发生在大于像素 
----------------------- Page 676-----------------------
的距离上时，其更加全局的性质是显而易见的。必须使用特殊方法 
来渲染此类效果。图 14.42显示了通过物体散射的光线。散射导致 
入射光采用许多不同的路径。由于单独模拟每个光子是不切实际的 
 （即使对于离线渲染），必须通过在可能的路径上进行积分或通过 
近似这样的积分来概率地解决该问题。除了散射，穿过材料的光也 
经历吸收。区分图 14.42所示各种光路的一个重要因素是散射事件 
的数量。对于某些路径，光散射一次后会离开材料;对于其他人来说， 
光被散射两次，三次或更多次。散射路径通常分组为单次散射和多 
次散射。每组通常使用不同的渲染技术。对于一些材料，单次散射 
是总效应的相对较弱的部分，并且多次散射占优势，例如皮肤。由 
于这些原因，许多次表面散射渲染技术专注于模拟多次散射。在本 
节中，我们提出了几种近似地下散射的技术。14.6。1包裹照明也 
许最简单的次表面散射方法是包裹照明[193]。第382页讨论了该技 
术作为面光源的近似值。当用于近似地下散射时，我们可以添加色 
移[586]。这解释了穿过材料的光的部分吸收。例如，在渲染皮肤时， 
可以应用红色偏移。634 14.体积和半透明渲染以这种方式使用时， 
环绕照明会尝试模拟多次散射对曲面阴影的影响。从相邻点到当前 
阴影点的光 “泄漏”使过渡区域从浅到暗软化，其中表面弯曲远离 
光源。Kolchin[922]指出这种效应取决于表面曲率，他派生出一个 
基于物理的版本。虽然派生表达式的评估有点昂贵，但它背后的思 
想是有用的。14.6.2正常模糊Stam [1686]指出可以将多次散射建 
模为扩散过程。詹森等人。[823]进一步发展该想法以推导出分析双 
----------------------- Page 677-----------------------
向表面散射分布函数（BSSRDF）模型。对于全局次表面散射的情 
况，BSSRDF是 BRDF的推广[1277]。扩散过程对出射辐射具有空 
间模糊效应。该模糊仅应用于漫反射。镜面反射发生在材料表面， 
不受次表面散射的影响。由于法线贴图通常会编码小规模的变化， 
次表面散射的一个有用技巧是将法线贴图仅应用于镜面反射[569]。 
光滑，无扰动的法线用于漫反射。由于没有增加的成本，因此在使 
用其他次表面散射方法时应用此技术通常是值得的。对于许多材料， 
在相对小的距离上发生多次散射。皮肤是一个重要的例子，大多数 
散射发生在几毫米的距离。对于这样的材料，不扰乱漫射阴影法线 
的技术本身就足够了。Ma等人。[1095]基于测量数据扩展该方法。 
他们确定了散射物体的反射光，发现镜面反射率是基于几何表面法 
线，次表面散射使漫反射表现得好像它使用模糊的表面法线。此外， 
模糊量可以在可见光谱上变化。他们提出了一种实时着色技术，使 
用独立采集的镜面反射法和漫反射的 R，G和 B通道法线图[245]。 
为每个通道使用不同的法线贴图将导致颜色渗色。由于这些漫反射 
法线贴图通常类似于镜面反射贴图的模糊版本，因此可以直接修改 
此技术以使用单个法线贴图，同时调整mipmap级别，但代价是失 
去颜色偏移，因为法线贴图相同每个频道。14.6.3预先集成的皮肤 
阴影结合包裹照明和正常模糊的想法，Penner[1369]提出了一种预 
先集成的皮肤着色解决方案。散射和透射率被集成并存储在二维查 
找表中。LUT的第一个轴基于n·l进行索引。第二轴是 14.6。次表 
面散射635基于 1/ r=||.n/.p||索引，表示表面曲率。曲率越高， 
----------------------- Page 678-----------------------
对透射和散射颜色的影响越大。由于每个三角形的曲率是常数，因 
此必须离线烘焙和平滑这些值。为了处理次表面散射对小表面细节 
的影响，Penner修改了 Ma等人的技术。[1095]，这已在上一节中 
讨论过。而不是为R，G和 B漫反射获取单独的法线贴图，Penner 
通过根据每个颜色通道的地下材料的扩散轮廓模糊原始法线贴图来 
生成它们。由于使用四个单独的法线贴图是内存密集型的，因此作 
为优化，他使用单个平滑法线贴图，该贴图与每个颜色通道的顶点 
法线混合。该技术将忽略跨越阴影边界的光漫射，因为默认情况下 
它仅依赖于曲率。为了使散射轮廓跨越阴影边界，阴影半影轮廓可 
用于偏置 LUT坐标。因此，这种快速技术能够逼近下一节[345]中 
提出的高质量方法。14.6.4纹理空间扩散模糊漫反射法则解释了多 
次散射的某些视觉效果，但对其他散射则不然，例如柔化的阴影边 
缘。纹理空间扩散的概念可用于解决这些限制。Lensch等人介绍了 
这个想法。[1032]作为不同技术的一部分，但 Borshukov和 Lewis 
[178,179]提出的版本是最有影响力的。他们将多次散射的概念形式 
化为模糊过程。首先，将表面辐照度（漫射照明）渲染成纹理。这 
是通过使用纹理坐标作为光栅化的位置来完成的。实际位置分别插 
值以用于着色。此纹理模糊，然后在渲染时用于漫反射着色。滤光 
片的形状和尺寸取决于材料和波长。例如，对于皮肤，R通道使用 
比G或 B更宽的滤波器进行过滤，从而导致阴影边缘附近变红。用 
于模拟大多数材料中的次表面散射的正确滤波器在中心具有窄的尖 
峰和宽的浅基部。该技术首次用于离线渲染，但 NVIDIA[345,586] 
----------------------- Page 679-----------------------
和ATI [568,569,803,1541]的研究人员很快就提出了实时GPU实 
现。d'Eon和 Luebke[345]的演示代表了该技术最完整的处理方法 
之一，包括支持模拟多层次表层结构效果的复杂滤波器。Donner 
和Jensen [369]表明这种结构可以产生最逼真的皮肤效果图。由 
d'Eon和 Luebke提供的完整 NVIDIA皮肤渲染系统产生了出色的 
效果（例如，参见图 14.43），但是非常昂贵，需要大量的模糊传 
递。然而，它可以很容易地缩小以提高性能。Hable[631]不是应用 
多个高斯通道，而是提供单个12样本内核。过滤器可以在纹理空间 
中作为预处理应用，也可以在屏幕上栅格化网格时应用于像素着色 
器。这使得脸部渲染很多63614.体积和半透明渲染XXX +XXX图 
14.43。纹理空间多层扩散。使用RGB权重组合六种不同的模糊。 
最终图像是此线性组合的结果，加上镜面术语。（图片由 NVIDIA 
公司提供[345]。）以一些现实主义为代价更快。近距离拍摄时，可 
以看到少量采样作为颜色带。但是，从中等距离来看，质量差异并 
不明显。14.6。5屏幕空间扩散渲染光照贴图并为场景中的所有网 
格模糊它可能很快变得昂贵，无论是计算还是记忆。此外，网格需 
要渲染两次，一次在光照贴图中，一次在视图中，并且光照贴图需 
要具有合理的分辨率，以便能够表示来自小尺度细节的次表面散射。 
为了解决这些问题，希门尼斯提出了一种屏幕空间方法[831]。首先， 
场景照常渲染，并且需要次表面散射的网格，例如人脸，将在模板 
缓冲区中注明。然后对存储的辐射度应用双通道屏幕空间处理以模 
拟次表面散射，使用模板测试仅在需要的地方应用昂贵的算法，包 
----------------------- Page 680-----------------------
含半透明材料的像素。附加通道应用水平和垂直两个一维和双边模 
糊内核。彩色模糊内核是可分离的，但由于两个原因，它不能以完 
全可分离的方式应用。首先，必须考虑线性视图深度，以根据表面 
距离将模糊拉伸到正确的宽度。其次，双边滤波避免了不同深度的 
材料，即不应相互作用的表面之间的光泄漏。此外，必须考虑正常 
方向，以使模糊滤镜不仅应用于屏幕空间，而且应用于表面切线。 
最后，这使得模糊内核的可分离性成为近似值，但仍然是高质量的。 
后来，改进的可分离过滤器 14.6。次表面散射637图14.44。扫描 
模型面的高质量渲染。屏幕空间次表面散射使得可以通过单个后处 
理在许多字符上渲染逼真的人体皮肤材料。（左图：由 Jorge 
Jimenez和 DiegoGutierrez，萨拉戈萨大学提供。扫描由XYZRGB 
Inc.提供。右图：由JorgeJimenez等人，Activision 出版公司， 
2013 年和萨拉戈萨大学提供。扫描由 Lee Perry-Smith， 
Infinite-Realities[831]。）被提议[833]。由于依赖于屏幕上的材 
料区域，该算法对于面部特写是昂贵的。然而，这种成本是合理的， 
因为这些领域的高质量正是所期望的。当场景由许多字符组成时， 
该算法特别有价值，因为它们将同时被处理。见图 14.44。为了进 
一步优化过程，线性深度可以存储在场景纹理的alpha通道中。一 
维模糊依赖于少量样本，因此在近距离的面上可以看到欠采样。为 
了避免这个问题，内核可以按像素旋转，这将隐藏带有噪声的重影 
伪像[833]。通过使用时间抗锯齿可以显着降低这种噪声的可见性 
 （见第5.4.2节）。在实现屏幕空间扩散时，必须注意仅模糊辐照 
----------------------- Page 681-----------------------
度而不是漫反射率或镜面光照。实现此目标的一种方法是将辐照度 
和镜面光照渲染到单独的屏幕空间缓冲区中。如果使用延迟着色（第 
20.1节），则可以使用具有漫反射率的缓冲区。为了减少内存带宽， 
Gallagher和 Mittring [512]建议使用棋盘图案将辐照度和镜面光 
照存储在单个缓冲区中。在辐照度模糊之后，通过将漫反射率与模 
糊辐照度相乘并在顶部添加镜面光照来合成最终图像。在该屏幕空 
间框架内，还可以渲染大规模的次表面散射现象，例如穿过鼻子或 
耳朵的光。当渲染网格漫射光时，Jimenez等人提出的技术。[827] 
还通过使用否定表面法线采样来自相对侧的入射光来从背面贡献添 
加地下透射。结果通过使用通过对从光的视点渲染的传统阴影图进 
行采样而恢复的深度估计的透射率值进行调制，类似于638 14.对 
于Dachsbacher和Stamminger[320]的方法的体积和半透明渲染 
在下一节中描述。为了表示锥形中的前向散射，可以多次对阴影贴 
图进行采样。为了使用每像素的低样本数来降低渲染成本，可以采 
用具有随机偏移或每像素旋转的两个阴影样本。这样做会导致很多 
不必要的视觉噪音。值得庆幸的是，这种噪声可以通过屏幕空间次 
表面模糊内核自动滤除，以实现半透明的地下光漫射。因此，可以 
呈现高质量的半透明效果，模拟通过面部的薄部分的锥形中的前向 
光散射，每个光源仅有一个额外的深度图样本。14.6.6深度图技术 
到目前为止所讨论的技术模拟了相对较小距离（例如皮肤）上的光 
散射。对于表现出大规模散射的材料，例如通过手传播的光，需要 
其他技术。其中许多专注于单次散射，这比多次散射更容易建模。 
----------------------- Page 682-----------------------
大型单次散射的理想模拟可以在图 14.45的左侧看到。由于折射， 
光路在进入和离开物体时改变方向。需要将所有路径的效果相加以 
遮蔽单个表面点。吸收也需要考虑 - 路径中的吸收量取决于材料内 
部的长度。即使对于离线渲染器，计算单个阴影点的所有这些折射 
光线也是昂贵的，因此通常忽略进入材料时的折射，并且仅考虑退 
出材料时的方向变化[823]。由于投射的光线总是在光的方向上， 
Hery[729,730]指出可以访问通常用于阴影的光空间深度图，而不 
是执行光线投射。见图 14.45的中间部分。对于根据相位函数散射 
光的介质，散射角度也会影响散射光的量。执行深度图查找比光线 
投射更快，但是所需的多个样本使得 Hery的方法对于大多数实时 
渲染应用程序来说太慢了。Green [586]提出了更快的近似，如图 
14.45右侧所示。虽然这种方法的物理基础较少，但其结果可能令 
人信服。一个问题是物体背面的细节可以显示出来，因为物体厚度 
的每次变化都会直接影响阴影颜色。尽管如此，格林的近似值足以 
被皮卡尔用于像拉塔图拉这样的电影[609]。皮克斯将这种技术称为 
gummi灯。Hery实现的另一个问题是深度图不应包含多个对象或 
高度非凸对象。这是因为假设阴影（蓝色）点和交叉点（红色）点 
之间的整个路径位于对象内。皮克斯通过使用一种深阴影贴图来解 
决这个问题[1066]。实时建模大规模多次散射非常困难，因为每个 
表面点都会受到来自任何其他表面点的光的影响。Dachsbacher和 
Stamminger[320]提出了阴影映射的扩展，称为translu 14.6。次 
表面散射639图14.45。在左边，是理想的情况，在进入和离开物 
----------------------- Page 683-----------------------
体时光线折射;通过材料内的光线行进正确地收集在离开物体时适 
当折射的所有散射贡献。在评估消光σt时，将考虑每条路径的长度。 
这可以使用路径跟踪或一些实时近似来实现[320]。中间图像显示了 
计算上更简单的情况，其中光线仅在退出时折射。这是在实时渲染 
中进行的通常近似，因为从样本点（黄色）中找到关于折射的入口 
点（红色）并不简单。右图显示近似值，因此更快，其中仅考虑单 
个光线而不是沿折射光线的多个样本[586]。分影映射，用于建模多 
重散射。附加信息 （例如辐照度和表面法线）存储在光空间纹理中。 
从这些纹理中取出几个样本，包括深度图，并组合以形成散射辐射 
的估计。NVIDIA的皮肤渲染系统[345]使用了这种技术的改进。 
Mertens等。[1201]提出了类似的方法，但在屏幕空间而不是光空 
间中使用纹理。树木中的叶子也表现出强烈的次表面散射效应，当 
光线从后面进入时呈现出明亮的绿色。除了反照率和普通纹理之外， 
表示通过叶体积的透射率Tr的纹理可以被映射到表面上[1676]。然 
后，可以使用ad hoc模型来近似来自灯的额外地下贡献。由于叶 
子是薄元素，因此可以使用否定法线作为对侧法线n的近似值。背 
光贡献可以评估为（l·.n）+· （。v·1）+，其中l是光方向，v是视 
图方向。然后可以将其与地表反照率相乘并添加到直接光贡献之上。 
以类似的方式，Barr'e-Brisebois和 Bouchard[105]提出了对网格 
上大规模次表面散射的廉价临时近似。首先，对于每个网格，它们 
生成存储平均局部厚度的灰度纹理，该局部厚度减去从面向内的法 
线计算的环境遮挡。这种称为tss的纹理被认为是可以应用于来自 
----------------------- Page 684-----------------------
表面相对侧的光的透射率的近似值。次表面散射640 14.体积和半 
透明渲染图 14.46。在左侧，为Hebe雕像生成局部厚度纹理。在 
中间，可以用它实现的地下光散射效果。在右边，使用相同技术渲 
染的半透明立方体的另一个场景。 （图片由ColinBarr'e-Brisebois 
和 Marc Bouchard提供[105]。）添加到常规表面照明被评估为 
tsscss.. （v·.l）+？p， （14.30）其中l和v是标准化的分别是光和 
视图向量，p是近似相位函数的指数（如第599页的图14.10所示）， 
css是地下反照率。然后将该表达式与光的颜色，强度和距离衰减相 
乘。该模型不是基于物理的或节能的，但它能够在一次通过中快速 
呈现合理的地下照明效果。见图14.46。14.7头发和毛发是从哺乳 
动物的真皮层中生长出来的蛋白质细丝。在人类的情况下，头发分 
散在身体的不同区域，不同类型包括头顶，胡须，眉毛和睫毛。其 
他哺乳动物通常被毛皮覆盖（密集，有限长度的头发），并且毛皮 
的特性往往在动物身体的不同位置变化。头发可以是直的，波浪形 
的或卷曲的，每个都具有不同的强度和粗糙度。发丝自然可以是黑 
色，棕色，红色，金色，灰色或白色，并且可以染成彩虹的所有颜 
色（取得不同的成功）。头发和毛皮结构基本相同。它由三层 
[1052,1128]组成，如图 14.47所示：。外面是角质层，代表纤维的 
表面。这个表面不是平滑的，而是由重叠的鳞片组成，与头发的方 
向相比倾斜约α=3.这使得法线朝向根部倾斜。14.7。毛发和毛发 
641根尖≈3°皮质髓质 RTRTTTωi鳞片角质层图 14.47。纵向切割 
表示构成它的不同材料的发束，以及沿着方向ωi的入射光产生的发 
----------------------- Page 685-----------------------
光成分。。中间是皮质，含有黑色素，使纤维具有颜色[346]。一种 
这样的色素是真黑素，负责棕色，σa，e = （0.419,0.697,1.37）， 
另一种是褐黑素，负责σa的红发，p= （0.187,0.4,1.05）。。内部 
是髓质。它很小，经常在模拟人发时被忽略[1128]。然而，它占据 
动物毛皮的较大部分毛发体积，其具有更大的意义[1052]。可以看 
到头发纤维与颗粒类似，如体积的离散化，但用曲线代替点。使用 
双向散射分布函数 （BSDF）描述头发纤维照明相互作用。这对应于 
BRDF，但光在球体上集成，而不仅仅是半球。BSDF聚集通过不同 
层发生在头发纤维内的所有相互作用。它在第14.7.2节中有详细描 
述。光在光纤内散射，但也从许多光反射，导致多次散射现象产生 
复杂的彩色辐射。此外，由于纤维根据其材料和颜料吸收光，因此 
表示在头发体积内发生的体积自阴影也很重要。在本节中，我们将 
描述最近的技术如何使我们能够渲染短毛，例如胡须，头发，以及 
最后的毛发。14.7。1几何和Alpha发束可以使用顶点着色器代码 
渲染为挤出的头发四边形，这些代码围绕着由艺术家绘制的头发引 
导曲线，从而在引导下生成四边形带。每个四边形带状物遵循其匹 
配的毛发引导曲线，根据皮肤后面的指定取向并代表一簇毛发 
[863,1228,1560]。这种方法非常适合胡须或短而大多数静态的头 
发。它也是有效的，因为大的四边形可以导致更多的视觉覆盖，因 
此需要更少的带来覆盖头部，这反过来提高了性能。如果需要更多 
细节，例如在通过物理模拟激活的细长头发的情况下，它是64214. 
体积和半透明渲染可以使用更薄的四边形带并渲染数千个。在这种 
----------------------- Page 686-----------------------
情况下，最好还使用沿着头发曲线切线的圆柱约束将生成的四边形 
朝向视图定向[36]。即使仅使用少量毛发引导进行毛发模拟，也可 
以通过插入周围毛发引导的特性来实例化新的股线[1954]。所有这 
些元素都可以呈现为alpha混合几何体。如果使用，头发的渲染顺 
序需要是正确的，以避免透明度伪影（第 5.5节）。为了缓解这个 
问题，可以使用预先排序的索引缓冲区，使头发首先接近头部，最 
后接近头部。这适用于短而非动画的头发，但不适用于长交错和动 
画发束。使用alpha测试可以通过依赖深度测试来修复排序问题。 
然而，这可能会导致高频几何和纹理出现严重的混叠问题。可以使 
用MSAA，每个样本进行alpha测试[1228]，但需要额外的样本和 
内存带宽。或者，可以使用任何与顺序无关的透明度方法，例如第 
5.5节中讨论的方法。例如，TressFX [36]存储k=8个最接近的片 
段，在像素着色器中更新以仅保留前七个有序层，从而实现多层α 
混合[1532]。另一个问题是由mipmap的alpha缩小产生的alpha 
测试工件（第6.6节）。这个问题的两个解决方案是执行更智能的 
alphamipmap生成或使用更高级的散列alpha测试[1933]。当渲 
染细长发股时，也可以根据像素覆盖率修改毛发不透明度[36]。胡 
须，睫毛和眉毛等小毛发比头发的全部毛发更容易渲染。睫毛和眉 
毛的几何形状甚至可以与头部和眼睑运动相匹配。可以使用不透明 
的BRDF材料点亮这些小元件上的毛发表面。也可以使用 BSDF遮 
盖发束，如下一节所述。14.7.2头发 Kajiya和 Kay[847]开发了一 
种 BRDF模型，以提供由有组织的和无限小的圆柱形纤维组成的体 
----------------------- Page 687-----------------------
积。在第9.10.3节中讨论的这个模型最初是通过光线行进通过表示 
表面上方密度的体积纹理来渲染毛茸茸的元素。BRDF用于表示体 
积的镜面反射和漫反射光响应，也可用于头发。Marschner等人的 
开创性工作。[1128]测量人类头发纤维中的光散射并且基于这些观 
察呈现模型。已经观察到在单根发束中散射的不同组分。这些都在 
图14.47中描述。首先，R分量表示在角质层上的空气/纤维界面处 
的光反射，这导致朝向根部的白色镜面峰移位。第二，TT成分表示 
通过从空气到头发材料一次传播而穿过头发纤维的光，并且第二次 
从头发到空气。最后，第三个TRT成分表示在头发纤维中行进的光 
为14.7。头发和毛皮643图14.48。金色 （左）和棕色 （右）毛发 
的路径追踪参考，由纤维偏心引起的镜面闪烁。（图片由d'Eon等 
人[346]提供。）被传播，被纤维的另一侧反射，然后传回到头发材 
料之外。变量名中的 “R”表示一个内部反射。TRT组件被认为是次 
级镜面反射高光，与R相比发生偏移，并且由于光在穿过纤维材料 
时被吸收而被着色。在视觉上，R成分被认为是头发上的无色镜面 
反射。当从后面照亮一定量的头发时，TT组件被认为是明亮的亮点。 
TRT组件对于渲染逼真的毛发至关重要，因为它会在具有偏心的股 
线上产生闪光，即在现实生活中，头发的横截面不是一个完美的圆 
形，而是一个椭圆形。闪光对于可信度很重要，因为它们使头发看 
起来不均匀。见图 14.48。Marschner等人。[1128]提出了将 R， 
TT和TRT组分建模为毛发 BSDF的一部分的功能，其代表毛发纤维 
对光的响应。该模型适当考虑了传输和反射事件中的菲涅耳效应， 
----------------------- Page 688-----------------------
但忽略了其他更复杂的光路，如TRRT，TRRRT和更长时间。然而， 
这种原始模型不能节约能源。这已经在d'Eon等人的工作中进行了 
研究和解决。[346]。BSDF组件已重新配制，并通过更好地考虑粗 
糙度和镜面锥体的收缩来节省能量。这些组件也已扩展到包括更长 
的路径，如TR*T.还使用测量的黑色素消光系数来控制透射率。与 
Marschner等人的工作相似。[1128]，他们的模型能够忠实地渲染 
具有偏心的股线上的闪光。Chiang等人提出了另一种节能模型。 
[262]。该模型给出了粗糙度和多重散射颜色的参数化，这对于艺术 
家来说更直观，而不是让他们调整高斯方差或黑色素浓度系数。例 
如，艺术家可能想要通过改变粗糙度参数来对角色上的头发上的镜 
面术语进行特定的观察。通过基于物理的节能和能量保持模型，分 
散的光线深入644 14。体积和半透明渲染RTTTRT多重完整模型 
图14.49。使用R，TT和TRT进行实时头发渲染，以及多次散射组 
件。（图片由 EpicGames，Inc。提供[863,1802]。）头发量也会 
发生变化。为了提供更多的艺术控制，可以分离前几个散射路径（R， 
TT，TRT）和多个散射部分[1525]。这是通过维持第二组BSDF参 
数来实现的，仅用于多个散射路径。此外，BSDFR，TT和TRT组 
件可以用简单的数学形状表示，艺术家可以理解和调整这些形状以 
进一步细化外观。通过根据进出方向对 BSDF进行归一化，仍然可 
以实现全套节能。上面介绍的每个BSDF模型都很复杂，评估费用 
昂贵，主要用于电影制作路径追踪环境。值得庆幸的是，存在实时 
版本。Scheuermann提出了一种易于实现，快速渲染的 ad hoc 
----------------------- Page 689-----------------------
BSDF模型，并且看起来很有说服力地呈现为大四边形带[1560]。 
更进一步，可以通过将 BSDF存储在由入和出方向索引的 LUT纹理 
中作为参数来实时使用Marschner模型[1128][1274]。然而，该 
方法可能使得难以使具有空间变化外观的头发呈现。为了避免这个 
问题，最近的一个基于物理的实时模型[863]近似于以前使用简化数 
学的工作的组件，以获得令人信服的结果。见图 14.49。然而，与 
离线结果相比，所有这些实时头发渲染模型的质量存在差距。简化 
算法通常不具有高级体积阴影或多次散射。这种效果对于具有低吸 
收性的头发（例如金发）特别重要。在体积阴影的情况下，最近的 
解决方案[36,863]依赖于使用d计算的透射率值作为根据恒定吸收 
σa沿着从第一根头发到达当前光纤的光的方向的距离。这种方法实 
用且简单，因为它依赖于任何引擎中可用的通常阴影贴图。然而， 
它不能代表由于成束的发束造成的局部密度变化，这对于明亮的头 
发尤其重要。见图 14.50。要解决此问题，可以使用体积阴影表示 
 （第7.8节）。在渲染头发时，多次散射是一个昂贵的术语。没有 
多少解决方案适合实时实施。卡里斯[863]提出了一个 14.7。头发和 
毛皮645图14.50。左：使用与第一个遮挡物的深度差与恒定的消 
光系数导致太平滑的体积阴影。中间：使用深阴影贴图[1953]可以 
实现更多的透射率变化，与毛发在头发体积内聚集在一起的方式相 
匹配。右：结合深阴影贴图和PCSS可以根据到第一个遮挡物的距 
离实现更平滑的体积阴影（更多细节见7.6节）。（使用头发模型 
呈现的图像由USC-HairSalon提供[781]。）近似多次散射的方式。 
----------------------- Page 690-----------------------
这个ad hoc模型使用假法线（类似弯曲法线），包裹漫射照明， 
并且在与光线相乘之前将毛发的基色提升到与深度相关的能量，在 
光线散射通过许多股线后近似色彩饱和度。Zinke等人提出了一种 
更先进的双散射技术。[1972]。见图14.51。它是双重的，因为它 
根据两个因素评估散射光的量。首先，通过组合在阴影像素和光的 
位置之间遇到的每根发束的 BSDF来评估全局透射率因子G. 因此， 
G给出了应用于阴影位置处的入射辐射的透射量。可以通过计算毛 
发的数量并计算光路上的平均线方向来评估该值，后者影响 BSDF， 
因此也影响透射率。使用深度不透明度映射[1953]或占用图[1646] 
可以实现累积这些数据。其次，局部散射分量L近似于这样的事实， 
即阴影位置处的透射辐射将在当前光纤周围的头发纤维中散射并且 
有助于辐射。这两个项都被添加为G +G L并通过像素链 BSDF馈 
送以累积光源贡献。这种技术更昂贵，但它是头发体积内轻微多重 
散射现象的准确实时近似。它也可以与本章介绍的任何 BSDF一起 
使用。环境照明是评估动画半透明材料的另一种复杂因素。通常从 
球谐波中简单地采样辐照度。照明还可以通过在其静止位置处从头 
发计算的非定向预先整合的环境遮挡来加权[1560]。使用相同的假 
64614.体积和半透明渲染图 14.51。前两个图像呈现使用路径追踪 
作为三个头发散射成分 （R，TT，TRT）的参考并且然后添加多个散 
射来呈现的头发。最后两幅图像使用双散射近似结果：路径跟踪， 
然后在 GPU上实时渲染。（图片由Arno Zinke和 CemYuksel 
[1953]提供。）正常的多次散射，Karis提出了一种环境照明的特殊 
----------------------- Page 691-----------------------
模型[863]。有关更多信息，可从Yuksel和Tariq [1954]在线获得 
全面的实时头发渲染课程。在阅读研究论文和学习更多细节之前， 
本课程将向您介绍头发渲染的许多方面，如模拟，碰撞，几何，BSDF， 
多重散射和体积阴影。在实时应用中，头发看起来很有说服力。然 
而，仍然需要进行大量研究才能更好地近似基于物理的环境照明和 
头发中的多重散射。14.7.3毛皮与毛发相反，毛皮通常被视为通常 
在动物身上发现的短而半组织的股线。与用于体积渲染的纹理层的 
方法相关的概念是体积纹理，其是由二维半透明纹理的层表示的体 
积描述[1203]。例如，Lengyel等。[1031]使用一组八个纹理来表 
示表面上的毛发。每个纹理代表通过距离表面给定距离的一组毛发 
的切片。模型渲染八次，顶点着色器程序每次沿着顶点法线将每个 
三角形稍微向外移动。以这种方式，每个连续模型描绘了表面上方 
的不同高度。以这种方式创建的嵌套模型称为shell。这种渲染技术 
沿着物体轮廓边缘分开，因为当层展开时，头发会分裂成点。为了 
隐藏这个神器，毛发也由沿着轮廓边缘生成的翅片上应用的不同毛 
发纹理表示。请参见第855页的图 14.52和图 19.28。轮廓鳍挤出 
的概念可用于为其他类型的模型创建视觉复杂性。例如，Kharlamov 
等人。[887]使用鳍和浮雕映射来提供具有复杂轮廓的树网格。14.7。 
头发和毛皮647图14.52。使用体积纹理的毛发。该模型呈现八次， 
每次通过表面向外扩展少量。左边是八次传球的结果。请注意沿着 
轮廓的头发分裂。在中间，显示了鳍渲染。右边是最终渲染，使用 
鳍和贝壳。（图片来自NVIDIASDK10[1300]样品 “Fur-Shellsand 
----------------------- Page 692-----------------------
Fins”，由NVIDIA公司提供。）几何着色器的引入使得实际上可 
以为具有毛发的表面挤出折线毛。这种技术用于失落的星球[1428]。 
渲染表面并在每个像素处保存值：毛发颜色，长度和角度。然后， 
几何着色器处理此图像，将每个像素转换为半透明折线。通过创建 
每个像素覆盖的一根头发，自动保持细节水平。毛皮分两次渲染。 
首先渲染向下指向屏幕空间的毛发，从屏幕的底部到顶部排序。以 
这种方式，正确地执行混合，从前到后。在第二关，向上的毛皮的 
其余部分从上到下呈现，再次正确混合。随着GPU的发展，新技术 
变得可行且有利可图。也可以使用前面部分中介绍的技术。可以将 
线条渲染为从皮肤表面挤出为几何体的四边形，例如星球大战前线 
游戏中的Chewbacca或TressFXRat演示[36]。当将发束呈现为细 
丝时，凌琦等人。[1052]已经证明，将头发模拟为均匀的圆柱是不 
够的。对于动物毛皮，髓质相对于毛发半径更深和更大。这减少了 
光散射的影响。因此，提出了一种双筒纤维 BSDF模型，其模拟更 
宽范围的头发和毛发[1052]。它考虑更详细的路径，如TttT，TrRrT， 
TttRttT，以及更多，其中小写字母表示与髓质的相互作用。这种复 
杂的方法可以产生更逼真的视觉效果，尤其适用于模拟粗糙的毛发 
和精细的散射效果。这样的毛发渲染648 14.体积和半透明渲染技 
术涉及许多链实例的光栅化，并且欢迎任何有助于减少渲染时间的 
东西。Ryu[1523]提出根据运动幅度和距离来抽取作为细节方案的 
级别呈现的链实例的数量。此方法用于离线电影渲染，并且似乎可 
以直接应用于实时应用程序。14.8统一方法我们已经达到了体积渲 
----------------------- Page 693-----------------------
染在实时应用程序中变得可承受的程度。未来可能实现的目标是什 
么？在本章的开头，我们说 “一切都是散射的。”在参与媒体材料 
时，可以使用高散射系数σs来获得不透明介质。这与驱动漫反射和 
镜面反应的复杂各向异性相位函数一起将导致不透明的表面材料。 
鉴于此，是否有办法统一实体和体积材料表示？截至今天，体积和 
不透明材料渲染是分开的，因为GPU的当前计算能力迫使我们使用 
对某些用例有效的特定方法。我们使用网格作为不透明表面，使用 
alpha混合网格作为透明材料，使用粒子广告牌作为烟雾卷，和射 
线行进在参与媒体内的一些体积照明效果。正如Dupuy等人所暗示 
的那样。[397]，可以使用统一表示来表示实体和参与媒体。一种可 
能的表示是使用对称GGX[710] （SGGX），它是第9.8.1节中给出 
的GGX正态分布函数的扩展。在这种情况下，表示体积内的取向片 
状颗粒的微薄片理论取代了用于表面正态分布表示的微观理论。从 
某种意义上说，与网格相比，细节水平会变得更加实用，因为它可 
以简单地成为对材质属性的体积过滤。这可以导致更加连贯的照明 
和大型详细世界的表现，同时保持照明，形状，遮挡，或在背景上 
施加透射率。例如，如图 14.53所示，使用体积过滤树表示渲染林 
将删除可见树状网格 LOD切换，提供平滑过滤薄几何体并避免分支 
引起的混叠，同时还在背景上提供正确的遮挡值考虑每个体素内的 
基础树几何。进一步阅读和资源这些资源已在整个文本中提及，但 
值得强调的是，这里特别值得注意。一般体积渲染在 14.8中解释。 
统一方法649图14.53。使用SGGX在顶部渲染的森林，从左到右 
----------------------- Page 694-----------------------
的细节水平逐渐降低。底部显示未经过滤的原始体素。（图片由Eric 
Heitz等人提供[710]。）Fong等人的课程笔记。[479]，提供相当 
多的背景理论，优化细节和电影制作中使用的解决方案。对于天空 
和云渲染，本章以 Hillaire的广泛课程笔记[743]为基础，其中包含 
了比我们在此处所包含的更多细节。体积材料的动画超出了本书的 
范围。我们建议读者阅读这些关于实时模拟的文章[303,464,1689]， 
特别是 Bridson [197]的完整书籍。McGuire的演讲[1182]以及 
McGuire和 Mara的文章[1185]，更广泛地理解了与透明度相关的 
效果以及可用于各种元素的一系列策略和算法。对于头发和毛发渲 
染和模拟，我们再次向读者介绍Yuksel和Tariq [1954]的大量课程 
笔记。第 15章非真实感渲染 “使用像'非线性科学'这样的术语就像 
把动物学的大部分称为'非大象动物的研究'。 “-StanislawUlam真 
实感渲染试图使图像与照片无法区分。非真实感渲染（NPR），也 
称为程式化渲染，具有广泛的目标。某些形式的 NPR的一个目标是 
创建类似于技术插图的图像。只有那些与特定应用目标相关的细节 
- 图 15.1。各种非照片级渲染样式应用于咖啡研磨机。（使用 
Viewpoint DataLabs中的LiveArt生成。）651652 15.非真实感 
渲染阳离子是应显示的阳离子。例如，一张闪亮的法拉利发动机的 
照片可能对向客户出售汽车很有用，但是为了修理发动机，突出显 
示相关部件的简化线条图可能更有意义 （打印成本更低）。NPR的 
另一个领域是绘画风格和天然媒体的模拟，例如钢笔和墨水，木炭 
和水彩。这是一个巨大的领域，适用于各种各样的算法，试图捕捉 
----------------------- Page 695-----------------------
各种媒体的感觉。一些例子如图 15.1所示。两本较旧的书籍涵盖了 
技术和绘画 NPR算法[563,1719]。鉴于这种广度，我们将重点放在 
渲染笔划和线条的技术上。我们的目标是实时提供一些用于 NPR的 
算法。本章将详细讨论实现卡通渲染风格的方法，然后讨论 NPR领 
域内的其他主题。本章以各种线条渲染技术结束。15.1香椿阴影正 
如改变字体给文本带来不同的感觉一样，不同的渲染风格也有自己 
的情绪，意义和词汇。对于一种特殊形式的 NPR，cel或toon渲染 
有很多关注。由于这种风格用漫画来识别，它具有幻想和童年的内 
涵。最简单的是，用实线绘制物体，分隔出不同纯色的区域。这种 
风格流行的一个原因是 McCloud在其经典着作“漫画漫画”[1157] 
中称之为 “通过简化放大”。通过简化和消除混乱，人们可以放大 
与演示相关的信息的影响。对于卡通人物而言，更广泛的受众将识 
别出以简单风格绘制的人物。数十年来，香椿渲染风格一直用于计 
算机图形学，以将三维模型与二维cel动画相结合。它非常适合计 
算机自动生成，因为与其他NPR样式相比，它很容易定义。许多视 
频游戏都使用它有效[250,1224,1761]。见图15.2。对象的轮廓通 
常以黑色呈现，这放大了卡通外观。查找和呈现这些轮廓将在下一 
节中介绍。表面着色有几种不同的方法。两种最常见的方法是用固 
体（未点亮）颜色填充网格区域或使用双色调方法，代表点亮和阴 
影区域。当阴影法线和光源方向的点积高于某个值时，双色调方法 
 （有时称为硬着色）在像素着色器中通过使用较浅的颜色很容易执 
行，如果不是，则使用较暗的色调。当照明更复杂时，另一种方法 
----------------------- Page 696-----------------------
是量化最终图像本身。也称为分色，这是一个连续范围的值并转换 
为几个音调的过程，每个音调之间有明显的变化。见图 15.3。量化 
RGB值会导致令人不快的色调偏移，因为每个单独的通道以与其他 
通道不紧密相关的方式变化。工作色调 15.1。Toon Shading653 
图 15.2。来自游戏Okami 的实时 NPR渲染的示例。（图片由 
Capcom Entertainment，Inc。提供）保留色彩空间，如HSV， 
HSL或Y'CbCr是更好的选择。或者，可以定义一维函数或纹理以 
将强度级别重新映射到特定的阴影或颜色。也可以使用量化或其他 
滤波器对纹理进行预处理。另一个具有更多色彩等级的示例显示在 
第665页的图 15.16中。基本实心分色铅笔图 15.3。左侧的基本渲 
染依次应用了实心填充，分色和铅笔着色技术。（Quidam的Jade2 
模型，由wismo [1449]出版，Creative Commons 2.5归属许可 
证。）654 15.非真实感渲染 Barla等。[104]通过使用二维图代替 
一维阴影纹理来添加依赖于视图的效果。通过表面的深度或方向访 
问第二维。例如，这允许物体在远离或快速移动时平稳地软化。该 
算法结合各种其他着色方程和绘制纹理，在游戏团队要塞2中使用， 
以融合卡通和逼真的风格[1224]。香椿着色器的变化可用于其他目 
的，例如在表面或地形上可视化特征时夸大对比度[1520]。15.2轮 
廓渲染用于cel边缘渲染的算法反映了 NPR的一些主要主题和技 
术。我们的目标是提供能够提供该领域风格的算法。使用的方法可 
以粗略地分类为基于表面着色，程序几何，图像处理，几何边缘检 
测或这些的混合。有几种不同类型的边可用于toon渲染：。边界 
----------------------- Page 697-----------------------
或边界边缘是两个三角形不共享的边界或边界边缘，例如纸张的边 
缘。实体对象通常没有边界边。。折痕，硬边或特征边是由两个三 
角形共享的边，并且两个三角形之间的角度（称为二面角）大于某 
个预定义值。一个好的默认折痕角是60度[972]。例如，立方体具 
有折痕边缘。折痕边缘可以进一步细分为脊和谷边缘。。当共享它 
的两个三角形在材质上不同或者导致阴影发生变化时，会出现材质 
边缘。它也可以是艺术家希望始终显示的边缘，例如前额线或用于 
分隔相同颜色的裤子和衬衫的线。。轮廓边缘是两个相邻三角形与 
一些方向矢量相比面向不同方向的轮廓边缘，通常是来自眼睛的一 
个方向矢量。。轮廓边是沿着对象轮廓的轮廓边，即，它将对象与 
图像平面中的背景分开。见图 15.4。这种分类基于文献中的常见用 
法，但存在一些变化，例如，我们称之为折痕，材料边缘有时被称 
为边界边缘。我们在这里区分轮廓和轮廓边缘。两者都是边缘，表 
面的一部分面向观察者，另一部分面向远离。轮廓边是轮廓边的子 
集，即将对象与另一个对象或背景分开的轮廓边。例如，在头部的 
侧视图中，耳朵形成 15.2。轮廓渲染 655 CS CS CS CS M M 
BBBBBBCCC图15.4。顶部开有一个盒子，正面有条纹。示出了边 
界（B），折痕（C），材料（M）和轮廓（S）边缘。根据给定的 
定义，没有边界边缘被认为是轮廓边缘，因为这些边缘仅具有一个 
相邻的多边形。轮廓边缘，即使它们出现在头部的轮廓轮廓内。图 
15.3中的其他例子包括鼻子，两个弯曲的手指，以及头发部位。在 
一些早期文献中，轮廓边缘被称为轮廓，但通常意味着完整的轮廓 
----------------------- Page 698-----------------------
边缘类别。此外，轮廓边不应与地形图上使用的轮廓线混淆。请注 
意，边界边缘与轮廓边缘或轮廓边缘不同。轮廓和轮廓边缘由视图 
方向定义，而边界边缘与视图无关。暗示轮廓[335]由几乎是原始视 
点轮廓的位置形成。它们提供额外的边缘，有助于传达物体的形状。 
见图 15.5。虽然我们的重点主要是检测 - 图15.5。从左到右：轮 
廓，轮廓和轮廓以及暗示轮廓边缘。（图片由DougDeCarlo，Adam 
Finkelstein，SzymonRusinkiewicz和AnthonySantella提供。） 
65615.非真实感渲染和渲染轮廓边缘，已经为其他类型的笔划做了 
大量工作[281,1014,1521]。我们还主要关注为多边形模型找到这样 
的边。B'enard等人。[132]讨论了寻找由细分曲面或其他高阶定义 
组成的模型轮廓的方法。15.2.1阴影正常轮廓边以与第15.1节中的 
曲面着色器类似的方式，阴影法线和眼睛方向之间的点积可用于给 
出轮廓边[562]。如果该值接近零，则表面几乎与眼睛边缘接近，因 
此可能接近轮廓边缘。将这些区域着色为黑色，随着点积的增加而 
下降为白色。见图 15.6。在可编程着色器之前，使用带有黑色环的 
球形环境贴图或将 mipmap金字塔纹理黑色的最顶层着色[448]来 
实现此算法。今天的这种类型的阴影直接在像素着色器中通过变为 
黑色来实现，因为屏幕法线变得垂直于视图方向。这种阴影在某种 
意义上与边缘照明相反，其中光照亮了物体的轮廓;在这里，场景从 
眼睛的位置被照亮，并且下降被夸大，使边缘变暗。它也可以被认 
为是图像处理中的阈值滤波器，其中图像在表面低于特定强度的任 
何地方都被转换为黑色，否则转换为白色。该方法的特征或缺点是 
----------------------- Page 699-----------------------
根据表面的曲率绘制具有可变宽度的轮廓线。此方法适用于没有折 
痕边缘的曲面模型，其中沿着轮廓的区域，例如，通常会有法线指 
向几乎垂直于视图方向的像素。图15.6。当阴影法线垂直于视图方 
向时，通过使曲面变暗来修剪轮廓边缘。通过加宽衰减角度，可以 
显示更粗的边缘。（图片由 KennyHoff提供。）15.2。轮廓渲染 
657算法在诸如立方体之类的模型上失败，因为折痕边缘附近的表 
面区域不具有此属性。它甚至在弯曲的表面上也会分裂并且看起来 
很糟糕，因为当物体距离很远并且在轮廓边缘附近采样的一些法线 
可能不是几乎垂直的。古德温等人。[565]注意这个基本概念如何作 
为视觉提示有效，并讨论如何组合照明，曲率和距离来确定行程厚 
度。15.2。2程序几何形状剪影 Rossignac和van Emmerik[1510] 
提出了实时轮廓边缘渲染的首批技术之一，后来由Raskar和Cohen 
[1460]进行了改进。一般的想法是正常渲染前面，然后渲染背面， 
使其轮廓边缘可见。渲染这些背面有多种方法，每种方法都有自己 
的优点和缺点。每种方法的第一步都是绘制正面。然后打开正面剔 
除并关闭背面剔除，以便仅渲染背面。渲染轮廓的一种方法是仅绘 
制背面的边 （而不是面）。使用偏置或其他技术 （第 15.4节）确保 
这些线中的一些线条正好在正面前面绘制。通过这种方式，只有前 
面和后面相交的边是可见的[969,1510]。使这些线条更宽的一种方 
法是将背面自身呈现为黑色，再次向前偏置。Raskar和Cohen提 
供了几种偏置方法，例如以固定量进行平移，或者通过补偿z深度 
的非线性特性的量，或者使用深度斜率偏置调用，例如OpenGL的 
----------------------- Page 700-----------------------
glPolygonOffset。Lengyel [1022]讨论了如何通过修改透视矩阵 
来提供更精细的深度控制。所有这些方法的一个问题是它们不能创 
建具有均匀宽度的线。要做到这一点，向前移动的数量不仅取决于 
背面，还取决于相邻的正面。见图15.7。背面的斜率可用于向前偏 
置多边形，但线的粗细也取决于正面的角度。图15.7。剪影的z偏 
差方法，通过向前平移背面来完成。如果正面处于不同的角度，如 
右图所示，可以看到不同数量的背面。（Raskar和Cohen之后的 
插图[1460]。）65815.非真实感渲染图 15.8。三角育肥。在左侧， 
背面三角形沿其平面展开。每个边缘在世界空间中移动不同的量， 
以使得到的边缘在屏幕空间中具有相同的厚度。对于薄三角形，当 
一个角变长时，这种技术就会崩溃。在右侧，三角形边缘被展开并 
连接以形成斜角以避免此问题。拉斯卡和科恩[1460，1461]解决这 
个邻居依赖问题，而不是沿着其边缘将每个背面三角形增加一个看 
到一致粗线所需的量。也就是说，三角形的斜率和距观察者的距离 
决定了三角形的扩展程度。一种方法是沿着其平面向外扩展每个三 
角形的三个顶点。渲染三角形的更安全的方法是将三角形的每个边 
缘向外移动并连接边缘。这样做可以避免顶点远离原始三角形。见 
图15.8。请注意，此方法不需要偏置，因为背面扩展超出前面的边 
缘。有关这三种方法的结果，请参见图 15.9。这种育肥技术更加可 
控和一致，并已成功用于视频游戏中的角色概述，如波斯王子[1138] 
和非洲武士[250]。图15.9。使用粗线，z偏置和加粗三角形算法使 
用背面边缘绘制渲染轮廓边。由于小特征上的偏置问题，背面边缘 
----------------------- Page 701-----------------------
技术在线和非均匀线之间提供了差的连接。由于依赖于前面的角度， 
z偏置技术给出了不均匀的边缘宽度。（图片由 Raskar和Cohen 
提供[1460]。）15.2。轮廓渲染659眼睛渲染前面展开并渲染黑色 
背面图 15.10。三角形壳技术通过沿着顶点法线移动曲面来创建第 
二个曲面。在刚刚给出的方法中，背面三角形沿其原始平面展开。 
另一种方法是通过沿共享顶点法线移动它们的顶点向外移动背面， 
其量与它们与眼睛的z距离成比例[671]。这被称为shell或 halo 
方法，因为移位的背面形成围绕原始对象的壳。想象一个球体。正 
常渲染球体，然后将球体扩展为相对于球体中心5像素宽的半径。 
也就是说，如果移动球体的中心一个像素相当于将它在世界空间中 
移动 3毫米，那么将球体的半径增加 15毫米。仅渲染此扩展版本 
的黑色背面。轮廓边缘宽5像素。见图 15.10。沿着法线向外移动 
顶点对于顶点着色器来说是一个完美的任务。这种类型的扩展有时 
称为shell映射。该方法易于实现，高效，稳健，并且性能稳定。见 
图15.11。可以通过根据它们的角度进一步扩展和着色这些背面来 
产生力场或光环效应。这种shell技术有几个潜在的缺陷。想象一下 
正面看着一个立方体，这样只能看到一张脸。形成轮廓边缘的四个 
背面中的每一个将在其相应的立方体面的方向上移动，从而在拐角 
处留下间隙。发生这种情况是因为虽然每个角上都有一个顶点，但 
每个面都有不同的顶点法线。问题是扩展的立方体不能真正形成壳， 
因为每个角顶点都在不同的方向上扩展。一种解决方案是在相同位 
置强制顶点以共享单个新的平均顶点法线。另一种技术是在折痕处 
----------------------- Page 702-----------------------
创建退化几何体，然后将其扩展为具有面积的三角形。Lira等人。 
[1053]使用附加阈值纹理来控制每个顶点移动多少。壳和肥育技术 
会浪费一些填充物，因为所有背面都被送到管道中。所有这些技术 
的其他限制是对边缘外观的控制很少，并且半透明表面很难正确渲 
染，这取决于所使用的透明度算法。66015.非真实感渲染图15.11。 
来自游戏CelDamage的实时香椿式渲染的示例，使用背面外壳扩 
展来形成轮廓边缘，以及明确的折痕边缘绘制。（图片由 Pseudo 
InteractiveInc.提供）这一整套几何技术的一个有价值的特征是在 
渲染过程中不需要连接信息或边缘列表。每个三角形独立于其余三 
角形处理，因此这些技术适合于GPU实现[1461]。这类算法仅渲染 
轮廓边。Raskar[1461]提供了一种巧妙的解决方案，用于在变形模 
型上绘制脊部折痕边缘，而无需创建和访问边缘连接数据结构。我 
们的想法是沿着渲染的三角形的每个边缘生成一个额外的多边形。 
这些边缘多边形通过用户定义的临界二面角弯曲远离三角形平面， 
该二面角确定何时应该可见折痕。如果在任何给定时刻，两个相邻 
的三角形大于该折痕角，边多边形将是可见的，否则它们将被三角 
形隐藏。见图 15.12。使用类似的技术可以实现谷边，但需要模板 
缓冲和多次通过。15.2.3通过图像处理进行边缘检测上一节中的算 
法有时被归类为基于图像的，因为屏幕分辨率决定了它们的执行方 
式。另一种算法是 15.2。大纲渲染661图15.12。两个三角形连接 
在一起的侧视图，每个三角形都附有一个小 “翅片”。当两个三角 
形沿边缘弯曲时，鳍片朝向变得可见。在右边，鳍露出来。漆成黑 
----------------------- Page 703-----------------------
色，这些看起来像一个山脊边缘。更直接的图像，因为它完全依赖 
于存储在图像缓冲区中的数据，并且不会修改（甚至直接了解）场 
景中的几何体。Saito和Takahashi [1528]首先介绍了这个G缓冲 
区概念，它也用于延迟着色（第20.1节）。Decaudin [336]扩展 
了使用G缓冲区来执行toon渲染。基本思想很简单：NPR可以通 
过在各种信息缓冲区上执行图像处理算法来完成。通过查找相邻z 
缓冲区值中的不连续性，可以找到许多轮廓边缘位置。相邻表面法 
线值的不连续性通常表示轮廓和边界边缘的位置。以环境颜色或使 
用对象标识值渲染场景可用于检测材质，边界和真实轮廓边。检测 
和渲染这些边缘由两部分组成。首先，渲染场景的几何体，像素着 
色器根据需要为各种渲染目标保存深度，法线，对象 ID或其他数据。 
然后以与第 12.1节中描述的类似方式执行后处理过程。后处理过程 
对每个像素周围的邻域进行采样，并基于这些样本输出结果。例如， 
假设我们为场景中的每个对象都有一个唯一的标识值。在每个像素 
处，我们可以对此 ID进行采样，并将其与测试像素角落处的四个相 
邻像素 ID值进行比较。如果任何 ID与测试像素的 ID不同，则输出 
黑色，否则输出白色。对所有八个相邻像素进行采样更加简单，但 
采样成本更高。这种简单的测试可用于绘制大多数对象的边界和轮 
廓边 （真实轮廓）。材质 ID可用于查找材料边缘。通过在普通和深 
度缓冲区上使用各种过滤器可以找到轮廓边缘。例如，如果相邻像 
素之间的深度差异高于某个阈值，则可能存在轮廓边缘，因此使像 
素变黑。关于相邻像素是否与我们的样本匹配的简单决定，不需要 
----------------------- Page 704-----------------------
其他更精细的边缘检测算子。我们不会在这里讨论各种边缘检测滤 
波器的优缺点，例如 Robertscross，Sobel和Scharr，因为图像 
处理文献广泛涵盖了这些[559,1729]。因为这些运算符的结果不一 
定是布尔值，在某些区域，我们可以调整它们的阈值或在黑白之间 
淡入淡出。请注意，普通缓冲区也可以检测折痕边缘，因为法线之 
间的较大差异可以表示轮廓或折痕边缘。Thibault和Cavanaugh 
[1761]讨论了他们如何使用这种技术 662 15.非真实感渲染图 
15.13。在游戏 “无主之地”中修改了Sobel边缘检测。最终发布 
的版本（此处未显示）通过掩盖前景中草的边缘来进一步改善外观 
[1761]。（图片由Gearbox Software，LLC。提供），带有游戏 
Borderlands的深度缓冲区。在其他技术中，他们修改Sobel滤波 
器，以便创建单像素宽的轮廓和深度计算，以提高精度。见图15.13。 
也可以走另一个方向，通过忽略相邻深度相差很大的边缘，仅在阴 
影周围添加轮廓[1138]。扩张算子是一种形态学算子，用于加厚检 
测到的边缘[226,1217]。生成边缘图像后，将应用单独的传递。在 
每个像素处，检查像素的值及其在某个半径内的周围值。找到的最 
暗像素值作为输出返回。通过这种方式，细黑线将被搜索区域的直 
径加厚。多个15.2。大纲渲染663图15.14。法线贴图 （左上）和 
深度贴图（上中）将Sobel边缘检测应用于其值，结果分别显示在 
左下和中下。右上角的图像是使用扩张的增厚复合材料。右下角的 
最终渲染是通过使用Gooch着色和边缘合成对图像进行着色来实 
现的。 （图片由DrewCard和Jason L.Mitchell提供，ATI技术公 
----------------------- Page 705-----------------------
司）通过可用于进一步加粗线，折衷的是额外通过的成本通过每次 
通过需要相当少的样本来抵消。不同的结果可以具有不同的厚度， 
例如，轮廓边缘可以制造得比其他轮廓边缘更厚。相关的侵蚀算子 
可用于细线或其他效果。有些结果请参见图 15.14。这种算法有几 
个优点。与大多数其他技术不同，它可以处理所有类型的平面或曲 
面。网格不必连接或甚至一致，因为该方法是基于图像的。这种技 
术存在相对较少的缺陷。对于接近边缘的表面，z深度比较滤波器 
可能错误地检测表面上的轮廓边缘像素。z深度比较的另一个问题 
是如果差异最小，则可以错过轮廓边缘。例如，桌子上的一张纸通 
常会遗漏其边缘。类似地，法线贴图将错过这张纸的边缘，因为法 
线是相同的。这仍然不是万无一失的;例如，折叠在其自身上的一张 
纸将产生边缘重叠的不可检测的边缘[725]。生成的线条显示阶梯式 
别名，但各种66415.非真实感渲染图 15.15。各种边缘方法。皱纹 
等特征边缘是纹理本身的一部分，由艺术家提前添加。角色的轮廓 
是通过背面拉伸生成的。使用具有变化权重的图像处理边缘检测来 
生成轮廓边缘。左图像的重量太小，因此这些边缘很微弱。中间显 
示轮廓，尤其是鼻子和嘴唇的轮廓边缘。右侧显示太重的人工制品 
[250]。 （AfroSamuraiR＆c2006TAKASHIOKAZAKI，GONZO 
/ SAMURAI PROJECT 。 计 划 c 2009 BANDAI NAMCO 
EntertainmentAmerica Inc.）第5.4.2节中描述的形态抗锯齿技术 
与这种高对比度输出以及诸如分色，提高边缘质量。检测也可能以 
相反的方式失败，创建不应存在的边。确定构成边缘的内容并非万 
----------------------- Page 706-----------------------
无一失的操作。例如，想象一下玫瑰的茎，一个细圆柱。关闭，邻 
近我们的样本像素的词干法线变化不大，因此没有检测到边缘。当 
我们离开玫瑰时，法线将逐个像素地变化得更快，直到某些点由于 
这些差异而在边缘附近可能发生假边缘检测。从深度图检测边缘会 
发生类似的问题，透视对深度的影响是需要补偿的另一个因素。 
Decaudin[336]通过处理法线和深度图的梯度而不仅仅是值本身， 
提供了一种寻找变化的改进方法。决定各种像素差异如何转化为颜 
色变化是一个经常需要针对内容进行调整的过程[250,1761]。见图 
15.15。一旦生成笔划，就可以根据需要执行进一步的图像处理。由 
于笔划可以在单独的缓冲区中创建，因此可以单独修改它们，然后 
在曲面顶部合成。例如，可以使用噪声函数分别对线条和曲面进行 
磨损和摆动，在两者之间创建小间隙并给出手绘外观。纸张的高度 
场可用于影响渲染，具有固体材料，例如沉积在凸起顶部的木炭或 
汇集在山谷中的水彩颜料。有关示例，请参见图 15.16。15.2。大 
纲渲染665图15.16。左侧的鱼模型使用边缘检测，分色，噪声扰 
动，模糊和纸张混合在右侧呈现。 （图片由Autodesk，Inc。提供） 
我们在这里专注于使用几何或其他非图形数据检测边缘，例如法线， 
深度和ID。自然地，为图像开发了图像处理技术，并且这种边缘检 
测技术可以应用于颜色缓冲器。一种方法称为高斯差分（DoG）， 
其中图像用两个不同的高斯滤波器处理两次，一个从另一个中减去。 
已经发现这种边缘检测方法对于NPR产生特别令人满意的结果，用 
于产生各种艺术风格的图像，例如铅笔阴影和粉彩 
----------------------- Page 707-----------------------
[949,1896,1966]。图像后处理操作员在许多模拟艺术媒体 （如水彩 
和丙烯酸涂料）的NPR技术中占有突出地位。这个领域有相当多的 
研究，对于交互式应用程序来说，最大的挑战是尝试使用最少数量 
的纹理样本来做最多的事情。可以在GPU上使用双边，均值平移和 
Kuwahara滤波器来保留边缘和平滑区域，就像绘制[58,948]一样。 
Kyprianidis等。[949]提供对该领域的图像处理效果的彻底审查和 
分类。Montesdeoca等人的工作。[1237]是将多种简单技术组合 
成以交互速率运行的水彩效果的一个很好的例子。使用水彩样式渲 
染的模型如图 15.17所示。15.2.4几何轮廓边缘检测到目前为止给 
出的方法的一个问题是边缘的样式化最多是有限的。我们不能轻易 
地让线条看起来破碎，更不用说看起来一手拉或像画笔一样。对于 
这种操作，我们需要找到轮廓边并直接渲染它们。具有单独的独立 
边缘实体使得可以创建其他效果，例如当网格在震动中冻结时使轮 
廓突然跳跃。66615.非真实感渲染图15.17。在左侧，标准的现实 
渲染。在右侧，水彩风格通过平均移位颜色匹配来柔化纹理，并增 
加对比度和饱和度等技术。（水彩图像由Autodesk，Inc。提供） 
轮廓边缘是两个相邻三角形中的一个面向观察者而另一个面向远离 
的边缘。测试是 （n0·v） （n1·v）<0， （15.1）其中n0和n1是两 
个三角形法线，v是从眼睛到边缘 （即，到任一端点）的视图方向。 
为使该测试正常工作，表面必须始终如一 （第 16.3节）。用于在模 
型中找到轮廓边缘的强力方法是遍历边缘列表并执行该测试 
[1130]。Lander[972]指出，有价值的优化是识别和忽略平面多边 
----------------------- Page 708-----------------------
形内的边。也就是说，给定连接的三角形网格，如果边缘的两个相 
邻三角形位于同一平面中，则边缘不可能是轮廓边缘。在简单的时 
钟模型上实现此测试会将边缘数从444个边缘减少到256个。此外， 
如果模型定义了实体对象，则凹边不能是轮廓边。Buchanan和 
Sousa[207]通过对每个面重复使用点积测试，避免了对每个边进行 
单独点积测试的需要。从头开始检测每个框架的轮廓边缘可能是昂 
贵的。如果摄像机视图和对象在帧与帧之间移动很少，则可以合理 
地假设来自先前帧的轮廓边缘可能仍然是有效的轮廓边缘。Aila和 
Miettinen[13]将每个边缘的有效距离联系起来。这个距离是 15.2 
多远。大纲渲染667图15.18。轮廓循环。左侧是相机的模型视图。 
中间显示三角形背对着蓝色的相机。右侧显示了一个面部区域的特 
写镜头。注意复杂性以及如何将一些轮廓环隐藏在鼻子后面。（模 
型由 Chris Landreth 提供，图片由 Pierre B'enard 和 Aaron 
Hertzmann提供[132]。）观察者可以移动并且仍然保持轮廓边缘 
保持其状态。在任何实体模型中，每个单独的轮廓总是由单个闭合 
曲线组成，称为轮廓循环，或者更恰当地，轮廓循环。对于对象边 
界内的轮廓，循环的某些部分可能会被遮挡。即使是实际的轮廓也 
可能由几个环组成，其中部分环在轮廓内或被其他表面隐藏。因此， 
每个顶点必须具有偶数个轮廓边[23]。见图15.18。注意当跟随网格 
边缘时，循环通常在三维中非常锯齿状，z深度明显变化。如果需 
要形成更平滑曲线的边缘，例如通过距离改变厚度[565]，可以进行 
额外的处理以在三角形法线中进行插值以逼近三角形内的真实轮廓 
----------------------- Page 709-----------------------
边缘[725,726]。逐帧跟踪循环位置比从头重建循环更快。 
Markosian等。[1125]以一组循环开始并使用随机搜索算法在相机 
移动时更新该组。当模型改变方向时，也会创建和销毁轮廓循环。 
Kalnins等。[848]注意，当两个循环合并时，需要采取纠正措施或 
者可以看到从一帧到下一帧的明显跳跃。他们使用像素搜索和 “投 
票”算法来尝试逐帧保持轮廓相干性。这些技术可以带来严重的性 
能提升，但可能不准确。线性方法确切但价格昂贵。使用相机访问 
轮廓边缘的分层方法结合了速度和精度。对于非动画模型的正交视 
图，Gooch等。[562]使用高斯映射的层次结构来确定轮廓边缘。 
桑德等人。[1539]使用正常锥体的 n-ary树（第 19.3节）。 
Hertzmann和Zorin [726]使用模型的双空间表示，允许它们在模 
型的边缘上施加层次结构。66815.非真实感渲染所有这些显式边缘 
检测方法都是CPU密集型的，并且具有较差的高速缓存一致性，因 
为形成轮廓的边缘分散在整个边缘列表中。为了避免这些成本，顶 
点着色器可用于检测和渲染轮廓边[226]。我们的想法是将模型的每 
个边缘沿着管道发送，因为两个三角形形成退化的四边形，两个相 
邻的三角形法线连接到每个顶点。当发现边缘是轮廓的一部分时， 
移动四边形的点，使其不再退化（即，使其可见）。然后绘制这个 
薄的四边形翅片。该技术基于与为阴影体积创建找到轮廓边所描述 
的相同的思想（第7.3节）。如果几何着色器是管道的一部分，则 
不需要存储这些额外的鳍四边形，但可以在运行中生成[282,299]。 
一个天真的实现将在鳍片之间留下缝隙和间隙，这可以通过修改鳍 
----------------------- Page 710-----------------------
片的形状来校正[723,1169,1492]。15.2.5隐藏线移除一旦找到轮 
廓，就会渲染线条。明确找到边缘的一个优点是，您可以将这些样 
式化为笔划，绘画笔划或您想要的任何其他媒介。笔画可以是基本 
线条，纹理冒名顶替者 （第 13.6.4节），一组原语，或者你想尝试 
的任何其他东西。尝试使用几何边缘的另一个复杂因素是并非所有 
这些边缘实际上都是可见的。渲染曲面以建立z缓冲区可以掩盖隐 
藏的几何边缘，这对于诸如虚线的简单样式可能已足够。Cole和 
Finkelstein[282]通过沿着线本身的脊柱采样z深度来对表示线的 
四边形进行扩展。但是，使用这些方法，沿线的每个点都是独立渲 
染的，因此事先不知道明确定义的起点和终点位置。对于轮廓线或 
其他边缘，其中线段用于定义画笔笔划或其他连续对象，我们需要 
知道每个笔划何时首次出现以及何时消失。确定每个线段的可见性 
称为隐藏线渲染，其中处理一组线段以进行可见性，并返回较小的 
一组 （可能已剪切的）线段。Northrup和 Markosian[1287]通过 
渲染所有对象的三角形和轮廓边以及为每个对象分配不同的标识号 
来解决此问题。读回该ID缓冲区，并从中确定可见的轮廓边缘。然 
后检查这些可见区段的重叠并链接在一起以形成平滑的笔划路径。 
如果屏幕上的线段很短，则此方法有效，但不包括线段本身的剪切。 
然后沿着这些重建的路径渲染程式化的笔划。笔画本身可以通过多 
种不同的方式进行风格化，包括锥形，眩光，摆动，过冲和褪色， 
以及深度和距离提示。一个例子如图 15.19 所示。Cole 和 
Finkelstein[282]提出了一组边缘的可见度计算方法。它们将每个 
----------------------- Page 711-----------------------
线段存储为两个世界空间坐标值。一系列通道在整个段组上运行像 
素着色器，剪切并确定长度 15.3。笔划表面样式669图15.19。使 
用 Northrup和 Markosian的混合技术生成的图像。找到轮廓边， 
将其构建为链，并将其渲染为笔触。（图片由LeeMarkosian提供。） 
以每个像素为单位，然后为每个潜在像素位置创建一个图集并确定 
可见度，然后使用此图集创建可见笔画。虽然复杂，该过程在GPU 
上相对较快，并提供具有已知开始和结束位置的可见笔划集。程式 
化通常包括将一个或多个预制纹理应用于线四边形。Rougier[1516] 
讨论了一种不同的方法，在程序上呈现虚线模式。每个线段访问存 
储所需的所有虚线图案的纹理。每个模式都被编码为一组命令，指 
定虚线模式以及使用的端盖和连接类型。使用四边形的纹理坐标， 
每个模式控制着色器进行的一系列测试，以确定线条覆盖四边形中 
每个点的像素的多少。确定轮廓边缘，将它们链接到相干链，然后 
确定每条链的可见性以形成笔划很难完全并行化。在产生高质量线 
条样式时的另一个问题是，对于下一帧，将再次绘制每个笔划，改 
变长度或可能第一次出现。B'enard等人。[130]提出了一种渲染方 
法的调查，该方法为沿着边缘和表面上的图案的笔划提供时间相干 
性。这不是一个已解决的问题，可能涉及计算，因此研究仍在继续 
[131]。15.3笔划表面样式虽然卡通渲染是一种尝试模拟的流行样 
式，但是有很多种其他样式可以应用于表面。效果的范围可以从修 
改现实67015.非真实感渲染图15.20。通过使用纹理调色板，纸张 
纹理和轮廓边缘渲染生成的图像。经（Adam Lake和CarlMarshall 
----------------------- Page 712-----------------------
许可转载，英特尔公司版权所有英特尔公司 2002.）texture 
[905,969,973]使算法在程序上逐帧生成几何装饰[853,1126]。在本 
节中，我们将简要介绍与实时渲染相关的技术。Lakeetal。[966] 
讨论使用漫反射着色项来选择在表面上使用哪种纹理。随着漫反射 
项变暗，使用具有较暗印象的纹理。使用屏幕空间坐标应用纹理以 
提供手绘外观。为了进一步增强草图的外观，纸张纹理也应用于屏 
幕空间中的所有表面。见图 15.20。这种类型的算法的主要问题是 
淋浴门效果，其中物体看起来像在动画期间通过图案化玻璃观察。 
物体感觉好像在穿过纹理游动。Breslav等人。通过确定什么图像变 
换最佳匹配一些基础模型位置的移动来维持纹理的二维外观。这可 
以保持与填充图案的基于屏幕的性质的连接，同时提供与对象的更 
强连接。一个解决方案显而易见：将纹理直接应用于曲面。挑战在 
于基于笔划的纹理需要保持相对均匀的笔划厚度和密度以使其看起 
来令人信服。如果纹理被放大，笔划看起来太厚;如果它被缩小，则 
笔划要么模糊不清，要么很薄且有噪音（取决于是否使用了 
mipmapping）。普劳等人。[1442]提出了一种生成笔画纹理 
mipmap并以平滑方式将其应用于表面的实时方法。这样做可以将 
屏幕上的笔划密度保持为对象的距离 15.3。中风表面样式671图 
15.21。色调艺术地图 （TAM）。笔划被绘制到mipmap级别。每 
个mipmap级别包含纹理到左侧和上方的所有笔划。这样，mip级 
别和相邻纹理之间的插值是平滑的。 （图片由普林斯顿大学的Emil 
Praun提供。）改变。第一步是形成要使用的纹理，称为色调艺术 
----------------------- Page 713-----------------------
地图 （TAM）。这是通过将笔划绘制到mipmap级别来完成的。见 
图15.21。Klein等人。[905]在他们的 “艺术地图”中使用相关的 
想法来维持NPR纹理的笔划大小。有了这些纹理，通过在每个顶点 
所需的音调之间进行插值来渲染模型。该技术产生具有手绘感觉的 
图像[1441]。见图15.22。Webb等。[1858]呈现对TAM的两个扩 
展，其给出更好的结果，一个使用体积纹理，其允许使用颜色，另 
一个使用阈值方案，其改善抗锯齿。Nuebel[1291]给出了一种执 
行木炭渲染的相关方法。他使用的噪声纹理也沿着图 15.22从暗到 
亮。使用色调艺术地图（TAM）渲染的两个模型。样本显示用于渲 
染每个样本的重叠纹理图案。 （图片由普林斯顿大学EmilPraun提 
供。）67215.非真实感渲染图15.23。两种不同的移植风格呈现斯 
坦福兔子。（图片由 BruceGooch和 MattKaplan提供，犹他大 
学。）一轴。强度值沿此轴访问纹理。李等人。[1009]使用TAM和 
其他技术来生成由铅笔绘制的令人印象深刻的图像。关于击球，许 
多其他操作可能比已经讨论的那些操作。为了给出草图效果，边缘 
可能会抖动[317,972,1009]或者可能会超出其原始位置，如图 15.1 
 （第651页）中的右上和中下图像所示.Girshick等。[538]讨论沿 
着表面上的主曲线方向线的渲染笔划。也就是说，从表面上的任何 
给定点，存在指向最大曲率方向的第一主方向切向量。第二主方向 
是垂直于该第一矢量的切向量，并给出表面最小弯曲的方向。这些 
方向线在弯曲表面的感知中是重要的。它们还具有仅需要为静态模 
型生成一次的优点，因为这样的笔划与照明和阴影无关。 
----------------------- Page 714-----------------------
Hertzmann和Zorin [726]讨论了如何清理和平滑主要方向。大量 
的研究和开发已经探索了使用这些方向和其他数据将纹理应用于任 
意表面，驱动模拟动画以及其他应用。参见Vaxman等人的报告。 
[1814]作为起点。移植物的想法[372,853，1126]是可以根据需要 
将几何形状或贴花纹理添加到表面以产生特定效果。它们可以通过 
所需的细节水平，表面的眼睛方向或其他因素来控制。这些也可用 
于模拟笔或笔刷笔触。一个例子如图 15.23所示。几何嫁接是程序 
建模的一种形式[407]。15.4。第673行本章几乎没有涉及 NPR研 
究所采取的一些方向。请参阅最后的 “进一步阅读和资源”部分， 
了解更多信息。在这个领域，我们可以使用很少或没有潜在的物理 
正确答案作为基本事实。这既有问题也有解放。技术在速度和质量 
以及实施成本之间进行权衡。在交互式渲染率的紧迫时间限制下， 
大多数方案在某些条件下会弯曲和折断。确定在您的应用程序中运 
行良好或足够好的是什么使得该领域成为一项令人着迷的挑战。我 
们的重点主要集中在特定主题，轮廓边缘检测和渲染。最后，我们 
将把注意力转向线条和文字。这两个非现实主义原语经常被使用并 
且有自己的一些挑战，因此值得单独报道。15.4线条简单实心 “硬” 
线的渲染通常被认为是相对无趣的。但是，它们在CAD等领域中非 
常重要，可用于查看基础模型构面和识别对象的形状。它们还可用 
于突出显示所选对象以及技术插图等区域。此外，所涉及的一些技 
术适用于其他问题。15.4.1三角形边缘渲染正确渲染填充三角形顶 
部的边缘比首次出现时更难。如果一条线与三角形的位置完全相同， 
----------------------- Page 715-----------------------
我们如何确保线总是在前面渲染？一个简单的解决方案是使所有线 
都具有固定的偏差[724]。也就是说，每条线的渲染程度都应该比实 
际线条更接近，因此它将位于曲面之上。如果固定偏差太大，则应 
显示隐藏的部分边缘，从而破坏效果。如果偏差太小，几乎边缘的 
三角形表面可能会隐藏部分或全部边缘。如第 15.2.2节所述，诸如 
OpenGL的glPolygonOffset之类的API调用可用于根据线的斜率 
向后移动线下方的曲面。这种方法工作得相当好，但并不完美。 
Herrell等人的计划。[724]完全避免偏见。它使用一系列步骤来标 
记和清除模板缓冲区，以便正确地在三角形顶部绘制边。除了最小 
的三角形组之外，这种方法是不切实际的，因为每个三角形必须单 
独绘制，并且模板缓冲区为每个三角形清除，这使得该过程非常耗 
时。B.rentzen等。[86,1295]提出了一种很好地映射到GPU的方 
法。他们使用像素着色器，使用三角形的重心坐标来确定到最近边 
缘的距离。如果像素靠近边缘，则使用边缘颜色绘制。边缘厚度可 
以是任何所需的值，并且可能受到距离的影响或674 15.非真实感 
渲染图 15.24。像素着色器生成的线条。左边是抗锯齿的单像素宽 
度边缘; 右边是可变粗细线，带有晕圈。（图片由 J. Andreas 
B.rentzen提供。）保持不变。见图 15.24。主要缺点是轮廓边缘的 
绘制厚度是内部线条的一半，因为每个三角形绘制每条线的厚度的 
一半。在实践中，这种不匹配通常是不明显的。Celes和Abraham 
[242]对这个想法进行了扩展和简化，他们也对以前的工作进行了全 
面的总结。他们的想法是为每个三角形边使用一维纹理坐标，对于 
----------------------- Page 716-----------------------
定义边的两个顶点使用 1.0，为另一个顶点使用0.0。他们利用纹理 
映射和mip链来提供恒定宽度的边缘。这种方法易于编码并提供一 
些有用的控件。例如，可以设置最大密度，使得密集网格不会完全 
被边缘填充，因此变成纯色。15.4.2渲染模糊线在常规线框图中， 
未绘制任何曲面，模型的所有边都可见。为了避免绘制由曲面隐藏 
的线条，将所有填充的三角形绘制到z缓冲区中，然后正常绘制边 
线[1192]。如果在绘制所有线之前无法绘制所有曲面，则稍微昂贵 
的解决方案是使用与背景匹配的纯色绘制曲面。线也可以绘制为部 
分遮挡而不是完全隐藏。例如，隐藏线可以以浅灰色显示，而不是 
根本不绘制。这可以通过适当设置z缓冲区的状态来完成。像以前 
一样绘制，然后反转z缓冲区的意义，这样只能绘制超出当前像素 
z深度的线条。同时关闭z缓冲区修改，以使这些绘制的线不会更 
改任何深度值。以模糊的样式再次绘制线条。只有15.5的线条。文 
本渲染675图15.25。四线渲染风格。从左到右：线框，隐藏线， 
模糊线和晕线。然后被隐藏起来。对于线条的程式化版本，可以使 
用完整的隐藏线移除过程[282]。15.4.3Haloing当两条线交叉时， 
一个常见的约定是擦除较远线的一部分，使得排序明显。这可以通 
过两次绘制每一行相对容易地完成，一次用晕[1192]。此方法通过 
在背景颜色中绘制重叠来擦除重叠。首先，将所有行绘制到z缓冲 
区，将每条线表示为代表光环的厚四边形。几何着色器可以帮助创 
建这样的四边形。然后，通常以彩色绘制每一行。由z缓冲区绘制 
遮盖的区域将隐藏在它们后面绘制的线条。必须使用偏置或其他方 
----------------------- Page 717-----------------------
法来确保每条细黑线位于厚z缓冲四边形的顶部。在顶点处会合的 
线可以被竞争的光晕部分隐藏。缩短创建光环的四边形可能有所帮 
助，但可能导致其他伪影。B.rentzen等人的线条渲染技术。[86,1295] 
也可用于晕圈。见图 15.24。每个三角形都会产生光晕，因此没有 
干扰问题。另一种方法是使用图像后处理 （第 15.2.3节）来检测和 
绘制光晕。图 15。图25示出了这里讨论的一些不同线渲染方法的 
结果。15.5文本渲染考虑到阅读文本对文明的重要性，不足为奇的 
是，人们已经很好地关注阅读文本。与许多其他对象不同，单个像 
素更改可以产生显着差异，例如将 “l”变为 “1”。本节总结了用 
于文本呈现的主要算法方法。眼睛对强度的差异比对颜色的差异更 
敏感。至少从AppleII[527]的日子开始，这个事实被用来改善感知 
的空间分辨率。这个想法的一个应用是微软的ClearType技术，676 
15.非真实感渲染图 15.26。相同单词的放大灰度抗锯齿和亚像素抗 
锯齿版本。当彩色像素显示在LCD屏幕上时，构成像素的相应彩色 
垂直子像素矩形被点亮。这样做可提供额外的水平空间分辨率 （由 
SteveGibson的 “Free＆Clear”程序生成的图像。）基于液晶显 
示器（LCD）显示器的一个特征。LCD显示器上的每个像素由三个 
垂直彩色矩形组成，红色，绿色和蓝色 - 在 LCD显示器上使用放 
大镜，亲眼看看。忽略这些子像素矩形的颜色，这种配置提供的水 
平分辨率是像素的三倍。使用不同的阴影填充不同的子像素，因此 
这种技术有时称为子像素渲染。眼睛将这些颜色混合在一起，而红 
色和蓝色的条纹变得无法察觉。见图15.26。这项技术于 1998年首 
----------------------- Page 718-----------------------
次发布，对大型低 DPI液晶显示器有很大帮助。Microsoft停止在 
Word2013中使用ClearType，显然是因为将文本与不同背景颜色 
混合出现问题。Excel使用该技术，以及各种Web浏览器，Adobe 
的CoolType，Apple的Quartz2D以及FreeType和SubLCD等 
库。Shemanarev [1618]的一篇陈旧但完整的文章涵盖了这种方法 
的各种细微之处和问题。这种技术是一个纯粹的例子，说明了在清 
晰地渲染文本上花了多少精力。字体中的字符（称为字形）通常由 
一系列线段和二次或三次 B'ezier曲线描述。有关示例，请参见第 
726页的图 17.9。所有字体渲染系统都可以确定字形如何影响它重 
叠的像素。FreeType和Anti-Grain Geometry等库通过为每个字 
形生成一个小纹理并根据需要重用它们来工作。为每种字体大小和 
重点制作不同的纹理，即斜体或粗体。这些系统假设每个纹理都是 
像素对齐的，每个像素一个纹素，就像通常用于文档一样。当文本 
应用于三维表面时，这些假设可能不再成立。使用带有一组字形的 
纹理是一种简单而流行的方法，但存在一些潜在的缺点。应用程序 
仍然可以将文本对齐以面向观看者，但缩放和旋转将打破每个像素 
的单个纹素的假设。即使屏幕对齐，也可能不考虑字体提示。提示 
是调整字形轮廓以与像素单元匹配的过程。例如，作为纹理像素宽 
的 “I”的垂直主干最佳地呈现为覆盖单个像素列而不是覆盖两个相 
邻列的半覆盖。见图 15.27。所有这些因素都意味着栅格纹理可以 
显示模糊或锯齿问题。Rougier[1515]全面介绍了纹理生成算法所 
涉及的问题，并展示了如何在基于OpenGL的字形渲染系统中使用 
----------------------- Page 719-----------------------
FreeType的提示。Pathfinder库[1834]是最近使用GPU生成字形 
的努力。它具有较低的设置时间和最少的内存使用，并且优于竞争 
15.5。文本渲染677图15.27。Verdana字体呈现未着色（顶部） 
和暗示（底部）。（图片由 NicolasRougier提供[1515]。）基于 
CPU的引擎。它使用曲面细分和计算着色器生成并总结曲线对每个 
像素的影响，并在功能较少的GPU上回退几何着色器和OpenCL。 
与 FreeType一样，这些字形被缓存并重用。它的高质量抗锯齿与 
高密度显示器的使用相结合，使暗示几乎过时。将文本应用于不同 
大小和方向的任意表面可以在没有精心的GPU支持的情况下完成， 
同时仍然提供合理的抗锯齿。Green[580]提出了这样一种系统，首 
先由Valve在Team Fortress2中使用。该算法使用Frisken等人 
引入的采样距离场数据结构。[495]。每个纹素都保持与字形最近边 
缘的符号距​ ​ 离。距离字段尝试编码纹理描述中每个字形的精确 
边界。然后，双线性插值给出了每个样本处字母的α覆盖率的良好近 
似值。有关示例，请参见图 15.28。通过双线性插值可以使锐角变 
得平滑，但是可以通过在四个单独的通道中编码更多距离值来保留 
锐角[263]。这种方法的局限性在于这些符号距离纹理的创建非常耗 
时，因此需要对它们进行预先计算和存储。尽管如此，一些字体渲 
染库基于这种技术[1440]，并且它很好地适应移动设备[3]。 
Reshetov和 Luebke[1485]总结了沿着这些线的工作并基于在放 
大期间调整样本的纹理坐标来给出它们自己的方案。即使没有缩放 
和旋转问题，使用中文字符的语言也是如此，例如，可能需要数千 
----------------------- Page 720-----------------------
或更多的字形。高质量的大字符需要更大的纹理。如果以一定角度 
观看字形，则可能需要对纹理进行各向异性过滤。渲染字形直接从 
其边缘和曲线描述将避免需要任意大的纹理并避免来自采样网格的 
伪像。Loop-Blinn方法[1068,1069]使用像素着色器直接评估 
B'ezier曲线，并在第 17.1.2节中讨论。该技术需要曲面细分步骤， 
这在加载时完成时可能很昂贵。Dobbie[360]通过为每个角色的边 
界框绘制一个矩形并在一次传递中评估所有的字形轮廓来避免这个 
问题。Lengyel[1028]提出了一个稳健的评估器，用于确定一个点 
是否在一个字形内，这对于避免伪像至关重要，并讨论评估优化和 
效果，如发光，阴影和多种颜色 （例如，用于表情符号）。67815. 
非真实感渲染图 15.28。矢量纹理。在左边，在距离场表示[3]中显 
示的字母 “g”。在右侧， “禁止侵入”标志从距离场渲染。通过将 
特定距离范围映射到轮廓颜色来添加文本周围的轮廓[580]。 （图片 
来自ARM有限公司左图）来自 “军团要塞2”的图片，由Valve 
公司提供。）进一步阅读和资源关于非真实感和香椿渲染的灵感， 
阅读Scott McCloud的理解漫画[1157]。从研究人员的角度来看， 
请参阅赫兹曼关于使用 NPR技术帮助建立关于艺术和插图的科学 
理论的文章[728]。尽管是在固定功能硬件时代编写的，但使用 
OpenGL [1192]的高级图形编程一书，有关各种技术插图和科学可 
视化技术的有价值的章节。虽然也有些过时，但Gooches [563]和 
Strothotte [1719]的书籍都是NPR算法的良好起点。Isenberg等 
人提供了轮廓边缘和笔划渲染技术的调查。[799]和赫兹曼[727]。 
----------------------- Page 721-----------------------
Rusinkiewicz等人在SIGGRAPH2008课程上的讲座。[1521]还详 
细检查了笔画渲染，包括更新的工作，以及B'enard等。[130]调查 
帧到帧一致性算法。对于艺术图像处理效果，我们将感兴趣的读者 
引用到Kyprianidis等人的概述中。[949]。非真实感动画和渲染国 
际研讨会（NPAR）的会议重点是该领域的研究。米切尔等人。[1223] 
提供了一个案例研究，探讨工程师和艺术家如何合作为游戏Team 
Fortress2提供独特的图形风格.Shodhan和Willmott [1632]讨论 
了游戏Spore中的后处理系统，并包括用于油画的像素着色器，老 
电影等效果。SIGGRAPH2010课程 “游戏中的程式化渲染”是实 
际例子的另一个有价值的来源。特别是，Thibault和Cavanaugh 
[1761]展示了艺术的发展 15.5。文本为Borderlands渲染679风 
格，并描述了沿途的技术挑战。埃文斯的演讲[446]是对各种渲染和 
建模技术的迷人探索，以实现特定的媒体风格。Pranckevicius 
[1440]提供了加速文本呈现技术的调查，其中填充了资源链接。第 
16章多边形技术 “三角形如此简单，如此简单，取之不尽，用之不 
竭，真的很精彩。” -LeopoldCrelle到目前为止，我们假设我们 
渲染的模型完全按照我们需要的格式提供，并且只是适量的细节。 
实际上，我们很少这么幸运。建模者和数据捕获设备有其特定的怪 
癖和限制，导致数据集内的模糊和错误，因此在渲染中也是如此。 
通常需要在存储大小，渲染效率和结果质量之间进行权衡。在本章 
中，我们将讨论多边形数据集中遇到的各种问题，以及这些问题的 
一些修复和解决方法。然后，我们介绍了有效渲染和存储多边形模 
----------------------- Page 722-----------------------
型的技术。交互式计算机图形中多边形表示的总体目标是视觉准确 
性和速度。 “准确性”是一个取决于背景的术语。例如，工程师希 
望以交互速率检查和修改机器零件，并要求每个时刻都可以看到对 
象上的每个斜角和倒角。将其与游戏进行比较，如果帧速率足够高， 
则允许给定帧中的微小错误或不准确，因为它们可能不会出现在注 
意力集中的地方，或者可能在下一帧中消失。在交互式图形工作中， 
重要的是要知道要解决的问题的边界是什么，因为这些决定了可以 
应用哪种技术。本章介绍的区域包括细分，合并，优化，简化和压 
缩。多边形可以以多种不同的形式到达，并且通常必须分成更易处 
理的基元，例如三角形或四边形。这个过程称为三角测量，或者更 
一般地说是曲面细分.1合并是我们的过程，包括将单独的多边形合 
并到网格结构中，以及为表面着色导出新数据，例如法线。优化意 
味着在网格中对多边形数据进行排序，以便更快地渲染。简化就是 
采用网格并删除其中无关紧要的特征。Com-1 “曲面细分”，加倍， 
可能是计算机图形学中最常拼写错误的单词，其中 “平截头体”紧 
随其后。68168216.多边形技术压力涉及最小化描述网格的各种元 
素所需的存储空间。三角测量可确保正确显示给定的网格描述。通 
过允许共享计算并减小内存大小，合并进一步改善了数据显示并且 
通常提高了速度。优化技术可以进一步提高速度。通过删除不需要 
的三角形，简化可以提供更快的速度。压缩可用于进一步减少总体 
内存占用，从而通过减少内存和总线带宽来提高速度。16.1三维数 
据的来源有多种方法可以创建或生成多边形模型：。直接输入几何 
----------------------- Page 723-----------------------
描述。。编写创建此类数据的程序。这称为程序建模。。将以其他 
形式发现的数据转换为表面或体积，例如，获取蛋白质数据并将其 
转换为一组球体和圆柱体。。使用建模程序来构建或雕刻对象。。 
从同一物体的一张或多张照片重建表面，称为摄影测量。。使用三 
维扫描仪，数字转换器或其他传感设备在各个点采样真实模型。。 
生成在某些空间体积中表示相同值的等值面，例如来自CAT或 MRI 
医学扫描的数据，或在大气中测量的压力或温度样本。。使用这些 
技术的某种组合。在建模领域，有两种主要类型的建模器：基于实 
体和基于表面。基于实体的建模器通常出现在计算机辅助设计 
 （CAD）领域，并且通常强调与实际加工过程相对应的建模工具， 
例如切割，钻孔和刨削。在内部，他们将拥有一个计算引擎，可以 
严格操纵对象的底层拓扑边界。对于显示和分析，这样的建模者具 
有特征。faceter是将内部模型表示转换为可以显示的三角形的软 
件。例如，球体可以通过中心点和半径在数据库中表示，并且面部 
可以将其转变为任意数量的三角形或四边形以便表示它。有时候最 
好的渲染加速是最简单的：降低使用整形器时所需的视觉精度可以 
通过生成更少的三角形来提高速度并节省存储空间。16.2。曲面细 
分和三角剖分683CAD工作中的一个重要考虑因素是所使用的面 
板是否设计用于图形渲染。例如，存在用于有限元方法（FEM）的 
面，其旨在将表面分成几乎相等面积的三角形。这种细分是简化的 
有力候选者，因为它们包含许多图形无用的数据。类似地，一些面 
孔生成的三角形组合对于使用3D打印创建真实世界对象是理想的， 
----------------------- Page 724-----------------------
但是缺少顶点法线并且通常不适合快速图形显示。像 Blender或 
Maya这样的建模者并不是基于内在的可靠性概念。相反，对象由 
其表面定义。像固体建模者一样这些基于表面的系统可以使用内部 
表示和面板来显示诸如样条曲线或细分曲面之类的对象 （第 17章）。 
它们还可以允许直接操纵曲面，例如添加或删除三角形或顶点。然 
后，用户可以手动降低模型的三角形数量。还有其他类型的建模器， 
例如隐式曲面（包括 “blobby”元球）创建系统[67,558]，它们与 
混合，权重和字段等概念一起使用。这些建模者可以通过生成由某 
个函数f （x，y，z）=0的解决方案定义的表面来创建有机形式。 
然后使用多边形化技术（例如行进立方体）来创建用于显示的三角 
形集 （第 17.3节）。点云是简化技术的有力候选者。通常以规则的 
间隔对数据进行采样，因此许多样本对所形成的表面的视觉感知具 
有可忽略的影响。研究人员花费了数十年的时间研究过滤缺陷数据 
和从点云重建网格的技术[137]。有关该区域的更多信息，请参见第 
13.9节。可以对从扫描数据生成的网格执行任意数量的清理或更高 
阶操作。例如，分割技术分析多边形模型并尝试识别单独的部分 
[1612]。这样做有助于创建动画，应用纹理贴图，匹配形状和其他 
操作。还有许多其他方法可以为表面表示生成多边形数据。关键是 
要了解数据是如何创建的，以及用于何种目的。经常，数据不是专 
门为有效的图形显示而生成的。此外，存在许多不同的三维数据文 
件格式，并且任何两者之间的转换通常不是无损操作。了解传入数 
据可能遇到的各种限制和问题是本章的主题。16.2曲面细分和三角 
----------------------- Page 725-----------------------
剖分曲面细分是将曲面分割为一组多边形的过程。在这里，我们专 
注于镶嵌多边形曲面;第 17.6节讨论了曲面曲面细分。可以出于多 
种原因进行多边形镶嵌。最常见的是684 16.多边形技术图 16.1。 
各种类型的镶嵌。最左边的多边形没有镶嵌细分，下一个被划分为 
凸面区域，下一个是三角形的，并且最右边是均匀网格。所有图形 
API和硬件都针对三角形进行了优化。三角形几乎就像原子一样， 
任何表面都可以由它们制成并呈现。将复杂多边形转换为三角形称 
为三角剖分。镶嵌多边形时有几个可能的目标。例如，要使用的算 
法可以仅处理凸多边形。这种细分被称为凸分区。可能需要对表面 
进行细分（网格化）以使用全局照明技术在每个顶点处存储阴影或 
互反射的效果[400]。图16.1显示了这些不同类型的曲面细分的示 
例。曲面细分的非图形原因包括诸如没有三角形大于某个给定区域 
的要求，或者三角形在其顶点处的角度都大于某个最小角度。 
Delaunay三角剖分要求由每个三角形的顶点形成的每个圆不包含 
任何剩余的顶点，这使最小角度最大化。虽然这些限制通常是非图 
形应用的一部分，例如有限元分析，但这些也可用于改善表面的外 
观。长而细的三角形通常值得避免，因为它们在远距离顶点上插值 
时会导致伪影。它们对光栅化效率也很低[530]。大多数细分算法都 
在两个维度上工作。他们假设多边形中的所有点都在同一平面上。 
但是，某些模型创建系统可以生成严重扭曲和非平面的多边形面。 
这个问题的一个常见情况是翘曲的四边形，几乎是边缘的;这可能形 
成所谓的沙漏或领结四边形。见图 16.2。虽然可以通过创建对角线 
----------------------- Page 726-----------------------
边缘来对这个特定多边形进行三角剖分，但是更复杂的扭曲多边形 
不能如此容易地管理。图16.2。翘曲的四边形被观察到边缘，形成 
一个不明确的领结或沙漏形象，以及两个可能的三角形。16.2。曲 
面细分和三角剖分685图16.3。耳夹。显示在v2，v4和v5处具 
有潜在耳朵的多边形。在右侧，移除v4处的耳朵。重新检查相邻顶 
点v3和v5以查看它们现在是否形成耳朵;v5。当有翘曲​ ​ 的多 
边形时，一个快速纠正措施是将顶点投影到垂直于多边形近似法线 
的平面上。通常通过计算三个正交xy，xz和yz平面上的投影面积 
来找到该平面的法线。也就是说，通过丢弃x坐标找到的yz平面上 
的多边形区域是x分量的值，xz是y，xy是z。这种计算平均法线 
的方法称为Newell公式[1505,1738]。投射到该平面上的多边形可 
能仍然具有自相交问题，其中两个或更多个边交叉。然后需要更精 
细和计算上昂贵的方法。邹等人。[1978]基于最小化所得曲面细分 
的表面积或二面角来讨论以前的工作，并且提出了用于在一组中优 
化一些非平面多边形的算法。Schneider和 Eberly [1574]，Held 
[714]，O'Rourke [1339]和de Berg等人。[135]每个都概述了各 
种三角测量方法。最基本的三角测量算法是检查多边形上任意两个 
给定点之间的每个线段，并查看它是否与多边形的任何边相交或重 
叠。如果是，则线段不能用于分割多边形，因此我们检查下一对可 
能的点。否则，使用此段将多边形拆分为两个部分，并使用相同的 
方法对这些新多边形进行三角测量。在O （n3）时，这种方法非常 
慢。一种更有效的方法是耳剪切，当作为两个进程完成时是O（n2）。 
----------------------- Page 727-----------------------
首先，在多边形上进行传递以找到耳朵，即查看具有顶点索引i， 
 （i+1）， （i+2） （模n）的所有三角形，并检查线段i，（i+2） 
是否与任何多边形边相交。如果没有，则三角形 （i+1）形成耳朵。 
见图16.3。依次从多边形中移除每个可用的耳朵，并且重新检查顶 
点i和（i +2）处的三角形以查看它们现在是否是耳朵。最终移除 
所有耳朵并对多边形进行三角测量。其他更复杂的三角测量方法是 
O （nlogn），对于典型情况，一些实际上是O （n）。Schneider 
和 Eberly [1574]给出了用于耳夹和其他更快的三角测量方法的伪 
代码。在存储和进一步的计算成本方面，将多边形划分为凸区域可 
以更有效，而不是三角测量。强健凸度的代码68616。多边形技术 
图16.4。具有三个轮廓的多边形转换为单轮廓多边形。连接边以红 
色显示。多边形内的蓝色箭头显示了访问顶点以生成单个循环的顺 
序。测试由Schorn和 Fisher[1576]给出。凸面多边形可以很容易 
地用扇形或三角形条表示，如第 16.4节中所述。一些凹多边形可以 
被视为扇形（这种多边形被称为星形），但检测这些多边形需要更 
多的工作[1339,1444]。Schneider和 Eberly[1574]给出了两种凸 
分区方法，一种快速而肮脏的方法和一种最佳方法。多边形并不总 
是由单个轮廓组成。图16.4显示了由三个轮廓组成的多边形，也称 
为循环或轮廓。通过在循环之间仔细生成连接边（也称为键孔边或 
桥边），可以始终将这种描述转换为单边形多边形。Eberly[403] 
讨论了如何找到定义这些边的相互可见的顶点。也可以反转此转换 
过程以检索单独的循环。编写一个强大而通用的三角函数是一项艰 
----------------------- Page 728-----------------------
巨的任务。各种微妙的错误，病态案例和精确问题使得简单易懂的 
代码难以创建。精确三角测量问题的一种方法是使用图形加速器本 
身直接渲染复杂的多边形。多边形呈现​ ​ 为模板缓冲区的三角形 
扇形。通过这样做，应该填充的区域被绘制奇数次，凹陷和孔被绘 
制为偶数。通过使用模板缓冲器的反转模式，在第一次通过结束时 
仅标记填充区域。见图 16.5。在第二遍中，再次渲染三角形扇形， 
使用模板缓冲区仅允许绘制填充区域。通过绘制每个循环形成的三 
角形，此方法甚至可用于渲染具有多个轮廓的多边形。主要的缺点 
是每个多边形必须使用两次传递来渲染，并且模板缓冲区清除每一 
帧，并且深度缓冲区不能直接使用。该技术可用于显示一些用户交 
互，例如显示动态绘制的复杂选择区域的内部。16.2.1着色问题有 
时数据将作为四边形网格到达，必须转换为三角形才能显示。很久 
以后，四边形将是凹的，在这种情况下，只有一种方法来对其进行 
三角测量。否则，我们可以选择两个 16.2中的任何一个。曲面细分 
和三角测量687AB 0 1234图16.5。通过光栅化进行三角测量， 
使用奇数/偶数奇偶校验可见的区域。左边的多边形被绘制到模板缓 
冲区中，作为来自顶点0的三个三角形的扇形。第一个三角形[0,1,2] 
 （左中）填充其区域，包括多边形外部的空间。三角形[0,2,3] （中 
间右侧）填充其区域，将区域A和 B的奇偶校验更改为偶数个绘制， 
从而使它们为空。三角形[0,3,4] （右）填充多边形的其余部分。对 
角线分开它。花一点时间选择更好的对角线有时可以提供明显更好 
的视觉效果。有几种不同的方法可以决定如何拆分四边形。关键思 
----------------------- Page 729-----------------------
想是尽量减少新边缘顶点的差异。对于在顶点没有附加数据的扁平 
四边形，通常最好选择最短的对角线。对于每个顶点具有颜色的简 
单烘焙全局照明解决方案，请选择颜色之间差异较小的对角线[17]。 
见图16.6。通过某种启发式确定的连接两个最不同角落的想法通常 
可用于最小化伪像。有时三角形无法正确捕捉设计师的意图。如果 
纹理应用于扭曲的四边形，则对角线分割都不会保留意图。也就是 
说，非三角四边形上的简单水平插值，即从左边缘到右边缘插值也 
是失败的。图16.7显示了该问题。出现这个问题是因为施加到表面 
的图像在显示时会翘曲。三角形只有三个纹理坐标，所以它可以如 
图16.6所示。左图呈现为四边形; 中间是两个三角形，右上角和左 
下角相连;右边显示了使用另一条对角线时会发生什么。中间人物的 
视觉效果要好于正确人物。688 16.多边形技术图 16.7。左上角显 
示了设计者的意图，一个扭曲的四边形，带有 “R”的方形纹理贴图。 
右边的两个图像显示了两个三角测量以及它们的区别。底行旋转所 
有多边形;非三角四边形改变了它的外观。建立仿射变换，但不是变 
形。最多，三角形上的基本（u，v）纹理可以剪切，而不是扭曲。 
Woo等人。[1901]进一步讨论这个问题。有几种解决方案可行：。 
提前扭曲纹理并使用新纹理坐标重新应用此新图像。。将曲面细分 
为更细的网格。这只会减轻问题。。使用投影纹理在运行中扭曲纹 
理[691,1470]。这具有纹理在表面上的不均匀间隔的不良影响。。 
使用双线性映射方案[691]。这可以通过每个顶点的附加数据来实 
现。虽然纹理失真听起来像病态情况，但是在任何时候施加的纹理 
----------------------- Page 730-----------------------
数据与下面的四边形的比例（即，几乎在任何曲面上）都不匹配。 
一个极端情况发生在一个共同的原语：锥形。当圆锥纹理化并刻面 
时，圆锥顶端的三角形顶点具有不同的法线。这些顶点法线不会被 
相邻的三角形共享，因此会出现阴影不连续性[647]。16.2。曲面细 
分和三角测量689图16.8。左图显示了两个表面相遇的裂缝。中间 
显示通过匹配边缘点来修复裂缝。右侧显示校正后的网格。16.2.2 
边缘裂纹和T形顶点第 17章详细讨论的曲面通常被镶嵌到网格中 
进行渲染。通过沿着定义曲面的样条曲线踩踏并因此计算顶点位置 
和法线来完成此曲面细分。当我们使用简单的步进方法时，样条曲 
面会遇到问题。在共享边缘，两个表面的点需要重合。由于模型的 
性质，有时可能会发生这种情况，但通常情况下，如果没有充分注 
意，为一条样条曲线生成的点将与其邻居生成的点不匹配。这种效 
应称为边缘裂缝，当观察者窥视表面时，它会导致令人不安的视觉 
伪影。即使观察者看不到裂缝，由于内插着色的方式不同，接缝也 
经常可见。修复这些裂缝的过程称为边缘缝合。目标是确保沿着（弯 
曲的）共享边的所有顶点都被两个样条曲面共享，这样就不会出现 
裂缝。见图16.8。第 17.6.2节讨论了使用自适应曲面细分来避免样 
条曲面的破裂。连接平面时遇到的相关问题是T顶点。只要两个模 
型的边相交，但不会沿着它们共享所有顶点，就会出现这种问题。 
即使理论上边缘理想地完美匹配，如果渲染器在屏幕上表示顶点位 
置的精度不够，也会出现裂缝。现代图形硬件使用子像素寻址[985] 
来帮助避免这个问题。更明显，而不是由于精度，是可以出现的阴 
----------------------- Page 731-----------------------
影瑕疵[114]。图16.9显示了问题，可以通过查找此类边并确保与 
边界面共享公共顶点来解决此问题。另一个问题是使用简单的扇形 
算法创建退化（零区域）三角形的危险。例如，在图中，比如说右 
上角的四边形abcd被三角形分成三角形abc和acd。三角形abc 
是退化的tri690 16.多边形技术baddaccb图16.9。在顶行中， 
曲面的基础网格显示阴影不连续。顶点b是T顶点，因为它属于左 
边的三角形，但不是三角形acd的一部分。一种解决方案是将该 
T-vertex添加到该三角形并创建三角形abd和bcd （未示出）。长 
而细的三角形更可能导致其他阴影问题，因此重新排列通常是更好 
的解决方案，如底行所示。角度，所以点b是T顶点。Lengyel[1023] 
讨论了如何找到这样的顶点并提供了适当地重新凸显凸多边形的代 
码。Cignoni等。[267]描述了当T-顶点的位置已知时避免创建简并 
 （零区域）三角形的方法。他们的算法是O （n）并且保证最多产生 
一个三角形条带和扇形。16.3合并一旦模型通过了所需的任何曲面 
细分算法，我们就会得到一组代表模型的多边形。有一些操作可能 
对显示这些数据很有用。最简单的是检查多边形本身是否正确形成， 
它是否具有至少三个唯一的顶点位置，并且它们不是共线的。例如， 
如果三角形中的两个顶点匹配，则它没有区域 16.3。合并691并可 
以丢弃。请注意，在本节中，我们确实指的是多边形，而不仅仅是 
三角形。根据您的目标，存储每个多边形可能更有效，而不是立即 
将其转换为三角形以供显示。三角测量可以创建更多边缘，从而为 
后续操作创造更多功能。通常应用于多边形的一个过程是合并，它 
----------------------- Page 732-----------------------
在面之间找到​ ​ 共享顶点。另一种操作称为取向，其中形成表面 
的所有多边形都面向相同的方向。定向网格对于几种不同的算法很 
重要，例如背面剔除，折痕边缘检测以及正确的碰撞检测和响应。 
与方向相关的是顶点法线生成，其中表面看起来很平滑。我们将所 
有这些类型的技术称为合并算法。16.3.1合并某些数据以断开连接 
的多边形的形式出现，通常被称为多边形汤或三角汤。存储单独的 
多边形会浪费内存，并且显示单独的多边形效率极低。由于这些原 
因和其他原因，单个多边形通常合并为多边形网格。最简单的是， 
网格由顶点列表和一组轮廓组成。每个顶点包含一个位置和其他可 
选数据，例如着色法线，纹理坐标，切线矢量和颜色。每个多边形 
轮廓都有一个整数索引列表。每个索引都是从0到 n的数字。1， 
其中n是顶点的数量，因此指向列表中的顶点。通过这种方式，每 
个顶点只能存储一次并由任意数量的多边形共享。三角形网格是仅 
包含三角形的多边形网格。第 16.4.5节深入讨论了网格存储方案。 
给定一组断开的多边形，可以通过多种方式进行合并。一种方法是 
使用散列[542,1135]。将顶点计数器初始化为零。对于每个多边形， 
尝试依次将每个顶点添加到哈希表中，基于顶点值进行哈希处理。 
如果一个顶点不在表中，则将其与顶点计数器值一起存储在那里， 
然后递增;还将顶点存储在最终顶点列表中。如果发现顶点匹配，则 
检索其存储的索引。使用指向顶点的索引保存多边形。处理完所有 
多边形后，顶点和索引列表就完成了。模型数据有时会带有单独的 
多边形顶点非常接近但不相同。合并这些顶点的过程称为焊接。有 
----------------------- Page 733-----------------------
效地焊接顶点可以通过使用排序以及位置的松散相等函数来完成 
[1135]。16.3.2方向模型数据的一个与质量相关的问题是面向方向。 
一些模型数据正确定向，表面法线明确或隐含地指向正确的方向。 
例如，在CAD工作中，标准是顶点69216.当观察正面时，多边形 
轮廓中的多边形技术沿逆时针方向前进。这称为缠绕方向，三角形 
使用右手规则。想象一下右手的手指以逆时针顺序环绕多边形的顶 
点。然后你的拇指指向多边形法线的方向。这个方向与使用的左手 
或右手视图空间或世界坐标方向无关，因为它在查看三角形的正面 
时完全依赖于世界顶点的排序。也就是说，如果将反射矩阵应用于 
定向网格，则每个三角形的法线与其卷绕方向相比将会反转。给定 
一个合理的模型，这里有一种方法来定向多边形网格：1。形成所有 
多边形的边缘 - 面结构。2.对边进行排序或散列以查找哪些边匹 
配。3.找到彼此接触的多边形组。4.对于每个组，根据需要翻转面以 
获得一致性。第一步是创建一组半边缘对象。半边是多边形的边， 
具有指向其关联面（多边形）的指针。由于边缘通常由两个多边形 
共享，这种数据结构称为半边。使用排序顺序创建每个半边，其第 
一个顶点存储在第二个顶点之前。如果其x坐标值较小，则一个顶 
点在排序顺序中位于另一个顶点之前。如果x坐标相等，则使用y 
值; 如果匹配，则使用 z。例如，顶点（.3,5,2）位于顶点之前 
 （.3,6，.8）; .3s匹配，但5 <6。目标是找到哪些边是相同的。由 
于存储每个边缘使得第一顶点小于第二顶点，因此比较边缘是比较 
第一到第一和第二到第二顶点的问题。不需要比较一个边的第一个 
----------------------- Page 734-----------------------
顶点到另一个第二个顶点的排列。哈希表可用于查找匹配的边 
[19,542]。如果所有顶点先前已合并，因此，半边使用相同的顶点 
索引，然后可以通过将每个半边放在与其第一个顶点索引相关联的 
临时列表上来匹配每个半边。顶点平均有6条边附着，一旦分组， 
边缘匹配极快[1487]。一旦边缘匹配，相邻多边形之间的连接就已 
知，形成邻接图。对于三角形网格，这可以表示为其（最多）三个 
相邻三角形面的每个三角形的列表。任何没有两个相邻多边形的边 
都是边界边。由边连接的多边形集形成连续的组。例如，茶壶模型 
有两组，锅和盖子。下一步是给出网格方向的一致性，例如，我们 
通常希望所有多边形都具有逆时针轮廓。对于每个连续的多边形组， 
请选择任意起始多边形。检查每个相邻多边形并确定方向是否一致。 
如果两个多边形的边缘遍历方向相同，则必须翻转相邻多边形。见 
16.3。合并693图16.10。选择起始多边形S并检查其邻居。由于 
S和 B共享的边中的顶点以相同的顺序（从x到y）遍历，因此需 
要反转 B的轮廓以使其遵循右手规则。图16.10。递归检查这些邻 
居的邻居，直到连续组中的所有多边形都被测试一次。尽管此时所 
有面都是正确定向的，但它们都可以向内定向。在大多数情况下， 
我们希望它们面向外 是否应翻转所有面的一个快速测试是计算组 
的签名体积并检查符号。如果是负数，则反转所有循环和法线。通 
过计算每个三角形的带符号体积标量三重乘积并对它们求和来计算 
此体积。在realtimerendering.com上的在线线性代数附录中查找 
体积计算。这种方法适用于固体物体，但并非万无一失。例如，如 
----------------------- Page 735-----------------------
果对象是形成房间的框，则用户希望其法线朝向相机向内。如果对 
象不是实体，而是表面描述，则定向每个表面的问题可能变得难以 
自动执行。例如，如果两个立方体沿边缘接触并且是同一网格的一 
部分，则该边缘将由四个多边形共享，使定位更加困难。像 
Mobobius条带这样的单面物体永远不能完全定向，因为内部和外 
部都没有分离。即使对于表现良好的表面网格，也很难确定哪一面 
应朝外。Takayama等。[1736]讨论以前的工作并提出他们自己的 
解决方案，从每个方面投射随机光线并确定哪个方向从外部更明显。 
16.3.3Solidity非正式地，如果网格被定向并且从外部可见的所有 
多边形具有相同的方向，则网格形成实体。换句话说，只有网格的 
一侧是可见的。这种多边形网格称为封闭或不透水。知道对象是可 
靠的意味着背面剔除可用于提高显示效率，如第 19.2节中所述。对 
于投射阴影体积的对象（第7.3节）和其他几种算法，Solidity也 
是一个关键属性。例如，3D打印机要求它打印的网格是实心的。694 
16.多边形技术最简单的实体测试是检查网格中的每个多边形边是 
否由两个多边形共享。对大多数数据集来说，此测试已足够。这种 
表面松散地称为歧管，具体地说，是双歧管。技术上，歧管表面是 
没有任何拓扑不一致的表面，例如具有共享边缘的三个或更多个多 
边形或者彼此接触的两个或更多个角。形成固体的连续表面是没有 
边界的歧管。16.3.4法线平滑和折痕边有些多边形网格形成曲面， 
但多边形顶点没有法线向量，所以他们不能用曲率的幻觉来渲染。 
见图 16.11。许多模型格式不提供表面边缘信息。有关各种类型的 
----------------------- Page 736-----------------------
边，请参见第 15.2节。由于几个原因，这些边缘很重要。它们可以 
突出显示由一组多边形组成的模型区域，或者可以帮助进行非照片 
写实渲染。因为它们提供了重要的视觉提示，所以这些边缘通常有 
利于避免通过渐进网格算法进行简化 （第 16.5节）。合理的折痕边 
和顶点法线通常可以从定向网格中获得一些成功。一旦方向一致并 
且导出邻接图，可以通过平滑技术生成顶点法线。模型的格式可以 
通过为多边形指定平滑组来提供帮助。图 16.11。左边的对象每个 
顶点没有法线;右边的那个。16.3。合并695 目。平滑组值用于明 
确定义组中的哪些多边形属于一起构成曲面。不同平滑组之间的边 
缘被认为是清晰的。平滑多边形网格的另一种方法是指定折痕角度。 
将该值与二面角进行比较，二面角是两个多边形的平面法线之间的 
角度。值通常在20到50度之间。如果发现两个相邻多边形之间的 
二面角低于指定的折痕角，那么这两个多边形被认为是在相同的平 
滑组中。这种技术有时被称为边缘保存。使用折痕角有时会产生不 
适当的平滑度，圆形边缘应该是折痕，反之亦然。通常需要进行实 
验，并且没有单个角度可以完美地用于网格。即使是平滑组也有局 
限性。一个例子是当你在中间捏一张纸时。这张纸可以被认为是一 
个单一的平滑组，但它内部有折痕，平滑组可以平滑。然后建模者 
需要多个重叠平滑组，或直接在网格上定义折痕边缘定义。另一个 
例子是由三角形制成的圆锥体。平滑锥体的整个表面会产生一种奇 
特的结果，即尖端有一个法线指向锥形轴的直接向外。锥形尖端是 
一个奇点。为了完美地表示插值法线，每个三角形需要更像四边形， 
----------------------- Page 737-----------------------
在这个尖端位置有两个法线[647]。幸运的是，这种有问题的案件通 
常很少见。找到平滑组后，可以计算组内共享的顶点的顶点法线。 
用于找到顶点法线的标准教科书解决方案是平均共享顶点的多边形 
的曲面法线[541,542]。但是，这种方法可能导致结果不一致和加权 
不佳。Thurmer和Wuthuth [1770]提出了另一种方法，其中每个 
多边形法线的贡献通过它在顶点形成的角度加权。无论共享顶点的 
多边形是否被三角化，该方法都具有给出相同结果的理想特性。如 
果曲面细分的多边形变成了两个共享顶点的三角形，平均法线方法 
会错误地施加两个三角形的影响，就像对原始多边形一样。见图 
16.12。Max[1146]给出了一种不同的加权方法，基于长边形成应 
该影响法线的多边形的假设。当使用简化技术时，这种类型的平滑 
可能是优越的，因为形成的较大多边形将不太可能遵循表面的曲率。 
Jin等人。[837]提供了对这些和其他方法的全面调查，得出的结论 
是，在各种条件下，按角度加权是最好的或最好的。Cignoni[268] 
在 Meshlab中实现了一些方法，并注意到了相同的一些方法。他还 
警告不要通过相关三角形的面积来加权每个法线的贡献。对于高度 
场，Shankel [1614]示出了如何使用沿每个轴的邻居的高度差来使 
用角加权方法快速近似平滑。对于给定的点p和四个相邻点，px.1 
和69616.多边形技术图16.12。在左侧，四边形和两个三角形的曲 
面法线被平均以给出顶点法线。在中间，四边形已被三角化。这导 
致平均法线移位，因为每个多边形的法线均等加权。在右边， 
Thurmer和W¨uthrich的方法通过形成它的一对边缘之间的角度 
----------------------- Page 738-----------------------
来加权每个法线的贡献，因此三角测量不会改变法线。在高度场的 
x轴上的 px +1和在y轴上的 py.1和 py +1，p处的（非标准化 
的）法线的近似近似是n=..px+1x。px.1x，py+1y。py.1y， 
2？。（16.1）16.4三角形风扇，条带和网格三角形列表是存储和 
显示一组三角形的最简单，通常效率最低的方法。每个三角形的顶 
点数据一个接一个地放在一个列表中。每个三角形都有自己独立的 
三个顶点集，因此三角形之间不存在顶点数据的共享。提高图形性 
能的标准方法是发送通过图形管道共享顶点的三角形组。共享意味 
着对顶点着色器的调用较少，因此需要转换较少的点和法线。在这 
里，我们描述了共享顶点信息的各种数据结构，从三角形扇形和条 
带开始，并逐渐演变为更精细，更有效的渲染曲面形式。16.4.1球 
迷图 16。图13示出了三角形风扇。该数据结构显示了我们如何形 
成三角形并且每个三角形的存储成本小于三个顶点。所有三角形共 
享的顶点称为中心顶点，在图中为顶点0。对于起始三角形0，发送 
顶点0,1和2 （按此顺序）。对于后续三角形，中心顶点始终与先 
前发送的顶点和当前正在发送的顶点一起使用。通过发送顶点3形 
成三角形 1，从而创建 16.4。三角形风扇，条带和网格697图16.13。 
左图说明了三角扇的概念。三角形T0发送顶点v0 （中心顶点）， 
v1和v2。随后的三角形Ti （i>0）仅发送顶点vi +2。右图显示了 
一个凸多边形，它总是可以变成一个三角形扇形。由顶点0 （始终 
包含），2 （先前发送的顶点）和3定义的三角形。三角形2通过 
发送顶点4构成，依此类推。请注意，一般凸多边形很容易表示为 
----------------------- Page 739-----------------------
三角形扇形，因为它的任何点都可以用作起始中心顶点。n个顶点 
的三角形扇被定义为有序顶点列表{v0，v1，...。。，vn.1}，（16.2） 
其中v0是中心顶点，在列表上施加一个结构，表示三角形i是△v0vi 
+1vi +2，（16.3）其中0≤i<n。2.如果三角形扇形由 m个三角 
形组成，则为第一个三角形发送三个顶点，然后为剩余的m中的每 
一个发送一个顶点。1个三角形。这意味着为长度为m的连续三角 
形扇形发送的平均顶点数va可以表示为va =3+ （m.1）m=1+ 
2m。 （16。4）很容易看出，va→1为m→∞。这似乎与现实案例 
无关，但考虑更合理的价值。如果m =5，则va =1.4，这意味着 
平均每个三角形仅发送 1.4个顶点。16.4.2条带三角形条带类似于 
三角形扇形，因为前面三角形中的顶点可以重复使用。而不是单个 
中心点和前一个顶点被重用，它是前一个三角形的两个顶点，有助 
于形成下一个三角形。考虑图 16.14。如果698 16.多边形技术图 
16.14。一系列三角形，可以表示为一个三角形条带。请注意，条带 
中的方向从三角形变为三角形，条带中的第一个三角形设置所有三 
角形的方向。在内部，通过遍历顶点[0,1,2]，[1,3,2]，[2,3,4]，[3,5,4] 
等，逆时针顺序保持一致。这些三角形被视为条带，然后可以更紧 
凑的方式将它们发送到渲染管道。对于第一个三角形 （表示为T0）， 
按顺序发送所有三个顶点（表示为v0，v1和v2）。对于此条带中 
的后续三角形，只需要发送一个顶点，因为其他两个顶点已经与前 
一个三角形一起发送。例如，发送三角形T1，仅发送顶点v3，并 
且来自三角形T0的顶点v1和v2用于形成三角形T1。对于三角形 
----------------------- Page 740-----------------------
T2，仅发送顶点v4，依此类推通过条带的其余部分。n个顶点的连 
续三角形条带被定义为有序顶点列表{v0，v1，...。。，vn.1}，（16。 
5）具有强加在其上的结构，表示三角形i是△vivi +1vi+2，（16.6） 
其中0≤i<n。这种条带称为顺序，因为顶点是按给定顺序发送的。 
该定义意味着n个顶点的连续三角形条带具有 n。2个三角形。对 
长度为m的三角形条带（即由m个三角形组成）的平均顶点数的 
分析，也表示为va，与三角形扇形相同 （见公式16.4），因为它们 
具有相同的启动阶段然后每个新三角形只发送一个顶点。类似地， 
当m→∞时，三角形条带的va 自然也趋向于每个三角形的一个顶 
点。对于m=20，va =1.1，这比3好得多并且接近 1.0的极限。 
与三角形风扇一样，第一个三角形的启动成本总是花费三个顶点， 
在随后的三角形上摊销。三角形条带的吸引力源于这一事实。根据 
瓶颈在渲染管道中的位置，有可能节省高达 16.4。Triangle Fans， 
Strips和 Meshes699三分之二的时间用简单的三角形列表进行渲 
染。加速是由于避免了冗余操作，例如将每个顶点两次发送到图形 
硬件，然后对每个顶点进行矩阵变换，剪切和其他操作。三角条对 
于诸如草叶或其他物体的物体是有用的，其中边缘顶点不被其他条 
带重复使用。由于其简单性，当输出多个三角形时，几何着色器使 
用条带。三角形条上有几种变体，例如，不对三角形施加严格的序 
列，或使用加倍的顶点或重新启动索引值，以便可以将多个断开的 
条带存储在单个缓冲区中。曾经有关于如何最好地将任意三角形网 
格分解成条带的研究很多[1076]。这种努力已经消失，因为索引三 
----------------------- Page 741-----------------------
角形网格的引入允许更好的顶点数据重用，导致更快的显示和通常 
所需的总体内存更少。16.4.3三角形网格三角形网格和条带仍有其 
用途，但所有现代GPU的标准是使用带有单个索引列表的三角形网 
格 （第 16.3.1节）用于复杂模型[1135]。条带和风扇允许一些数据 
共享，但网格存储允许更多。在网格中，附加的索引数组跟踪哪些 
顶点形成三角形。通过这种方式，单个顶点可以与多个三角形相关 
联。连接平面图的 Euler-Poincar'e公式[135]有助于确定形成闭合 
网格的平均顶点数：v。e +f +2g =2. （16.7）这里v是顶点数， 
e是边数，f是面数，g是属。属是对象中的孔数。例如，球体具有 
属0，环面具有属1.每个面假设具有一个环。如果面可以有多个循 
环，则公式变为v。e +2f。l +2g =2，（16.8）其中l是循环次 
数。对于闭合（实体）模型，每个边都有两个面，每个面至少有三 
个边，所以2e≥3f。如果网格是所有三角形，则如GPU所要求的那 
样，则2e =3f。假设属0并代入 1。式中e为5f，产生f≤2v。4. 
如果所有面都是三角形，则f =2v。4.对于大的闭合三角形网格， 
经验法则是三角形的数量约等于顶点数量的两倍。类似地，我们发 
现每个顶点连接到近六个三角形的平均值（因此，六个边缘）。连 
接到顶点的边数称为其效价。请注意，网格的网络不会影响结果， 
只会影响三角形的数量。由于条带中每个三角形的平均顶点数接近 
1，因此数量为70016.多边形技术顶点是三角形的两倍，如果大网 
格由三角形条带表示，则每个顶点必须发送两次 （平均） 。在极限 
处，三角形网格可以为每个三角形发送0.5个顶点。请注意，此分 
----------------------- Page 742-----------------------
析仅适用于平滑，闭合的网格。只要存在边界边（两个多边形之间 
没有共享边），顶点与三角形的比率就会增加。Euler-Poincar'e公 
式仍然存在，但网格的外边界必须被视为与所有外边缘接壤的单独 
 （未使用）面。类似地，任何模型中的每个平滑组实际上都是它自 
己的网格，因为GPU需要具有单独的顶点记录，其中两个组相遇的 
锐边具有不同的法线。例如，立方体的角在单个位置将具有三个法 
线，因此存储三个顶点记录。纹理或其他顶点数据的更改也会导致 
不同顶点记录的数量增加。理论预测我们需要处理每个三角形约0.5 
个顶点。在实践中，顶点由GPU转换并放入先进先出（FIFO）缓 
存，或者近似于最近最少使用 （LRU）系统[858]。此缓存保存通过 
顶点着色器运行的每个顶点的变换后结果。如果传入的顶点位于此 
缓存中，则可以在不调用顶点着色器的情况下使用缓存的变换后结 
果，从而显着提高性能。相反，如果三角形网格中的三角形以随机 
顺序向下发送，则缓存不太可能有用。三角条带算法针对两个缓存 
大小进行优化，即，使用的最后两个顶点。Deering和 Nelson[340] 
首先探讨了通过使用算法确定将顶点数据添加到缓存的顺序，将顶 
点数据存储在更大的 FIFO缓存中的想法。FIFO缓存的大小有限。 
例如，PLAYSTATION3系统保存大约24个顶点，具体取决于每个 
顶点的字节数。较新的GPU没有显着增加此缓存，32个顶点是典 
型的最大值。Hoppe[771]介绍了缓存重用的重要测量，平均缓存 
未命中率（ACMR）。这是每个三角形需要处理的平均顶点数。它 
的范围可以从3 （每个三角形的每个顶点必须每次重新处理）到0.5 
----------------------- Page 743-----------------------
 （在大的闭合网格上完美重用;没有顶点被重新处理）。如果高速缓 
存大小与网格本身一样大，则ACMR与理论顶点与三角形的比率相 
同。对于给定的高速缓存大小和网格排序，可以精确计算ACMR， 
因此描述该高速缓存大小的任何给定方法的效率。16.4。4 
Cache-Oblivious MeshLayouts网格中三角形的理想顺序是我们 
最大化顶点缓存的使用。Hoppe [771]提出了一种最小化网格的 
ACMR的算法，但是必须事先知道高速缓存大小。如果假定的高速 
缓存大小大于实际高速缓存大小，则生成的网格可以具有显着较少 
的益处。解决不同大小的缓存可能会产生不同的最佳排序。因为当 
目标高速缓存大小未知时，已经开发了高速缓存无关的网格布局算 
法 16.4。三角形风扇，条带和网格701，无论大小如何，都可以产 
生良好的排序。这种排序有时被称为通用索引序列。Forsyth[485] 
和 Lin和Yu [1047]提供了使用类似原理的快速贪婪算法。顶点根据 
它们在缓存中的位置以及附加到它们的未处理三角形的数量给出分 
数。接下来处理具有最高组合顶点得分的三角形。通过对最近使用 
的三个顶点进行较低评分，该算法避免了简单地制作三角形条带， 
而是创建类似于希尔伯特曲线的模式。通过给仍然附着较少三角形 
的顶点提供较高分数，该算法倾向于避免留下孤立的三角形。实现 
的平均高速缓存未命中率与更昂贵和复杂的算法相当。Lin和Yu的 
方法稍微复杂一点，但使用了相关的想法。对于高速缓存大小为 12， 
一组30个未优化模型的平均ACMR为1.522;优化后，平均值降至 
0.664或更低，具体取决于缓存大小。桑德等人。[1544]概述了以 
----------------------- Page 744-----------------------
前的工作并提出了他们自己的更快（虽然不是缓存大小的遗忘）方 
法，称为Tipsify。另外一个补充是，他们还努力将最外面的三角形 
放在列表的早期，以尽量减少透支 （第 18.4.5节）。例如，想象一 
下咖啡杯。通过使三角形首先形成杯子的外部，内部的后三角形可 
能被隐藏在视野之外。Storsj¨o[1708]对比并比较了 Forsyth和 
Sander的方法，并提供了两者的实现。他的结论是，这些方法提供 
了接近理论极限的布局。Kapoulkine[858]的一项新研究比较了三 
个硬件供应商的GPU上的四种缓存感知顶点排序算法。他的结论是 
英特尔使用 128入口FIFO，每个顶点使用三个或更多条目，AMD 
和 NVIDIA的系统接近一个16项 LRU缓存。这种架构差异显着影 
响算法行为。他发现Tipsify [1544]以及Forsyth算法[485]在较小 
程度上在这些平台上的表现相对较好。总之，三角网格的离线预处 
理可以显着提高顶点缓存性能，以及当这个顶点阶段成为瓶颈时的 
整体帧速率。它在实践中是快速的，有效的O （n）。有几种开源版 
本可供使用[485]。鉴于此类算法可以自动应用于网格，并且此类优 
化没有额外的存储成本，并且不会影响工具链中的其他工具，这些 
方法通常是成熟开发系统的一部分。例如，Forsyth的算法似乎是 
PLAYSTATION网格处理工具链的一部分。虽然顶点后变换缓存由 
于现代GPU采用统一着色器架构而发展，但避免缓存未命中仍然是 
一个重要问题[530]。16.4.5顶点和索引缓冲区/数组使用模型数据 
提供现代图形加速器的一种方法是使用 DirectX调用顶点缓冲区和 
OpenGL调用顶点缓冲区对象（VBO）。我们将702 16.多边形技 
----------------------- Page 745-----------------------
术与本节中的DirectX术语一致。提出的概念具有OpenGL等价物。 
顶点缓冲区的想法是将模型数据存储在连续的内存块中。顶点缓冲 
区是特定格式的顶点数据数组。格式指定顶点是否包含法线，纹理 
坐标，颜色，或其他具体信息。每个顶点都有一个组中的数据，一 
个接一个的顶点。顶点的字节大小称为stride。这种类型的存储称 
为交错缓冲区。或者，可以使用一组顶点流。例如，一个流可以保 
存位置数组{p0p1p2。。。}和另一个正常的法线数组{n0n1n2。。}。 
在实践中，包含每个顶点的所有数据的单个缓冲区通常在GPU上更 
有效，但不应该避免多个流[66,1494]。多个流的主要成本是额外的 
API调用，如果应用程序受CPU限制，则可能值得避免，但其他方 
面并不重要[443]。Wihlidal [1884]讨论了多个流可以帮助渲染系统 
性能的不同方式，包括API，缓存，和CPU处理优势。例如，用于 
CPU上的矢量处理的SSE和AVX更容易应用于单独的流。使用多 
个流的另一个原因是更有效的网格更新。例如，如果仅顶点位置流 
随时间变化，则更新该一个属性缓冲区比形成和发送整个交织流更 
低成本[1609]。如何访问顶点缓冲区取决于设备的DrawPrimitive 
方法。数据可视为：1。各个点的列表。2.未连接线段的列表，即顶 
点对。3.单一折线。4.三角形列表，其中每组三个顶点形成三角形， 
例如，顶点[0,1,2]形成一个，[3,4,5]形成下一个，依此类推。一个 
三角扇，其中第一顶点与每个连续的顶点对形成三角形，例如， 
[0,1,2]，[0,2,3]，[0,3,4]。6.三角形条带，其中每组三个连续顶点形 
成三角形，例如[0,1,2]，[1,2,3]，[2,3,4]。在DirectX10中，三角 
----------------------- Page 746-----------------------
形和三角形条带还可以包含相邻的三角形顶点，供几何着色器使用 
 （第3.7节）。顶点缓冲区可以按原样使用，也可以由索引缓冲区 
引用。索引缓冲区中的索引保存顶点缓冲区中顶点的位置。指数存 
储为 16位无符号整数，如果网格很大且GPU和API支持，则为 
32位（第 16.6节）。索引缓冲区和顶点缓冲区的组合用于显示与 
 “原始”顶点缓冲区相同类型的绘制基元。不同之处在于索引/顶点 
缓冲区组合中的每个顶点只需要存储 16.4。三角形风扇，条带和网 
格703一次在其顶点缓冲区中，而不是在没有索引的情况下在顶点 
缓冲区中发生的重复。三角形网格结构由索引缓冲区表示。存储在 
索引缓冲区中的前三个索引指定第一个三角形，接下来的三个指定 
第二个三角形，依此类推。这种安排称为索引三角形列表，其中索 
引本身形成三角形列表。OpenGL将索引缓冲区和顶点缓冲区与顶 
点数组对象（VAO）中的顶点格式信息绑定在一起。索引也可以按 
三角形条带顺序排列，这样可以节省索引缓冲区空间。这种格式， 
索引三角形条，在实践中很少使用，因为为大型网格创建这样的条 
带需要花费一些精力，所有处理几何的工具也需要支持这种格式。 
有关顶点和索引缓冲区结构的示例，请参见图 16.15。使用哪种结 
构由原语和程序决定。使用四个顶点作为双三角三角形或扇形，只 
需一个顶点缓冲区即可轻松显示一个简单的矩形。如前所述，索引 
缓冲区的一个优点是数据共享。另一个优点是简单，因为三角形可 
以是任何顺序和配置，不具有三角形条带的锁定步骤要求。最后， 
当使用索引缓冲区时，需要传输和存储在GPU上的数据量通常较 
----------------------- Page 747-----------------------
小。包含索引数组的小开销远远超过共享顶点所实现的内存节省。 
索引缓冲区和一个或多个顶点缓冲区提供了一种描述多边形网格的 
方法。然而，数据通常以GPU渲染效率的目标存储，不一定是最紧 
凑的存储。例如，存储立方体的一种方法是将其八个角位置保存在 
一个数组中，将其六个不同的法线保存在另一个数组中，以及定义 
其面的六个四索引循环。然后，每个顶点位置由两个索引描述，一 
个用于顶点列表，一个用于普通列表。纹理坐标由另一个数组和第 
三个索引表示。这种紧凑的表示形式用于许多模型文件格式，例如 
WavefrontOBJ。在GPU上，只有一个索引缓冲区可用。单个顶点 
缓冲区将存储24个不同的顶点，因为每个角点位置具有三个单独的 
法线，每个相邻面一个。索引缓冲区将存储定义形成表面的 12个三 
角形的索引。Masserann[1135]讨论了将这种文件描述有效地转换 
为紧凑且有效的索引/顶点缓冲区，而不是共享顶点的未索引三角形 
的列表。通过诸如将网格存储在纹理贴图或缓冲纹理中以及使用顶 
点着色器的纹理提取或拉取机制等方法，可以实现更紧凑的方案， 
但是它们的性能损失是无法使用后变换顶点缓存[223] ，1457]。为 
了获得最大效率，顶点缓冲区中顶点的顺序应与索引缓冲区访问它 
们的顺序相匹配。那是，索引缓冲区中第一个三角形引用的前三个 
顶点应该是顶点缓冲区中的前三个。当在索引缓冲区中遇到新的顶 
点时，它应该在顶点缓冲区中接下来。给出这个顺序可以最大限度 
地减少预变换顶点缓存中的缓存未命中，这与所讨论的后变换缓存 
分开70416.多边形技术图16.15。定义基元的不同方式，从大多数 
----------------------- Page 748-----------------------
到最小内存的粗略顺序从上到下使用：单独的三角形，作为顶点三 
角形列表，作为两个或一个数据流的三角形条带，以及作为索引缓 
冲区列出单独的三角形或三角形剥离订单。16.4。三角形风扇，条 
带和网格705图16.16。左上角是Crater Lake的高度场，渲染了 
200,000个三角形。右上图显示该模型在三角形不规则网络（TIN） 
中简化为1000个三角形。底层的简化网格显示在底部。（图片由 
MichaelGarland提供。）见第 16.4.4节。重新排序顶点缓冲区中 
的数据是一个简单的操作，但对于为变换后顶点缓存找到有效的三 
角形顺序而言，性能同样重要[485]。有更高级别的方法来分配和使 
用顶点和索引缓冲区来实现更高的效率。例如，不改变的缓冲区可 
以存储在GPU上以供每个帧使用，并且可以从同一缓冲区生成对象 
的多个实例和变体。第 18.4.2节深入讨论了这些技术。使用管道的 
流输出功能（第3.7.1节）将处理过的顶点发送到新缓冲区的能力 
允许一种方法来处理GPU上的顶点缓冲区而不渲染它们。例如，描 
述三角形网格的顶点缓冲区可以被视为初始传递中的一组简单点。 
顶点着色器可用于根据需要执行每顶点计算，结果使用流输出发送 
到新的顶点缓冲区。在随后的传递中，这个新的顶点缓冲区可以与 
描述网格连通性的原始索引缓冲区配对，以进一步处理和显示生成 
的网格。706 16.多边形技术 16.5简化网格简化，也称为数据简化 
或抽取，是在尝试保持其外观的同时采用详细模型并减少其三角形 
计数的过程。对于实时工作，完成此过程以减少存储和发送到管道 
的顶点数量。这对于使应用程序可扩展非常重要，因为功能较弱的 
----------------------- Page 749-----------------------
机器可能需要显示较少数量的三角形。还可以接收模型数据，其具 
有比合理表示所必需的更多的细分。图 16.16给出了如何通过数据 
缩减技术减少存储三角形的数量的意义。Luebke[1091,1092]确定 
了三种类型的网格简化：静态，动态和视图相关。静态简化是在渲 
染开始之前创建单独的细节级别（LOD）模型的想法，并且渲染器 
在这些之间进行选择。该表格在第 19.9节中介绍。离线简化对于其 
他任务也很有用，例如为细分曲面提供粗网格以进行细化 
[1006,1007]。动态的implification给出连续光谱的 LOD模型而不 
是几个离散模型，因此这种方法被称为连续细节水平（CLOD）算 
法。视图相关技术适用于模型中细节级别不同的位置。具体地，地 
形渲染是视野中的附近区域需要详细表示而远处的那些区域处于较 
低细节水平的情况。本节将讨论这两种简化方式。16.5.1动态简化 
减少三角形计数的一种方法是使用边折叠操作，通过移动其两个顶 
点重合来移除边。有关此操作的示例，请参见图 16.17。对于实体 
模型，边折叠会删除总共两个三角形，三个边和一个顶点。所以， 
具有3000个三角形的闭合模型将应用1500个边缘折叠以将其减少 
为零面。经验法则是具有v个顶点的闭合三角形网格具有大约 2v 
个面和3v个边。这个规则可以使用f的Euler-Poincar'e公式导出。 
对于实体表面，e+v =2 （第 16.4.3节）。边缘坍塌过程是可逆的。 
通过按顺序存储边缘折叠，我们可以从简化模型开始并从中重建复 
杂模型。该特征对于模型的网络传输是有用的，因为数据库的边缘 
折叠版本可以以有效压缩的形式发送，并且在接收到模型时逐步建 
----------------------- Page 750-----------------------
立和显示[768,1751]。由于这个功能，这种简化过程通常被称为与 
视图无关的渐进网格划分 （VIPM）。在图 16.17中，u被折叠到v 
的位置，但是v可能已经折叠到了u中。仅限于这两种可能性的简 
化系统是使用子集放置策略。这种策略的一个优点是，如果我们限 
制可能性，我们可能隐含地编码所做的选择[516,768]。这个策略 
16.5。简化707图16.17。左边是uv边缘折叠发生前的数字;右图 
显示点u折叠到点v，从而删除三角形A和 B以及边缘uv。更快， 
因为需要评估的可能性更少，但它也可以产生较低的质量近似值， 
因为检查了较小的解空间。使用最佳放置策略时，我们研究了更广 
泛的可能性。而不是将一个顶点折叠到另一个顶点，边缘的两个顶 
点都缩小到新位置。Hoppe[768]研究了u和v都移动到连接它们 
的边缘上的某个位置的情况。他指出，为了改善最终数据表示的压 
缩，搜索可以限于检查中点。Garland和 Heckbert[516]更进一步， 
求解二次方程以找到最佳位置，一个可能位于边缘之外的位置。最 
佳放置策略的优势在于它们倾向于提供更高质量的网格。缺点是额 
外的处理，代码和存储器用于记录这种更广泛的可能的放置。为了 
确定最佳点位置，我们对当地社区进行分析。由于多种原因，该地 
区是一个重要且有用的特征。如果边缘折叠的成本仅取决于几个局 
部变量（例如，边缘长度和边缘附近的面法线），则成本函数易于 
计算，并且每次折叠仅影响其几个邻居。例如，假设模型具有在开 
始时计算的3000个可能的边缘折叠。执行具有最低成本函数值的 
边缘折叠。因为它只影响几个附近的三角形及其边缘，所以只需要 
----------------------- Page 751-----------------------
重新计算其成本函数受这些变化影响的那些边缘折叠可能性 （例如， 
10而不是3000），并且该列表仅需要一点点的求助。因为边缘折 
叠仅影响其他几个边折叠成本值，维护此成本值列表的一个好选择 
是堆或其他优先级队列[1649]。无论成本如何，都必须避免一些收 
缩。请参见图 16.18中的示例。这些可以通过检查相邻三角形是否 
由于塌陷而翻转其正常方向来检测。折叠操作本身是模型数据库的 
编辑。用于存储这些塌陷的数据结构已被充分记录 
[481,770,1196,1726]。使用成本函数分析每个边缘塌陷，并且执行 
具有最小成本值的边缘塌陷 708 16.多边形技术 uv边缘交叉图 
16.18。坏崩溃的例子。在将顶点u折叠成v之前，左边是一个网 
格。右边是折叠后的网格，显示边缘现在如何交叉。下一个。最佳 
成本函数可以并且将随着模型的类型和其他因素而变化[1092]。根 
据所解决的问题，成本函数可以在速度，质量，稳健性和简单性之 
间进行权衡。它还可以被定制以保持表面边界，材料位置，照明效 
果，沿轴的对称性，纹理放置，体积或其他约束。我们将介绍Garland 
和 Heckbert的二次误差度量 （QEM）成本函数[515,516]，以便了 
解这些函数的工作原理。该功能通常用于许多情况。相比之下，在 
早期的研究中，Garland和 Heckbert [514]发现使用 Hausdorff 
距离最适合地形简化，而其他人已经证实了这一点[1496]。此函数 
只是简化网格中顶点距原始网格的最长距离。图 16.16显示了使用 
此度量标准的结果。对于给定的顶点，存在一组共享它的三角形， 
并且每个三角形具有与其相关联的平面方程。用于移动顶点的QEM 
----------------------- Page 752-----------------------
成本函数是这些平面中的每一个与新位置之间的平方距离的总和。 
更正式地，c （v）=Xm i=1 （ni·v +di）2是新位置v和m平面 
的代价函数，其中ni是平面i的法线，di是它与原点的偏移。图16.19 
显示了相同边缘的两种可能收缩的示例。说立方体是两个单位宽。 
将e折叠成c （e→c）的成本函数将为0，因为当它进入c时，点e 
不会偏离其共享的平面。c→e的成本函数将为1，因为c离开立方 
体右面的平面的平方距离为 1.因为它具有较低的成本，所以e→c 
折叠优于c→即 16.5。简化709ecce图16.19。左图显示了一个沿 
一条边有一个额外点的立方体。中图显示了如果此点e折叠到拐角 
c会发生什么。右图显示c折叠为e。可以以各种方式修改该成本函 
数。想象一下，两个共用边缘的三角形形成锋利的边缘，例如，它 
们是鱼鳍或涡轮叶片的一部分。折叠此边上的顶点的成本函数很低， 
因为沿一个三角形滑动的点不会远离另一个三角形的平面移动。基 
本功能的成本值与移除功能的音量变化有关，但不是其视觉重要性 
的良好指标。保持具有尖锐折痕的边缘的一种方法是添加包括边缘 
的额外平面并且具有法线，该法线是两个三角形法线的平均值。现 
在远离此边缘的顶点将具有更高的成本函数[517]。一种变化是通过 
三角形区域的变化来对成本函数进行加权。另一种类型的扩展是使 
用基于维持其他表面特征的成本函数。例如，模型的折痕和边界边 
缘在描绘它时很重要，因此应该不太可能修改它们。见图 16.20。 
值得保留的其他表面特征是有材料变化的位置，纹理贴图边缘，和 
每顶点颜色的变化[772]。见图16.21。大多数简化算法出现的一个 
----------------------- Page 753-----------------------
严重问题是纹理通常以明显的方式偏离其原始外观[1092]。当边缘 
折叠时，纹理到表面的底层映射可能会变形。此外，纹理坐标值可 
以在边界处匹配但是属于应用纹理的不同区域，例如，沿着镜像模 
型的中心边缘。Caillaud等人。[220]调查了各种先前的方法，并提 
出了自己的处理纹理接缝的算法。速度可能是另一个问题。在用户 
创建自己的内容的系统中，例如在CAD系统中，需要动态创建详细 
级别的模型。使用GPU执行简化已经取得了一些成功[1008]。另一 
种方法是使用更简单的简化算法，例如顶点聚类[1088,1511]。这种 
方法的核心思想是用三维体素网格或类似结构覆盖模型。体素中的 
任何顶点都移动到该单元格的 “最佳”顶点位置。这样做可能会消 
除一些三角形，当每个三角形的顶点中的两个或多个落在同一位置 
时，会使其退化。该算法是健壮的，不需要网格的连通性，并且可 
以容易地聚合单独的网格710 16.多边形技术图16.20。网格简化。 
左上方显示 13,546个面的原始网格，右上方简化为 1,000个面， 
左下方为 500个面，右下方为 150个面[770]。（图片c 1996 
Microsoft。版权所有。）合而为一。然而，基本顶点聚类算法很少 
提供与完整QEM方法一样好的结果。Willmott [1890]讨论了他的 
团队如何使用这种聚类方法以一种强大而有效的方式为游戏Spore 
中的用户创建内容工作。将曲面的原始几何体转换为凹凸贴图的法 
线贴图是与简化相关的想法。按钮或皱纹等小功能可以通过纹理来 
表示，保真度几乎没有损失。桑德等人。[1540]讨论此领域的先前 
工作并提供解决方案。这些算法通常用于开发交互式应用程序的模 
----------------------- Page 754-----------------------
型，将高质量的模型烘焙成纹理表示[59]。简化技术可以从单个复 
杂模型中生成大量细节级别 （LOD）模型。在使用 LOD模型时发现 
的一个问题是，如果一个模型在一帧和下一帧之间立即替换另一帧， 
则有时可以看到过渡[508]。这个问题被称为 “弹出”。一种解决方 
案是使用地貌[768]来增加或减少细节水平。由于我们知道更复杂模 
型中的顶点如何映射到简单模型，因此可以创建平滑过渡。更多详 
细信息，请参见第 19.9.1节。16.5。简化711图16.21。网格简化。 
顶行：带网格和简单的灰色材质。底行：带纹理。从左到右：模型 
包含51,123,6,389和 1,596个三角形。模型上的纹理尽可能保持， 
尽管随着三角形数量下降，一些失真会逐渐消失。（图片c 2016 
Microsoft。保留所有权利。使用与视图无关的渐进网格划分的一个 
优点是，可以创建一个单个顶点缓冲区，并在不同细节级别的同一 
模型的副本之间共享[1726]。但是，在基本方案下，需要为每个副 
本创建单独的索引缓冲区。另一个问题是效率。因为折叠的顺序决 
定了三角形显示顺序，所以顶点缓存一致性很差。Forsyth[481]讨 
论了几种在形成和共享索引缓冲区时提高效率的实用解决方案。网 
格减少技术可能很有用，但全自动系统并不是万能的。保持对称性 
的问题如图16.22所示。一个才华横溢的模型制造商可以创建质量 
低于712的低三角计数对象.16。多边形技术图16.22。对称问题。 
左侧的圆柱体有 10个平面 （包括顶部和底部）。通过自动缩小消除 
1面后，中间圆柱面有9个平面。在由建模者的面板再生之后，右 
圆柱体具有9个平面。那些由自动程序产生的。例如，眼睛和嘴巴 
----------------------- Page 755-----------------------
是脸部最重要的部分。一个天真的算法会使这些变得无比顺畅。 
Retopology是一个过程，其中边缘被添加到模型中，以在应用建 
模，平滑或简化技术时保持各种特征分离。简化相关算法继续尽可 
能地开发和自动化。16.6压缩和精度三角网格数据可以以各种方式 
压缩数据，并可以产生类似的好处。正如PNG和JPEG图像文件格 
式对纹理使用无损和有损压缩一样，已经开发了用于压缩三角形网 
格数据的各种算法和格式。压缩最小化了用于数据存储的空间，代 
价是编码和解码所花费的时间。通过传输较小的表示节省的时间必 
须超过解压缩数据所花费的额外时间。当在因特网上传输时，较慢 
的下载速度意味着可以使用更复杂的算法。可以使用在 MPEG-4中 
采用的 TFAN [1116]来压缩和有效地解码网状连接。像 
Open3DGC，OpenCTM和 Draco这样的编码器可以创建模型文 
件，与仅使用gzip压缩相比，模型文件可以是大小的四分之一或更 
小[1335]。使用这些方案的减压意味着一次性操作，一些相对较慢 
的东西 - 每秒几百万个三角形 - 但这可以通过节省传输数据所花 
费的时间来为自己付出代价。Maglo等。[1099]提供对算法的全面 
回顾。在这里，我们专注于直接涉及GPU本身的压缩技术。16.6。 
压缩和精度713本章的大部分内容都致力于三角网格存储最小化的 
各种方式。这样做的主要动机是提高效率。在几个三角形之间重用 
和重复顶点数据将导致更少的高速缓存未命中。删除几乎没有视觉 
冲击力的三角形可以节省顶点处理和内存。较小的内存大小可以降 
低带宽成本并提高缓存使用率。GPU可以存储在内存中的限制，因 
----------------------- Page 756-----------------------
此，数据缩减技术可以产生更多可以显示的三角形。顶点数据可以 
使用固定速率压缩进行压缩，原因与压缩纹理时类似 （第6.2.6节）。 
固定速率压缩是指最终压缩存储大小已知的方法。对每个顶点具有 
自包含形式的压缩意味着可以在GPU上进行解码。Calver[221]提 
出了各种使用顶点着色器进行解压缩的方案。Zarge [1961]指出， 
数据压缩还可以帮助将顶点格式与缓存行对齐。Purnomo等人。 
[1448]组合简化和顶点量化技术，并使用图像空间度量来优化给定 
目标网格尺寸的网格。在索引缓冲区的格式中可以找到一种简单的 
压缩形式。索引缓冲区由无符号整数数组组成，这些整数为顶点缓 
冲区中的顶点提供数组位置。如果顶点缓冲区中有少于或等于216 
个顶点，则索引缓冲区可以使用unsignedshort而不是unsigned 
longs。某些API支持少于28个顶点的网格的无符号字节，但使用 
这些可能会导致代价高昂的对齐问题，因此通常会避免这种情况。 
值得注意的是，OpenGLES2.0，未扩展的WebGL 1.0以及一些较 
旧的台式机和笔记本电脑GPU都有一个限制，即不支持无符号长索 
引缓冲区，因此必须使用无符号短路。另一个压缩机会是三角形网 
格数据本身。作为基本示例，一些三角形网格存储每个顶点的一种 
或多种颜色以表示烘焙照明，模拟结果或其他信息。在典型的监视 
器上，颜色由8位红色，绿色和蓝色表示，因此数据可以作为三个 
无符号字节而不是三个浮点数存储在顶点记录中。GPU的顶点着色 
器可以将此字段转换为单独的值，然后在三角形遍历期间进行插值。 
但是，应该注意许多架构。例如，Apple建议iOS将3字节数据字 
----------------------- Page 757-----------------------
段填充到4字节以避免额外处理[66]。请参见图16.23中的中间插 
图。另一种压缩方法是根本不存储任何颜色。如果颜色数据是，例 
如，显示温度结果，则温度本身可以存储为单个数字，然后将其转 
换为颜色的一维纹理中的索引。更好的是，如果不需要温度值，然 
后可以使用单个无符号字节来引用此颜色纹理。即使存储温度本身， 
也可能只需要几个小数位。浮点数的总精度为24位，略大于7位 
十进制数。注意，16位给出几乎5个十进制数字的精度。温度值的 
范围可能足够小，以至于浮点格式的指数部分是不必要的。通过使 
用最小值作为偏移量和714 16.多边形技术位置x位置y位置z单 
精度浮点数据使用边界框的大小转换为无符号短路 posx posy 
posz红绿蓝转换为字节并添加 paddingrgbnormalx normaly 
normalzoct.uoct.voctantencode图16.23。顶点数据的典型固 
定速率压缩方法。（来自Cigolle等[269]的Octant转换数字，由 
MorganMcGuire提供。）最高值减去最低值作为比例，值可以在 
有限范围内均匀分布。例如，如果值的范围为28.51到 197.12，则 
无符号短值将通过首先除以216来转换为温度。1，然后将结果乘 
以比例因子（197.12.28.51），最后加上偏差28.51。通过存储数 
据集的比例和偏移因子并将它们传递给顶点着色器程序，数据集本 
身可以存储在空间的一半中。这种类型的变换称为标量量化[1099]。 
顶点位置数据通常是这种减少的良好候选者。单个网格跨越空间中 
的一小块区域，因此，对于整个场景具有比例和偏移矢量（或4×4 
矩阵）可以节省相当大的空间而不会显着损失保真度。对于某些场 
----------------------- Page 758-----------------------
景，可以为每个对象生成比例和偏移，从而提高每个模型的精度。 
但是，这样做可能会导致裂缝出现在单独的网格触摸[1381]。最初 
位于相同世界位置但在单独模型中的顶点可以缩放并偏移到略微不 
同的位置。当所有模型与整个场景相比相对较小时，一种解决方案 
是对所有模型使用相同的比例并对齐偏移，这可以提供更多的精度 
位[1010]。16.6。压缩和精度715有时，即使顶点数据的浮点存储 
也不足以避免精度问题。一个典型的例子是在地球上渲染的航天飞 
机。航天飞机模型本身可以指定为毫米级，但地球表面距离超过 
100,000米，给出了8位小数位的差异。当航天飞机的世界空间位 
置相对于地球计算时，生成的顶点位置需要更高的精度。如果没有 
采取纠正措施，当观察者靠近屏幕时，航天飞机将在屏幕周围抖动。 
虽然穿梭示例是此问题的极端版本​ ​ ，但如果始终使用单个坐标 
系统，则大型多人游戏世界可能会受到相同的影响。条纹上的物体 
将失去足够的精度以使问题变得可见 - 动画对象将会抖动，各个顶 
点在不同时间捕捉，和阴影贴图纹理将随着最轻微的相机移动而跳 
跃。一种解决方案是重做变换管道，以便对于每个以原点为中心的 
对象，首先将世界和相机翻译连接在一起，因此大部分取消 
[1379,1381]。另一种方法是分割世界并将原点重新定义为每个区段 
的中心，然后挑战从一个区段移动到另一个区段。Ohlarik [1316] 
和Cozzi和 Ring[299]深入讨论了这些问题和解决方案。其他顶点 
数据可以具有与它们相关联的特定压缩技术。纹理坐标通常限制在 
[0.0,1.0]的范围内，因此通常可以安全地减少到无符号短路，隐式 
----------------------- Page 759-----------------------
偏移为0，标度除数为216.1。通常有成对的价值观，它很适合两 
个无符号短路[1381]，甚至只需3个字节[88]，具体取决于精度要 
求。与其他坐标集不同，法线通常是标准化的，因此所有标准化法 
线的集合形成一个球体。出于这个原因，研究人员研究了球体在平 
面上的变换，以便有效地压缩法线。Cigolle等。[269]分析各种算 
法的优点和权衡，以及代码样本。他们得出结论，八分圆和球面投 
影是最实用的，最小化误差，同时有效地进行解码和编码。 
Pranckevicius[1432]和 Pesce[1394]讨论了为延迟着色生成G缓 
冲区时的正常压缩 （第20.1节）。其他数据可能具有可用于减少存 
储的属性。例如，正常，切线，和双切向量通常用于法线贴图。当 
这三个矢量相互垂直（不偏斜）时，如果手性一致，则只能存储两 
个矢量，而第三个矢量由交叉乘积导出。更紧凑的是，单个4字节 
四元数与7位w一起保存的旋向性位可以表示基础形成的旋转矩阵 
[494,1114,1154,1381,1639]。为了获得更高的精度，可以省略四 
个四元数值中的最大值，而另外三个值各自以10位存储。剩余的2 
位标识未存储四个值中的哪一个。由于四元数的平方和为 1，我们 
可以从其他三个推导出第四个值[498]。Doghramachi等。[363] 
使用存储轴和角度的切线/比特/正常方案。它也是4个字节，与四 
元数存储相比，需要大约一半的着色器指令才能解码。有关固定速 
率压缩方法的摘要，请参见图 16.23。71616.多边形技术进一步阅 
读和资源Meshlab是一个开源网格可视化和操作系统，它实现了大 
量的算法，包括网格清理，常规推导和简化。Assimp是一个开源 
----------------------- Page 760-----------------------
库，可以读写各种三维文件格式。有关更多软件建议，请参阅本书 
的网站realtimerendering.com。Schneider和 Eberly[1574]提出 
了各种关于多边形和三角形以及伪代码的算法。Luebke的实践调查 
[1091]虽然陈旧，但仍然是简化算法的一个很好的介绍。3D图形的 
详细程度[1092]详细介绍了简化和相关主题。第 17章曲线和曲面 
 “有物质的地方有几何。” - 约翰尼斯开普勒三角形是一个基本的 
原子渲染基元。这是图形硬件调整为快速变成阴影片段并放入帧缓 
冲区的原因。但是，在建模系统中创建的对象和动画路径可以具有 
许多不同的基础几何描述。曲线和曲面可以通过方程精确描述。评 
估这些方程，然后创建三角形组并沿管道向下发送以进行渲染。使 
用曲线和曲面的美感至少有四倍：（1）它们比一组三角形具有更紧 
凑的表示，（2）它们提供可伸缩的几何图元，（3）它们提供比直 
线和平面三角形更平滑和更连续的图元，并且 （4）动画和碰撞检测 
可以变得更简单和更快。紧凑的曲线表示为实时渲染提供了几个优 
势。首先，模型存储可以节省内存 （因此内存缓存效率会有所提高）。 
这对游戏控制台特别有用，游戏控制台通常没有 PC那么多的内存。 
与变换表示表面的网格相比，变换曲面通常涉及更少的矩阵乘法。 
如果图形硬件可以直接接受这种曲面描述，则主机CPU必须发送到 
图形硬件的数据量通常远小于发送三角形网格。诸如PN三角形和 
细分曲面之类的曲线模型描述具有值得的特性，即具有较少多边形 
的模型可以变得更具说服力和逼真度。单个多边形被视为曲面，因 
此在曲面上创建更多顶点。更高顶点密度的结果是更好地照亮表面 
----------------------- Page 761-----------------------
和轮廓边缘。有关示例，请参见图 17.1。曲面的另一个主要优点是 
它们是可扩展的。曲面描述可以变成2个三角形或2000个。曲面 
是飞行水平的细节建模的自然形式：当弯曲的物体接近时，更加密 
集地采样分析表示并生成更多的三角形。对于717718 17.曲线和 
曲面图17.1。 “使命召唤”中的场景：高级战争，使用第 17.6.3节 
中的自适应四叉树算法，使用Catmull-Clark细分曲面渲染人物 
Ilona的脸部。 （图片来自 “使命召唤”，由Activision Publishing， 
Inc。提供，2018。）动画，曲面的优点是需要设置更少数量的点。 
这些点可用于形成曲面，然后可生成平滑的曲面细分。此外，碰撞 
检测可能更有效和准确[939,940]。曲线和曲面的主题一直是整本书 
的主题[458,777,1242,1504,1847]。我们的目标是覆盖在实时渲染 
中常见的曲线和曲面。17.1参数曲线在本节中，我们将介绍参数曲 
线。这些在许多不同的上下文中使用，并且使用许多不同的方法来 
实现。对于实时图形，参数曲线通常用于沿预定义路径移动查看器 
或某些对象。这可能涉及改变位置和方向。但是，在本章中，我们 
只考虑位置路径。有关方向插值的信息，请参见第4.3.2节。另一 
种用途是使头发呈现，如图 17.2所示。假设您希望在一定时间内将 
摄像机从一个点移动到另一个点，而与底层硬件的性能无关。例如， 
假设摄像机应在一秒钟内在这些点之间移动，并且一帧的渲染需要 
50ms。这意味着我们将能够在该秒期间渲染20帧。在更快的计算 
机上，一帧可能只需要25毫秒，这将等于每秒40帧，因此我们想 
要 17.1。参数曲线719图17.2。使用曲面细分立方曲线的头发渲 
----------------------- Page 762-----------------------
染[1274]。 （图片来自 “Nalu”演示，由NVIDIA公司提供。）将 
相机移动到40个不同的位置。找到任意一组点都可以使用参数曲 
线。参数曲线使用某个公式作为参数t的函数来描述点。在数学上， 
我们将其写为p （t），这意味着该函数为t的每个值提供一个点。 
参数t可以属于某个区间，称为域，例如，t∈[a，b]。生成的点是 
连续的，即as。→0然后是 p （t +。）→p （t）。松散地说，这意 
味着如果。是一个微小的数字，然后是 p （t）和p （t +。）是两个 
非常接近的点。在下一节中，我们将从 B'ezier曲线的直观和几何描 
述开始，这是一种常见的参数曲线形式，然后将其置于数学设置中。 
然后我们讨论如何使用分段 B'ezier曲线并解释曲线连续性的概念。 
在第 17.1.4节和第 17.1.5节中，我们将介绍另外两条有用的曲线， 
即立方Hermites和 Kochanek-Bartels样条曲线。最后，我们将使 
用第17.1.2节中的GPU渲染 B'ezier曲线。720 17.曲线和曲面图 
17.3。两点之间的线性插值是直线上的路径（左）。对于七个点， 
右上角显示线性插值，右下角显示某种更平滑的插值。使用线性插 
值最令人反感的是线性段之间的连接处的不连续变化（突然的抖 
动）。17.1.1B'ezier曲线线性插值在两个点p0和 p1之间描绘出 
一条直线的路径。这很简单。请参见图 17.3中的左图。给定这些点， 
以下函数描述线性插值点p（t），其中t是曲线参数，并且t∈[0,1]： 
p （t）=p0 +t （p1.p0）= （1。 t）p0 +tp1。（17.1）参数t 
控制点p （t）将落在线上的位置; p （0）=p0，p （1）=p1，0 <t 
<1给出了p0和 p1之间直线上的一个点。所以，如果我们想在一 
----------------------- Page 763-----------------------
秒钟内以20步的步长将相机从p0移动到p1，那么我们将使用ti = 
i/ （20.1），其中i是帧号 （从0开始到 19结束）。当您仅在两个 
点之间进行插值时，线性插值可能就足够了，但是对于路径上的更 
多点，它通常不会。例如，当插入几个点时，连接两个段的点（也 
称为关节）处的突然变化变得不可接受。这显示在图 17.3的右侧。 
为了解决这个问题，我们进一步采用线性插值的方法，并重复线性 
插值。通过这样做，我们得到了 B'ezier （发音为beh-zee-eh）曲 
线的几何结构。作为历史记录，B'ezier曲线由PauldeCasteljau 
和 PierreB'ezier独立开发，用于法国汽车工业。它们被称为B'ezier 
曲线，因为B'ezier能够在deCasteljau之前公开他的研究，尽管 
deCasteljau在 B'ezier之前写了他的技术报告[458]。首先，为了 
能够重复插值，我们必须添加更多的点。例如，可以使用称为控制 
点的三个点a，b和c。假设我们想要找到p （1/3），即t =1/3 
的曲线上的点。我们使用t =1/3从a＆b和b＆c通过线性插值计 
算两个新点d和e。见图17.4。最后，我们使用17.1从d和e再 
次通过线性插值计算f。参数曲线721图17.4。重复线性插值给出 
B'ezier曲线。该曲线由三个控制点a，b和c定义。假设我们想要 
找到参数t =1/3的曲线上的点，我们首先在a和 b之间进行线性 
插值得到d。接下来，从b和c插入e。最后一点，p （1/3）=f 
是通过在d和e之间插值得到的。t =1/3。我们定义p （t）=f。 
使用这种技术，我们得到以下关系：p （t）= （1.t）d+te = （1.t） 
[ （1.t）a +tb] +t [ （1.t）b+tc] = （1.t）2a+2 （1.t）tb +t2c， 
----------------------- Page 764-----------------------
 （17.2）是抛物线，因为最大t度是2。实际上，给定n +1个控 
制点，结果曲线的度数为 n。这意味着更多的控制点为曲线提供了 
更多的自由度。第一度曲线是直线（称为线性），第二度曲线称为 
二次曲线，第三度曲线称为立方，第四度曲线称为四次曲线，依此 
类推。这种重复或递归线性插值通常被称为 de Casteljau算法 
[458,777]。图17.5显示了使用五个控制点时的示例。为了概括， 
而不是使用点a-f，如在该示例中，使用以下符号。控制点表示为 
pi，因此在该示例中，p0=a，p1=b，并且p2=c。然后，在已 
经应用k次线性插值之后，获得中间控制点 pki。在我们的例子中， 
图17.5。从五个点重复线性插值给出四度 （四次）B'ezier曲线。曲 
线位于控制点的凸包（绿色区域）内，由黑点标记。此外，在第一 
点，曲线与第一点和第二点之间的线相切。同样也适用于曲线的另 
一端。72217.曲线和曲面图17.6。重复线性插值如何对 B'ezier曲 
线起作用的说明。在该示例中，示出了四次曲线的插值。这意味着 
有五个控制点，p0i，i =0,1,2,3,4，显示在底部。应该从下往上读 
取该图，即，p10由权重为1的权重p00形成。t并加上p01加权。 
这一直持续到曲线p （t）的点在顶部获得。 （Goldman[551]之后 
的插图。）我们有p10 =d，p11 =e，p20 =f。n +1个控制点 
的B'ezier曲线可用下面所示的递归公式描述，其中p0i =pi是初 
始控制点：pki （t）= （1.t）pk.1i （t）+tpk.1i+1 （t）， （k= 
1... n，i =0。。n。ķ。（17.3）注意曲线上的点由p （t）=pn0 
 （t）描述。这并不像看起来那么复杂。再次考虑当我们从三个点 
----------------------- Page 765-----------------------
p0，p1和p2构建 B'ezier曲线时会发生什么，它们等于p00，p01 
和p02。三个控制点意味着n=2.为了缩短公式，有时从p中删除 
 “（t）”。在第一步k=1，其给出 p10= （1.t）p0+tp1，并且 
p11= （1.t）p1+tp2。最后，对于k=2，我们得到p20= （1.t） 
p10 +tp11，这与p （t）所寻求的相同。图17.6显示了一般如何 
工作的说明。现在我们已经了解了 B'ezier曲线如何工作的基础知 
识，我们可以看一下相同曲线的更多数学描述。使用 Bernstein多 
项式的 B'ezier曲线如公式17.2所示，可以使用代数公式来描述二 
次 B'ezier曲线。事实证明，每个B'ezier曲线都可以用这样的代数 
公式来描述，这意味着您不需要进行重复插值。这在下面的公式17.4 
中示出，其产生与公式17.3所描述的相同的曲线。B'ezier曲线的 
这种描述称为 Bernstein形式：p （t）=Xni=0Bni （t）pi。（17.4） 
17.1。参数曲线723图17.7。Bernstein多项式，n =1，n =2， 
n=3 （从左到右）。左图显示了线性插值，中间二次插值和右三次 
插值。这些是 Bernstein形式的 B'ezier曲线中使用的混合函数。因 
此，要评估某个t值的二次曲线（中间图），只需找到x轴上的t 
值，然后垂直移动直到遇到三条曲线，这给出了三个控制点的权重。 
注意，当t∈[0,1]时，Bni （t）≥0，并且这些混合函数的对称性： 
Bni （t）=Bnni （1.t）。该函数包含Bernstein多项式，有时也 
称为 B'ezier基函数，Bni （t）=？你 ？ti （1。t）ni=n！我！（我。）！ 
ti （1。t）ni （17.5）第一项，二项式系数，在这个等式中定义在第 
1章的公式 1.6中.Bernstein多项式的两个基本性质如下：Bni （t） 
----------------------- Page 766-----------------------
∈[0， 1]，当t∈[0,1]和Xn i=0Bni （t）=1时。（17.6）第一 
个公式意味着当t也是0时，Bernstein多项式处于0到 1之间的 
区间内第二个公式表示公式17中的所有伯恩斯坦多项式项。对于所 
有不同的曲线度，4总和为 1 （这可以在图17.7中看到）。松散地 
说，这意味着曲线将保持 “接近”控制点 pi。实际上，整个 B'ezier 
曲线将位于控制点的凸包（参见我们的在线线性代数附录）中，其 
遵循方程 17.4和 17.6。在计算曲线的边界区域或体积时，这是一 
个有用的属性。有关示例，请参见图 17.5。在图 17.7中，示出了n 
=1，n=2和n=3的伯恩斯坦多项式。这些也称为混合函数。当 
n=1 （线性插值）时的情况是说明性的，其中它表示曲线y =1。 
t和y =t。这意味着当t =0时，则p （0）=p0，并且当t增加时， 
p0的混合权重减小，而p1的混合权重增加相同的量，保持权重之 
和等于 1.最后，当t =1时，p （1）=p1。通常，它适用于所有 
B'ezier曲线，即p （0）=p0和p （1）=pn，即，端点被内插724 
17.曲线和曲面 （即，在曲线上）。同样，曲线在t =0时与矢量p1.p0 
相切，在t = 1时与 pn.pn.1相切。另一个有用的特性是不是在 
B'ezier曲线上计算点，而是旋转曲线，首先可以旋转控制点，然后 
可以计算曲线上的点。控制点通常比曲线上生成的点少，因此首先 
转换控制点更有效。作为 Bernstein版 B'ezier曲线如何工作的一个 
例子，假设n=2，即，二次曲线。等式 17.4则p （t）=B20p0+ 
B21p1 +B22p2 =？20？t0 （1。t）2p0 +？2 1？t1 （1。t） 
1p1+？22？t2 （1.t）0p2 = （1.t）2p0 +2t （1.t）p1 +t2p2， 
----------------------- Page 767-----------------------
 （17.7），与式17.2相同。请注意，上面的混合函数（1.t）2,2t 
 （1.t）和t2是图 17.7中间显示的函数。以相同的方式，将三次曲 
线简化为p （t）= （1.t）3p0+3t （1.t）2p1+3t2（1.t）p2+t3p3。 
 （17.8）这个等式可以用矩阵形式重写为 p （t）=...1tt2t3？。... 
1000.33003.630.13.31。.........p0p1p2p3。......，（17.9） 
在进行数学简化时有时很有用。通过收集公式 17.4中tk形式的项， 
可以看出每个B'ezier曲线可以用下面的形式写成，称为幂形式，其 
中ci是通过收集项而掉出的点：p （t）=Xn i =0tici。（17.10） 
可以直接区分公式 17.4，以获得B'ezier曲线的导数。重组和收集 
术语后的结果如下[458]所示：ddtp （t）=nnX.1i=0Bn.1i （t） 
 （pi +1.pi）。（17.11）实际上，导数也是B'ezier曲线，但比p 
 （t）低一度。17.1。参数曲线725 B'ezier曲线的潜在缺点是它们 
不通过所有控制点（端点除外）。另一个问题是程度随着控制点的 
数量而增加，使得评估越来越昂贵。对此的解决方案是在每对后续 
控制点之间使用简单的低度曲线，并确保这种分段插值具有足够高 
的连续性。这是第 17.1.3-17.1.5节的主题。理性 B'ezier曲线虽然 
B'ezier曲线可用于许多事物，但它们没有那么多的自由度 - 只有 
控制点的位置可以自由选择。而且，并非每条曲线都可以用 B'ezier 
曲线描述。例如，圆圈通常被认为是一个简单的形状，但它不能由 
一个或一组B'ezier曲线定义。一种替代方案是有理B'ezier曲线。 
这种类型的曲线由公式 17.12中所示的公式描述：p （t）=Pni=0 
wiBn Pi （t）pini=0wiBni （t）。（17.12）分母是伯恩斯坦多 
----------------------- Page 768-----------------------
项式的加权和，而分子是标准B'ezier曲线的加权版本（公式 17.4）。 
对于这种类型的曲线，用户具有权重wi作为附加自由度。关于这些 
曲线的更多信息可以在Hoschek和 Lasser [777]以及 Farin的书 
[458]中找到。Farin还描述了如何通过三条有理 B'ezier曲线描述 
圆。17.1.2GPU上的有界 B'ezier曲线将呈现用于在GPU上渲染 
B'ezier曲线的方法[1068,1069]。具体地，目标是 “有界 B'ezier 
曲线”，其中曲线与第一和最后控制点之间的直线之间的区域被填 
充。通过使用专门的像素着色器渲染三角形，有一种非常简单的方 
法。我们使用二次方，即二次B'ezier曲线，控制点 p0，p1和p2。 
如果我们将这些顶点的纹理坐标设置为t0 = （0,0），t1 = （0.5,0） 
和t2 = （1,1），在渲染三角形时，纹理坐标将照常插补？p0p1p2。 
我们还为每个像素评估三角形内的以下标量函数，其中u和v是插 
值纹理坐标：f （u，v）=u2。v。（17.13）然后，像素着色器确 
定像素是在内部 （f （u，v）<0）还是在外面。如图 17.8所示。使 
用此像素着色器渲染透视投影三角形时，我们将获得相应的投影 
B'ezier曲线。Loop和 Blinn[1068,1069]给出了这方面的证明。例 
如，这种类型的技术可用于渲染TrueType字体。如图17.9所示。 
Loop和 Blinn还显示了如何渲染有理二次曲线72617.曲线和曲面 
10.5000.51uvv=u2f （u，v）<0f （u，v）>0t0t1t2p0p1 
p2图17.8。有界 B'ezier曲线渲染。左：曲线以规范纹理空间显示。 
右：曲线在屏幕空间中渲染。如果条件f （u，v）≥0用于消除像素， 
则浅蓝色区域将由渲染产生。图17.9。e由几条直线和二次B'ezier 
----------------------- Page 769-----------------------
曲线 （左）表示。在中间，这种表示被 “细分”成几个有界 B'ezier 
曲线（红色和蓝色）和三角形（绿色）。最后一封信显示在右边。 
 （经MicrosoftCorporation许可转载。）曲线和三次曲线，以及 
如何使用此表示进行抗锯齿处理。由于文本呈现的重要性，该领域 
的研究仍在继续。有关相关算法，请参见第 15.5节。17.1。3连续 
性和分段 B'ezier曲线假设我们有两条B'ezier曲线是立方的，即每 
个由四个控制点定义。第一条曲线由qi定义，第二条曲线由 ri定义， 
i=0,1,2,3。为了连接曲线，我们可以设置q3=r0。这一点被称为 
联合。但是，如图 17.10所示，使用这种简单的技术，接头将不会 
平滑。由几个曲线片（在这种情况下为两个）形成的复合曲线称为 
分段 B'ezier曲线，在此表示为p （t）。此外，假设我们想要p （0） 
=q0，p （1）=q3 =r0，并且p （3）=r3。因此，当我们达到 
q0，q3=r0和r3时的时间是t0 =0.0,17.1。参数曲线727图17.10。 
该图显示了两个立方B'ezier曲线 （每个四个控制点）之间从左到右 
的C0，G1和C1连续性。顶行显示控制点，底行显示曲线，左曲 
线为 10个采样点，右侧为20个采样点。以下时间点对用于此示例： 
 （0.0，q0）， （1.0，q3）和 （3.0，r3）。在C0连续性的情况下， 
连接处突然出现抖动（其中q3 =r0）。通过使连接处的切线平行 
 （并且长度相等），可以改善G1。虽然，自3.0。1.06=1.0。0.0， 
这不给C1连续性。这可以在样本点突然加速的连接处看到。要实 
现C1，连接处的右切线必须是左切线的两倍。t1 =1.0，t2 =3.0。 
有关表示法，请参见图 17.10。从上一节我们知道 B'ezier曲线是为 
----------------------- Page 770-----------------------
t∈[0,1]定义的，所以这对qi定义的第一条曲线段来说效果很好， 
因为q0的时间是0.0，q3的时间是1.0。但是当1.0 <t≤3.0时会 
发生什么？答案很简单：我们必须使用第二个曲线段，然后将参数 
区间从[t1，t2]转换并缩放到[0,1]。这是使用以下公式完成的：t'=t。 
t1t2。t1。（17.14）因此，t'被输入由ri定义的 B'ezier曲线段。 
这很容易概括为将几个 B'ezier曲线拼接在一起。连接曲线的更好方 
法是使用在 B'ezier曲线的第一个控制点处切线平行于q1的事实。 
q0 （第17.1.1节）。类似地，在最后一个控制点，三次曲线与q3 
相切。Q2。可以看到这种行为72817.图17.5中的曲线和曲面。因 
此，要使两条曲线在切口处切向连接，第一条曲线和第二条曲线的 
切线应该平行。更正式地说，以下应该成立：（r1.r0）=c （q3.q2）， 
对于c>0. （17.15）这仅仅意味着输入切线q3。q2，在关节处应 
与输出切线 r1具有相同的方向。R0。在公式17.15中使用由公式 
17.16[458]定义的c，可以实现甚至更好的连续性：c=t2。t1t1。 
t0。 （17.16）这也显示在图 17.10中。如果我们改为设置t2 =2.0， 
则c=1.0，所以当每个曲线段上的时间间隔相等时，输入和输出切 
线矢量应该相同。但是，当t2 =3.0时，这不起作用。曲线看起来 
相同，但p （t）在复合曲线上移动的速度不会平滑。公式17中的 
常数c。16负责这一点。使用分段曲线的一些优点是可以使用较低 
度曲线，并且得到的曲线将通过一组点。在上面的示例中，对于两 
个曲线段中的每一个使用三度，即立方度。通常使用立方曲线，因 
为那些是可以描述S形曲线的最低度曲线，称为拐点。得到的曲线 
----------------------- Page 771-----------------------
p （t）对点q0，q3 =r0和 r3进行插值，即通过。此时，通过实 
例介绍了两个重要的连续性措施。下面是曲线连续性概念的稍微数 
学表示。对于一般的曲线，我们使用Cn表示法来区分关节处的不 
同类型的连续性。这意味着所有第n个一阶导数在整个曲线上应该 
是连续的且非零的。C0的连续性意味着该段应该在同一点处连接， 
因此线性插值满足该条件。本节的第一个例子就是这种情况。C1的 
连续性意味着如果我们在曲线上的任何点（包括关节）得到一次， 
结果也应该是连续的。这是本节第三个例子的情况，其中使用了公 
式 17.16。还有一种表示为Gn的度量。我们以G1 （几何）连续性 
为例。为此，来自在关节处相遇的曲线段的切向量应该是平行的并 
且具有相同的方向，但是假定长度没有任何关系。换句话说，G1的 
连续性比C1弱，并且C1的曲线总是G1，除非两条曲线的速度在 
曲线连接的点处变为零，并且它们在连接之前具有不同的切线。几 
何连续性的概念可以扩展到更高的维度。图 17.10中的中间插图显 
示了G1连续性。17.1。参数曲线7292t3-3t2+1-2t3+3t2t3 
-2t2 +tt3-t2图17.11。Hermite三次插值的混合函数。注意切 
线的混合函数的不对称性。否定混合函数t3。公式17.17中的t2 
和m1将给出对称的外观。17.1.4三次 Hermite插值 B'ezier曲线 
有利于描述平滑曲线构造背后的理论，但有时无法预测。在这个部 
分，我们将呈现立方 Hermite插值，这些曲线往往更容易控制。原 
因在于，不是给出四个控制点来描述三次 B'ezier曲线，而是通过起 
点和终点 p0和 p1以及起点和终点切线 m0和 m1来定义三次 
----------------------- Page 772-----------------------
Hermite曲线。Hermite插值，p （t），其中t∈[0,1]，是p （t） 
= （2t3.3t2 +1）p0 + （t3.2t2 +t）m0 + （t3.t2）m1 + （.2t3 
+3T2）P1。（17.17）我们还将p （t）称为Hermite曲线段或三 
次样条曲线段。这是一个三次插值，因为t3是上式中混合函数中的 
最高指数。对于该曲线如下：p （0）=p0，p （1）=p1，.p.t （0） 
=m0，.p .t （1）=m1。（17.18）这意味着Hermite曲线内插 
p0和 p1，这些点的切线为m0和 m1。公式17.17中的混合函数 
如图 17.11所示，它们可以从公式 17.4和 17.18中导出。立方 
Hermite插值的一些例子可以在图 17.12中看到。所有这些示例都 
插入相同的点，但具有不同的切线。另请注意，不同长度730 17. 
曲线和曲面图17.12。Hermite插值。曲线由两个点p0和p1以及 
每个点处的切线m0和m1定义。切线的结果不同;较长的切线对整 
体形状有较大影响。立方 Hermite插值用于渲染 Nalu​ ​ 演示中 
的头发[1274]。见图 17.2。粗控制头发用于动画和碰撞检测，计算 
切线，并对三次曲线进行细分和渲染。17.1。5Kochanek-Bartels 
曲线在两个以上的点之间进行插值时，可以连接多个Hermite曲线。 
但是，在执行此操作时，在选择提供不同特征的共享切线方面存在 
自由度。在这里，我们将介绍一种计算此类切线的方法，称为 
Kochanek-Bartels曲线。假设我们有n个点，p0，....。。，pn.1， 
应该用 n插值。1Hermite曲线段。我们假设每个点只有一个切线， 
我们开始看 “内部”切线，m1,. 。。，mn.2。pi处的切线可以被 
计算为两个和弦的组合[917]：pi。pi.1和pi +1。pi，如图17.13 
----------------------- Page 773-----------------------
左侧所示。首先，引入张力参数a，其修改切向量的长度。这可以 
控制曲线在关节处的锐度。切线计算为mi =1。a2.. （pi.pi.1）+ 
 （pi+1.pi）？。 （17.19）图17.13右侧的顶行显示了不同的张力 
参数。默认值为a =0;更高的值会产生更尖锐的弯曲（如果a> 1， 
则会有 17.1。参数曲线731图17.13。计算切线的一种方法是使用 
和弦的组合 （左）。右上角显示三条曲线具有不同的张力参数 （a）。 
左曲线具有≈1，这意味着高张力;中间曲线具有≈0，这是默认张力; 
右曲线具有≈1，这是低张力。右边两行曲线的底行显示不同的偏置 
参数。左边的曲线有负偏差，右边的曲线有正偏差。在关节处循环）， 
负值在关节附近产生较少的拉紧曲线。其次，引入偏差参数 b，其 
影响切线的方向（并且间接地影响切线的长度）。使用张力和偏差 
给出mi= （1.a）（1+b）2 （pi.pi.1）+ （1.a） （1.b）2 （pi+1.pi）， 
 （17.20）其中默认值为b=0.正偏差给出更多指向和弦pi的弯曲。 
pi.1和负偏差给出了更多指向另一个和弦的弯曲：pi +1。PI。这 
显示在图 17.13右侧的底行。用户可以设置张力和偏置参数，也可 
以让它们具有默认值，从而产生通常称为Catmull-Rom样条曲线 
[236]。第一个和最后一个点的切线也可以用这些公式计算，其中一 
个和弦只是设置为零的长度。控制关节行为的另一个参数可以合并 
到切线方程[917]中。然而，这需要在每个关节处引入两个切线，一 
个输入，表示为si （用于源），一个输出表示为di （用于目的地）。 
见图17.14。注意，pi和pi+1之间的曲线段使用切线di和si+1。 
切线计算如下，其中c是连续性参数：si=1。c2 （pi.pi.1）+1+ 
----------------------- Page 774-----------------------
c2 （pi +1.pi），di =1+c2 （pi.pi.1）+1。c2 （pi +1.pi）。 
 （17.21）同样，c=0是默认值，这使得si=di。设置c=.1给出 
si =pi。pi.1，和di =pi +1。pi，在关节处产生一个尖角，这只 
是C0。增加c的值使得si和di越来越相似。对于c =0,732 17. 
曲线和曲面图17.14。Kochanek-Bartels曲线的传入和传出切线。 
在每个控制点pi处，还示出了其时间ti，其中对于所有i，ti>ti.1。 
那么si =di。当达到c =1时，我们得到si =pi+1。pi，和di = 
pi。pi.1。因此，连续性参数c是向用户提供更多控制的另一种方式， 
并且如果需要，它使得可以在关节处获得尖角。张力，偏差和连续 
性的组合，其中默认参数值是a =b=c=0，是si= （1.a）（1+ 
b） （1.c）2 （pi.pi.1） + （1.a） （1.b） （1+c）2 （pi+1.pi）， 
di= （1.a） （1+b） （1+c）2 （pi.pi.1） + （1.a） （1.b） （1.c） 
2 （pi +1.pi）。（17.22）方程17.20和 17。22仅当所有曲线段 
使用相同的时间间隔长度时才起作用。为了考虑曲线段的不同时间 
长度，必须调整切线，类似于第17.1.3节中的操作。调整后的切线， 
表示为s'i和d'i，是s'i=si2？i？i.1+？i和d'i=di2？i.1？i.1+？ 
i，（17.23） ）其中？i=ti +1。TI。17.1.6B样条在这里，我们 
将简要介绍 B样条的主题，我们将特别关注立方均匀 B样条。通常， 
B样条与B'ezier曲线非常相似，并且可以表示为t （使用移位基函 
数），βn （由控制点加权）和ck的函数：例如，sn （t） =Xkckkn 
 （t.k）。（17.24）在这种情况下，这是一条曲线，其中t是x轴， 
sn （t）是y轴，并且控制点是简单均匀间隔的y值。有关更广泛的 
----------------------- Page 775-----------------------
报道，请参阅 KillerB[111]，Farin[458]以及Hoschek和 Lasser 
[777]的文章。17.1。参数曲线733ci-1w0ciw1w2ci +1ci +2 
w3 t ---- 图17.15。左：β3 （t）基函数显示为脂肪黑色曲线， 
由两个分段立方函数 （红色和绿色）构成。|t|时使用绿色曲线 <1， 
当1≤|t|时的红色曲线 <2，曲线在其他地方为零。右：使用四个控 
制点创建曲线段，ck，k∈{i。1，i，i +1，i +2}，我们只得到ci 
和ci +1的t坐标之间的曲线.α被输入w函数来评估基函数，这些 
值是然后乘以相应的控制点。最后，所有的值都加在一起，这给了 
我们曲线上的一个点。见图 17.16。（Ruijters等人[1518]之后右图）。 
在这里，我们将按照 Ruijters等人的介绍。[1518]并呈现均匀立方 
B样条的特殊情况。基函数β3 （t）由三部分拼接在一起：β3 （t） 
=........0，|t | ≥2,16 （2。|t |）3,1≤|t | <2,23。12|t |2 （2。 
|t |），|t | <1. （17.25）这个基函数的构造如图17.15左侧所示。 
此函数在任何地方都具有C2连续性，这意味着如果将多个 B样条 
曲线段拼接在一起，则复合曲线也将为C2。三次曲线具有C2连续 
性，并且通常，度数 n的曲线具有Cn.1连续性。通常，基函数如 
下创建。β0 （t）是 “平方”函数，即，如果|t|则为 1 <0.5，如果 
|t|则为0.5 =0.5，其他地方为0。下一个基函数β1 （t）是通过积 
分β0 （t）创建的，它给出了帐篷函数。之后的基函数是通过积分β 
1 （t）创建的，它提供了更平滑的函数，即C1。重复此过程以获得 
C2，依此类推。如何评估曲线段如图 17.15右侧所示，其公式为s3 
 （i+α）=w0 （α）ci.1 +w1 （α）ci+w2 （α）ci +1+w3 （α） 
----------------------- Page 776-----------------------
CI+2。 （17.26）注意，任何时候只使用四个控制点，这意味着曲 
线具有局部支持，即需要有限数量的控制点。函数wk （α）使用β3 
 （）定义为w0 （α）=β3 （.α.1），w1 （α）=β3 （.α），w2 （α） 
=β3 （1.α），w3 （α）=β3 （2.α）。（17.27）734 17。曲线和 
曲面图17.16。在该示例中，控制点ck （绿色圆圈）定义了均匀的 
三次样条。只有两条脂肪曲线是分段B样条曲线的一部分。左（绿 
色）曲线由最左边的四个控制点定义，右（红色）曲线由最右边的 
四个控制点定义。曲线在t =1处相遇，具有C2连续性。Ruijters 
等。[1518]表明这些可以改写为w0 （α）=16 （1.α）3，w1 （α） 
=23。12α2 （2.α），w2 （α）=23。12 （1.α）2 （1 +α）， 
w3 （α）=16α3。（17.28）在图17.16中，我们显示了将两个均 
匀的三次B样条曲线拼接成一个的结果。主要优点是曲线是连续的， 
具有与基函数β （t）相同的连续性，在立方B样条的情况下是C2。 
从图中可以看出，无法保证曲线将通过任何控制点。请注意，我们 
还可以为x坐标创建一个 B样条，这将在平面中给出一般曲线（而 
不仅仅是一个函数）。然后得到的二维点将是 （sx3 （i+α），sy3 
 （i +α）），即，简单地对等式17.26的两个不同的评估，一个用 
于x，一个用于y。我们已经展示了如何仅使用均匀的 B样条。如果 
控制点之间的间距不均匀，则方程变得更精细但更灵活 
[111,458,777]。17.2参数曲线曲面参数曲线的自然延伸是参数曲 
面。一个类比是三角形或多边形是线段的延伸，其中我们从一个到 
两个17.2。参数曲面735尺寸。参数曲面可用于对具有曲面的对象 
----------------------- Page 777-----------------------
进行建模。参数曲面由少量控制点定义。参数曲面的曲面细分是评 
估几个位置处的曲面表示的过程，并将它们连接起来以形成接近真 
实曲面的三角形。这样做是因为图形硬件可以有效地渲染三角形。 
然后，在运行时，可以根据需要将曲面细分为多个三角形。因此， 
参数曲面非常适合在质量和速度之间进行权衡，因为更多三角形需 
要更多时间来渲染，但会提供更好的阴影和轮廓。参数化曲面的另 
一个优点是可以对控制点进行动画处理，然后可以对曲面进行曲面 
细分。这与直接制作大型三角形网格的动画形成对比，这可能更昂 
贵。本节首先介绍 B'ezier贴片，它是具有矩形域的曲面。这些也称 
为张量积B'ezier曲面。然后呈现 B'ezier三角形，其具有三角形域， 
然后在第 17.2.3节中讨论连续性。在第 17.2.4节和第 17.2.5节中， 
提出了两种方法，用 B'ezier三角形替换每个输入三角形。这些技术 
分别称为 PN三角形和 Phong镶嵌。最后，B样条补丁见 17.2.6 
节。17.2.1B'ezier补丁第 17.1.1节介绍的B'ezier曲线的概念可以 
从使用一个参数扩展到使用两个参数，从而形成曲面而不是曲线。 
让我们从将线性插值扩展到双线性插值开始。现在，我们使用四个 
点，称为a，b，c和d，而不仅仅使用两个点，如图17.17所示。 
我们现在使用两个参数（u，v），而不是使用一个名为t的参数。 
使用u线性插值a＆b和c＆d给出e和f：e= （1.u）a +ub，f = 
 （1.u）c +ud。（17.29）图17.17。使用四点进行双线性插值。 
736 17.曲线和曲面图17.18。左：由9个控制点pij定义的双二次 
B'ezier曲面。右：为了在B'ezier曲面上生成一个点，首先使用最 
----------------------- Page 778-----------------------
近控制点的双线性插值创建四个点p1ij。最后，点表面p （u，v） 
=p200从这些创建的点进行双线性插值。接下来，线性插值点，e 
和f在另一个方向上线性插值，使用v。这产生双线性插值：p （u， 
v）= （1.v）e+vf = （1.u） （1.v）a +u （1.v）b+ （1.u）vc + 
uvd。 （17.30）请注意，这与用于纹理映射的双线性插值的方程式 
相同（第 179页的公式6.1）。公式17.30描述了最简单的非平面 
参数曲面，其中使用不同的（u，v）值生成表面上的不同点。域， 
即有效值集合，是（u，v）∈[0,1]×[0,1]，这意味着u和v都应属 
于[0,1]。当域是矩形时，生成的表面通常称为补丁。为了从线性插 
值扩展 B'ezier曲线，添加了更多的点并重复插值。补丁可以使用相 
同的策略。假设九点，使用排列在3×3网格中。如图17.18所示， 
其中也显示了符号。为了从这些点形成双二次B'ezier贴片，我们首 
先需要进行四次插值以创建四个中间点，如图 17.18所示。接下来， 
表面上的最终点是从先前创建的点进行双线性插值。上面描述的重 
复双线性插值是deCasteljau算法对补丁的扩展。此时我们需要表 
面上的最后一点是从先前创建的点进行双线性插值。上面描述的重 
复双线性插值是deCasteljau算法对补丁的扩展。此时我们需要表 
面上的最后一点是从先前创建的点进行双线性插值。上面描述的重 
复双线性插值是deCasteljau算法对补丁的扩展。此时我们需要定 
义一些符号。表面的程度是n。控制点是pi，j，其中i和j 属于[0。。。 
N]。因此， （n+1）2个控制点用于度数n的补丁。请注意，控制 
点应该用0，即p0i，j 上标，但这通常被省略，有时我们使用下标 
----------------------- Page 779-----------------------
ij而不是 i，j，当没有混淆时。使用de Casteljau算法的 B'ezier 
补丁在下面的等式中描述：17.2。参数曲面737图17.19。不同方 
向的不同程度。deCasteljau [patches]：pki，j （u，v）= （1.u） 
 （1.v）pk.1i，j +u （1.v）pk.1i，j +1+ （1。 u）vpk.1 i+1， 
j +uvpk.1i+1，j +1k=1。。。n，i=0。。。n。k，j =0。。。 
n。ķ。（17.31）类似于B'ezier曲线，B'ezier贴片上（u，v）处 
的点是pn0,0 （u，v）。B'ezier补丁也可以用 Bernstein多项式用 
Bernstein形式描述，如公式 17.32所示：Bernstein[patch]：p （u， 
v）=Xm i=0 Bmi （u）Xnj =0 Bnj （v）pi，j =Xm i=0Xn 
j =0 Bmi （u）Bnj （v）pi，j，=Xm i =0Xnj =0？我？你好 
吗？ui （1.u）m.ivj （1.v）n.jpi，j。 （17.32）注意，在公式 17.32 
中，有两个参数，m和n，表面的程度。 “复合”度有时表示为 m 
×n。通常m=n，这简化了实现。例如，m>n的结果是先进行双 
线性插值n次，然后线性插值 m。n次。如图 17.19所示。通过将 
其重写为p （u，v）=Xm i =0 Bmi （u）Xnj =0 Bnj （v）pi， 
j =X mi =0 Bmi （u），找到对等式17.32的不同解释气（v）。 
 （17.33）在这里，qi （v）=Pnj =0Bnj （v）pi，j，i=0。。.M。 
从公式 17.33的最后一行可以看出，当我们修正一个v值时，这只 
是一个 B'ezier曲线。假设v =0.35，可以从B'ezier曲线计算点 
qi （0.35），然后公式17.33描述B'ezier曲面上的B'ezier曲线， 
对于v =0.35。738 17.曲线和曲面接下来，将介绍B'ezier贴片的 
一些有用特性。通过设置（u，v）= （0,0），（u，v）= （0,1）， 
----------------------- Page 780-----------------------
 （u，v）= （1,0）和 （u，v）= （1,1）在公式 17.32中，很容易证 
明B'ezier曲面内插，即通过角控制点p0,0，p0，n，pn，0和pn， 
n。此外，贴片的每个边界由边界上的控制点形成的度数n的B'ezier 
曲线描述。因此，拐角控制点处的切线由这些边界B'ezier曲线定义。 
每个拐角控制点都有两个切线，每个切线在u和v方向上​ ​ 各一 
个。与 B'ezier曲线的情况一样，补丁也位于其控制点的凸包内，并 
且Xm i =0Xnj =0 Bmi （u）Bnj （v）=1 （17.34）for （u ， 
v）∈[0,1]×[0,1]。最后，旋转控制点然后在补丁上生成点在数学上 
与（然而通常更快）在补丁上生成点然后旋转它们相同。部分微分 
方程 17.32给出[458]下面的等式：导数[补丁]：。p （u，v）.u=m 
Xnj =0 mX.1i =0 Bm.1i （u）Bnj （v） [pi+1，j。pi，j] ,. p 
 （u，v）.v=nXmi=0nX.1j =0Bmi （u）Bn.1j （v）[pi，j + 
1。pi，j]。 （17.35）可以看出，贴片的程度在分化的方向上减少一 
个。然后将非标准化法向量形成为 n （u，v）=。p （u，v）.u×.p 
 （u，v）.v。（17.36）在图17.20中，显示了控制网格与实际的 
B'ezier补丁。移动控制点的效果如图 17.21所示。理性 B'ezier补 
丁正如B'ezier曲线可以扩展到有理B'ezier曲线（第17.1.1节）， 
从而引入更多自由度，B'ezier补丁也可以扩展到理性 B 'ezier 
patch：p （u，v）=Pmi =0 Pnj =0wi，jBm i （u）Bnj （v） 
pi，j Pmi =0 Pnj =0wi，jBm i （u）Bnj （v）。（17.37）有 
关此类补丁的信息，请参阅 Farin的书[458]和 Hochek和 Lasser 
的书[777]。同样，有理B'ezier三角形是 B'ezier三角形的延伸， 
----------------------- Page 781-----------------------
接下来治疗 17.2。参数曲面739图17.20。左：控制4×4 B'ezier 
贴片的网格，程度为3×3。中间：在表面上生成的实际四边形。右 
图：阴影B'ezier补丁。图17.21。这组图像显示了移动一个控制点 
时B'ezier补丁发生了什么。大多数变化都在移动的控制点附近。 
740 17.曲线和曲面图17.22。B'ezier三角形的控制点，三度（立 
方）。17.2.2B'ezier三角形尽管三角形通常被认为是比矩形更简单 
的几何图元，但对于B'ezier曲面则不是这样：B'ezier三角形不像 
B'ezier曲面那么简单。这种类型的补丁值得展示，因为它用于形成 
PN三角形和用于Phong镶嵌，快速而简单。请注意，某些游戏引 
擎（如虚幻引擎，Unity和 Lumberyard）支持Phong镶嵌和 PN 
三角形。控制点位于三角形网格中，如图 17.22所示。B'ezier三角 
形的度数是 n，这意味着每边有n +1个控制点。这些控制点表示 
为p0i，j，k，有时缩写为pijk。注意，对于所有控制点，i +j +k 
=n，并且i，j，k≥0。因此，控制点的总数是 nX+1x =1x = （n 
+1）（n +2）2。（17.38）B'ezier三角形也基于重复插值并不 
奇怪。但是，由于域的三角形形状，必须使用重心坐标 （第22.8节） 
进行插值。回想一下三角形内的一个点？p0p1p2，可以描述为p 
 （u，v）=p0+u （p1.p0）+v （p2.p0）= （1.uv）p0+up1+ 
vp2，其中（u，v）是重心坐标。对于三角形内的点，必须满足以 
下条件：u≥0，v≥0和 1。 （u+v）≥0。u+v≤1。基于此，B'ezier 
三角形的deCasteljau算法是deCasteljau [三角形]：pli，j，k 
 （u，v）=upl.1i+1，j，k+vpl.1i，j +1，k+ （1.u.v）pl.1i， 
----------------------- Page 782-----------------------
j，k+1，l =1。。。n，i +j +k =n。湖 （17.39）在（u，v） 
的B'ezier三角形上的最后一点是pn000 （u，v）。伯恩斯坦形式 
的B'ezier三角形是17.2。参数曲面741图17.23。左：镶嵌的B'ezier 
三角形的线框。右：阴影表面与控制点一起。伯恩斯坦[三角形]：p 
 （u，v）=X i +j +k =nBnijk （u，v）pijk。（17.40）伯恩斯 
坦多项式现在依赖于u和v，因此计算方式不同，如下所示：Bnijk 
 （u，v）=n！我！Ĵ！k来！uivj （1.u.v）k，i+j +k=n。 （17.41） 
偏导数是[475]导数[三角形]：。p （u，v）.u=Xi+j +k=n.1nBn.1 
ijk （u，v）..pi+1，j，k。pi，j，k+1？，.p （u，v）.v=Xi+ 
j +k=n.1nBn.1ijk （u，v）..pi，j +1，k。pi，j，k+1？。（17.42） 
B'ezier三角形的一些不令人惊讶的特性是它们插入 （通过）三个角 
控制点，并且每个边界是由该边界上的控制点描述的 B'ezier曲线。 
而且，表面位于控制点的凸包中。AB'ezier三角形如图17.23所示。 
17.2.3连续性从 B'ezier曲面构造复杂物体时，人们经常想要将几 
个不同的 B'ezier表面缝合在一起以形成一个复合表面。为了获得良 
好的结果，必须注意确保在表面上获得合理的连续性。这与第 17.1.3 
节中的曲线精神相同。假设应将两个双三次 B'ezier贴片拼接在一 
起。它们各有4×4个控制点。如图 17.24所示，其中左侧贴片具有 
控制点aij，右侧具有控制点bij，0≤i，j≤3。为确保C0连续性，贴 
片必须共享相同的控制点。 border，即a3j =b0j。74217.曲线和 
曲面图17.24。如何用C1连续性拼接两个 B'ezier贴片。粗线上的 
所有控制点必须共线，并且它们必须在两个段长度之间具有相同的 
----------------------- Page 783-----------------------
比率。请注意，a3j=b0j以获取补丁之间的共享边界。这也可以在 
图17.25的右侧看到。但是，这还不足以获得漂亮的复合材料表面。 
相反，将提出一种简单的技术，给出C1连续性[458]。为此，我们 
必须约束最靠近共享控制点的两行控制点的位置。这些行是a2j和 
b1j。对于每个j，点a2j，b0j和b1j必须是共线的，也就是说，它 
们必须位于一条直线上。而且，它们必须具有相同的比率，这意味 
着||a2j。b0j||=k||b0j。b1j||。这里，k是常数，并且对于所有 
j 必须相同。示例如图 17.24和 17.25所示。这种结构消耗了设置控 
制点的许多自由度。将四个贴片拼接在一起时，可以更清楚地看到 
这一点，共享一个共同的角落。结构如图 17.26所示。结果显示在 
该图的右侧，其中显示了共享控制点周围的八个控制点的位置。这 
9个点必须全部位于同一平面上，并且必须形成双线性贴片，如图 
17.17所示。如果一个人对拐角处的G1连续性感到满意 （并且仅在 
那里），那么使九个点共面就足够了。这使用较少的自由度。B'ezier 
三角形的连续性通常更复杂，以及B'ezier曲面和三角形的G1条件 
[458,777]。在构建许多B'ezier曲面的复杂对象时，通常很难看到 
跨越所有边界的合理连续性。对此的一个解决方案是转向细分曲面， 
在第 17.5节中处理。请注意，跨边界的漂亮纹理需要C1连续性。 
对于反射和阴影，获得G1连续性的合理结果。C1或更高可以获得 
更好的结果。一个例子如图 17.25所示。在接下来的两个小节中， 
我们将介绍两种利用三角形顶点法线的方法，以得到每个输入（平 
面）三角形的 B'ezier三角形。17.2。参数曲面743图17.25。左 
----------------------- Page 784-----------------------
栏显示两个 B'ezier补丁仅以C0连续性连接。显然，补丁之间存在 
着色不连续性。右栏显示了与C1连续性相结合的类似补丁，看起 
来更好。在顶行中，虚线表示两个连接的补丁之间的边界。在右上 
方，黑线表示连接补片的控制点的共线性。图17.26。 （a）将四个 
补丁 F，G，H和 I拼接在一起，其中所有补丁共享一个角。（b） 
在垂直方向上，三组三个点（每条粗线）必须使用相同的比率 k。 
这种关系在这里没有显示;看到最右边的人物。对（c）进行类似的 
处理，其中，在水平方向上，两个贴片必须使用相同的比率l。 （d） 
拼接在一起时，所有四个贴片必须垂直使用比率k，并且水平使用l。 
 （e）显示结果，其中正确计算了最接近 （和包括）共享控制点的九 
个控制点的比率。74417。曲线和曲面17.2.4PN三角形给定一个 
输入三角形网格，每个顶点都有法线，Vlachos等人的 PN三角形 
方案的目标。[1819]与仅使用三角形相比构建更好看的表面。字母 
 “PN”是 “点和正常”的缩写，因为这是生成曲面所需的所有数据。 
它们也被称为N-patches。该方案试图通过创建曲面来替换每个三 
角形来改善三角形网格的阴影和轮廓。曲面细分硬件能够动态制作 
每个曲面，因为曲面细分是从每个三角形的点和法线生成的，不需 
要邻居信息。有关示例，请参见图 17.27。这里介绍的算法建立在 
van Overveld和Wyvill [1341]的工作之上。图17.27。列显示同 
一模型的不同细节级别。原始三角形数据由414个三角形组成，如 
左图所示。中间模型有 3,726个三角形，而右边有20,286个三角 
形，都是用所提出的算法生成的。请注意轮廓和阴影如何改善。底 
----------------------- Page 785-----------------------
行显示线框中的模型，显示每个原始三角形生成相同数量的子三角 
形。（型号由idSoftware提供。来自ATITechnologies Inc.演示 
的图片。）17.2。参数曲面745图17.28。如何使用p300处的正 
常n200和两个角点 p300和 p030计算 B'ezier点 p210。假设我 
们有一个顶点为 p300，p030和 p003的三角形，法线为n200， 
n020和n002。基本思想是使用此信息为每个原始三角形创建一个 
三次B'ezier三角形，并从B'ezier三角形生成任意数量的三角形。 
要缩短表示法，将使用w =1.uv。立方B'ezier三角形由p （u，v） 
=Xi+j +k=3B3ijk u（，v）pijk=u3p300+v3p030 +w3p003 
+ 3u2vp210 + 3u2wp201 + 3uv2p120 + 3v2wp021 + 
3vw2p012+3uw2p102给出+6uvwp111。（17.43）见图 17.22。 
为了确保两个PN三角形之间的边界处的C0连续性，可以从拐角控 
制点和那些拐角处的法线确定边缘上的控制点。（假设法线在相邻 
三角形之间共享）。假设我们想要使用控制点 p300，p030和p300 
处的正常 n200来计算p210，如图 17.28所示。只需取点23p300 
+ 1 3p030 并将其沿法线方向 n200 投射到由 p300和 n200 
[457,458,1819]定义的切平面上。假设归一化法线，则点 p210被 
计算为p210 =13...2p300 +p030。（n200· （p030.p300）） 
n200？。（17.44）其他边界控制点可以类似地计算，因此仅保留 
计算内部控制点p111。这是如下面的等式所示完成的，并且该选择 
遵循二次多项式[457,458]：p111=14 （p210+p120+p102+ 
p201+p021+p012）。16 （p300+p030+p003）。 （17.45） 
----------------------- Page 786-----------------------
而不是使用公式 17.42计算表面上的两条切线，而不是正常的， 
Vlachos等。[1819]选择使用746插值法线17.曲线和曲面图17.29。 
该图说明了为什么需要法线的二次插值，以及为什么线性插值不够。 
左列显示了使用法线的线性插值时会发生什么。当法线描述凸面（顶 
部）时，这种方法可以正常工作，但当表面有拐点（底部）时会发 
生故障。右栏说明了二次插值。（van Overveld和Wyvill之后的 
插图[1342]。）二次方案，如下所示：n （u，v）=X i+j +k=2 
B2ijk （u，v）nijk=u2n200+v2n020 +w2n002 +2 （uvn110 
+uwn101+vwn011）。 （17.46）这可以被认为是二度的 B'ezier 
三角形，其中控制点是六个不同的法线。在公式17.46中，度数的 
选择，即二次方，是很自然的，因为导数比实际的B'ezier三角形低 
一度，并且因为法线的线性插值不能描述拐点。见图 17.29。为了 
能够使用公式 17.46，需要计算正常控制点n110，n101和n011。 
一个直观但有缺陷的解决方案是使用 n200和 n020的平均值（原 
始三角形的顶点处的法线）来计算n110。但是，当n200 =n020 
时，将再次遇到图17.29左下方显示的问题。相反，n110的构造 
首先取平均值n200和n020，然后在平面π中反映这个法线，如图 
17.30所示。该平面具有与端点p300和p030之间的差异平行的法 
线。因为只有法向量会以π反映出来，我们可以假设π穿过原点，因 
为法线与平面上的位置无关。另请注意，每个法线都应该标准化。 
在数学上，n110的非标准化版本表示为[1819]n'110 =n200 + 
n020。2 p030.p300（ ）· n200（  +n020）（p030.p300）· p030.p300（ ） 
----------------------- Page 787-----------------------
 （p030.p300）。 （17.47）最初，vanOverveld和Wyvill在这个 
等式中使用了3/2而不是2的因子。通过观察图像很难判断哪个值 
最好，但使用2可以很好地解释平面中的真实反射。17.2。参数曲 
面747图17.30。PN三角形的 n110构造。虚线法线是 n200和 
n020的平均值，并且n110是在平面π中反映的该法线。平面π具 
有与 p030平行的法线。P300。在此刻，已经计算了三次B'ezier 
三角形的所有B'ezier点和用于二次插值的所有法线向量。只剩下在 
B'ezier三角形上创建三角形以便可以渲染它们。这种方法的优点是 
表面可以以相对较低的成本获得更好的轮廓和形状。指定详细程度 
的一种方法如下。原始三角形数据被认为是LOD0.然后 LOD数量 
随着三角形边缘上新引入的顶点的数量而增加。因此，LOD1在每 
个边缘引入一个新顶点，因此在 B'ezier三角形上创建四个子三角 
形，LOD2在每个边缘引入两个新顶点，生成九个子三角形。通常， 
LODn生成（n+1）2个子三角形。为了防止 B'ezier三角形之间 
的开裂，网格中的每个三角形必须使用相同的LOD进行细分。这是 
一个严重的缺点，因为一个小三角形将被镶嵌成一个大三角形。自 
适应曲面细分 （第 17.6.2节）和分数曲面细分 （第 17.6.1节）等技 
术可用于避免这些问题。PN三角形的一个问题是折痕难以控制，并 
且通常需要在期望的折痕附近插入额外的三角形。B'ezier三角形之 
间的连续性仅为C0，但在许多情况下它们仍然可以接受。这主要是 
因为法线在三角形上是连续的，因此一组PN三角形模仿G1表面。 
Boubekeur等人提出了一种更好的解决方案。[181]，其中顶点可 
----------------------- Page 788-----------------------
以具有两个法线，并且两个这样的连接顶点产生折痕。请注意，要 
获得漂亮的纹理，三角形（或补丁）之间的边界需要C1连续性。 
另外值得了解的是，如果两个相邻的三角形不共享相同的法线，则 
会出现裂缝。Gr¨un[614]描述了一种进一步改善 PN三角形连续性 
质量的技术。Dyken等人。[401]提出了一种受 PN三角形启发的技 
术，其中只有从观察者看到的轮廓被自适应地细分，因此变得更加 
弯曲。这些轮廓曲线以与 PN三角曲线类似的方式导出。为了获得 
平滑过渡，它们在粗略轮廓和镶嵌轮廓之间进行混合。为了提高连 
续性，Füunzzig等。[505]呈现PNG1三角形，其是PN三角形的 
修改，其在任何地方都具有G1连续性。McDonald和Kilgard[1164] 
提出了 PN三角形的另一个扩展，它可以处理相邻三角形上的不同 
法线。74817.曲线和曲面n0n1p0p1p （u）t0 （p （u））t1 （p 
 （u））p* （u）p* （u）α图17.31。使用曲线而不是曲面来说明 
Phong曲面细分结构，这意味着p （u）仅是u的函数而不是（u， 
v），并且类似于ti。请注意，p （u）首先投影到切平面上，生成 
t0和t1。之后，p。 （u）由t0和t1的线性插值产生。作为最后一 
步，使用形状因子α在基本三角形和p。（u）之间进行混合。在这 
个例子中，我们使用α= 0.75。17.2.5 Phong Tessellation 
Boubekeur和Alexa [182]提出了一种称为 Phong镶嵌的表面结 
构，它与 PN三角形有许多相似之处，但评估速度更快，实施起来 
更简单。调用基本三角形p0，p1和p2的顶点，并使相应的归一化 
法线为n0，n1和n2。首先，回想一下，重心坐标 （u，v）上的基 
----------------------- Page 789-----------------------
本三角形上的点被计算为p （u，v）= （u，v，1.u.v）· （p0，p1， 
p2）。 （17.48）在 Phong着色中，法线在平面三角形上插值，也 
使用上面的等式，但是用法线代替点。Phong镶嵌尝试使用重复插 
值创建 Phong着色法线插值的几何形式，这导致 B'ezier三角形。 
在本次讨论中，我们将参考图 17.31。第一步是创建一个函数，将 
基准三角形上的点q投影到由点和法线定义的切平面。这是以ti（q） 
=q完成的。.. （q.pi）·ni？你。（17.49）不使用三角形顶点进行 
线性插值 （公式 17.48），使用函数ti进行线性插值，得到p。（u， 
v）= （u，v，1.u.v）· ..t0 （u，v），t1 （u，v），t2 （u，v）？。 
 （17.50）为了增加一些灵活性，增加了一个形状因子α，它在基本 
三角形和公式17.50之间进行插值，得到 Phong曲面细分的最终公 
式：p。？ （u，v）= （1.α）p （u，v）+αp。 （u，v）， （17.51） 
其中α=0.75是推荐设置[182]。生成此曲面所需的唯一信息是基本 
三角形的顶点和法线以及用户17.3。隐式曲面749图17.32。Phong 
镶嵌应用于怪物青蛙。从左到右：带有平面阴影的基础网格，带有 
Phong阴影的基础网格，最后，Phong曲面细分应用于基础网格。 
注意改进的轮廓。在这个例子中，我们使用α=0.6。（使用Tamy 
Boubekeur的演示程序生成的图像。）提供α，这使得快速评估该 
表面。得到的三角形路径是二次的，即比 PN三角形的程度低。法 
线只是线性插值，就像标准的 Phong着色一样。有关 Phong曲面 
细分应用于网格的效果的示例，请参见图 17.32。17.2.6B样条曲 
面17.1.6节简要介绍了 B样条曲线，这里我们将对引入 B样条曲面 
----------------------- Page 790-----------------------
进行相同的操作。第732页的公式17.24可以推广到Bspline补丁， 
因为sn （u，v）=X kX lck，lβn （u.k）βn （v.1），（17.52） 
与 B'ezier非常相似补片公式 （公式 17.32）。注意sn （你，v）是 
表面上的三维点。如果此函数用于纹理过滤，则公式 17.52将是高 
度场，并且ck，l将是一维的，即高度。对于双三次 B样条补丁， 
公式 17.25中的β3 （t）函数将用于公式17.52。将需要总共4×4 
个控制点ck，l，并且由等式 17.52描述的实际表面补片将在最内部 
的2×2控制点内。如图 17.33所示。请注意，双立方 B样条补丁对 
于Catmull-Clark细分曲面 （第 17.5.2节）也是必不可少的。有许 
多关于 B样条曲面的更多信息的好书[111,458,777]。17.3隐式曲 
面到目前为止，只讨论了参数曲线和曲面。隐式曲面构成了另一个 
用于表示模型的有用类。而不是使用一些 750 17.曲线和曲面 
uvc-1，-1c22c2，-1c-1,211c00图17.33。双三次 B样条补丁 
的设置，具有4×4个控制点，ck，l。 （u，v）的域是单位正方形， 
如右图所示。参数，比如u和v，为了明确地描述表面上的一个点， 
使用下面的形式，称为隐函数：f （x，y，z）=f （p）=0. （17.53） 
这是解释的如下：如果在将点插入隐函数f时结果为零，则点p在 
隐式曲面上。隐式曲面通常用于与光线的交叉测试（第22.6-22.9 
节），因为它们可以比相应的（如果有的话）参数曲面更简单。隐 
式曲面的另一个优点是可以轻松地将构造型实体几何算法应用于它 
们，也就是说，可以相互减去对象，逻辑地：AND：ed或OR：ed。 
此外，物体可以很容易地混合和变形。位于原点的隐式曲面的一些 
----------------------- Page 791-----------------------
示例是fs （p，r）=||p||。r，球体;fxz （p）=py，xz中的平面;frb 
 （p，d，r）=||max （|p|.d，0）||。r，圆形框。（17.54）这 
些值得一些解释。球体只是从半径减去p到原点的距离，因此如果 
p在半径为r的球体上，则fs （p，r）等于0。否则，将返回有符号 
距离，其中负数表示p在球体内部，而在正外部。因此，这些功能 
有时也称为带符号距离函数 （SDF）。平面fxz （p）只是p的y坐 
标，即y轴为正的一侧。对于圆角框的表达式，我们假设每个组件 
计算绝对值（|p|）和向量的最大值。此外，d是盒子半边的矢量。 
请参见图 17.34中所示的圆角框;公式在标题中解释。要获得一个非 
圆形框，只需设置r=0.17.3。隐式曲面751rdxdyp2p3p0dx 
dy非圆角框圆角框符号距离增加图17.34。左：一个非圆形框，其 
带符号距离函数为||max （|p|.d，0）||，其中p是要测试的点， 
而d's分量是所示的半边。请注意|p|使其余的计算发生在右上象 
限 （在2D中）。减去d意味着|px|。如果p位于沿x的框内，则 
dx将为负，对于其他轴也是如此。仅保留正值，而负值通过 max 
 （）钳位为零。因此，||max （|p|.d，0）||计算到盒子边的最近 
距离，这意味着如果在评估max （）后多于一个值为正，则框外的 
带符号距离字段将被舍入。右：通过从非圆形框中减去r来获得圆 
形框，其将框展开为r为所有方向。隐式曲面的法线由偏导数描述， 
称为渐变，并表示为.f：.f （x，y，z）=？.f.x，.f.y，.f.z？。 （17.55） 
为了能够精确地评估它，公式 17.55中的f必须是可微分的，因此 
也是连续的。在实践中，人们常常使用一种称为中心差异的数值技 
----------------------- Page 792-----------------------
术，使用场景函数f[495]进行采样：.fx≈f （p+.ex）。f （p.ex）， 
 （17.56）和.fy和.fz类似。回想一下ex= （1,0,0），ey= （0,1,0） 
和ez = （0,0,1）和那个。是一个很小的数字。要使用公式17.54 
中的基元构建场景，使用联合运算符∪。例如，f （p）=fs （p，1） 
∪fxz （p）是由球体和平面组成的场景。union运算符是通过取两 
个操作数中最小的一个来实现的，因为我们想要找到最接近p的表 
面。通过在调用有符号距离函数之前转换p来完成转换，即，fs（p.t， 
1）是由t转换的球体。旋转和其他变换可以以相同的精神完成，即， 
将逆变换应用于 p。通过使用r =mod （p，c）.0.5c而不是p作 
为有符号距离函数的参数，在整个空间上重复对象也是直截了当的。 
混合隐式曲面是一个很好的特性，可以用于通常被称为 blobby建 
模[161]，软对象或元球[67,558]。有些例子，请参见图17.35。基 
本思想是使用几个简单的基元，如75217.曲线和曲面图17.35。左： 
成对的球体混合不同的增加（从左到右）混合半径和底层由重复的 
圆形框组成。右：三个球体混合在一起。如球形，椭圆形或任何可 
用的东西，并将它们平滑地混合。每个物体可以看作是原子，并且 
在混合之后获得原子分子。混合可以通过许多不同的方式完成。将 
两个距离d1和d2与混合半径rb混合的常用方法[1189,1450]是h 
=min..max （0.5+0.5 （d2.d1）/ rb，0.0），1.0？，d = （1.h） 
d2+hd1+rbh （1.h）， （17.57）其中d是混合距离。虽然此功 
能仅将最短距离与两个对象混合，但可以重复使用该功能来混合更 
多对象 （请参见图 17.35的右侧部分）。为了可视化一组隐式函数， 
----------------------- Page 793-----------------------
使用的常用方法是射线行进[673]。一旦您可以在场景中进行光线穿 
越，也可以生成阴影，反射，环境光遮挡和其他效果。有符号距离 
场内的射线行进如图 17.36所示。在第一点，p，在射线上，我们 
评估图 17.36。射线与签名的距离场进行游行。虚线圆圈表示距离 
其中心最近的表面的距离。位置可以沿着光线前进到前一个位置的 
圆圈的边界。17.4。细分曲线753图17.37。雨林 （左）和蜗牛 （右） 
使用有符号距离函数和射线行进程序创建。使用因程序噪声而移位 
的椭圆体生成树木。 （Shadertoy使用来自 I.nigoQuilez的程序生 
成的图像。）到场景的最短距离d。由于这表明在半径为d的p周 
围存在球体而没有其他物体更接近，我们可以沿着射线方向移动射 
线d单位，依此类推，直到我们到达某个epsilon内的表面，或者 
当预定义的射线 - 行军步骤已经满足，在这种情况下，我们可以假 
设背景被击中。两个极好的例子如图 17.37所示。每个隐式曲面也 
可以变成由三角形组成的曲面。有几种算法可用于执行此操作 
[67,558]。一个众所周知的例子是第13.10节中描述的行进立方体 
算法。使用Wyvill和 Bloomenthal算法进行多边形化的代码可以 
在网上找到[171]和deAra'ujo等人。[67]提出了关于隐式曲面多边 
形化的最新技术的调查。Tatarchuk和Shopf [1744]描述了一种他 
们称之为行进四面体的技术，其中GPU可用于在三维数据集中找到 
等值面。第48页的图3.13显示了使用几何着色器进行等值面提取 
的示例。肖等人。[1936]提出了一种流体模拟系统，其中GPU计算 
100k粒子的位置并使用它们以交互速率显示等值面。17.4细分曲 
----------------------- Page 794-----------------------
线细分技术用于创建平滑的曲线和曲面。它们用于建模的一个原因 
是它们弥合了离散表面（三角形网格）和连续表面（例如，B'ezier 
贴片的集合）之间的差距，因此可用于详细技术水平（第 19.9节）。 
在这里，我们将首先描述细分曲线的工作原理，然后讨论更流行的 
细分曲面方案。通过使用角切割的示例可以最好地解释细分曲线。 
见图17.38。切掉最左边多边形的角，创建一个新的多边形75417. 
曲线和曲面图17。38.Chaikin的细分计划在起作用。初始控制多 
边形P0被细分为 P1，然后再细分为 P2。可以看出，每个多边形的 
角Pi在细分期间被切掉。在无限多个细分之后，获得极限曲线 P∞。 
这是近似方案，因为曲线不经过初始点。有两倍的顶点。然后，这 
个新多边形的角被切断，等等到无穷大（或者更实际地，直到我们 
看不到任何差异）。由此产生的曲线称为极限曲线，因为所有角都 
被切掉了。由于去除了所有尖角（高频），因此该过程也可以被认 
为是低通滤波器。此过程通常写为P0→P1→P2····P∞，其中P0是 
起始多边形，也称为控制多边形，和 P∞是极限曲线。该细分过程 
可以以许多不同的方式完成，并且每个方式的特征在于细分方案。 
图17.38所示的方法称为Chaikin方案[246]，其工作原理如下。假 
设多边形的n个顶点是 P0={p00，....。。，p0n.1}，其中上标表 
示细分水平。Chaikin的方案在原始多边形的每个后续顶点对之间 
创建两个新顶点，比如pki和pki+1，pk+12i=34 pki+14 pki 
+1和 pk+12i+1=14 pki+34 pki+1。（17.58）可以看出， 
上标从k变为 k +1，这意味着我们从一个细分级别转到下一个细 
----------------------- Page 795-----------------------
分级别，即Pk→Pk+1。在执行这样的细分步骤之后，丢弃原始顶 
点并重新连接新点。这种行为可以在图 17.38中看到，其中新点从 
原始顶点向相邻顶点创建 1/4。细分方案的美妙之处在于快速生成 
平滑曲线的简单性。但是，如第 17.1节所示，您不会立即获得曲线 
的参数形式，但可以证明 Chaikin 算法生成二次 B 样条 
[111,458,777,1847]。到目前为止，所提出的方案适用于 （封闭的） 
多边形，但大多数方案也可以扩展到开放折线。在Chaikin的情况 
下，唯一的区别是折线的两个端点保留在每个细分步骤中（而不是 
被丢弃）。这使得曲线通过端点。有两种不同的细分方案，即近似 
和插值。Chaikin的方案是近似的，因为极限曲线一般是17.4。细 
分曲线755 i-1图17.39。行动中的4点细分方案。这是曲线通过 
初始点的插值方案，并且通常曲线Pi+1经过Pi的点。请注意，图 
17.38中使用了相同的控制多边形。不要位于初始多边形的顶点上。 
这是因为顶点被丢弃（或更新，对于某些方案）。相反，插值方案 
保留了前一细分步骤中的所有点，因此限制曲线 P∞遍历P0，P1， 
P2等的所有点。这意味着该方案会插入初始多边形。使用与图17.38 
相同的多边形的示例如图 17.39所示。该方案使用四个最近点来创 
建新点[402]：pk+12i =pki，pk+12i+1=？12+w？（pki 
+pki+1）。w （pki.1+pki+2）。 （17.59）公式 17.59中的第 
一行只是意味着我们保留上一步的点而不改变它们（即插值），第 
二行用于在pki和 pki +1之间创建一个新点。重量w称为张力参 
数。当w =0时，结果是线性插值，但是当w =1/16时，我们得 
----------------------- Page 796-----------------------
到的行为如图 17.39所示。可以示出[402]当0 <w<1/8时，得到 
的曲线是C1。对于开放折线，我们在端点处遇到问题，因为我们在 
新点的两侧都需要两个点，而我们只有一个点。如果端点旁边的点 
反映在端点上，则可以解决此问题。所以，对于折线的起点，p1反 
映在p0上以获得p.1。然后在细分过程中使用该点。p.1的创建如 
图17.40所示。-1图17.40。为开放折线创建反射点p.1。反射点 
计算如下：p.1 =p0。（p1.p0）=2p0。P1。756 17.曲线和曲面 
另一种近似方案使用以下细分规则：pk + 12i =34 pki + 18 
 （pki.1+pki+1），pk+12i+1=12 （pki+pki+1）。（17.60） 
第一行更新现有点，第二行计算两个相邻点之间的线段上的中点。 
该方案生成三次 Bspline曲线（第17.1.6节）。参考关于细分的 
SIGGRAPH课程[1977]，杀手B的书[111]，沃伦和韦默的细分书 
[1847]，或者Farin的CAGD书[458]了解有关这些曲线的更多信息。 
给定点p及其相邻点，可以将该点直接 “推”到极限曲线，即，确 
定 p的坐标在P∞上是什么。这对于切线也是可能的。例如，请参 
阅Joy对此主题的在线介绍[843]。细分曲线的许多概念也适用于细 
分曲面，下面将介绍细分曲面。17.5细分曲面细分曲面是一种强大 
的范例，用于从具有任意拓扑的网格定义平滑，连续，无裂缝的曲 
面。与本章中的所有其他曲面一样，细分曲面也提供无限级别的细 
节。也就是说，您可以根据需要生成任意数量的三角形或多边形， 
并且原始曲面表示是紧凑的。被细分的表面的一个例子如图 17.41 
所示。另一个优点是细分规则简单且易于实现。缺点是表面连续性 
----------------------- Page 797-----------------------
的分析通常在数学上涉及。然而，这种分析通常只对那些希望创建 
新细分方案的人感兴趣，并且超出了本书的范围。有关详细信息， 
请参阅Warren和Weimer的书[1847]以及关于细分的SIGGRAPH 
课程[1977]。通常，表面（和曲线）的细分可以被认为是两阶段过 
程[915]。从称为控制网格或控制网格的多边形网格开始，称为细化 
阶段的第一个阶段创建新顶点并重新连接以创建新的较小三角形。 
第二个，称为平滑阶段，通常计算网格中某些或所有顶点的新位置。 
如图 17.42所示。这两个阶段的细节是细分方案的特征。在第一阶 
段，多边形可以以不同的方式分割，而在第二阶段，细分规则的选 
择给出不同的特征，例如连续性水平，以及表面是近似还是插值， 
这些是属于部分中描述的属性 17.4。细分方案的特征在于静止或非 
静止，均匀或不均匀，以及它是基于三角形还是基于多边形。固定 
方案在每个细分步骤使用相同的细分规则，而17.5。细分曲面757 
图17.41。左上角的图像显示了控制网格，即原始网格，这是描述 
生成的细分曲面的唯一几何数据。以下图像分为一次，两次和三次。 
可以看出，生成了越来越多的多边形，表面变得更加平滑和平滑。 
这里使用的方案是Catmull-Clark方案，如第 17.5.2节所述。图 
17.42。细分为细化和平滑。细化阶段创建新顶点并重新连接以创建 
新三角形，平滑阶段计算顶点的新位置。758 17.曲线和曲面图 
17.43。Loop方法的两个细分步骤的连通性。每个三角形生成四个 
新三角形。非平稳可以根据当前正在处理的步骤来改变规则。以下 
处理的方案都是固定的。统一方案对每个顶点或边使用相同的规则， 
----------------------- Page 798-----------------------
而非均匀方案可以对不同的顶点或边使用不同的规则。例如，一组 
不同的规则通常用于表面边界上的边。基于三角形的方案仅对三角 
形进行操作，因此仅生成三角形，而基于多边形的方案对任意多边 
形进行操作。接下来介绍几种不同的细分方案。在这些之后，提出 
了两种技术，它们扩展了细分曲面的使用，以及细分法线，纹理坐 
标和颜色的方法。最后，给出了一些细分和渲染的实用算法。17.5.1 
LoopSubdivision Loop方法[767,1067]是三角形的第一个细分方 
案。这就像第 17节中的最后一个方案。4它是近似的，它更新每个 
现有的顶点并为每个边创建一个新的顶点。该方案的连接性如图 
17.43所示。可以看出，每个三角形被细分为四个新的三角形，因 
此在 n个细分步骤之后，三角形被细分为4n个三角形。首先，让 
我们关注现有的顶点pk，其中k是细分步数。这意味着 p0是控制 
网格的顶点。在一个细分步骤之后，p0变为p1。通常，p0→p1→ 
p2→····p∞，其中p∞是极限点。如果pk有n个相邻顶点，则pki， 
i∈{0,1，...。。，n。1}，然后我们说pk的价数是n。有关上述符 
号，请参见图 17.44。此外，具有化合价6的顶点称为常规或普通。 
否则它被称为不规则或非常。下面给出了 Loop方案的细分规则， 
其中第一个公式是将现有顶点pk更新为pk+1的规则，第二个公 
式用于创建pk和pk之间的新顶点 pk+1i。 pki。同样，n是 pk 
的化合价：pk+1= （1.nβ）pk+β （pk0+···+pkn.1），pk+1 
i =3pk +3pki +pki.1 +pki +18，i =0。。。n。1. （17.61） 
17.5。细分曲面7591n-1n-11图17.44。用于 Loop的细分方案 
----------------------- Page 799-----------------------
的符号。左边的街区被细分为右边的街区。更新中心点pk并用pk+ 
1代替，并且对于pk和pki之间的每个边，创建新点（pk +1i，i 
∈1，...，n）。注意，我们假设索引是以模n计算的，所以如果i= 
n.1，那么对于i+1，我们使用索引0，同样当i=0时，我们使用 
i。1，我们使用索引n。这些细分规则很容易被视为面具，也称为 
模板。见图 17.45。这些的主要用途是它们仅使用简单的图示来传 
达几乎整个细分方案。请注意，两个掩码的权重总和为 1。这是一 
个适用于所有细分方案的特征，其基本原理是新点应该位于加权点 
的附近。在公式 17.61中，常数β实际上是n的函数，由β （n）=1 
n？给出。58。（3 +2cos （2π/ n））264？。（17.62）循环 
对β函数的建议[1067]在每个规则顶点处给出C2连续性的表面，在 
其他地方[1976]给出C1，即在所有不规则顶点处。由于在细分期间 
仅创建了规则顶点，因此表面在图17.45中仅为C1。Loop的细分 
方案的掩码 （黑色圆圈表示更新/生成哪个顶点）。掩码显示每个相 
关顶点的权重。例如，当更新现有顶点时，权重 1.nβ用于现有顶点， 
权重β用于所有相邻顶点，称为 1-环。76017.曲线和曲面图17.46。 
蠕虫用 Loop的细分方案细分了三次。我们在控制网格中有不规则 
顶点的地方。有关使用Loop方案细分的网格示例，请参见图17.46。 
Warren和Weimer [1847]给出了避免三角函数的等式 17.62的变 
体：β （n）=3n （n +2）。（17.63）对于常规效价，这给出了 
C2表面，而C1则出现在其他地方。得到的表面很难与常规的 Loop 
表面区分开来。对于未关闭的网格，我们不能使用显示的细分规则。 
----------------------- Page 800-----------------------
相反，必须使用特殊规则来实现这种边界。对于 Loop方案，可以 
使用公式 17.60的反射规则。这也在第 17.5.3节中处理。无限多个 
细分步骤后的曲面称为极限曲面。可以使用闭合表达式表达式来计 
算极限曲面点和极限切线。使用公式 17.61中第一行的公式，通过 
用γ （n）= 1 n +3 8 （n）代替β （n）来计算顶点的极限位置 
[767,1977]。 （17.64）顶点pk的两个极限切线可以通过加权直接 
相邻顶点来计算，称为 1环或 1邻域，如下所示[767,1067]：tu = 
nX.1i =0cos （2πi/n）pki，tv =nX.1i =0sin （2πi/n）pki。 
 （17.65）然后正常是n =tu×tv。请注意，这通常比第16.3节中 
描述的方法更便宜[1977]，后者需要计算相邻三角形的法线。更重 
要的是，这给出了该点的精确法线。17.5。细分曲面761图17.47。 
四面体用Loop's，√3和修改后的蝴蝶 （MB）方案[1975]细分五次。 
循环和√3方案[915]都是近似的，而 MB是内插的，后者意味着初 
始顶点位于最终表面上。由于它们在游戏和离线渲染中的流行，我 
们仅涵盖本书中的近似方案。近似细分方案的一个主要优点是得到 
的表面趋于公平。松散地说，公平性与曲线或曲面弯曲的平滑程度 
有关[1239]。更高的公平性意味着更平滑的曲线或表面。另一个优 
点是近似方案比插值方案收敛得更快。然而，这意味着形状经常缩 
小。这对于小的凸网格最为显着，例如图 17.47中所示的四面体。 
减少此效果的一种方法是在控制网格中使用更多顶点，即在建模时 
必须小心。Maillot和Stam提出了一个组合细分方案的框架，以便 
可以控制收缩[1106]。有时可以充分利用的特征是环表面包含在原 
----------------------- Page 801-----------------------
始控制点的凸包内[1976]。Loop细分方案生成一个广义的三向四次 
方框样条.1因此，对于仅由常规顶点组成的网格，我们实际上可以 
将表面描述为一种样条曲面。但是，对于不规则设置，此描述是不 
可能的。能够从任何顶点网格生成平滑表面是细分方案的一大优势。 
有关使用 Loop方案的细分曲面的不同扩展，请参见第 17.5.3节和 
第 17.5.4节。17.5.2Catmull-Clark细分可以处理多边形网格（而 
不仅仅是三角形）的两个最着名的细分方案是Catmull-Clark[239] 
和 Doo-Sabin [370]。2 在这里，我们只简要介绍前者。 
Catmull-Clark表面已被用于皮克斯的短片Geri'sGame[347]，玩 
具总动员2以及皮克斯的所有后续故事片中。这种细分方案也常用 
于制作游戏模型，可能是最受欢迎的一种。正如DeRose等人所指 
出的那样。[347]，Catmull-1这些样条曲面超出了本书的范围。请 
参阅Warren的书[1847]，SIGGRAPH课程[1977]，或 Loop的论 
文[1067]。2无疑，两者都出现在同一期刊的同一期刊上。76217. 
曲线和曲面图17.48。Catmull-Clark细分的基本思想。每个多边形 
生成一个新点，每个边生成一个新点。然后如右图所示连接它们。 
此处未显示原始点的加权。Clark表面往往会产生更加对称的表面。 
例如，椭圆形盒子形成对称的椭球状表面，这与直觉一致。相反， 
基于三角形的细分方案会将每个立方体面部视为两个三角形，因此 
会根据方形的分割方式生成不同的结果。Catmull-Clark曲面的基 
本思想如图 17.48所示，Catmull-Clark细分的实际例子如图 17.41 
 （第757页）所示。可以看出，该方案仅生成具有四个顶点的面。 
----------------------- Page 802-----------------------
实际上，在第一个细分步骤之后，仅生成化合价4的顶点，因此这 
些顶点被称为普通或常规（与三角形方案的化合价6相比）。遵循 
Halstead等人的记号。[655]，让我们关注具有n个边缘点eki的 
顶点vk，其中i=0。。。n。1.见图 17.49。现在，对于每个面部， 
计算新的面部点fk+1作为面部质心，即面部的点的平均值。鉴于 
此，细分规则是[239,655,1977]vk +1=n。2nvk +1n2nX.1j 
=0ekj +1n2nX.1j =0f k+1j，ek +1j =vk +ekj +f k+1 
j.1 +f k +1j 4。（17.66）可以看出，顶点vk +1被计算为所考 
虑的顶点的加权，边缘点的平均值和新创建的面部点的平均值。另 
一方面，新边缘点由所考虑的顶点，边缘点和具有边缘作为邻居的 
两个新创建的面部点的平均值计算。Catmull-Clark表面描述了广 
义的双三次 B样条曲面。所以，对于仅由规则顶点组成的网格，我 
们实际上可以将表面描述为双三次 B样条曲面（第 17.2.6节） 
[1977]。但是，这对于不规则网格设置是不可能的，并且能够使用 
细分曲面处理这些是该方案的优势之一。极限位置和切线也可能达 
到 17.5。细分曲面763v0e00e01e02v1e10e11f10f1 1e1 
2f 1n-10 n-1e图17.49。在细分之前，我们有蓝色顶点和相应 
的边和面。在Catmull-Clark细分的一步之后，我们获得红色顶点， 
并且所有新面都是四边形。（Halstead等人[655]之后的插图。） 
计算，甚至使用显式公式计算任意参数值[1687]。Halstead等。[655] 
描述了计算极限点和法线的不同方法。有关可以使用 GPU渲染 
Catmull-Clark细分曲面的一组有效技术，请参见第 17.6.3节。 
----------------------- Page 803-----------------------
17.5.3分段平滑细分在某种意义上，曲面可能被认为是无聊的，因 
为它们缺乏细节。改善此类曲面的两种方法是使用凹凸贴图或置换 
贴图（第17.5.4节）。这里描述了第三种方法，即分段平滑细分。 
基本思想是更改细分规则，以便可以使用飞镖，角落和折痕。这增 
加了可以建模和表示的不同表面的范围。Hoppe等。[767]首先描 
述了 Loop的细分曲面。有关标准Loop细分曲面与具有分段平滑 
细分的曲面的比较，请参见图 17.50。为了能够在表面上使用这些 
特征，我们首先要标记我们想要锐利的边缘，因此我们知道在哪里 
进行不同的细分。进入顶点的尖锐边缘的数量表示为s。然后将顶 
点分类为：平滑 （s=0），dart （s=1），折痕 （s=2）和角 （s> 
2）。因此，折痕是曲面上的曲线，其中曲线的连续性为C0。飞镖 
是非边界顶点，其中折痕结束并平滑地混合到表面中。最后，一个 
角是一个顶点，三个或更多的折痕聚集在一起。可以通过将每个边 
界边缘标记为锐利来定义边界。在对各种顶点类型进行分类后， 
Hoppe等人。使用表来确定用于各种组合的掩码。他们还展示了如 
何计算76417。曲线和曲面图17.50。顶行显示控制网格，限制曲 
面使用标准 Loop细分方案。底行显示了 Loop方案的分段平滑细 
分。左下图显示了带有标记边缘（清晰）的控制网格，以浅灰色显 
示。得到的表面显示在右下方，标有角，飞镖和折痕。（图片由 
HuguesHoppe提供。）限制表面点并限制切线。比尔曼等人。[142] 
提出了几个改进的细分规则。例如，当非常顶点位于边界上时，先 
前的规则可能导致间隙。新规则可以避免这种情况。此外，它们的 
----------------------- Page 804-----------------------
规则使得可以在顶点处指定法线，并且所得到的表面将适应于在该 
点处获得该法线。DeRose等人。[347]提出了一种产生柔软折痕的 
技术。它们允许边缘首先被细分为多次（包括分数），然后使用标 
准细分。17.5。细分曲面76517.5.4移位细分凹凸贴图 （第6.7节） 
是向平滑曲面添加细节的一种方法。然而，这只是一种幻觉技巧， 
可以改变每个像素的正常或局部遮挡。无论是否有凹凸贴图，对象 
的轮廓看起来都一样。凹凸贴图的自然延伸是位移映射[287]，其中 
表面被移位。这通常沿法线方向进行。因此，如果表面的点是p， 
并且其归一化法线是n，则位移表面上的点是s （u，v）=p （u，v） 
+d （u，v）n （u， v）。 （17。67）标量d是点p处的位移。位 
移也可以是矢量值[938]。在本节中，将显示移位的细分曲面[1006]。 
一般的想法是将移位表面描述为粗控制网格，其被细分为光滑表面， 
然后使用标量场沿其法线移位。在位移细分曲面的上下文中，公式 
17.67中的p是细分曲面（粗控制网格）上的极限点，n是 p处的 
归一化法线，计算为n=n'||n'|| ，其中n'=pu×pv，（17.68）在 
公式 17.68中，pu和pv是细分曲面的一阶导数。因此，他们在 p 
描述了两个切线。李等人。[1006]使用 Loop细分曲面作为粗控制 
网格，并且可以使用公式17.65计算其切线。请注意，这里的符号 
略有不同;我们使用pu和pv而不是tu和tv。公式 17.67描述了所 
得表面的位移位置，但我们还需要在移位的细分曲面上使用法线ns， 
以便正确渲染它。它是分析计算的，如下所示[1006]：ns=su×sv， 
其中su=.s.u=pu+dun +dnu和sv=.s.v=pv+dvn+dnv。 
----------------------- Page 805-----------------------
 （17.69）为简化计算，Blinn[160]认为如果位移很小，第三项可以 
忽略。否则，以下表达式可用于计算nu （并且类似地nv）[1006]：ˉ 
nu=puu×pv+pu×puv，nu=ˉnu。 （ˉnu·n）n||n'||。 （17.70） 
注意ˉnu不是任何新的表示法，它只是计算中的 “临时”变量。对 
于普通顶点 （化合价n=6），第一个和第二个76617.曲线和曲面 
-1-1-1-2-1-2-2-1-2-1-2图17.51。Loop的细分方案中普 
通顶点的掩码。请注意，使用这些掩码后，结果总和应如图所示进 
行划分。（Lee等人[1006]之后的插图。）有序衍生物特别简单。 
他们的面具如图 17.51所示。对于非常顶点（效价 n6 =6），省 
略了等式17.69中第一行和第二行中的第三项。使用Loop细分的 
位移映射的示例如图 17.52所示。当移位的表面远离观察者时，可 
以使用标准的凹凸贴图来给出这种位移的错觉。这样做可以节省几 
何处理。一些凹凸贴图方案需要在顶点处使用切线空间坐标系，并 
且可以使用以下内容： （b，t，n），其中t =pu/ ||pu||并且b= 
n×t。Nie.ner和 Loop[1281]提出了与 Lee等人的上述方法类似的 
方法，但是他们使用Catmull-Clark表面并且使用直接评估位移函 
数的导数，这更快。他们还使用硬件细分管道（第3.6节）进行快 
速细分。图 17.52。左边是粗网格。在中间，它使用Loop的细分 
方案细分。右图显示了移位的细分曲面。图片由（        Aaron Lee，Henry 
Moreton和 HuguesHoppe提供。）17.6。高效细分76717.5.5 
正常，纹理和颜色插值在本节中，我们将介绍处理法线，纹理坐标 
和每个顶点颜色的不同策略。如第 17.5.1节中的 Loop方案所示， 
----------------------- Page 806-----------------------
可以显式计算限制切线，从而限制法线。这涉及评估可能很昂贵的 
三角函数。Loop和 Schaefer [1070]提出了一种近似技术，其中 
Catmull-Clark表面总是由双三次 B'ezier曲面近似（第 17.2.1节）。 
对于法线，导出两个切线补丁，即一个在u方向，一个在v方向。 
然后发现法线作为这些矢量之间的叉积。通常，B'ezier贴片的导数 
使用公式 17.35 计算。然而，由于导出的 B'ezier 斑块接近 
Catmull-Clark表面，因此切线斑块将不会形成连续的正常场。请 
参阅Loop和Schaefer关于如何克服这些问题的论文[1070]。Alexa 
和 Boubekeur[29]认为，在每次计算的质量方面，它也可以更有效 
地细分法线，从而在阴影中提供更好的连续性。我们参考他们的论 
文，了解如何细分法线。更多类型的近似也可以在 Ni等人的 
SIGGRAPH课程[1275]中找到。假设网格中的每个顶点都具有纹理 
坐标和颜色。为了能够将这些用于细分曲面，我们还必须为每个新 
生成的顶点创建颜色和纹理坐标。最明显的方法是使用与我们用于 
细分多边形网格相同的细分方案。例如，您可以将颜色视为四维向 
量（RGBA），并细分这些以为新顶点创建新颜色。这是一种合理 
的方法，因为颜色将具有连续的导数（假设细分方案至少为C1）， 
因此在表面上避免了颜色的突然变化。纹理坐标当然可以做同样的 
事情[347]]。但是，当纹理空间中存在边界时，必须小心。例如， 
假设我们有两个补丁共享一条边，但沿着这条边有不同的纹理坐标。 
几何应该像往常一样用表面规则细分，但在这种情况下应该使用边 
界规则细分纹理坐标。Piponi和 Borshukov[1419]给出了一种用 
----------------------- Page 807-----------------------
于纹理细分曲面的复杂方案。17.6高效曲面细分要在实时渲染上下 
文中显示曲面，我们通常需要创建表面的三角形网格表示。此过程 
称为曲面细分。最简单的镶嵌形式称为均匀镶嵌。假设我们有一个 
参数 B'ezier贴片p （u，v），如公式17.32所述。我们希望通过 
计算每个补丁侧 11个点来对该补丁进行细分，从而产生 10×10×2 
=200个三角形。最简单的方法是均匀地采样紫外空间。因此，我 
们评估所有（uk，vl）= （0.1k，0.1l）的p （u，v），其中k和 l 
都可以是任何76817.曲线和曲面Hull着色器Tessellator （控制着 
色器）域着色器 （评估着色器）顶点着色器几何着色器 11图17.53。 
带有硬件镶嵌的管道，其中新阶段显示在中间三（蓝色）框中。我 
们在这里使用DirectX的命名约定，在括号中使用OpenGL对应物。 
船体着色器计算控制点的新位置并计算曲面细分因子，这决定了后 
续步骤应生成多少个三角形。曲面细分器在uv空间中生成点，在这 
种情况下是单位正方形，并将它们连接成三角形。最后，域着色器 
使用控制点计算每个uv坐标处的位置。从0到 10的整数。这可以 
通过两个嵌套的for循环来完成。可以为四个表面点p （uk，v1）， 
p （uk+1，v1），p （uk+1，v1 +1）和p （uk，v1 +1）创建 
两个三角形。虽然这当然很简单，但有更快的方法。而不是通过从 
CPU到GPU的总线发送由许多三角形组成的细分曲面，将曲面表 
示发送到GPU并让它处理数据扩展更有意义。回想一下，细分阶段 
在第3.6节中描述。有关快速复习的信息，请参见图 17.53。曲面 
细分器可以使用分数曲面细分技术，这将在下一节中描述。然后是 
----------------------- Page 808-----------------------
关于自适应曲面细分的部分，最后，我们将介绍如何使用曲面细分 
硬件渲染Catmull-Clark曲面和位移贴图曲面。17.6.1分数曲面细 
分为了获得参数曲面更平滑的细节水平，Moreton引入了分数曲面 
细分因子[1240]。这些因素实现了有限形式的自适应曲面细分，因 
为可以在参数曲面的不同侧上使用不同的曲面细分因子。这里，将 
介绍这些技术如何工作的概述。在图 17.54中，左侧显示行和列的 
常量曲面细分因子，右侧显示所有四个边的独立曲面细分因子。请 
注意，边缘的曲面细分因子是在该边缘上生成的点数减去 1。在右 
侧的补丁中，对于这两个边缘，内部使用较大的顶部和底部因子， 
并且类似地，在内部使用较大的左和右因子。因此，基本镶嵌率为 
4×8。对于具有较小因子的边，沿边缘填充三角形。Moreton[1240] 
更详细地描述了这个过程。图 17.55中的边缘显示了分数曲面细分 
因子的概念。对于整数曲面细分因子n，在k/ n处生成 n+1个点， 
其中k=0，....。。，n。对于分数曲面细分因子，r，.r。积分是生 
成的以 k/ r，17.6编辑。高效的细分769图17.54。左：正常曲面 
细分 - 一个因子用于行，另一个用于列。右：所有四条边上的独立 
镶嵌因子。 （Moreton[1240]之后的插图。）图17.55。顶部：整 
数镶嵌。中：分数曲面细分，右边的分数。底部：分数镶嵌与中间 
的分数。这种配置避免了相邻贴片之间的裂缝。其中k=0,. 。。，.r.. 
这里，.r。计算r的上限，这是朝向+∞的最接近整数，和.r。计算 
地板，这是最接近.∞的整数。然后，最右边的点被 “捕捉”到最右 
端点。从图 17.55中的中图可以看出，这种模式不对称。这会导致 
----------------------- Page 809-----------------------
问题，因为相邻的贴片可能在另一个方向上产生点，所以在表面之 
间产生裂缝。Moreton通过创建点的对称模式解决了这个问题，如 
图17.55的底部所示。有关示例，请参见图17.56。图17.56。具 
有矩形域的补丁进行分数细分。（Moreton[1240]之后的插图。） 
770 17.曲线和曲面1.01.21.52.0图17.57。三角形的分数镶嵌， 
显示曲面细分因子。请注意，细分因子可能与实际细分硬件产生的 
细分不完全对应。 （Tatarchuk之后的插图[1745]。）到目前为止， 
我们已经看到了用矩形域曲面细分曲面的方法，例如 B'ezier贴片。 
但是，三角形也可以使用分数进行镶嵌[1745]，如图17.57所示。 
与四边形一样，也可以为每个三角形边缘指定独立的分数曲面细分 
率。如上所述，这可以实现自适应曲面细分 （第 17.6.2节），如图 
17.58所示，其中渲染了位移映射地形。一旦创建了三角形或四边 
形，就可以将它们转发到管道中的下一步，这将在下一小节中处理。 
17.6.2自适应细分如果采样率足够高，均匀细分可以得到很好的结 
果。然而，在表面上的一些区域中，可能不像其他区域那样需要高 
镶嵌。这可能是因为表面在某些区域弯曲得更快，因此可能需要更 
高的曲面细分，而表面的其他部分几乎是平坦的或远的，并且只需 
要几个三角形来近似它们。生成不必要三角形问题的解决方案是自 
适应曲面细分，它是指根据某种度量调整曲面细分率的算法（例如 
图17.58。使用自适应分数曲面细分的位移地形渲染。如放大网格 
中可见在右边，红色三角形的边缘使用独立的分数镶嵌率，这为我 
们提供了自适应镶嵌。（图片由GameComputingApplications 
----------------------- Page 810-----------------------
Group，Advanced MicroDevices，Inc。提供）17.6。高效镶嵌 
771图17.59。左边，两个区域之间可以看到裂缝。这是因为右边 
的镶嵌率比左边高。问题在于右侧区域已经评估了存在黑色圆圈的 
表面，而左侧区域没有。标准解决方案显示在右侧。曲率，三角形 
边长或某些屏幕尺寸测量）。图 17.58显示了地形的自适应镶嵌的 
示例。必须注意避免在不同的镶嵌区域之间出现裂缝。见图17.59。 
使用分数细分时，通常将边缘细分因子基于仅来自边缘本身的信息， 
因为边缘数据都是在两个连接的补丁之间共享的。这是一个良好的 
开端，但由于浮点不准确，仍然可能出现裂缝。Nie.ner等。[1279] 
讨论如何使计算完全不透水，例如，通过确保对于边缘，无论是否 
从p0到p1进行细分，反之亦然，都会返回完全相同的点。在本节 
中，我们将介绍一些可用于计算分数曲面细分率的通用技术，或决 
定何时终止进一步细分以及何时将较大的补丁拆分为一组较小的补 
丁。终止自适应细分为了提供自适应细分，我们需要确定何时停止 
细分，或者等效地如何计算分数细分因子。您可以仅使用边缘信息 
来确定是否应终止曲面细分，或使用整个三角形或组合中的信息。 
还应注意，使用自适应曲面细分，如果某个边缘的曲面细分因子从 
一帧到另一帧变化太大，则可以逐帧游动或弹出伪影。在计算曲面 
细分因子时，这可能是要考虑的因素。给定边缘（a，b），具有相 
关的曲线，即斑块边缘曲线，我们可以尝试估计曲线在a和b之间 
的平坦程度。见图17.60。找到a和b之间的参数空间的中点，并 
计算其三维对应物c。最后，计算c与其投影d之间的长度 l，在a 
----------------------- Page 811-----------------------
和 b之间的线上。该长度 l用于确定该边缘上的曲线段是否足够平 
坦。如果 l足够小，则认为是扁平的。注意，该方法可能错误地认 
为S形曲线段是平坦的。对此的解决方案是随机扰动参数样本点 
[470]。仅使用l的替代方法是使用772 17.曲线和曲面图17.60。 
已经在该表面上生成了点a和 b。问题是：是否应在表面上生成一 
个新点，即c？比率l/ ||a。b||，给出相对度量[404]。请注意，此 
技术也可以扩展为考虑三角形，您只需计算三角形中间的曲面点， 
并使用从该点到三角形平面的距离。为了确保这种类型的算法终止， 
通常设置一些可以进行细分的上限。达到该限制时，细分结束。对 
于分数曲面细分，从c到d的矢量可以投影到屏幕上，及其 （缩放） 
长度用作镶嵌率。到目前为止，我们已经讨论了如何仅从表面的形 
状确定曲面细分率。通常用于实时曲面细分的其他因素包括顶点的 
局部邻域是否为[769,1935]：1。在视锥体内。2.正面。3.占据屏幕 
空间的大面积。4.靠近物体的轮廓。这些因素将在这里依次讨论。 
对于视锥体剔除，可以放置球体来包围边缘。然后针对视锥体测试 
该球体。如果它在外面，我们不会进一步细分那个边缘。对于面剔 
除，可以从表面描述计算a，b和可能c的法线。这些法线与a，b 
和c一起定义了三个平面。如果全部都是背面，很可能该边缘不需 
要进一步细分。实现屏幕空间覆盖有许多不同的方法（另请参见第 
19.9.2节）。所有方法都将一些简单的对象投影到屏幕上并估计屏 
幕空间中的长度或区域。大面积或长度意味着应该进行曲面细分。 
图17.61显示了从a到b的线段的屏幕空间投影的快速估计。首先， 
----------------------- Page 812-----------------------
转换线段，使其中点位于视线上。然后，假设线段与近平面n平行， 
并且从该线段计算屏幕空间投影s。使用图中右边的线段a'和 b'的 
点，屏幕空间投影则是s =p （a'。b'）· （a'。b'）v· （a'。 e）。 
 （17.71）17.6。高效的细分773图17.61。估计线段的屏幕空间投 
影s。分子只是线段的长度。这除以从眼睛e到线段中点的距离。 
然后将计算出的屏幕空间投影s与阈值t进行比较，阈值t表示屏幕 
空间中的最大边缘长度。重写前一个等式以避免计算平方根，如果 
满足以下条件，则曲面细分应继续：s>t.. （a'。b'）· （a'。b'）>t2 
 （v· （a） '。e））2。 （17.72）注意t2是常数，因此可以预先计 
算。对于分数曲面细分，可以使用公式 17.71中的s作为曲面细分 
速率，可能应用缩放因子。测量投影边长的另一种方法是将球体放 
置在边缘的中心，使半径为边长的一半，然后使用球体的投影作为 
边缘曲面细分因子[1283]。该测试与面积成比例，而上述测试与边 
长成比例。增加轮廓的镶嵌率非常重要，因为它们对于对象的感知 
质量起着主要作用。通过测试a处的法线与从眼睛到a的矢量之间 
的点积是否接近于零，可以找到三角形是否接近轮廓边缘。如果对 
于a，b或c中的任何一个都是如此，则应进行进一步的细分。对于 
移位细分，Nie.ner和 Loop [1281]对每个基础网格顶点v使用以 
下因子之一，其连接到 n个边向量ei，我∈{0,1，....。。，n。1}： 
f1 =k1·||c。v ||，f2 =k2qXei×ei +1，f3 =k3max.. ||e0 ||， 
||e1 ||,. 。。，||en.1 ||？，（17.73）其中循环索引i遍历连接到 
v的所有n个边ei，c是摄像机的位置，ki是用户提供的常数。这 
----------------------- Page 813-----------------------
里，f1简单地基于距相机的顶点的距离，f2计算连接到v的四边形 
的面积，f3使用最大的边长。顶点的曲面细分因子为774 17.曲线 
和曲面曲面然后计算为边的两个基顶点的曲面细分因子的最大值。 
内部曲面细分因子被计算为相对边缘曲面细分因子的最大值（在u 
和v 中）。此方法可与本节中介绍的任何边缘曲面细分因子方法一 
起使用。值得注意的是，Nie.ner等人。[1279]建议对字符使用单 
个全局镶嵌因子，这取决于到角色的距离。细分的数量是.log2f。， 
其中f是每个字符的细分因子，可以使用上述任何方法计算。很难 
说哪种方法适用于所有应用程序。最好的建议是测试几种呈现的启 
发式方法及其组合。分裂和骰子方法Cook等。[289]引入了一种称 
为分割和骰子的方法，目标是对曲面进行曲面细分，使每个三角形 
变为像素大小，以避免几何混叠。出于实时目的，此曲面细分阈值 
应增加到GPU可以处理的范围。首先将每个补丁递归地分割成一组 
子补丁，直到估计如果对某个子补丁使用均匀曲面细分，三角形将 
具有所需的大小。因此，这也是一种自适应曲面细分。想象一下， 
一个大型补丁被用于景观。一般而言，例如，分数曲面细分无法进 
行调整以使曲面细分率更接近相机并且更低距离。因此，分割和骰 
子的核心可用于实时渲染，即使目标曲面细分率在我们的情况下具 
有比像素大小更大的三角形。接下来，我们将描述实时图形场景中 
分割和骰子的一般方法。假设使用矩形贴片。然后用整个参数域启 
动递归例程，即从（0,0）到（1,1）的平方。使用刚才描述的自适 
应终止标准，测试表面是否足够细分。如果是，则终止曲面细分。 
----------------------- Page 814-----------------------
否则，将此域拆分为四个不同的同样大的正方形，并为四个子方块 
中的每一个递归调用例程。递归继续，直到曲面足够细分或达到预 
定义的递归级别。该算法的本质意味着在曲面细分期间递归地创建 
四叉树。但是，如果相邻的子方格被细分为不同的级别，这将产生 
裂缝。标准解决方案是确保两个相邻的子方格最多只在一个级别上 
不同。这称为受限四叉树。然后使用图 17.59右侧所示的技术填充 
裂缝。这种方法的缺点是簿记涉及更多。Liktor等。[1044]呈现用 
于GPU的分裂和骰子的变体。问题是当由于例如相机已经移近表面 
而突然决定再次分裂时避免游泳伪影和爆裂效应。为了解决这个问 
题，他们使用分数分割方法，灵感来自分数曲面细分。如图 17.62 
所示。由于分裂从曲线的一侧朝向曲线的中心平滑地引入，或者朝 
向贴片侧的中心平滑地引入，因此避免了游泳和爆裂伪影。当自适 
应镶嵌的终止标准为 17.6时。高效细分775t =8t =6t =4t =2 
t =4 1.00.50.51.0图17.62。分数分裂应用于立方B'ezier曲线。 
显示每条曲线的曲面细分率t。分裂点是大的黑色圆圈，它从曲线的 
右侧向曲线的中心移动。为了对三次曲线进行分数分割，黑点平滑 
地向曲线中心移动，原始曲线被两个立方 B'ezier段替换，这两个段 
一起生成原始曲线。在右边，针对补丁说明了相同的概念，补丁已 
被拆分为四个较小的子补丁，其中 1.0表示分割点位于边缘的中心 
点，0.0表示它位于补丁角。（在 Liktor等人[1044]之后的图示） 
已到达，每个剩余的子片段也由GPU使用分数细分进行细分。17.6.3 
快速Catmull-ClarkTessellationCatmull-Clark表面 第（17.5节）。 
----------------------- Page 815-----------------------
2）经常用于建模软件和特征电影渲染，因此能够使用图形硬件有效 
地渲染这些也是有吸引力的。近年来，Catmull-Clark表面的快速 
镶嵌方法一直是一个活跃的研究领域。在这里，我们将介绍一些这 
些方法。近似方法 Loop 和 Schaefer [1070]提出了一种将 
Catmull-Clark曲面转换为可以在域着色器中快速评估的表示的技 
术，而无需知道多边形的邻居。如第 17.5.2节所述，当所有顶点都 
是普通顶点时，Catmull-Clark曲面可以描述为许多小的B样条曲 
面。Loop和Schaefer将原始Catmull-Clark细分网格中的四边形 
 （四边形）多边形转换为双立方B'ezier曲面 （第 17.2节）。1）。 
这对于非四边形是不可能的，因此我们假设没有这样的多边形（回 
想一下，在细分的第一步之后只有四边形多边形）。当顶点的化合 
价不同于4 时，不可能创建与Catmull-Clark表面相同的双三次 
B'ezier贴片。因此，提出了近似表示，其对于具有四价顶点的四边 
形是精确的，并且在其他地方接近Catmull-Clark表面。为此，使 
用几何补丁和切线补丁，这将在下面描述。几何贴片只是一个带有 
4×4控制点的双三次 B'ezier贴片。我们将描述如何计算这些控制 
点。完成此操作后，可以对补丁进行细分，域着色器可以在77617 
快速评估 B'ezier补丁。曲线和曲面422 144 114 114 1624 
1281图17.63。左：四边形网格的一部分，我们想要为灰色四边 
形计算 B'ezier贴片。请注意，灰色四边形的顶点只有四价。蓝色顶 
点是相邻的四边形顶点，绿色圆圈是 B'ezier贴片的控制点。以下三 
个插图显示了用于计算绿色控制点的不同掩模。例如，为了计算内 
----------------------- Page 816-----------------------
部控制点之一，使用中间右侧掩模，并且使用掩模中显示的权重对 
四边形的顶点进行加权。任何参数坐标（u，v）。因此，假设我们 
的网格只包含四个顶点的四边形，我们希望计算网格中某个四边形 
的相应B'ezier补丁的控制点。为此，需要四边形附近的邻域。标准 
方法如图 17.63所示，其中显示了三种不同的掩模。这些可以旋转 
和反射，以创建所有16个控制点。注意，在实现中，掩码的权重应 
该总和为 1，为清楚起见，这里省略了该过程。上述技术为普通情 
况计算B'ezier补丁。当存在至少一个非常顶点时，我们计算一个特 
殊的补丁[1070]。这个掩模如图17.64所示，其中灰色四边形中的 
左下顶点是一个非常顶点。请注意，这会导致贴片接近 
Catmull-Clark细分曲面，并且沿着具有非常顶点的边缘仅为C0。 
添加阴影时，这通常会分散注意力，因此建议使用与N-patch相似 
的技巧 （第 17.2.4节）。但是，为了降低计算复杂度，有两个44 1 
4 114 n214 22 1n24 1122n图17.64。左：生成网格灰色 
四边形的B'ezier补丁。灰色四边形中的左下顶点是非常的，因为其 
效价是 n6=4.蓝色顶点是相邻四边形的顶点，绿色圆圈是B'ezier 
贴片的控制点。以下三个插图显示了用于计算绿色控制点的不同掩 
模。17.6。高效的细分777图17.65。左：网格的四边形结构。白 
色四边形是普通的，绿色有一个非常顶点，蓝色有一个以上。中左： 
几何贴片近似。中右：具有切线补丁的几何补丁。请注意，明显的 
 （红色圆圈）着色伪影消失了。右：真正的Catmull-Clark表面。 
 （图片由Charles Loop和ScottSchaefer提供，经微软公司许可 
----------------------- Page 817-----------------------
转载。）切线补丁得出：一个在u方向，一个在v方向。然后发现 
法线作为这些矢量之间的叉积。通常，B'ezier贴片的导数使用公式 
17.35计算。然而，由于导出的B'ezier斑块接近Catmull-Clark表 
面，因此切线斑块将不会形成连续的正常场。请参阅 Loop和 
Schaefer关于如何克服这些问题的论文[1070]。图17.65显示了可 
能发生的工件类型的示例。Kovacs等人。[931]描述了如何扩展上 
述方法以处理折痕和角落（第 17.5.3节），并在Valve的Source 
引擎中实现这些扩展。功能自适应细分和OpenSubdiv Pixar提出 
了一个名为OpenSubdiv的开源系统，它实现了一组称为特征自适 
应细分（FAS）的技术[1279,1280,1282]。基本方法与刚才讨论的 
先前技术有很大不同。这项工作的基础在于细分相当于常规面的双 
三次B样条补丁 （第 17.2.6节），即每个顶点是规则的四边形，这 
意味着顶点的价数为四。因此，细分仅针对非正常面继续递归，直 
到达到某个最大细分级别。这在图 17.66的左侧说明。FAS还可以 
处理折痕和半光滑折痕[347]，FAS算法还需要细分这些折痕，如图 
17.66右侧所示。可以使用曲面细分管道直接渲染双三次 B样条曲 
面片。该方法首先使用CPU创建表。此表对在细分到指定级别期间 
需要访问的顶点的索引进行编码。因此，基础网格可以是动画的， 
因为索引独立于顶点位置。一旦生成双三次B样条补丁，就不需要 
继续递归，这意味着该表通常变得相对较小。基础网格和具有索引 
以及附加价数和折痕数据的表被上载到GPU一次。778 17.曲线和 
曲面图17.66。左：围绕非常顶点的递归细分，即中间顶点有三条 
----------------------- Page 818-----------------------
边。随着递归的继续，它留下了一条规则的补丁（有四个顶点，每 
个顶点有四个入射边缘）。右：在中间用粗线表示的平滑折痕周围 
细分。 （Nie.ner等人[1279]之后的插图。）为了将网格细分一步， 
首先计算新的面部点，然后计算新的边缘点，最后更新顶点，并且 
每个顶点都使用一个计算着色器。这些类型。对于渲染，可以区分 
完整补丁和过渡补丁。完整补丁（FP）仅与具有相同细分级别的补 
丁共享边缘，并且使用GPU细分管道将常规 FP直接渲染为双三次 
B样条补丁。否则细分继续。自适应细分过程确保相邻补丁之间最 
多存在一个细分级别的差异。转换补丁（TP）在细分级别与至少一 
个邻居之间存在差异。为了获得无裂缝渲染，每个TP被分成几个子 
补丁，如图 17.67所示。这样，曲面细分顶点沿每条边的两侧匹配。 
使用实现插值变体的不同外壳和域着色器渲染每种类型的子补丁。 
例如，图17.67中最左边的情况呈现为三个三角形B样条补丁。在 
非常顶点周围，使用另一个域着色器，其中使用Halstead等人的方 
法计算极限位置和极限法线。[655]。使用 OpenSubdiv 的 
Catmull-Clark曲面渲染示例如图17.68所示。图17.67。红色方块 
是过渡补丁，每个都有四个直接邻居，它们是蓝色 （当前细分级别） 
或绿色（下一个细分级别）。此图显示了可能发生的五种配置，以 
及它们如何拼接在一起。（Nie.ner等人[1279]之后的插图。）17.6。 
高效的细分779图17.68。左：绿色和红色线条中的控制网格，使 
用一个细分步骤生成灰色表面 （8k顶点）。中间：网格细分了另外 
两个步骤 （102k顶点）。右：使用自适应曲面细分 （28k顶点）生 
----------------------- Page 819-----------------------
成的曲面。（使用OpenSubdiv的dxViewer生成的图像。）FAS 
算法处理折痕，半光滑折痕，分层细节和自适应细节级别。我们参 
考 FAS论文[1279]和 Nie.ner博士论文[1282]了解更多细节。Sch¨ 
afer等。[1547]提出了一种称为 DFAS的 FAS变体，哪个更快。 
AdaptiveQuadtreesBrainerd等。[190]提出了一种称为自适应四 
叉树的方法。它类似于Loop和Schaefer[1070]的近似方案，其中 
每个原始基础网格的四边形提交单个细分的图元。此外，它预先计 
算一个细分计划，这是一个四叉树，它编码从输入面到最大细分级 
别的层次细分（类似于特征自适应细分）。细分计划还包含细分面 
所需的控制点的模板掩模列表。在渲染过程中，遍历四叉树，从而 
可以将 （u，v） - 坐标映射到细分层次结构中的补丁，可以直接评 
估。四叶树叶是原始面部域的子区域，并且可以使用模板中的控制 
点直接评估该子区域中的表面。迭代循环用于遍历域着色器中的四 
叉树，其输入是参数 （u，v）- 坐标。遍历需要继续，直到到达 （u， 
v）坐标所在的叶节点。根据四叉树中到达的节点类型，采取不同的 
操作。例如，当到达可以直接评估的子区域时，将检索其对应的双 
三次 B样条补丁的 16个控制点，并且着色器继续评估该补丁。有 
关使用此技术呈现的示例，请参见第718页的图 17.1。这种方法是 
迄今为止最精确地渲染Catmull-Clark细分曲面的方法，780 17. 
曲线和曲面图17.69。剩下：根据特征自适应细分 （FAS）的分层细 
分，其中每个三角形和四边形被渲染为单独的细分基元。右：使用 
自适应四叉树进行分层细分，其中整个四边形呈现为单个细分基元。 
----------------------- Page 820-----------------------
 （插图见Brainerd等人[190]。）并处理折痕和其他拓扑特征。使 
用自适应四叉树优于FAS的另一个优点如图17.69所示，并进一步 
显示在图 17.70中。自适应四叉树还提供更均匀的曲面细分，因为 
每个提交的四边形和曲面细分基元之间存在一对一的映射。图 
17.70。使用自适应四叉树的细分补丁。每个补丁，对应一个基础网 
格面，被表面上的黑色曲线包围，并且细分步骤在每个补丁内分层 
示出。可以看出，中心有一个色彩均匀的贴片。这意味着它被渲染 
为双三次B样条补丁，而其他（具有非常顶点）清楚地显示其潜在 
的自适应四叉树。 （图片由WadeBrainerd提供。）17.6。高效的 
细分781进一步阅读和资源曲线和曲面的主题是巨大的，有关更多 
信息，最好查阅专注于此主题的书籍。Mortenson的书[1242]是几 
何建模的一般介绍。Farin[458,460]以及Hoschek和 Lasser[777] 
的书籍是通用的，并且涉及计算机辅助几何设计（CAGD）的许多 
方面。对于隐式曲面，请参阅Gomes等人的书。[558]和deAra'ujo 
等人最近的文章。[67]。有关细分曲面的更多信息，请参阅Warren 
和 Heimer的书[1847]和SIGGRAPH课程中关于Zorin等人的“建 
模和动画细分”的课程说明。[1977]。Ni等人关于细分曲面替代的 
课程。[1275]这里也是一个有用的资源。Nie.ner等人的调查。[1283] 
和Nie.ner的博士论文[1282]非常适合使用GPU实时渲染细分曲面 
的信息。对于样条插值，除了Farin[458]以及Hoschek和 Lasser 
[777]的上述书籍之外，我们还将感兴趣的读者引用到KillerB的书 
[111]。Bermantein多项式的许多性质，包括曲线和曲面，都由 
----------------------- Page 821-----------------------
Goldman [554]给出。几乎所有关于三角形 B'ezier曲面的知识都 
可以在 Farin的文章[457]中找到。另一类有理曲线和曲面是非均匀 
有理 B样条（NURBS）[459,1416,1506]，常用于CAD。第18章 
管道优化 “我们应该忘记小的效率，大约97％的时间说：过早的优 
化是所有邪恶的根源。” - 唐纳德·克鲁特在本卷中，算法已经在质 
量，内存和绩效权衡。在本章中，我们将讨论与特定算法无关的性 
能问题和机会。瓶颈检测和优化是重点，从进行小的局部变化开始， 
并以结构化整个应用程序的技术结束，以利用多处理功能。正如我 
们在第2章中看到的，渲染图像的过程基于流水线架构，具有四个 
概念阶段：应用程序，几何处理，光栅化和像素处理。总有一个阶 
段是瓶颈 - 管道中最慢的过程。这意味着该瓶颈阶段设置了吞吐量 
的限制，即总渲染性能，因此是优化的主要候选者。优化渲染流水 
线的性能类似于优化流水线处理器 （CPU）的过程[715]，因为它主 
要包括两个步骤。首先，找到了管道的瓶颈。其次，该阶段以某种 
方式进行了优化;在那之后，如果未达到性能目标，则重复步骤 1。 
请注意，在优化步骤之后，瓶颈可能位于也可能不位于同一位置。 
最好只投入足够的精力来优化瓶颈阶段，以便将瓶颈转移到另一个 
阶段。在此阶段再次成为瓶颈之前，可能必须优化其他几个阶段。 
出于这个原因，不应该浪费过度优化阶段。瓶颈的位置可能在一帧 
内变化，甚至在平局调用中也会发生变化。在某一时刻，几何阶段 
可能是瓶颈，因为渲染了许多小三角形。稍后在帧中，像素处理可 
能是瓶颈，因为在每个像素处评估重量级程序着色器。在像素着色 
----------------------- Page 822-----------------------
器中，执行可能会停止，因为纹理队列已满，或者在达到特定循环 
或分支时花费更多时间。因此，当我们谈论应用程序阶段是783784 
18.管道优化瓶颈时，我们的意思是它是该框架中大部分时间的瓶 
颈。很少有一个瓶颈。另一种利用流水线结构的方法是认识到，当 
最慢的阶段不能进一步优化时，其他阶段可以与最慢的阶段一样工 
作。这不会改变性能，因为最慢阶段的速度不会改变，但额外处理 
可用于改善图像质量[1824]。例如，假设瓶颈处于应用阶段，产生 
帧需要50毫秒（ms），而其他每个需要25ms。这意味着在不改 
变渲染管道的速度（50毫秒等于每秒20帧）的情况下，几何体和 
光栅化器阶段也可以在50毫秒内完成它们的工作。例如，假设这不 
会增加应用程序阶段的工作量，我们可以使用更复杂的照明模型或 
增加阴影和反射的真实度。计算着色器还会改变我们对瓶颈和未使 
用资源的思考方式。例如，如果正在渲染阴影贴图，则顶点和像素 
着色器很简单，如果光栅化器或像素合并等固定功能阶段成为瓶颈， 
则GPU计算资源可能未得到充分利用。使用异步计算着色器重叠这 
样的绘制可以在这些条件出现时使着色器单元保持忙碌[1884]。基 
于任务的多处理将在本章的最后一节中讨论。流水线优化是我们首 
先最大化渲染速度，然后允许非瓶颈的阶段消耗与瓶颈一样多的时 
间的过程。也就是说，它并不总是一个简单的过程，因为GPU和驱 
动程序可以有自己的特点和快速路径。在阅读本章时，由于优化技 
术对于不同的体系结构而言差异很大，所以知道您的体系结构应该 
始终在您的脑海中。也就是说，要特别注意基于特定GPU的功能实 
----------------------- Page 823-----------------------
现进行优化，因为硬件可以并且会随着时间的推移而变化[530]。简 
单来说，一个相关的格言是测量，测量，测量。18。1分析和调试 
工具分析和调试工具在查找代码中的性能问题时非常有用。能力各 
不相同，可能包括：。帧捕获和可视化。通常可以使用逐步帧重放， 
并显示正在使用的状态和资源。。分析在CPU和GPU上花费的时 
间，包括调用图形API所花费的时间。18.1。分析和调试工具785。 
着色器调试，以及可能的热编辑，以查看更改代码的效果。。使用 
在应用程序中设置的调试标记，以帮助识别代码区域。分析和调试 
工具因操作系统，图形API以及GPU供应商而异。大多数组合都 
有工具，这就是神创造谷歌的原因。那说，我们将提到一些专门用 
于交互式图形的软件包名称，以帮助您开始您的任务：。RenderDoc 
是 DirectX，OpenGL和Vulkan的高质量Windows调试器，最初 
由Crytek开发，现在是开源的。。GPU PerfStudio是AMD针对 
其图形硬件产品的工具套件，适用于Windows和 Linux。提供的一 
个值得注意的工具是静态着色器分析器，无需运行应用程序即可提 
供性能估计。AMD的RadeonGPU Profiler是一个独立的相关工 
具。。NVIDIANsight是一个具有广泛功能的性能和调试系统。它 
与Windows上的VisualStudio和 MacOS和 Linux上的Eclipse 
集成。。微软的 PIX早已被Xbox开发者使用，并已在Windows 
上用于 DirectX12。Visual Studio的Graphics Diagnostics可以 
与早期版本的 DirectX一起使用。。Microsoft的GPUView使用事 
件跟踪Windows （ETW），一种高效的事件记录系统。GPUView 
----------------------- Page 824-----------------------
是 ETW会话消费者的几个程序之一。它侧重于CPU和GPU之间 
的交互，显示哪个是瓶颈[783]。。图形性能分析器 （GPA）是英特 
尔的一个套件，不专门针对其图形芯片，专注于性能和帧分析。。 
OSX上的Xcode提供了 Instruments，它有多种工具可用于计时， 
性能，网络，内存泄漏等。值得一提的是OpenGL ESAnalysis， 
它可以检测性能和正确性问题并提出解决方案，以及MetalSystem 
Trace，它提供来自应用程序，驱动程序和GPU的跟踪信息。这些 
是几年来存在的主要工具。也就是说，有时没有工具可以完成这项 
工作。定时器查询调用内置于大多数API 中，以帮助分析GPU的 
性能。一些供应商也提供了访问GPU计数器和线程跟踪的库。786 
18.管道优化 18.2找到瓶颈优化管道的第一步是找到最大的瓶颈 
[1679]。找到瓶颈的一种方法是设置多个测试，其中每个测试减少 
特定阶段执行的工作量。如果这些测试之一导致每秒帧数增加，则 
发现瓶颈阶段。测试阶段的相关方法是减少其他阶段的工作量，而 
不会减少测试阶段的工作量。如果性能没有改变，瓶颈是工作量没 
有改变的阶段。性能工具可以提供有关哪些API调用很昂贵的详细 
信息，但不一定能准确确定管道中哪个阶段正在减慢其余部分。即 
使他们这样做，理解每个测试背后的想法也是有用的。以下是对用 
于测试各个阶段的一些想法的简要讨论，以便了解如何进行此类测 
试。理解底层硬件的重要性的一个完美示例伴随着统一着色器架构 
的出现。从2006年底开始，它构成了许多GPU的基础。这个想法 
是顶点，像素和其他着色器都使用相同的功能单元。GPU负责负载 
----------------------- Page 825-----------------------
平衡，改变分配给顶点的单位与像素着色的比例。例如，如果渲染 
一个大的四边形，只有少数着色器单元可以分配给顶点变换，而批 
量则被赋予片段处理的任务。精确定位瓶颈是在顶点还是像素着色 
器阶段不太明显[1961]。然而，作为整体或另一个阶段的着色器处 
理仍将是瓶颈，因此我们依次讨论每种可能性。18.2.1测试应用程 
序阶段如果正在使用的平台配有用于测量处理器工作负载的实用程 
序，则可以使用该实用程序查看您的程序是否使用 100％ （或接近） 
的CPU处理功率。如果CPU一直在使用，您的程序可能会受CPU 
限制。这并非总是万无一失，因为应用程序有时可能会等待GPU完 
成一个帧。我们谈论的程序是CPU或GPU限制的，但瓶颈可能会 
在帧的生命周期内发生变化。测试CPU限制的一种更智能的方法是 
发送导致GPU几乎不做任何工作的数据。对于某些系统，这可以通 
过简单地使用空驱动程序 （接受调用但不执行任何操作的驱动程序） 
而不是真实驱动程序来实现。这有效地设置了运行整个程序的速度 
的上限，因为您不使用图形硬件也不调用驱动程序，因此CPU上的 
应用程序始终是瓶颈。通过这个测试，您可以了解在应用程序阶段 
未运行的基于GPU的阶段有多少改进空间。那说，请注意，使用空 
驱动程序还可以隐藏由于驱动程序自身处理和CPU与GPU之间的 
通信而导致的任何瓶颈。驱动程序通常可能是CPU端瓶颈的原因， 
这是我们稍后将深入讨论的主题。18.2。找到瓶颈787另一种更直 
接的方法是在可能的情况下对 CPU进行降频[240]。如果性能与 
CPU速率成正比，则应用程序至少在某种程度上受CPU限制。可 
----------------------- Page 826-----------------------
以为GPU执行相同的降频方法。如果GPU速度变慢并且性能下降， 
那么至少在某些时候应用程序受GPU限制。这些降频方法可以帮助 
识别瓶颈，但有时会导致一个不成为瓶颈的阶段。另一种选择是超 
频，但你没有在这里阅读。18.2。2测试几何处理阶段几何阶段是 
最难测试的阶段。这是因为如果此阶段的工作负载发生变化，那么 
其中一个或两个阶段的工作负载也经常会发生变化。为了避免这个 
问题，Cebenoyan [240]提供了一系列测试工作，从光栅化器阶段 
开始支持管道。在几何阶段可能会出现瓶颈的两个主要区域：顶点 
提取和处理。要查看瓶颈是否是由对象数据传输引起的，请增加顶 
点格式的大小。例如，这可以通过为每个顶点发送几个额外的纹理 
坐标来完成。如果性能下降，这个领域就是瓶颈。顶点处理由顶点 
着色器完成。对于顶点着色器瓶颈，测试包括使着色器程序更长。 
必须注意确保编译器不优化这些附加指令。如果管道也使用几何着 
色器，则它们的性能是输出大小和程序长度的函数。如果您使用曲 
面细分着色器，则程序长度会再次影响性能以及曲面细分因子。改 
变这些元素中的任何一个，同时避免其他阶段执行的工作的变化， 
可以帮助确定是否有任何瓶颈。18.2.3测试光栅化阶段此阶段包括 
三角形设置和三角形遍历。阴影贴图生成使用极其简单的像素着色 
器，可以在光栅化器或合并阶段产生瓶颈。虽然通常很少[1961]， 
三角形设置和光栅化可能是来自曲面细分的小三角形或草或树叶等 
物体的瓶颈。但是，小三角形也可以增加顶点和像素着色器的使用。 
给定区域中的更多顶点明显增加了顶点着色器负载。像素着色器负 
----------------------- Page 827-----------------------
载也会增加，因为每个三角形都被一组2×2四边形光栅化，因此每 
个三角形外部的像素数量会增加[59]。这有时被称为四重过度（第 
23.1节）。要查找光栅化是否真的成为瓶颈，请通过增加其程序大 
小来增加顶点和像素着色器的执行时间。如果每帧的渲染时间没有 
增加，则瓶颈处于光栅化阶段。78818.管道优化 18.2。4测试像素 
处理阶段可以通过更改屏幕分辨率来测试像素着色器程序的效果。 
如果较低的屏幕分辨率导致帧速率明显上升，则像素着色器可能是 
瓶颈，至少在某些时候。如果有一套详细的系统，就必须小心。较 
小的屏幕也可能简化显示的模型，减轻几何阶段的负荷。降低显示 
分辨率还会影响三角形遍历，深度测试和混合以及纹理访问等成本。 
为了避免这些因素并隔离瓶颈，一种方法与顶点着色器程序相同， 
添加更多指令以查看对执行速度的影响。再次，重要的是确定编译 
器不会优化这些附加指令。如果帧渲染时间增加，则像素着色器是 
瓶颈（或者至少在某些时候因为其执行成本增加而成为瓶颈）。或 
者，像素着色器可以简化为最少数量的指令，这在顶点着色器中通 
常很难做到。如果整体渲染时间减少，则发现瓶颈。纹理高速缓存 
未命中也可能是昂贵的。如果用 1×1分辨率版本替换纹理可以提供 
相当快的性能，那么纹理内存访问是一个瓶颈。着色器是具有自己 
的优化技术的独立程序。Persson[1383,1385]介绍了几种低级着色 
器优化，以及有关图形硬件如何发展以及最佳实践如何变化的细节。 
18.2.5测试合并阶段在此阶段进行深度和模板测试，完成混合，并 
将幸存的结果写入缓冲区。更改这些缓冲区的输出位深度是改变此 
----------------------- Page 828-----------------------
阶段带宽成本的一种方法，并查看它是否可能成为瓶颈。为不透明 
对象打开Alpha混合或使用其他混合模式也会影响光栅操作执行的 
内存访问和处理量。这个阶段可能是后处理过程，阴影，粒子系统 
渲染以及在较小程度上渲染头发和草地的瓶颈，其中顶点和像素着 
色器很简单，因此几乎没有工作。18.3性能测量为了优化我们需要 
测量。这里我们讨论GPU速度的不同度量。图形硬件制造商过去常 
常提出峰值速率，例如每秒顶点数和每秒像素数，这些最高难以达 
到。此外，由于我们正在处理流水线系统，因此真正的性能并不像 
列出这些数字那么简单。这是因为瓶颈的位置可能从一次移动到另 
一次，并且不同的管道阶段在执行期间以不同的方式相互作用。 
18.3。性能测量789由于这种复杂性，GPU部分基于其物理属性进 
行营销，例如内核的数量和时钟速率，内存大小，速度和带宽。总 
而言之，GPU计数器和线程跟踪 （如果可用）是很好用的重要诊断 
工具。如果某些给定部分的峰值性能已知且计数较低，则该区域不 
太可能成为瓶颈。一些供应商将计数器数据作为每个阶段的利用率 
百分比。这些值是在瓶颈可以移动的给定时间段内，因此并不完美， 
但在找到瓶颈方面有很大帮助。越多越好，但即使看似简单的物理 
测量也难以精确比较。例如，同一GPU的时钟速率可能因IHV合 
作伙伴而异，因为每个合作伙伴都有自己的冷却解决方案，因此它 
的GPU超出其认为安全的范围。甚至在单个系统上进行 FPS基准 
比较并不总是听起来那么简单。NVIDIA的GPU Boost [1666]和 
AMD的PowerTune[31]技术就是我们 “了解你的架构”的典范。 
----------------------- Page 829-----------------------
 “NVIDIA的GPUBoost之所以产生，部分原因是因为一些综合基 
准测试同时处理了GPU管道的许多部分，因此将功耗降至极限，这 
意味着 NVIDIA必须降低其基本时钟速率以防止芯片过热。许多应 
用程序不会在这种程度上运行管道的所有部分，因此可以安全地以 
更高的时钟速率运行。GPU Boost技术可跟踪GPU功率和温度特 
性，并相应地调整时钟速率。AMD和英特尔的GPU具有类似的功 
耗/性能优化。这种可变性可能导致相同的基准测试以不同的速度运 
行，具体取决于GPU的初始温度。为了避免这个问题，Microsoft 
在 DirectX12中提供了一种锁定GPU核心时钟频率的方法，以获 
得稳定的时序[121]。其他API可以检查电源状态，但更复杂[354]。 
在测量CPU的性能时，趋势是避免使用 IPS（每秒指令数），FLOPS 
 （每秒浮点运算数），千兆赫数和简单的短基准。相反，首选方法 
是测量一系列不同的真实程序的挂钟时间[715]，然后比较这些程序 
的运行时间。遵循这一趋势，大多数独立的图形基准测试用于测量 
几个给定场景的FPS中的实际帧速率，以及各种不同的屏幕分辨率， 
以及抗锯齿和质量设置。许多图形密集型游戏包括基准测试模式或 
由第三方创建的游戏，这些基准测试通常用于比较GPU。虽然FPS 
是比较运行基准的GPU的有用简写，但在分析一系列帧速率时应该 
避免使用。FPS的问题在于它是一个倒数测量，而不是线性测量， 
因此可能导致分析错误。例如，假设您发现应用程序在不同时间的 
帧速率为50,50和20 FPS。如果平均这些值，则可获得40 FPS。 
这个价值充其量是误导。这些帧速率转换为20,20和 50毫秒，因 
----------------------- Page 830-----------------------
此平均帧时间为30ms，即33.3FPS。同样，在测量各个算法的性 
能时，几乎需要毫秒。对于具有790的特定基准测试情况18.管道 
优化给定测试和给定机器，可以说某些特定的阴影算法或后处理效 
果 “成本”为7 FPS，并且基准测试运行得慢得多。但是，概括这 
个陈述是没有意义的，因为这个值还取决于处理帧中其他所有内容 
所花费的时间，并且因为你不能将不同技术的 FPS加在一起 （但你 
可以添加时间）[1378]。为了能够看到流水线优化的潜在影响，重 
要的是在禁用双缓冲的情况下测量每帧的总渲染时间，即在单缓冲 
模式下通过关闭垂直同步来测量。这是因为打开双缓冲时，缓冲区 
的交换仅与监视器的频率同步，如第2.1节中的示例所述。De 
Smedt[331]讨论了分析帧时间，以便从CPU工作负载中的尖峰中 
查找并修复帧断续问题，以及优化性能的其他有用技巧。通常需要 
使用统计分析。还可以使用 GPU时间戳来了解帧内发生的事情 
[1167,1422]。原始速度很重要，但对于移动设备，另一个目标是优 
化功耗。有目的地降低帧速率但保持应用程序交互可以显着延长电 
池寿命并且对用户的体验几乎没有影响[1200]。Akenine-M'oller 
和Johnsson [25,840]指出，每瓦性能就像每秒帧数一样，与 FPS 
有相同的缺点。他们认为更有用的衡量标准是每个任务的焦耳，例 
如每像素的焦耳。18.4优化一旦找到瓶颈，我们希望优化该阶段以 
提高性能。在本节中，我们将介绍应用程序，几何，光栅化和像素 
处理阶段的优化技术。18.4.1应用程序阶段通过使代码更快并且程 
序的内存访问更快或更少来优化应用程序阶段。在这里，我们将介 
----------------------- Page 831-----------------------
绍一般适用于CPU的代码优化的一些关键元素。对于代码优化，在 
大多数时间花费在代码中的位置是至关重要的。一个好的代码分析 
器对于找到大部分时间花费的代码热点至关重要。然后在这些地方 
进行优化工作。程序中的这些位置通常是内部循环，每帧执行多次 
的代码片段。优化的基本规则是尝试各种策略：重新检查算法，假 
设和代码语法，尽可能尝试变体。CPU架构和编译器性能通常会限 
制用户形成​ ​ 关于如何编写最快代码的直觉的能力，因此质疑您 
的假设并保持开放的心态。18.4。优化791最初的步骤之一是试验 
编译器的优化标志。通常会有许多不同的标志可供尝试。关于使用 
什么优化选项的假设很少（如果有的话）。例如，将编译器设置为 
使用更积极的循环优化可能会导致代码更慢。此外，如果可能的话， 
尝试不同的编译器，因为这些编译器以不同的方式进行优化，而且 
有些编译器显着优越。您的探查器可以告诉您任何更改有什么影响。 
内存问题多年前，算术指令的数量是算法效率的关键指标;现在关键 
是内存访问模式。处理器速度比 DRAM的数据传输速率快得多，后 
者受到引脚数的限制。从 1980年到2005年，CPU性能大约每两 
年翻一番，DRAM性能每六倍翻一番[1060]。这个问题被称为Von 
Neumann瓶颈或记忆墙。面向数据的设计侧重于缓存一致性作为 
优化的手段.1在现代GPU上，重要的是数据传播的距离。速度和功 
率成本与此距离成正比。缓存访问模式可以达到数量级的性能差异 
[1206]。缓存是一个存在的小型fastmemory 区域，因为程序中通 
常存在很大的一致性，缓存可以利用它。那是，存储器中的附近位 
----------------------- Page 832-----------------------
置倾向于一个接一个地访问（空间局部性），并且通常顺序地访问 
代码。此外，存储器位置倾向于被重复访问（时间局部性），高速 
缓存也利用[389]。处理器缓存快速访问，仅次于寄存器以提高速度。 
许多快速算法用于在本地（和尽可能少）访问数据。寄存器和本地 
缓存构成存储器层次结构的一端，其延伸到动态随机存取存储器 
 （DRAM）旁边，然后存储在SSD和硬盘上。顶部是少量快速，昂 
贵的内存，底部是大量缓慢且廉价的存储。在层次结构的每个级别 
之间，速度会下降一些明显的因素。见图18.1。例如，通常在一个 
时钟周期内访问处理器寄存器，在几个周期内访问 L1高速缓存存储 
器。通过这种方式，级别的每次更改都会增加延迟。正如3.10节所 
讨论的那样，架构有时会隐藏延迟，但它始终是一个必须牢记的因 
素。在分析器中很难直接检测到错误的内存访问模式。从一开始就 
需要在设计中构建好的模式[1060]。下面是编程时应该考虑的指针 
列表。。在代码中顺序访问的数据也应该按顺序存储在内存中。例 
如，当渲染三角形网格时，如果按顺序访问纹理坐标＃0，正常＃0， 
颜色＃0，顶点＃0，纹理坐标＃1和正常＃1，则顺序存储在存储器 
中。这也可以是1这个研究领域不应该与数据驱动设计混淆，数据 
驱动设计可能意味着任何数量的东西，从AWK编程语言到A/ B 
测试。792 18.流水线优化CPU处理器寄存器 L1，L2，L3缓存随 
机存取存储器固态磁盘存储硬盘驱动器云存储/外部备份图 18.1。内 
存层次结构。当我们下降金字塔时，速度和成本会降低。在GPU上 
很重要，就像变换后的顶点缓存一样 （第 16.4.4节）。另请参见第 
----------------------- Page 833-----------------------
16.4.5节，了解为什么存储单独的数据流可能是有益的。。避免指 
针间接，跳转和函数调用（在代码的关键部分），因为这些可能会 
显着降低CPU性能。当您按照指向另一个指针的指针时，您将获得 
指针间接，依此类推。现代CPU试图推测性地执行指令 （分支预测） 
和获取存储器（缓存预取）以使其所有功能单元忙于运行代码。当 
代码流在循环中一致时，这些技术非常有效，但是在分支数据结构 
 （如二叉树，链表和图形）中失败; 尽可能使用数组。McVoy和 
Staelin[1194]显示了一个代码示例，它通过指针跟随链表。这会导 
致之前和之后数据的缓存未命中，并且它们的示例使CPU停止的时 
间比跟踪指针所花费的时间长100多倍 （如果缓存可以提供指针的 
地址）。Smits [1668]注意到如何将基于指针的树展平为具有跳过 
指针的列表显着改善了层次结构遍历。使用van EmdeBoas布局 
是帮助避免缓存未命中的另一种方法 - 请参见第 19.1.4节。高分 
支树通常优于二叉树，因为它们减少了树的深度，因此减少了间接 
量。。将经常使用的数据结构与高速缓存行大小的倍数对齐可以显 
着提高整体性能。例如，64字节高速缓存行在 Intel和AMD处理 
器上是常见的[1206]。编译器选项可以提供帮助，但考虑到对齐 （称 
为填充），设计数据结构是明智的。用于Windows和Linux的VTune 
和CodeAnalyst，用于Mac的Instruments以及用于Linux的开 
源Valgrind等工具可以帮助识别缓存瓶颈。对齐也会影响GPU着 
色器性能[331]。18.4。优化793。尝试不同的数据结构组织。例如， 
Hecker[698]展示了如何通过测试简单矩阵乘法器的各种矩阵结构 
----------------------- Page 834-----------------------
来节省大量时间。结构数组，structVertex {floatx，y，z;};顶点 
myvertices[1000];或者数组的结构，structVertexChunk{floatx 
[1000]，y [1000]，z [1000];};VertexChunk myvertices;对于给 
定的架构可能更好。第二种结构更适合使用SIMD命令，但随着顶 
点数量的增加，缓存未命中的可能性也会增加。随着阵列大小的增 
加，混合方案，structVertex4{floatx [4]，y [4]，z [4];};Vertex4 
myvertices[250];可能是最好的选择。。在启动时为相同大小的对 
象分配大量内存通常会更好，然后使用您自己的分配和自由例程来 
处理该池的内存[113,736]。Boost等库提供了池分配。一组连续记 
录比单独分配创建的记录更可能是高速缓存一致的。也就是说，对 
于具有垃圾收集的语言，例如C＃和Java，池实际上可以降低性能。 
虽然与内存访问模式没有直接关系，但值得避免在呈现循环中分配 
或释放内存。使用池并分配暂存空间一次，并且只有堆栈，数组和 
其他结构增长 （使用变量或标志来记录应将哪些元素视为已删除）。 
18.4.2API调用在本书中，我们根据硬件的一般趋势给出了建议。 
例如，索引顶点缓冲区对象通常是为加速器提供几何数据的最快方 
法 （第 16.4.5节）。本节介绍如何最好地调用图形API本身。大多 
数图形API具有类似的体系结构，并且有很好的方法可以有效地使 
用它们。了解对象缓冲区分配和存储是高效渲染的基础[1679]。对 
于具有CPU和独立的独立GPU的桌面系统，每个GPU通常都有 
自己的内存。图形驱动程序通常控制对象所在的位置，但可以给出 
最佳存储位置的提示。常见的分类是静态缓冲区和动态缓冲区。如 
----------------------- Page 835-----------------------
果缓冲区的数据正在改变每个帧，则使用动态缓冲区（最好不需要 
GPU上的永久存储空间）。控制台，具有低功耗集成GPU的笔记 
本电脑和移动794 18.管道优化设备通常具有统一内存，GPU和 
CPU共享相同的物理内存。即使在这些设置中，在正确的池中分配 
资源也很重要。正确地将资源标记为仅CPU或仅GPU也可以产生 
好处。一般来说，如果两个芯片都必须访问一个内存区域，那么当 
一个芯片写入时，另一个必须使其缓存失效 - 这是一项昂贵的操作 
- 以确保不会获得过时的数据。如果对象没有变形，或者变形可以 
完全由着色器程序 （例如，蒙皮）执行，则将对象的数据存储在GPU 
存储器中是有利的。可以通过将其存储为静态缓冲区来发信号通知 
该对象的不变性质。通过这种方式，对于每个渲染的帧，它不必通 
过总线发送，从而避免了管道这个阶段的任何瓶颈。GPU上的内部 
存储器带宽通常远高于CPU和GPU之间的总线。状态更改调用API 
有几个与之相关的成本。在应用程序方面，无论调用实际执行的是 
什么，更多调用意味着花费更多的应用程序时间。此成本可以是最 
小的或明显的，并且空驱动程序可以帮助识别它。依赖于来自GPU 
的值的查询功能可能由于与 CPU 同步的停顿而使帧速率减半 
[1167]。在这里，我们将深入研究优化常见的图形操作，准备管道 
绘制网格。此操作可能涉及更改状态，例如，设置着色器及其制服， 
附加纹理，更改混合状态或使用的颜色缓冲区等。应用程序提高性 
能的主要方法是通过将具有类似呈现状态的对象分组来最小化状态 
更改。因为GPU是一个极其复杂的状态机，也许是计算机科学中最 
----------------------- Page 836-----------------------
复杂的，改变状态可能很昂贵。虽然可能涉及GPU的一小部分成本， 
但大部分费用来自驱动程序在CPU上的执行。如果GPU很好地映 
射到API，则状态变化成本往往是可预测的，尽管仍然很重要。如 
果GPU具有严格的功率限制或有限的硅足迹，例如某些移动设备， 
或者有解决的硬件错误，则驱动程序可能必须执行导致意外高成本 
的英雄事件。状态变化成本主要在CPU侧，在驱动程序中。一个具 
体的例子是 PowerVR架构如何支持混合。在较旧的API 中，使用 
固定功能类型的接口指定混合。PowerVR的混合是可编程的，这意 
味着它们的驱动程序必须将当前混合状态修补到像素着色器[699]。 
在这种情况下，更高级的设计不能很好地映射到API，因此在驱动 
程序中会产生显着的设置成本。虽然在本章中我们注意到硬件架构 
和运行它的软件会影响各种优化的重要性，但对于状态变化成本尤 
其如此。即使特定的GPU类型和驱动程序版本也可能有效。在阅读 
时，请想象一下在本节的每一页上用大红色字母标记的 “您的里程 
可能会有所不同”。18.4。优化795 Everitt和 McDonald [451] 
注意到不同类型的状态变化在成本上有很大差异，并且对于在 
NVIDIAOpenGL驱动程序上执行一秒钟的少数几次提供了一些粗 
略的想法。从2014年开始，这是他们的订单，从最贵到最少：。 
渲染目标 （帧缓冲对象），~60k/sec。。着色器程序，~300k/sec。。 
混合模式 （ROP），例如透明度。。纹理绑定，约 1.5M/秒。。顶 
点格式。。统一缓冲区对象（UBO）绑定。。顶点绑定。。统一更 
新，约 10M/秒。这个近似成本顺序由其他人证实[488,511,741]。 
----------------------- Page 837-----------------------
一个更昂贵的变化是在GPU的渲染模式和它的计算着色器模式之 
间切换[1971]。避免状态更改可以通过对着色器进行分组来对要显 
示的对象进行排序，然后使用纹理，依此类推成本顺序。按状态排 
序有时称为批处理。另一种策略是重构对象的数据，以便进行更多 
共享。最小化纹理绑定变化的常用方法是将几个纹理图像放入一个 
大纹理中，或者更好的是纹理数组。如果API支持它，无绑定纹理 
是避免状态更改的另一种选择（第6.2.5节）。与更新制服相比， 
更改着色器程序通常相对昂贵，因此一类材质中的变化可以通过使 
用 “if”语句的单个着色器更好地表示。您也可以通过共享着色器来 
制作更大的批次[1609]。然而，使着色器更复杂也会降低GPU的性 
能。衡量什么是有效的是唯一简单易懂的方法。对图形API进行更 
少，更有效的调用可以节省一些额外的成本。例如，通常可以定义 
几个制服并将其设置为一组，从而绑定一个单个统一缓冲对象的效 
率要高得多[944]。在 DirectX中，这些称为常量缓冲区。正确使用 
这些可以节省每个函数的时间和每个单独API调用中错误检查所花 
费的时间[331,613]。现代司机经常推迟设置状态，直到遇到第一个 
绘图调用。如果在此之前进行了冗余API调用，则驱动程序将对这 
些进行过滤，从而避免执行状态更改。通常使用脏标记来指示需要 
进行状态更改，因此在每次绘制调用之后返回基本状态可能会变得 
昂贵。例如，您可能希望在约796时默认情况下关闭状态X 18.管 
道优化以绘制对象。实现这一目标的一种方法是 “启用（X）;绘制 
 （M1）;禁用 （X）; “然后”启用 （X）;绘制 （M2）;禁用 （X）; “因 
----------------------- Page 838-----------------------
此，每次平局后恢复状态。但是，即使在它们之间没有发生实际状 
态变化，也可能浪费大量时间在两个绘制调用之间再次设置状态。 
通常，应用程序对何时需要状态更改具有更高级别的知识。例如， 
从透明表面的 “替换”混合模式变为透明表面的 “过度”模式通常 
需要在帧期间进行一次。在渲染每个对象之前发布混合模式可以很 
容易地避免。Galeano[511]展示了忽略这种过滤和发出不需要的状 
态调用将如何使他们的WebGL应用程序花费近2毫秒/帧。但是， 
如果驱动程序已经有效地进行了这种冗余过滤，那么在应用程序中 
每次调用执行相同的测试可能是一种浪费。过滤掉API调用所需的 
工作量主要取决于底层驱动程序[443,488,741]。整合和实例化使用 
API​ ​ 可以有效避免CPU成为瓶颈。API的另一个问题是小批量 
问题。如果忽略，这可能是影响现代API性能的重要因素。简而言 
之，一些三角形填充网格比许多小而简单的网格渲染效率更高。这 
是因为每次绘制调用都存在固定成本开销，无论大小如何，处理基 
元所需的成本。早在2003年，Wloka [1897]表明，每批绘制两个 
 （相对较小的）三角形的距离是GPU测试的最大吞吐量的375倍。 
而不是每秒1.5亿个三角形，速率为40万，一个2.7GHz的CPU。 
对于由许多小而简单的对象组成的场景，每个对象只有几个三角形， 
性能完全由API限制;GPU无法增加它。也就是说，绘制调用的CPU 
上的处理时间大于GPU实际绘制网格所花费的时间，因此GPU缺 
乏。Wloka的经验法则是 “每帧获得X个批次。”这是每帧可以进 
行的最大绘制调用次数，这完全是由于CPU是限制因素。2003年， 
----------------------- Page 839-----------------------
API成为瓶颈的断点是每个对象约 130个三角形。图18.2显示了断 
点在2006年如何上升到每个网格510个三角形。时代变了。为改 
善这种绘图调用问题做了大量工作，CPU变得更快。2003年的建 
议是每帧300次抽签;在2012年，每帧 16,000次抽签是一个团队 
的上限[1381]。也就是说，即使这个数字对于一些复杂的场景也是 
不够的。使用 DirectX 12，Vulkan和 Metal等现代API，驱动程 
序成本本身可以最小化 - 这是它们的主要优势之一[946]。但是， 
GPU可以拥有自己的每个网格固定成本。2Wloka使用批处理来表 
示使用绘制调用渲染的单个网格。这个术语多年来已经扩大，现在 
有时意味着要呈现的具有相同状态的一组单独对象，因为可以减少 
API开销。18.4。优化797图18.2。使用运行 DirectX10的NVIDIA 
G80GPU的英特尔酷睿2双核2.66GHzCPU的批量性能基准测 
试。不同大小的批次在不同条件下运行和定时。 “低”条件适用于 
仅具有位置和恒定颜色像素着色器的三角形;另一组测试用于合理 
的网格和阴影。 “单个”多次渲染单个批次。 “Instancing”重用 
网格数据并将每个实例数据放在一个单独的流中。“常量”是DirectX 
10方法，其中实例数据放在常量内存中。可以看出，小批量会伤害 
所有方法，但实例化会比例地提高性能。在几百个三角形中，性能 
水平超出，因为瓶颈变为从顶点缓冲区和缓存中检索顶点的速度。 
 （图片由NVIDIA公司提供。）减少绘制调用次数的一种方法是将 
多个对象合并为一个网格，只需要一次绘制调用即可渲染该集合。 
对于使用相同状态且静态的对象组，至少相对于彼此，可以进行一 
----------------------- Page 840-----------------------
次合并，并且可以每帧重复使用批次[741,1322]。能够合并网格是 
考虑通过使用常见着色器和纹理共享技术来避免状态更改的另一个 
原因。合并带来的成本节约不仅仅是避免API绘制调用。应用程序 
本身也可以节省处理更少的对象。然而，如果批量比所需要的大得 
多，则可以使其他算法（例如视锥体剔除）效率降低[1381]。一种 
做法是使用边界卷层次结构来帮助查找和分组彼此靠近的静态对 
象。合并的另一个问题是选择，因为所有静态对象在一个网格中是 
无差别的。典型的解决方案是在网格中的每个顶点处存储对象标识 
符。最小化应用程序处理和API成本的另一种方法是使用某种形式 
的实例化[232,741,1382]。大多数API都支持拥有79818.Pipeline 
Optimization对象的想法，并在一次调用中多次绘制它。这通常通 
过指定基本模型并提供单独的数据结构来完成，该数据结构保存有 
关所需的每个特定实例的信息。除了位置和方向之外，还可以为每 
个实例指定其他属性，例如由于风引起的叶子颜色或曲率，或者着 
色器程序可以使用的任何其他属性来影响模型。可以通过自由使用 
实例来创建郁郁葱葱的丛林场景。见图 18.3。人群场景非常适合实 
例化，通过从一组选择中选择不同的身体部位，每个角色都显得独 
特。可以通过随机着色和贴花来添加进一步的变化。实例化也可以 
与详细程度技术相结合[122,1107,1108]。有关示例，请参见图 
18.4。将合并和实例化组合在一起的概念称为合并实例化，其中合 
并网格包含可以反过来实例化的对象[146,1382]。理论上，几何着 
色器可用于实例化，因为它可以创建传入网格的重复数据。实际上， 
----------------------- Page 841-----------------------
如果需要许多实例，则此方法可能比使用实例化API命令慢。几何 
着色器的目的是执行局部的小规模数据放大[1827]。此外，对于某 
些架构，例如Mali的基于tile的渲染器，几何着色器在软件中实现。 
引用马里的最佳实践指南[69]， “找到解决问题的更好方法。几何 
着色器不是您的解决方案。 “18.4.3几何体阶段几何体阶段负责变 
换，每顶点照明，裁剪，投影和屏幕映射。其他章节讨论了减少流 
经管道的数据量的方法。高效的三角形网格存储，模型简化和顶点 
数据压缩 （第 16章）都可以节省处理时间和内存。截头锥和遮挡剔 
除等技术（第19章）避免在管道中发送完整的原语本身。在CPU 
上添加如此大规模的技术可以完全改变应用程序的性能特征，因此 
值得在开发早期尝试。在GPU上，这种技术不太常见。一个值得注 
意的例子是计算着色器如何用于执行各种类型的剔除[1883,1884]。 
可以根据每个顶点，每个像素（在像素处理阶段中）或两者来计算 
照明元素的效果。可以通过多种方式优化照明计算。首先，应考虑 
使用的光源类型。所有三角形都需要照明吗？有时，模型只需要纹 
理化，在顶点处使用颜色进行纹理处理，或者只需要顶点处的颜色。 
如果光源相对于几何是静态的，则可以预先计算漫射和环境光，并 
将其存储为顶点处的颜色。这样做通常被称为照明上的 “烘烤”。 
更精细的预照明形式是预先计算场景中的漫反射全局照明（第 
11.5.1节）。这种照明可以作为颜色或强度存储在顶点处或作为光 
照图。18.4。优化799图18.3。植被实例化。下图中相同颜色的所 
有对象都在单个绘图调用中呈现[1869]。 （图片来自CryEngine1， 
----------------------- Page 842-----------------------
由Crytek提供。）80018.管道优化图 18.4。人群现场。使用实例 
化可以最大限度地减少所需的绘制调用次数。还使用了详细程度技 
术，例如为远程模型渲染冒名顶替者[1107,1108]。（图片由 
JonathanMa.m ，Barbara Yersin ，Mireille Clavien 和 Daniel 
Thalmann提供。）对于前向渲染系统，光源的数量会影响几何阶 
段的性能。更多的光源意味着更多的计算。减少工作的常用方法是 
禁用或减少局部照明，而是使用环境贴图 （第 10.5节）。18.4.4光 
栅化阶段光栅化可以通过几种方式进行优化。对于封闭（实心）物 
体以及永远不会显示其背面的物体（例如，房间墙壁的背面），应 
打开背面剔除 （第 19.3节）。这将光栅化的三角形数量减少了大约 
一半，因此减少了三角形遍历的负荷。另外，当像素着色计算昂贵 
时，这可能是特别有益的，因为背面从不被遮蔽。18.4.5像素处理 
阶段优化像素处理通常是有利可图的，因为通常存在比顶点多的像 
素。有明显的例外。即使绘图最终不生成任何可见像素，也必须始 
终处理顶点。渲染引擎中的无效剔除可能会使顶点着色成本超过像 
素着色。太小的三角形不仅导致更多的顶点着色评估，而不是18.4。 
需要优化801，但也可以创建更多部分覆盖的四边形，从而导致额 
外的工作。更重要的是，仅覆盖几个像素的纹理网格通常具有较低 
的线程占用率。如3.10节所述，采样纹理需要花费大量时间，GPU 
通过切换到其他片段上执行着色器程序来隐藏，稍后在获取纹理数 
据时返回。低占用率可能导致隐藏的延迟较差。使用大量寄存器的 
复杂着色器也可以通过允许一次使用更少的线程来降低占用率（第 
----------------------- Page 843-----------------------
23.3节）。这种情况称为高套准压力。还有其他细微之处，例如， 
频繁切换到其他 warp 可能会导致更多缓存未命中。Wronski 
[1911,1914]讨论了各种占用问题和解决方案。首先，使用原生纹理 
和像素格式，即使用图形加速器内部使用的格式，以避免从一种格 
式到另一种格式的可能昂贵的转换[278]。另外两种与纹理相关的技 
术只加载所需的 mipmap级别（第 19.10.1节）和使用纹理压缩（第 
6.2.6节）。像往常一样，越来越少的纹理意味着使用更少的内存， 
这反过来意味着更低的传输和访问时间。纹理压缩还可以提高缓存 
性能，因为相同数量的缓存内存被更多像素占用。一个级别的细节 
技术是使用不同的像素着色器程序，这取决于对象与观看者的距离。 
例如，在一个场景中有三个飞碟模型，最近的可能有一个精心设计 
的凹凸贴图，用于表面细节，两个更远的地方不需要。此外，最远 
的碟子可能会将镜面突出显示简化或完全删除，既可简化计算又可 
减少 “萤火虫”，即来自欠采样的闪烁伪影。在简化模型上使用每 
个顶点的颜色可以提供额外的好处，即由于纹理改变而不需要状态 
改变。仅当片段在光栅化三角形时可见时，才会调用像素着色器。 
GPU的early-z测试（第23.7节）检查片段与z缓冲区的z深度。 
如果不可见，则丢弃片段而不进行任何像素着色器评估，从而节省 
大量时间。虽然可以通过像素着色器修改z深度，但这样做意味着 
无法执行早期z测试。为了理解程序的行为，尤其是像素处理阶段 
的负载，可视化深度复杂度是有用的，深度复杂度是覆盖像素的表 
面的数量。图18.5显示了一个示例。生成深度复杂度图像的一种简 
----------------------- Page 844-----------------------
单方法是使用类似OpenGL的glBlendFunc （GLONE，GLONE） 
的调用，禁用z缓冲。首先，图像被清除为黑色。然后使用颜色 （1 
/255,1/255,1/255）渲染场景中的所有对象。混合函数设置的效 
果是对于渲染的每个图元，写入的像素的值将增加一个强度级别。 
深度复杂度为0的像素则为黑色，深度复杂度为255的像素为全白 
色（255,255,255）。像素过度绘制的数量与实际渲染的表面数量 
有关。通过再次渲染场景，但启用了z缓冲区，可以找到像素着色 
器的计算次数。Overdraw是努力量802 18.管道优化图 18.5。左 
侧场景的深度复杂度显示在右侧。（使用 NVIDIACorporation的 
NVPerfHUD创建的图像。浪费计算表面的阴影，然后由稍后的像 
素着色器调用隐藏。延迟渲染 （第20.1节）和光线跟踪的优点是在 
执行所有可见性计算之后执行着色。假设两个三角形覆盖一个像素， 
因此深度复杂度为2。如果首先绘制更远的三角形，则更近的三角 
形将其拉长，并且透支的数量为 1。如果首先绘制较近的，则更远 
的三角形未通过深度测试而未绘制，因此没有透支。对于覆盖像素 
的随机不透明三角形集，平均绘制数是谐波系列[296]：H （n）=1 
+12 +13 +。。。+1n。（18.1）这背后的逻辑是渲染的第一 
个三角形是一个平局。第二个三角形位于第一个三角形的前面或后 
面，50/50的机会。与前两个三角形相比，第三个三角形可以有三 
个位置中的一个，其中三个三角形位于最前面。当n变为无穷大时， 
limn→∞H （n）=ln （n）+γ，（18.2）其中γ=0.57721。。。 
是 Euler-Mascheroni常数。当深度复杂性较低时，透支会迅速上 
----------------------- Page 845-----------------------
升，但会迅速逐渐减少。例如，深度复杂度为4时平均为2.08次抽 
取，11次为 3.02次抽取，但深度复杂度为 12,367次，平均达到 
10.00次抽取。因此，透支不一定像看起来那么糟糕，但我们仍然 
希望尽量减少它，而不会花费太多的CPU时间。粗略地排序然后以 
近似的前后顺序（靠近远处）绘制场景中的不透明对象是减少透支 
的常用方法[240,443,488,511]。稍后绘制的被遮挡的对象将不会写 
入颜色或z缓冲区 （即，减少过度绘制）。此外，在甚至达到 18.4 
之前，可以通过遮挡剔除硬件来拒绝像素片段。优化803距离场着 
色器 ID纹理ID透明度位图 18.6。绘制顺序的示例排序键。键从低 
到高排序。设置透明度位意味着对象是透明的，因为透明对象将在 
所有不透明对象之后呈现。物体与相机的距离存储为低精度的整数。 
对于透明对象，距离是反转或否定的，因为我们需要按从后到前的 
顺序对象。每个着色器都有一个唯一的标识号，纹理也是如此。像 
素着色器程序 （第23.5节）。可以通过许多方法完成排序。基于沿 
所有不透明对象的质心的视图方向的距离的显式排序是一种简单的 
技术。如果已经使用边界体积层次结构或其他空间结构进行视锥体 
剔除，我们可以选择在层次结构下面首先遍历的更近的子体。另一 
种技术对于具有复杂像素着色器程序的表面非常有用。执行 
z-prepass会首先将几何体渲染到z缓冲区，然后正常渲染整个场 
景[643]。这消除了所有过度绘制着色器评估，但代价是完全单独运 
行所有几何体。Pettineo[1405]写道，他的球队在他们的视频游戏 
中使用深度预防的主要原因是为了避免透支。然而，以粗略的前后 
----------------------- Page 846-----------------------
顺序绘制可以提供大部分相同的好处，而无需额外的工作。混合方 
法是识别并首先绘制一些可能带来最大益处的大型简单封堵器 
[1768]。正如McGuire[1177]所指出的那样，一个完整的预制通道 
并没有帮助他的特定系统的性能。测量是了解哪种技术（如果有的 
话）对您的应用最有效的唯一方法。之前我们建议使用着色器和纹 
理进行分组，以最大限度地减少状态变化;这里我们讨论按距离排序 
的渲染对象。这两个目标通常给出不同的对象绘制顺序，因此相互 
冲突。对于给定的场景和视点，总有一些理想的绘制顺序，但这很 
难提前找到。混合方案是可能的，例如，按深度排序附近的物体， 
并按材料排序其他所有物体[1433]。一种常见的，灵活的解决方案 
[438,488,511,1434,1882]是为每个对象创建一个排序密钥，通过为 
每个对象分配一组来封装所有相关标准。见图18.6。我们可以选择 
按距离排序，但是通过限制存储深度的位数，我们可以允许着色器 
分组与给定距离范围内的对象相关。将绘制分类为两个或三个深度 
分区并不罕见。如果某些对象具有相同的深度并使用相同的着色器， 
则纹理标识符用于对对象进行排序，然后将对象与具有相同纹理的 
对象组合在一起。这是一个简单的例子，并且是情境化的，例如， 
渲染引擎本身可以将不透明和透明对象分开，这样就不需要透明位。 
其他字段的位数肯定会随最大值 804而变化。管道优化 RGBA 
RGBAYCo RGBARGBAYCgYCgYCo RGBARGBARGBARGBA 
YCoYCgYCgYCo图18.7。左：4×2像素，每个像素存储四个颜 
色分量（RGBA）。右：一种替代表示，其中每个像素以棋盘图案 
----------------------- Page 847-----------------------
存储亮度Y和第一（Co）或第二（Cg）色度分量。预期着色器和 
纹理的数量。可以添加或替换其他字段，例如用于混合状态的字段 
和用于z缓冲区读取和写入的另一个字段。最重要的是建筑。例如， 
移动设备上的一些基于磁贴的GPU渲染器从前后排序都没有任何 
好处，因此状态排序是优化的唯一重要元素[1609]。这里的主要思 
想是将所有属性放入一个整数键可以让您执行有效的排序，从而尽 
可能地减少过度绘制和状态更改。18.4.6帧缓冲技术渲染场景通常 
会导致对帧缓冲区和许多像素着色器执行的大量访问。为了减轻缓 
存层次结构的压力，一个常见的建议是减少帧缓冲区的每个像素的 
存储大小。虽然每个颜色通道的 16位浮点值提供更高的精度，但8 
位值是大小的一半，这意味着假设精度足够，访问速度更快。色度 
通常在许多图像和视频压缩方案中进行二次采样，例如JPEG和 
MPEG。由于人类视觉系统对亮度比对色度更敏感的事实，这通常 
可以用可忽略的视觉效果来完成。例如，Frostbite游戏引擎[1877] 
使用这种色度子采样的思想来降低用于后处理其每通道 16位图像 
的带宽成本。Mavridis和 Papaioannou[1144]提出在第 197页描 
述的有损YCoCg变换用于在光栅化期间对颜色缓冲器实现类似的 
效果。它们的像素布局如图 18.7所示。与 RGBA相比，这会减少 
颜色缓冲存储要求（假设不需要A），并且通常会提高性能，具体 
取决于架构。由于每个像素只有一个色度成分，在显示之前转换回 
RGB之前，需要重建滤波器来推断每个像素的完整YCoCg。例如， 
对于缺少Co值的像素，可以使用四个最接近的Co值的平均值。然 
----------------------- Page 848-----------------------
而，这不会重建边缘以及期望的边缘。因此，使用简单的边缘感知 
滤波器，其实现为Co =X3i=0wiCo，i，其中wi =1.0。步骤 （t。 
|Li.L|）， （18.3）18.5。对于不具有Co的像素的多处理805，其 
中Co，i和 Li是当前像素的左，右，顶部和底部的值，L是当前像 
素的亮度，并且t是阈值用于边缘检测。Mavridis和 Papaioannou 
使用t =30/255。如果x <0，则步骤（x）函数为0，否则为1。 
因此，滤波器权重wi为0或 1，如果亮度梯度|Li.L|大于t，则它 
们为零。具有源代码的WebGL演示可在线获得[1144]。由于显示 
分辨率的持续增加和着色器执行成本的节省，使用棋盘图案进行渲 
染已经在若干系统中使用[231,415,836,1885]。对于虚拟现实应用， 
Vlachos [1824]对于视图周边的像素使用棋盘图案，并且Answer 
[59]将每个2×2quad减少一到三个样本。18.4.7合并阶段确保仅 
在有用时启用混合模式。理论上，可以为每个三角形设置 “过度” 
合成，不透明或透明，因为使用 “over”的不透明表面将完全覆盖 
像素中的值。但是，这比简单的 “替换”光栅操作更昂贵，因此， 
使用切口纹理和具有透明度的材料来跟踪对象是值得的。或者，有 
一些光栅操作不需要额外费用。例如，当使用z缓冲区时，在某些 
系统上，访问模板缓冲区也不需要额外的时间。这是因为8位模板 
缓冲区值存储在与24位z深度值相同的字中[890]。考虑何时需要 
使用或清除各种缓冲区是值得的。由于GPU具有快速清除机制 （第 
23.5节），因此建议始终清除颜色和深度缓冲区，因为这样可以提 
高这些缓冲区的内存传输效率。如果可以帮助，通常应该避免将渲 
----------------------- Page 849-----------------------
染目标从GPU读回CPU。CPU的任何帧缓冲区访问都会导致整个 
GPU 管道在返回渲染之前被刷新，从而失去所有并行性 
[1167,1609]。如果您确实发现合并阶段是您的瓶颈，您可能需要重 
新考虑您的方法。你可以使用低精度输出目标，也许通过压缩？有 
没有办法重新排序你的算法，以减轻这个阶段的压力？对于阴影， 
有没有办法缓存和重用没有移动的部分？在本节中，我们讨论了通 
过搜索瓶颈和调整性能来很好地使用每个阶段的方法。也就是说， 
请注意使用完全不同的技术可以更好地服务时反复优化算法的危 
险。18.5多处理传统的API已发展为发出更少的呼叫，每个呼叫都 
做得更多[443，451]。新一代API-DirectX 12，Vulkan，Metal-- 
采取不同的策略。80618.流水线优化对于这些API，驱动程序是简 
化和最小化的，其中大部分复杂性和责任用于验证状态转移到调用 
应用程序，以及内存分配和其他功能[249,1438,1826]。这个重新设 
计很好地完成了最小化绘制调用和状态更改开销，这来自必须将旧 
API 映射到现代GPU。这些新API鼓励的另一个元素是使用多个 
CPU处理器来调用API。2003年左右，由于散热和功耗等几个物 
理问题，CPU的时钟速度不断上升的趋势在 3.4 GHz左右变平 
[1725]。这些限制产生了多处理CPU，而不是更高的时钟速率，更 
多的CPU放在一个芯片中。事实上，许多小内核提供了每单位面积 
的最佳性能[75]，这也是GPU本身如此有效的主要原因。从那时起， 
创建利用并发性的高效可靠的程序一直是挑战。在本节中，我们将 
介绍CPU内核上高效多处理的基本概念，最后讨论图形API如何发 
----------------------- Page 850-----------------------
展以在驱动程序本身内实现更多并发。多处理器计算机可大致分为 
消息传递体系结构和共享存储器多处理器。在消息传递设计中，每 
个处理器都有自己的存储区域，并且在处理器之间发送消息以传达 
结果。这些在实时渲染中并不常见。共享内存多处理器就像听起来 
一样;所有处理器之间共享一个内存的逻辑地址空间。最流行的多处 
理器系统使用共享内存，其中大多数都具有对称多处理（SMP）设 
计。SMP意味着所有处理器都是相同的。多核 PC系统是对称多处 
理架构的一个例子。在这里，我们将介绍使用多个处理器实现实时 
图形的两种通用方法。第一种方法 - 多处理器流水线操作，也称为 
时间并行 - 将比二次并行处理（也称为空间并行）更详细地介绍。 
这两种方法如图 18.8所示。然后将这两种类型的并行性与基于任务 
的多处理结合在一起，其中应用程序创建可以由单个核心拾取和处 
理的作业。18.5。1多处理器流水线操作正如我们所看到的，流水 
线操作是一种通过将作业划分为并行执行的某些流水线阶段来加速 
执行的方法。一个管道阶段的结果传递给下一个。对于n个流水线 
阶段，理想的加速是n次，而最慢的阶段（瓶颈）决定了实际的加 
速。到目前为止，我们已经看到流水线与单个CPU核心和GPU一 
起使用，以并行运行应用程序，几何处理，光栅化和像素处理。当 
主机上有多个处理器可用时，也可以使用流水线操作，在这些情况 
下，它称为多进程流水线操作或软件流水线操作。18.5。多处理807 
Indata管道阶段 1 （CPU1）管道阶段2（CPU2）管道阶段3（CPU 
3）Outdata IndataOutdata并行处理（CPU 1）并行处理（CPU 
----------------------- Page 851-----------------------
2）并行处理（CPU3）图18.8。使用多个处理器的两种不同方式。 
在顶部，我们展示了如何在多处理器管道中使用三个处理器（CPU）， 
在底部我们展示了在三个CPU上的并行执行。这两种实现之间的区 
别之一是，如果使用底部的配置，则可以实现更低的延迟。另一方 
面，使用多处理器管道可能更容易。这两种配置的理想加速是线性 
的，即使用n个CPU可以提供n倍的加速。在这里，我们描述了 
一种软件流水线。无限的变化是可能的，并且该方法应该适应特定 
的应用。在该示例中，应用阶段分为三个阶段[1508]：APP，CULL 
和 DRAW。这是粗粒度流水线，这意味着每个阶段都相对较长。APP 
阶段是管道中的第一阶段，因此控制其他阶段。正是在这个阶段， 
应用程序员可以添加额外的代码，例如，进行碰撞检测。这个阶段 
也更新了观点。CULL阶段可以执行：。在场景图上的遍历和分层视 
图视锥体剔除（第19.4节）。。详细程度选择（第 19.9节）。。 
状态排序，如第 18.4.5节中所述。。最后 （并且总是执行），生成 
应该呈现的所有对象的简单列表。DRAW阶段从CULL阶段获取列 
表并在此列表中发出所有图形调用。这意味着它只需遍历列表并提 
供GPU。图18.9显示了如何使用此管道的一些示例。如果有一个 
处理器核心可用，则所有三个阶段都在该核心上运行。如果两个CPU 
核心可用，则可以在一个核心上执行APP和CULL，在另一个核心 
上执行DRAW。另一种配置是在一个核心上执行APP和CULL808 
18.管道优化图 18.9。多处理器管道的不同配置。粗线表示阶段之间 
的同步，下标表示帧编号。在顶部，显示了单个CPU管道。在中间 
----------------------- Page 852-----------------------
和底部显示了使用两个CPU的两个不同的管道细分。中间有一个用 
于APP和CULL的管道阶段和一个用于DRAW的管道阶段。如果 
DRAW比其他工作要做更多的工作，这是一个合适的细分。在底部， 
APP有一个管道阶段，另外两个有另一个管道阶段。如果APP比其 
他人有更多的工作，这是合适的。请注意，底部的两个配置有更多 
的时间用于APP，CULL和 DRAW阶段。和另一方面的DRAW。 
哪个是最好的取决于不同阶段的工作量。最后，如果主机有三个可 
用核心，则每个阶段都可以在一个单独的核心上执行。这种可能性 
如图 18.10所示。该技术的优点是吞吐量，即渲染速度增加。缺点 
是，与并行处理相比，延迟更大。延迟或时间延迟，是从轮询用户 
的动作到最终图像所花费的时间[1849]。这不应与帧速率混淆，帧 
速率是每秒显示的帧数。例如，假设用户正在使用unteth-图18.10。 
在顶部，显示了一个三级管道。与图 18.9中的配置相比，此配置为 
每个管道阶段提供了更多时间。下图显示了一种减少延迟的方法： 
CULL和 DRAW与之间的 FIFO缓冲重叠。18.5。多处理809ered 
头戴式显示器。确定磁头的位置可能需要 10毫秒才能到达CPU， 
然后渲染帧需要 15毫秒。从初始输入到显示，等待时间为25毫秒。 
即使帧速率为66.7Hz （1/ 0.015秒），如果没有执行位置预测或 
其他补偿，则由于将位置变化发送到CPU的延迟，交互性可能会感 
觉迟缓。忽略由于用户交互而导致的任何延迟（这是两个系统下的 
常量），多处理比并行处理具有更多延迟，因为它使用管道。正如 
下一节中详细讨论的那样，并行处理将框架的工作分解为并发运行 
----------------------- Page 853-----------------------
的部分。与在主机上使用单个CPU相比，多处理器流水线提供了更 
高的帧速率，并且由于同步成本，延迟大致相同或略大。延迟随着 
管道中的阶段数量而增加。对于均衡的应用程序，nCPU的加速是 
n倍。用于减少等待时间的一种技术是在APP阶段结束时更新视点 
和其他等待时间关键的参数[1508]。这将等待时间减少了（大约） 
一帧。减少延迟的另一种方法是执行CULL和 DRAW重叠。这意味 
着只要有任何准备好的渲染，CULL的结果就会被发送到DRAW。 
为此，必须在这些阶段之间进行一些缓冲，通常是 FIFO。这些阶段 
在空旷和充分的条件下停滞不前;也就是说，当缓冲区已满时，CULL 
必须停止，当缓冲区为空时，DRAW必须饿死。缺点是诸如状态排 
序之类的技术不能在相同程度上使用，因为基元必须在它们被CULL 
处理后立即呈现。这种延迟减少技术在图 18.10中可视化。此图中 
的管道最多使用三个CPU，并且这些阶段具有某些任务。但是，这 
种技术绝不仅限于此配置 - 相反，您可以使用任意数量的CPU并 
以您想要的任何方式划分工作。关键是要对整个工作进行智能划分， 
以便管道趋于平衡。多处理器流水线技术需要最少的同步，因为它 
只需要在切换帧时进行同步。附加处理器也可用于并行处理，这需 
要更频繁的同步。18.5.2并行处理使用多处理器流水线技术的一个 
主要缺点是延迟趋于增加。对于某些应用，例如飞行模拟器，第一 
人称射击游戏和虚拟现实渲染，这是不可接受的。移动视点时，通 
常需要即时（下一帧）响应，但是当延迟很长时，这种情况就不会 
发生。这就是说，这一切都取决于。如果多处理将帧速率从具有 1 
----------------------- Page 854-----------------------
帧延迟的30FPS提升到具有2帧延迟的60FPS，则额外帧延迟将 
没有可察觉的差异。81018.流水线优化如果有多个处理器可用，也 
可以尝试同时运行代码的各个部分，这可能会导致更短的延迟。为 
此，程序的任务必须具有并行性的特征。有几种不同的方法可以并 
行化算法。假设有n个处理器可用。使用静态赋值[313]，总工作包， 
如加速结构的遍历，分为n个工作包。然后，每个处理器负责工作 
包，并且所有处理器并行执行其工作包。当所有处理器完成其工作 
包时，可能需要合并处理器的结果。为此，工作负载必须具有高度 
可预测性。如果不是这种情况，可以使用适应不同工作负载的动态 
分配算法[313]。这些使用一个或多个工作池。生成作业时，它们将 
被放入工作池中。然后，CPU可以在完成当前作业时从队列中获取 
一个或多个作业。必须小心，只有一个CPU可以获取特定的作业， 
因此维护队列的开销不会损害性能。较大的作业意味着维护队列的 
开销变得不那么成问题，但另一方面，如果作业太大，则性能可能 
由于系统的不平衡而降低 - 即，一个或多个CPU可能会饿死。对 
于多处理器流水线，在n个处理器上运行的并行程序的理想加速比 
为n倍。这称为线性加速。尽管线性加速很少发生，但实际结果有 
时可能接近它。在第807页的图 18.8中，显示了多处理器管道和 
具有三个CPU的并行处理系统。暂时假设这些应该为每个帧执行相 
同的工作量，并且两个配置都实现线性加速。这意味着与串行执行 
 （即，在单个CPU上）相比，执行将运行快三倍。此外，我们假设 
每帧的总工作量需要30ms，这意味着单个CPU上的最大帧速率将 
----------------------- Page 855-----------------------
是 1/0.03≈33帧/秒。多处理器管道（理想情况下）将工作划分为 
三个大小相等的工作包，并让每个CPU负责一个工作包。然后每个 
工作包需要10毫秒才能完成。如果我们遵循管道中的工作流程，我 
们将看到管道中的第一个CPU工作10毫秒 （即作业的三分之一）， 
然后将其发送到下一个CPU。然后，第一个CPU开始处理下一帧 
的第一部分。当帧最终完成时，它需要30毫秒才能完成，但由于工 
作已在流水线中并行完成，因此每10毫秒就会完成一帧。所以，延 
迟是30毫秒，并且加速是三倍 （30/10），导致每秒 100帧。同一 
程序的并行版本也会将作业分成三个工作包，但这三个包将在三个 
CPU上同时执行。这意味着延迟将是 10毫秒，一帧的工作也需要 
10毫秒。结论是，使用并行处理时的延迟要比使用多处理器管道时 
短得多。 18.5。 entityQuery entityQueryGrp entityQuery 
entityQuery  entityQuery  entityQuery   entityQuery 
shaderDispGroup     shaderDispatch   shaderDispList 
shaderDispatch     shaderDispList    shaderDispatch 
shaderDispList    shaderDispatch     shaderDispList 
shaderDispatch     shaderDispList    shaderDispatch 
shaderDispList    shaderDispatch     shaderDispatch 
shaderDispatch shaderDispList shaderDispatch 图 18.11 。 
FrostbiteCPU作业图，带有一个小的放大部分插图[45]。 （图片由 
Johan Andersson-Electronic Arts提供。）18.5.3基于任务的多 
处理了解流水线和并行处理技术，将两者结合在一个系统中是很自 
----------------------- Page 856-----------------------
然的。如果只有少数处理器可用，那么建立一个将系统明确分配给 
特定核心的简单系统可能是有意义的。然而，鉴于许多CPU上有大 
量内核，趋势是使用基于任务的多处理。就像可以为可以并行化的 
进程创建多个任务（也称为作业）一样，这个想法可以扩展到包括 
流水线。任何核心生成的任何任务都会在生成时放入工作池。任何 
免费的处理器都可以完成任务。转换为多处理的一种方法是获取应 
用程序的工作流程并确定哪些系统依赖于其他系统。见图 18.11。 
812 18.流水线优化在等待同步时处理器停止意味着由于此成本和 
任务管理的开销，应用程序的基于任务的版本甚至可能变慢[1854]。 
然而，许多程序和算法确实具有可以同时执行的大量任务，因此可 
以从中受益。下一步是确定每个系统的哪些部分可以分解为任务。 
作为任务的良好候选者的一段代码的特征包括[45,1060,1854]:.该 
任务具有明确定义的输入和输出。。任务在运行时是独立且无状态 
的，并且始终完成。。它不是一项大任务，它经常成为唯一运行的 
过程。诸如C ++11之类的语言在其中内置了用于多线程的工具 
[1445]。在与英特尔兼容的系统上，英特尔的开源线程构建模块 
 （TBB）是一个高效的库，可以简化任务生成，池化和同步[92]。让 
应用程序创建自己的多处理任务集，例如模拟，碰撞检测，遮挡测 
试和路径规划，在性能至关重要时给出[45,92,1445,1477,1854]。 
我们再次注意到，有时GPU核心往往处于空闲状态。例如，在阴影 
贴图生成或深度预处理期间，这些通常未得到充分利用。在这样的 
空闲时间期间，计算着色器可以应用于其他任务[1313,1884]。根据 
----------------------- Page 857-----------------------
体系结构，API和内容，有时渲染管道无法使所有着色器保持繁忙， 
这意味着总有一些池可用于计算着色。我们不会讨论优化这些问题 
的主题，因为Lauritzen提出了一个令人信服的论点，即由于硬件 
差异和语言限制，编写快速便携的计算着色器是不可能的[993]。如 
何优化核心渲染管道本身是下一节的主题。18.5.4图形API多处理 
支持并行处理通常不映射到硬件约束。例如，DirectX10和更早版 
本一次只允许一个线程访问图形驱动程序，因此实际绘制阶段的并 
行处理更加困难[1477]。图形驱动程序中有两个操作可能使用多个 
处理器：资源创建和与渲染相关的调用。创建纹理和缓冲区等资源 
可以纯粹是CPU端操作，因此可以自然地并行化。也就是说，创建 
和删除也可以阻止任务，因为它们可能会触发GPU上的操作或需要 
特定的设备上下文。在任何情况下，旧的API是在消费级多处理CPU 
存在之前创建的，因此需要重写以支持这种并发。使用的一个关键 
构造是命令缓冲区或命令列表，它可以追溯到一个称为显示列表的 
旧OpenGL概念。命令缓冲区（CB）是API状态更改和绘制调用 
的列表。这些列表可以创建，存储和重放为 18.5。多处理813Exec 
CBA ExecCB MExecCBT ExecCBG当前过程＃1PSprogVS 
progUBO DrawCBA ExecCB NProcess＃4 PSprogVS prog 
UBODrawDrawCBT Process＃3 PSprogVS progUBODraw 
CB M PS prog VS prog UBO Draw CB N Process＃2 Draw 
DrawPSprogVS progUBODrawCBG图18.12。命令缓冲区。 
每个处理器使用其延迟上下文（以橙色显示）来创建和填充一个或 
----------------------- Page 858-----------------------
多个命令缓冲区，以蓝色显示。每个命令缓冲区都被发送到进程＃1， 
进程＃1根据需要使用其直接上下文执行这些操作，如绿色所示。 
进程＃1可以在等待进程＃3的命令缓冲区N时执行其他操作。（在 
Zink等人[1971]之后。）期望。它们也可以组合在一起形成更长的 
命令缓冲区。只有一个CPU处理器通过驱动程序与GPU通信，因 
此可以将其发送给CB执行。但是，每个处理器（包括此单个处理 
器）可以并行创建或连接存储的命令缓冲区。例如，在 DirectX11 
中，与驱动程序通信的处理器将其呈现调用发送到所谓的直接上下 
文。其他处理器均使用延迟上下文来生成命令缓冲区。顾名思义， 
这些不会直接发送给驱动程序。代替，这些被发送到直接上下文进 
行渲染。见图 18.12。或者，可以将命令缓冲区发送到另一个延迟 
上下文，将其插入到自己的CB中。除了向驱动程序发送命令缓冲 
区以执行之外，立即上下文可以执行的主要操作是延迟不能是GPU 
查询和回读。否则，命令缓冲区管理从任一类型的上下文看起来都 
是相同的。命令缓冲区及其前身显示列表的一个优点是可以存储和 
重放它们。命令缓冲区在创建时未完全绑定，这有助于它们的重用。 
例如，假设CB包含视图矩阵。相机移动，因此视图矩阵会发生变 
化。但是，视图矩阵存储在常量814 18.管道优化缓冲区中。常量 
缓冲区的内容不存储在CB中，只存储在它们的引用中。可以在不 
重建CB的情况下更改常量缓冲区的内容。确定如何最佳地最大化 
并行性涉及为每个视图，每个对象，每个材料选择合适的粒度 - 以 
创建，存储和组合命令缓冲区[1971]。这种多线程绘制系统存在多 
----------------------- Page 859-----------------------
年 ， 之 后 命 令 缓 冲 区 成 为 现 代 API 的 一 部 分 
[1152,1349,1552,1554]。API支持使流程更简单，并允许更多工具 
与创建的系统一起使用。但是，命令列表确实具有与之关联的创建 
和内存成本。此外，如第18.4.2节所述，使用DirectX11和OpenGL 
将API的状态设置映射到底层GPU的费用仍然是一项代价高昂的 
操作。在这些系统中，命令缓冲区可以在应用程序成为瓶颈时提供 
帮助，但在驱动程序出现时可能会有害。这些早期API中的某些语 
义不允许驱动程序并行化各种操作，这有助于推动Vulkan，DirectX 
12和 Metal的开发。精确映射到现代GPU的精简绘图提交界面可 
最大限度地降低这些较新API的驱动程序成本。命令缓冲区管理， 
内存分配和同步决策成为应用程序而不是驱动程序的责任。此外， 
具有这些较新API的命令缓冲区在形成时进行一次验证，因此重复 
播放的开销比使用早期API （如DirectX11）的开销少。所有这些 
元素相结合，以提高API效率，允许多处理，并减少司机成为瓶颈 
的可能性。进一步阅读和资源移动设备可以在不同的时间平衡，特 
别是如果他们使用基于磁贴的架构。Merry[1200]讨论了这些成本 
以及如何有效地使用这种类型的GPU。Pranckevicius和Zioma 
[1433]提供了有关移动设备优化的许多方面的深入介绍。 
McCaffrey[1156]比较了移动与桌面架构和性能特征。像素着色通 
常是移动GPU上最大的成本。Sathe [1545]和 Etuaho[443]讨论 
着色器精度问题和移动设备上的优化。对于桌面，Wiesendanger 
[1882]详细介绍了现代游戏引擎的架构。O'Donnell [1313]介绍了 
----------------------- Page 860-----------------------
基于图形的渲染系统的优点。Zink等人。[1971]深入讨论 DirectX 
11。DeSmedt[331]为视频游戏中常见的热点提供指导，包括针对 
DirectX11和12的优化，针对多GPU配置和针对虚拟现实的优化。 
Coombes[291]给出了DirectX12最佳实践的概述，Kubisch[946] 
提供了何时使用 Vulkan 的指南。有许多关于从旧API 移植到 
DirectX12和Vulkan的演示文稿[249,536,699,1438]。当你读到 
这篇文章时，毫无疑问会有更多。检查 IH​ ​ V开发者网站，例如 
NVIDIA，AMD和 Intel;Khronos集团;和网络，以及本书的网站。 
18.5。多处理815虽然有点过时，但Cebenoyan的文章[240]仍然 
具有相关性。它概述了如何找到瓶颈和提高效率的技术。一些流行 
的C ++优化指南是 Fog的[476]和 Isensee的[801]，网上免费提 
供。休斯等人。[783]提供了一个现代的，深入的讨论，讨论如何使 
用跟踪工具和GPUView来分析瓶颈发生的位置。虽然专注于虚拟 
现实系统，但所讨论的技术适用于任何基于Windows 的机器。 
Sutter [1725]讨论了如何平衡CPU时钟速率和多处理器芯片组。 
有关发生这种变化的原因以及有关芯片设计的信息，请参阅 
Asanovic等人的深入报告。[75]。Foley[478]讨论了图形应用程序 
开发环境中的各种形式的并行性。Game EngineGems 2 [1024] 
有几篇关于为游戏引擎编程多线程元素的文章。Preshing [1445] 
解释了Ubisoft如何使用多线程并给出了使用C++11的线程支持 
的细节。Tatarchuk [1749,1750]给出了有关用于游戏 Destiny的多 
线程架构和着色管道的两个详细介绍。第 19章加速算法 “现在，你 
----------------------- Page 861-----------------------
可以看到，你可以做的所有运行都可以保持在同一个地方。如果你 
想要到达其他地方，你必须至少跑两倍！“- 刘易斯卡罗尔关于计 
算机的一个重大神话是有一天我们将拥有足够的处理能力。即使在 
文字处理等相对简单的应用程序中，我们也发现可以将额外的功能 
应用于各种功能，例如动态拼写和语法检查，抗锯齿文本显示和听 
写。在实时渲染中，我们至少有四个性能目标：每秒更多的帧数， 
更高的分辨率和采样率，更真实的材料和照明，以及更高的几何复 
杂度。通常认为每秒60-90帧的速度足够快。即使运动模糊可以降 
低图像质量所需的帧速率，仍然需要快速的速率来最小化与场景交 
互时的等待时间[1849]。今天，我们有4k显示器，分辨率为3840 
×2160;存在具有7680×4320分辨率的8k显示器，但尚未普及。 
4k显示器通常具有大约每英寸 140-150个点 （DPI），有时称为每 
英寸像素（PPI）。移动电话显示器的值最高可达400 DPI。目前， 
许多打印机公司提供 1200DPI的分辨率，是4k显示器像素数的 
64倍。即使屏幕分辨率有限，抗锯齿也会增加生成高质量图像所需 
的样本数量。如第23.6节所述，每个颜色通道的位数也可以增加， 
这推动了对更高精度（因此更昂贵）计算的需求。如前面的章节所 
示，描述和评估对象的材料可能在计算上很复杂。对光和表面的相 
互作用进行建模可以吸收任意大量的计算能力。这是正确的，因为 
图像最终应该由沿着从照明源到眼睛的无限数量的路径传播的光的 
贡献形成。帧速率，分辨率和阴影总是可以变得更复杂，但是增加 
任何这些都会有一些收益递减的感觉。然而，没有817818 19.加 
----------------------- Page 862-----------------------
速算法图 19.1。一个 “减少”的波音模型，只有3.5亿个三角形， 
用光线追踪渲染。通过使用用户定义的剪切平面执行分割。（图片 
由萨尔州大学计算机图形集团提供。源于波音公司提供和使用的3D 
数据。）场景复杂性的真实上限。波音777的渲染包括132,500个 
独特零件和 3,000,000多个紧固件，这使得多边形模型具有超过 
500,000,000个多边形[310]。见图19.1。即使由于它们的小尺寸或 
位置而看不到大多数这些物体，也必须做一些工作来确定是这种情 
况。如果不使用技术来减少所需的大量计算，z缓冲和光线跟踪都 
不能处理这样的模型。我们的结论：总是需要加速算法。在本章中， 
我们提供了一种用于加速计算机图形渲染的算法，特别是渲染大量 
几何图形。许多此类算法的核心是基于空间数据结构，这将在下一 
节中介绍。基于这些知识，我们继续采用剔除技术。这些算法试图 
快速确定哪些对象是可见的并且需要进一步处理。细节级别技术降 
低了渲染剩余对象的复杂性。为了结束这一章，我们讨论了渲染大 
型模型的系统，包括虚拟纹理，流媒体，转码和地形渲染。19。1 
空间数据结构空间数据结构是在一些n维空间中组织几何的结构。 
本书中只使用了二维和三维结构，但这些概念通常可以很容易地扩 
展到更高的维度。这些数据结构可用于加速关于几何实体是否重叠 
的查询。此类查询用于各种操作，例如剔除算法，交叉点测试和光 
线跟踪期间以及碰撞检测。空间数据结构的组织通常是分层的。松 
散地说，这意味着最顶层包含一些孩子，每个孩子都定义了自己的 
19.1。空间数据结构819体积的空间，而后者又包含自己的子节点。 
----------------------- Page 863-----------------------
因此，该结构是嵌套的并且具有递归性质。此层次结构中的某些元 
素引用了几何。使用层次结构的主要原因是不同类型的查询变得更 
快，通常是从O （n）到O （logn）的改进。也就是说，我们不是 
搜索所有n个对象，而是在执行诸如在给定方向上找到最近对象的 
操作时访问一个小子集。空间数据结构的构建时间可能很昂贵，并 
且取决于其内部的几何数量和数据结构的期望质量。然而，该领域 
的重大进步大大减少了施工时间，并且在某些情况下可以实时完成。 
通过延迟评估和增量更新，可以进一步减少构建时间。一些常见类 
型的空间数据结构是绑定卷层次结构，二进制空间分区 （BSP）树， 
四叉树和八叉树的变体。BSP树和八叉树是基于空间细分的数据结 
构。这意味着场景的整个空间被细分并在数据结构中编码。例如， 
所有叶节点的空间的并集等于场景的整个空间。通常，叶节点的体 
积不会重叠，除了不常见的结构，例如松散的八叉树。BSP树的大 
多数变体是不规则的，这意味着空间可以更加任意地细分。八叉树 
是规则的，意味着空间以统一的方式分裂。虽然限制性更强，但这 
种一致性通常可以成为效率的源泉。另一方面，边界体积层次结构 
不是空间细分结构。相反，它包围了几何物体周围空间的区域，因 
此 BVH不需要包围每个层次的所有空间。BVH，BSP树和八叉树 
都将在以下部分中与场景图一起描述，场景图是一种更关注模型关 
系的数据结构，而不是高效渲染。19.1.1边界体积层次结构体积 
 （BV）是包含一组对象的体积。BV的想法是它应该比包含的对象 
更简单的几何形状，因此使用 BV的测试可以比使用对象本身更快 
----------------------- Page 864-----------------------
地完成。BV的示例是球体，轴对齐边界框 （AABB），定向边界框 
 （OBB）和k-DOP。有关定义，请参见第22.2节。BV对渲染图像 
没有视觉上的贡献。代替，它被用作代理来代替有界对象，以加速 
渲染，选择，查询和其他计算。对于三维场景的实时渲染，边界体 
积层次结构通常用于分层视锥体剔除 （第 19.4节）。场景以分层树 
结构组织，由一组连接的节点组成。最顶层的节点是根，没有父节 
点。内部节点具有指向其子节点的指针，这些节点是其他节点。因 
此，根是内部节点，除非它是树中的唯一节点。叶节点保存要渲染 
的实际几何体，并且它为820 19.加速算法边界圆图 19.2。左侧部 
分显示了一个包含五个对象的简单场景，其边界圆圈用于右侧的边 
界体积层次结构中。单个圆圈包围所有对象，然后较小的圆圈以递 
归方式位于大圆圈内。右侧部分显示用于表示左侧对象层次结构的 
边界体积层次结构（树）。没有任何子节点。树中的每个节点（包 
括叶节点）都有一个边界体积，该边界体在其整个子树中包含几何 
体。还可以决定从叶节点中排除 BV，而是将它们包括在每个叶节点 
正上方的内部节点中。此设置是名称边界卷层次结构源自的位置。 
每个节点的 BV包含其子树中所有叶节点的几何。这意味着根有一 
个包含整个场景的 BV。BVH的一个例子如图19.2所示。请注意， 
一些较大的边界圆可以变得更紧，因为每个节点只需要包含其子树 
中的几何，而不是后代节点的BV。对于边界圆 （或球体），形成这 
种更紧密的节点可能是昂贵的，因为其子树中的所有几何体都必须 
由每个节点检查。在实践中，节点的BV通常通过树形成 “自下而 
----------------------- Page 865-----------------------
上”，通过制作包含其子节点的BV的BV。BVH的基础结构是树， 
而在计算机科学领域，关于树数据结构的文献是巨大的。在这里， 
只会提到一些重要的结果。有关详细信息，请参阅Cormen等人的 
 “算法简介”一书。[292]。考虑k-ary树，即每个内部节点有k个 
子节点的树。只有一个节点（根）的树被称为高度为0.根的叶节点 
高度为 1，等等。平衡树是一棵树，其中所有叶节点都处于高度h 
或h。1.通常，平衡树的高度h是.logkn。，其中n是树中节点 （内 
部和叶子）的总数。请注意，较高的k给出了一个较低高度的树， 
这意味着遍历树所需的步骤较少，但是每个节点也需要更多的工作。 
二叉树通常是最简单的选择，并且提供合理的性能。但是，有 19.1。 
空间数据结构821证明较高的k （例如，k=4或k=8）为某些应 
用提供了更好的性能[980,1829]。使用k=2，k=4或k=8可以 
很容易地构造树;只需沿k=2的最长轴细分，k=4的两个最长轴 
细分，k=8的所有轴细分。为其他k值形成良好的树木更加困难。 
从性能角度来看，通常优选每个节点具有更高数量（例如，k =8） 
的树木，因为它们减少了平均树深度和随后的间接数量（从父节点 
到子节点的指针）。BVH非常适合执行各种查询。例如，假设光线 
应该与场景相交，并且应该返回找到的第一个交叉点，就像阴影光 
线的情况一样。要使用 BVH，测试从根开始。如果光线错过了它的 
光线，则光线会错过 BVH中包含的所有几何体。否则，递归地继续 
测试，即测试根的子节点的 BV。一旦射线错过了BV，测试就可以 
在 BVH的子树上终止。如果光线击中叶节点的BV，则针对此节点 
----------------------- Page 866-----------------------
处的几何体测试光线。性能提升部分来自于使用 BV测试光线的速 
度很快。这就是为什么简单的物体，如球体和盒子被用作 BV。另一 
个原因是 BV的嵌套，这允许我们避免由于树中的提前终止而测试 
大的空间区域。通常是最近的交叉路口，而不是第一个路口而且， 
是什么是期望的。所需的唯一额外数据是遍历树时找到的最近对象 
的距离和标识。当前最近距离也用于在遍历期间剔除树。如果BV 
相交，但其距离超出到目前为止找到的最近距离，则可以丢弃BV。 
在检查父框时，我们将所有子 BV相交并找到最接近的子框。如果 
在此 BV的后代中找到交叉点，则使用此新的最近距离来剔除是否 
需要遍历其他子项。可以看出，BSP树比普通 BVH具有优势，因为 
它可以保证前后排序，而不是BVH提供的粗略排序。BVH也可以 
用于动态场景[1465]。当BV中包含的对象移动时，只需检查它是 
否仍包含在其父级BV中。如果是，那么BVH仍然有效。否则，将 
删除对象节点并重新计算父级 BV。然后，该节点以递归方式从根插 
回到树中。另一种方法是增长父母的BV以根据需要递归地将孩子 
保持在树上。无论采用哪种方法，随着执行越来越多的编辑，树可 
能变得不平衡且效率低下。另一种方法是在一段时间内将 BV置于 
物体运动极限附近。这被称为时间边界体积[13]。例如，一个摆可 
以有一个边界框，它包围整个体积通过其运动扫过。人们还可以执 
行自下而上的改装[136]或选择树的一部分来重新改造或重建 
[928,981,1950]。要创建 BVH，首先必须能够围绕一组对象计算紧 
密的 BV。第22.3节讨论了该主题。然后，必须创建 BV的实际层 
----------------------- Page 867-----------------------
次结构。有关 BV 构建策略的更多信息，请参 阅 
realtimerendering.com上的碰撞检测章节。822 19.加速算法 
19.1.2BSP树二进制空间分区树 （或简称 BSP树）作为计算机图形 
中两种明显不同的变体存在，我们称之为轴对齐和多边形对齐。通 
过使用平面将空间分成两部分，然后将几何体分类到这两个空间中 
来创建树。这种划分是递归完成的。一个有价值的特性是，如果以 
某种方式遍历BSP树，则可以从任何视点从前到后对树的几何内容 
进行排序。对于多边形对齐的 BSP，此排序是轴对齐和精确的近似。 
请注意，轴对齐的 BSP树也称为 kd树。轴对齐的 BSP树 （kD树） 
轴对齐的 BSP树按如下方式创建。首先，整个场景被封闭在轴对齐 
的边界框 （AABB）中。然后，我们的想法就是将这个盒子递归地细 
分为更小的盒子。现在，考虑任何递归级别的框。选择盒子的一个 
轴，并产生垂直平面，将空间分成两个盒子。一些方案修复了这个 
分区平面，使它将盒子分成两半;其他人允许飞机的位置变化。通过 
变化的平面位置 （称为非均匀细分），生成的树可以变得更加平衡。 
具有固定的平面位置，称为均匀细分，节点内存中的位置由其在树 
中的位置隐式给出。可以以任何数量的方式处理与平面相交的物体。 
例如，它可以存储在树的这个级别，或者成为两个子框的成员，或 
者由平面真正地分成两个单独的对象。存储在树级别的优点是树中 
只有一个对象副本，使对象删除变得简单。然而，与分裂平面相交 
的小物体变得隐藏在树的上层中，这往往是低效的。将相交的对象 
放置到两个子节点中可以为更大的对象提供更紧密的边界，因为所 
----------------------- Page 868-----------------------
有对象都会向下渗透到一个或多个叶节点，但只会覆盖它们重叠的 
那些节点。每个子框包含一些对象，并且重复该平面分裂过程，递 
归地细分每个AABB，直到满足某个标准以停止该过程。有关轴对 
齐BSP树的示例，请参见图 19.3。粗略的前后排序是如何使用轴对 
齐的BSP树的示例。这对于遮挡剔除算法 （第 19.7和23.7节）以 
及通常通过最小化像素过度绘制来降低像素着色器成本非常有用。 
假设当前遍历了一个名为 N的节点。这里，N是遍历开始时的根。 
检查N的分裂平面，并且树遍历在观察者所在的平面侧递归地继续。 
因此，只有当遍历了整个树的一半时​ ​ ，我们才开始遍历另一侧。 
此遍历不会给出精确的前后排序，因为叶节点的内容没有排序，并 
且因为对象可能在树的许多节点中。但是，它提供了粗略的排序， 
这通常是有用的。与观察者的位置相比，通过在节点平面的另一侧 
开始遍历，粗略的从后到前的排序可以是 19.1。空间数据结构823 
图19.3。轴对齐的 BSP树。在此示例中，允许空间分区位于轴的任 
何位置，而不仅仅是在其中点。形成的空间体积标记为A到 E.右侧 
的树显示了底层的BSP数据结构。每个叶节点代表一个区域，该区 
域的内容显示在其下方。请注意，三角形位于两个区域C和 E的对 
象列表中，因为它与两个区域重叠。获得。这对透明度排序很有用。 
BSP遍历还可用于针对场景几何体测试光线。光线的原点只是交换 
了观察者的位置。多边形对齐的BSP树另一种类型的 BSP树是多边 
形对齐的形式[4,500,501]。此数据结构对于以精确排序顺序渲染静 
态或刚性几何图形特别有用。这个算法很受 DOOM （2016）等游 
----------------------- Page 869-----------------------
戏的欢迎，当时没有硬件z-buffer。它仍然偶尔使用，例如用于碰 
撞检测和交叉测试。在该方案中，选择多边形作为分隔符，将空间 
分成两半。也就是说，在根处，选择多边形。多边形所在的平面用 
于将场景中的其余多边形划分为两组。任何与分割平面相交的多边 
形沿着交叉线分成两个单独的部分。现在在分割平面的每个半空间 
中，选择另一个多边形作为分隔符，其仅在其半空间中划分多边形。 
这是递归完成的，直到所有多边形都在 BSP树中。创建有效的多边 
形对齐 BSP树是一个耗时的过程，这些树通常计算一次并存储以供 
重用。这种类型的 BSP树如图 19.4所示。通常最好形成平衡树， 
即每个叶节点的深度相同或最多偏离一个的平衡树。多边形对齐的 
BSP树具有一些有用的属性。一个是，对于给定的视图，结构可以 
严格地从后到前（或从前到后）遍历。824 19。加速算法分裂平面 
图19.4。多边形对齐的BSP树。从上面显示了多边形A到G.空间 
首先被多边形A分割，然后每个半空间被 B和C分开。由多边形B 
形成的分裂平面与左下角的多边形相交，将其分成单独的多边形 D 
和 E.形成的 BSP树显示在右侧。这与轴对齐的 BSP树相比，后者通 
常只给出粗略的排序顺序。确定摄像机位于根平面的哪一侧。然后， 
该平面远侧的多边形集超出近侧​ ​ 的集合。现在使用远侧设置， 
采用下一级别的分割平面并确定相机所在的一侧。远侧的子集再次 
是距离摄像机最远的子集。通过递归地继续，该过程建立严格的从 
前到后的顺序，并且可以使用画家的算法来渲染场景。画家的算法 
不需要z缓冲区。如果所有对象都是按从后到前的顺序绘制的，则 
----------------------- Page 870-----------------------
每个较近的对象都会在其后面的任何对象前面绘制，因此不需要进 
行z深度比较。例如，考虑图 19.4中观察者v所看到的内容。无论 
观察方向和平截头体，v是由A形成的分裂平面的左侧，因此C，F 
和G在 B，D和 E之后。将V与C的分裂平面进行比较，我们发现 
G到在这个平面的另一侧，所以首先显示它。对B平面的测试确定 
E应该在 D之前显示。从后到前的顺序是G，C，F，A，E，B，D。 
请注意，此顺序不保证一个对象比另一个对象更靠近查看者。相反， 
它提供了严格的遮挡顺序，一个微妙的差异。例如，多边形F比多 
边形 E更接近v，即使它在遮挡顺序中更远。19.1.3八叉树八叉树 
类似于轴对齐的 BSP树。沿所有三个轴同时分割一个方框，分割点 
必须是方框的中心。这会创建八个新盒子 - 因此名称为八叉树。这 
使得结构规则，这可以使一些查询更有效。19.1。空间数据结构825 
图19.5。四叉树的构造。通过将所有对象封闭在边界框中，构造从 
左侧开始。然后将这些框递归地分成四个相等大小的框，直到每个 
框（在这种情况下）为空或包含一个对象。通过将整个场景封闭在 
最小轴对齐框中来构造八叉树。该过程的其余部分本质上是递归的， 
并且在满足停止标准时结束。与轴对齐的BSP树一样，这些标准可 
以包括达到最大递归深度，或者在框中获得一定数量的图元 
[1535,1536]。如果满足标准，则算法将基元绑定到框并终止递归。 
否则，它使用三个平面沿着主轴细分框，从而形成八个相等大小的 
框。每个新盒子都经过测试，可能再次细分为2×2×2个较小的盒 
子。这在两个方面说明，其中数据结构称为四叉树，如图 19.5所示。 
----------------------- Page 871-----------------------
四叉树是八叉树的二维等价物，第三轴被忽略。它们在沿着所有三 
个轴分类数据几乎没有优势的情况下非常有用。八叉树可以与轴对 
齐的BSP树相同的方式使用，因此可以处理相同类型的查询。事实 
上，BSP树可以提供与八叉树相同的空间分区。如果一个单元格首 
先沿着x轴的中间分割，那么这两个子节点沿着y的中间分割，最 
后那些子节点沿着z分割，八个大小相等的单元格形成的与由八叉 
树分割的一个应用创建的相同。八叉树的一个效率来源是它不需要 
存储更灵活的 BSP树结构所需的信息。例如，分裂平面位置是已知 
的，因此不必明确描述。这种更紧凑的存储方案还可以通过在遍历 
期间访问更少的内存位置来节省时间。轴对齐的 BSP树仍然可以更 
有效，因为由于需要检索分裂平面的位置而增加的存储器成本和遍 
历时间可以通过更好的平面放置的节省来抵消。没有整体最佳效率 
方案;它取决于底层几何的性质，访问结构的使用模式，以及运行代 
码的硬件的体系结构，仅举几个因素。通常，内存布局的位置和缓 
存友好程度是最重要的因素。这是下一节的重点。82619.加速算法 
图19.6。与松散的八叉树相比，一个普通的八叉树。圆点表示方框 
的中心点（在第一个细分中）。在左边，星星穿过普通八角形的一 
个分裂平面。因此，一种选择是将星形放在最大的盒子 （根的盒子） 
中。在右边，显示了k =1.5的松散八叉树（即，框大50％）。盒 
子稍微移位，以便可以辨别它们。现在，星星可以完全放在左上方 
的红色框中。在上面的描述中，对象总是存储在叶节点中。因此， 
某些对象必须存储在多个叶节点中。另一种选择是将对象放在包含 
----------------------- Page 872-----------------------
整个对象的最小的框中。例如，图中的星形物体应放在左起第二个 
图中的右上方框中。这具有显着的缺点，例如，位于八叉树中心的 
 （小）对象将被放置在最顶部（最大）节点中。这是无效的，因为 
一个微小的物体然后被包围整个场景的盒子限制。一种解决方案是 
拆分对象，但这会引入更多基元。另一个是在它所在的每个叶子框 
中放置一个指向对象的指针，从而降低效率并使八叉树编辑更加困 
难。乌尔里希提出了第三种解决方案，松散的八叉树[1796]。松散 
八叉树的基本思想与普通八叉树相同，但是每个盒子的大小选择都 
很放松。如果普通盒子的边长是 l，则使用k1代替，其中 k> 1.这 
在k=1.5时示出，并且与普通八叉树相比，在图 19.6中。请注意， 
框的中心点是相同的。通过使用更大的框，减少了穿过分割平面的 
对象的数量，从而可以将对象放置在八叉树中更深的位置。一个对 
象总是只插入一个八叉树节点，因此从八叉树中删除是微不足道的。 
使用k=2可以产生一些优点。首先，对象的插入和删除是O （1）。 
知道对象的大小意味着立即知道它可以成功插入的八叉树的级别， 
完全适合一个松散的盒子。在实践中，有时可以将对象推到八叉树 
中的更深的框中。也，如果k<2，如果对象不适合，则可能必须将 
对象向上推。对象的质心决定了它放入哪个松散的八叉树盒。由于 
这些属性，这种结构很好地限制了动态对象，但牺牲了一些 BV效 
率，并且在遍历结构时失去了强排序。此外，对象通常仅在帧与帧 
之间轻微移动，因此前一个框在下一帧中仍然有效。因此，只有动 
画 19.1的一小部分。空间数据结构松散八叉树中的827个对象需 
----------------------- Page 873-----------------------
要更新每个帧。Cozzi[302]指出，在将每个对象/基元分配给松散的 
八叉树之后，可以计算每个节点中的对象周围的最小AABB，其在 
该点基本上变为BVH。此方法可避免跨节点拆分对象。19.1.4高速 
缓存遗忘和高速缓存感知表示由于存储器系统的带宽与CPU的计 
算能力之间的差距每年都在增加，因此设计算法和空间数据结构表 
示时需要考虑缓存。在本节中，我们将介绍缓存感知 （或缓存意识） 
和缓存不经意的空间数据结构。高速缓存感知表示假定高速缓存块 
的大小是已知的，因此我们针对特定体系结构进行优化。相比之下， 
缓存无关的算法被设计为适用于所有类型的缓存大小，因此与平台 
无关。要创建缓存感知数据结构，必须首先了解缓存块的大小是什 
么。例如，这可以是64字节。然后尝试最小化数据结构的大小。例 
如，Ericson[435]显示了仅对kd树节点使用32位就足够了。这部 
分是通过挪用节点的32位值的两个最低有效位来完成的。这两个位 
可以表示四种类型：叶节点，或在三个轴之一上分割的内部节点。 
对于叶节点，高30位保存指向对象列表的指针;对于内部节点，这 
些表示 （略低精度）浮点分割值。因此，可以在64字节的单个高速 
缓存块中存储15个节点的四级深度二叉树。第十六个节点指示存在 
哪些子节点以及它们位于何处。详情请见他的书。关键概念是通过 
确保结构打包以缓存边界来大大改进数据访问。一个流行且简单的 
缓存 - 不经意的树木排序是van EmdeBoas布局[68,422,435]。 
假设我们有一棵树，高度为 h。目标是计算树中节点的缓存无关布 
局或排序。关键的想法是，通过递归地将层次结构分成更小和更小 
----------------------- Page 874-----------------------
的块，在某种程度上，一组块将适合缓存。这些块在树中彼此靠近， 
因此缓存数据的有效时间比例如我们只是从顶层向下列出所有节点 
的时间长。像这样的天真列表会导致内存位置之间出现大幅跳跃。 
让我们将T的van EmdeBoas布局表示为v （T）。这种结构是递 
归定义的，并且树中单个节点的布局就是节点本身。如果T中有多 
个节点，则树被分割为高度的一半，.h/2..最高的.h/2。将等级放 
在表示为T0 的树中，并且从T0 的叶节点开始的子子树用T1表 
示。。。，Tn。树的递归性质描述如下：v （T）=？{T}，如果T中 
有单个节点，{T0，T1，...。。，Tn}，否则。 （19.1）82819.加速 
算法0 1knhh/ 2h/ 2图19.7。通过将树的高度h分成两部分来 
创建树的van EmdeBoas布局。这会创建子树T0，T1,. 。。，Tn 
和每个子树以相同的方式递归地分割，直到每个子树只剩下一个节 
点。注意，所有子树Ti，0≤i≤n也由上面的递归定义。这意味着， 
例如，T1必须以其高度的一半分割，依此类推。有关示例，请参见 
图19.7。通常，创建缓存无关布局包括两个步骤：集群的聚类和排 
序。对于van EmdeBoas布局，聚类由子树给出，并且排序隐含 
在创建顺序中。Yoon等人。[1948,1949]开发了专门为有效的边界 
体积层次结构和 BSP树设计的技术。他们开发了一个概率模型，该 
模型考虑了父母与子女之间的地点以及空间位置。这个想法是通过 
确保孩子访问成本低廉来最小化访问父级时的缓存未命中。此外， 
彼此接近的节点在排序中更靠近在一起。开发了一种贪婪算法，该 
算法聚合具有最高概率的节点。在不改变基础算法的情况下获得性 
----------------------- Page 875-----------------------
能的大幅增加 - 仅 BVH中的节点的排序是不同的。19.1.5场景图 
BVH，BSP树和八叉树都使用某种树作为其基本数据结构。它是如 
何划分空间并存储它们不同的几何形状。它们还以分层方式存储几 
何对象，而不存储任何其他对象。然而，渲染三维场景不仅仅是几 
何。动画，可见性和其他元素的控制通常使用场景图来执行，场景 
图在glTF中称为节点层次结构。这是一个面向用户的树结构，增加 
了纹理，变换，细节层次，渲染状态（例如，材料属性），光源以 
及其他任何适合的东西。它由树表示，并且以某种顺序遍历该树以 
渲染场景。例如，可以将光源放在内部节点上，该内部节点仅影响 
其子树的内容。另一个例子是当树中遇到材料时。材质可以应用于 
该节点的子树中的所有几何体，或者可能被子项的设置覆盖。另请 
参见第861页的图 19.34，了解如何在场景图中支持不同的细节级 
别。从某种意义上说，每个图形应用程序都使用一些 19.1。空间数 
据结构829图19.8。具有应用于内部节点的不同变换 M和 N的场 
景图及其各自的子树。请注意，这两个内部节点也指向同一个对象， 
但由于它们具有不同的变换，因此会出现两个不同的对象（一个是 
旋转和缩放的）。场景图的形式，即使图形只是一个根节点，其中 
包含要显示的子节点列表。动画对象的一种方法是改变树中内部节 
点的变换。然后，场景图实现转换该节点的子树的整个内容。由于 
转换可以放在任何内部节点中，因此可以进行分层动画。例如，汽 
车的车轮可以旋转，整个汽车可以向前移动。当若干节点可指向同 
一子节点时，树结构称为有向无环图 （DAG）[292]。术语非循环意 
----------------------- Page 876-----------------------
味着它不得包含任何循环或循环。按照指示，我们的意思是，当两 
个节点通过边连接时，它们也以特定顺序连接，例如，从父节点到 
子节点。场景图通常是DAG，因为它们允许实例化，即，当我们想 
要制作对象的多个副本 （实例）而不复制其几何时。图19.8中显示 
了一个示例，其中两个内部节点具有应用于其子树的不同变换。使 
用实例可以节省内存，GPU可以通过API调用快速呈现实例的多个 
副本 （第 18.4.2节）。当要在场景中移动对象时，必须更新场景图。 
这可以通过树结构上的递归调用来完成。变换在从根到叶子的路上 
更新。矩阵在该遍历中相乘并存储在相关节点中。但是，当转换已 
更新时，任何附属的 BV都已过时。因此，BV在从叶子向根的方向 
上更新。过于宽松的树结构极大地使这些任务复杂化，因此通常避 
免使用 DAG，或者使用有限形式的DAG，其中仅共享叶节点。有 
关此主题的更多信息，请参阅 Eberly的书[404]。还要注意，当使 
用基于JavaScript的API （例如WebGL）时，尽可能多地将尽可 
能多的工作移交给GPU并使用尽可能少的反馈到CPU是极其重要 
的[876]。场景图本身可用于提供一些计算效率。场景图中的节点通 
常具有边界体积，因此非常类似于830 19.加速算法a BVH。场景 
图中的叶子存储几何。重要的是要意识到完全不相关的效率方案可 
以与场景图一起使用。这是空间化的想法，其中用户的场景图增强 
了为不同任务创建的单独数据结构 （例如，BSP树或 BVH），例如 
更快的剔除或拣选。大多数模型所在的叶节点是共享的，因此额外 
空间效率结构的费用相对较低。19.2剔除技术要剔除 “从群中移除” 
----------------------- Page 877-----------------------
的手段，并且在计算机图形学的背景下，这正是剔除技术所做的。 
flock是我们想要渲染的整个场景，并且移除仅限于场景中那些不被 
认为对最终图像有贡献的部分。场景的其余部分通过渲染管道发送。 
从而，术语可见性剔除也经常用于渲染的上下文中。但是，也可以 
对程序的其他部分进行剔除。示例包括碰撞检测（通过对屏幕外或 
隐藏对象进行不太精确的计算），物理计算和AI。这里，仅呈现与 
渲染相关的剔除技术。这种技术的示例是背面剔除，视锥体剔除和 
遮挡剔除。这些如图 19.9所示。背面剔除消除了背离观察者的三角 
形。查看视锥体剔除消除视锥体外的三角形组。遮挡剔除可以消除 
其他对象组隐藏的对象。这是最复杂的剔除技术，因为它需要计算 
对象如何相互影响。实际剔除理论上可以在渲染管道的任何阶段进 
行，对于某些遮挡剔除算法，它甚至可以预先计算。对于在GPU上 
实现的剔除算法，我们有时只能启用/禁用或设置剔除功能的一些参 
数。最快的三角形眼视锥体视锥体背面遮挡图 19.9。不同的剔除技 
术。剔除几何图形为虚线。（Cohen-Or等[277]之后的插图。）19.3。 
背面剔除831渲染是从未发送到GPU的渲染。接下来，管道中的 
剔除越早发生越好。剔除通常通过使用几何计算来实现，但绝不限 
于这些。例如，算法也可以使用帧缓冲器的内容。理想的剔除算法 
将仅通过管道发送基元的精确可见集（EVS）。在本书中，EVS被 
定义为部分或完全可见的所有基元。允许理想剔除的一种这样的数 
据结构是方面图，在任何观点下，可以从中提取 EVS[532]。从理 
论上讲，创建这样的数据结构是可能的，但实际上并非如此，因为 
----------------------- Page 878-----------------------
最坏的时间复杂度可能与O （n9）一样糟糕[277]。相反，实际算法 
试图找到一组，称为潜在可见集（PVS），它是EVS的预测。如果 
PVS完全包括 EVS，那么只丢弃不可见的几何体，则称 PVS是保守 
的。PVS也可以是近似的，其中EVS未被完全包括在内。因此，这 
种类型的PVS可能生成不正确的图像。目标是使这些错误尽可能小。 
由于保守的PVS总是生成正确的图像，因此通常认为它更有用。通 
过高估或近似 EVS，我们的想法是可以更快地计算PVS。困难在于 
如何进行这些估算以获得整体性能。例如，算法可以处理不同粒度 
的几何，即三角形，整个对象或对象组。找到PVS后，将使用z缓 
冲区进行渲染，该缓冲区可解析最终的每像素可见性。请注意，有 
些算法会对网格中的三角形进行重新排序，以便提供更好的遮挡剔 
除，即减少过度绘制，同时改进顶点缓存局部性。虽然这些与剔除 
有些相关，我们将感兴趣的读者引用参考文献[256,659]。在第 
19.3-19.8节中，我们处理背面剔除，视锥体剔除，门户剔除，细节 
剔除，遮挡剔除和剔除系统。19.3背面剔除想象一下，您正在观察 
场景中的不透明球体。大约一半的球体将不可见。这一观察的结论 
是，不可能呈现不可见的东西，因为它对图像没有贡献。因此，不 
需要处理球体的背面，这就是背面剔除背后的想法。这种类型的剔 
除也可以一次对整个组进行，因此称为聚类背面剔除。假设相机在 
外面，可以剔除作为实体不透明物体一部分的所有背面三角形，以 
避免进一步处理，并且不会穿透（即，接近夹入）物体。如果已知 
投影三角形在屏幕空间中以顺时针方式定向，则一致定向的三角形 
----------------------- Page 879-----------------------
 （第16.3节）背面。可以通过在二维屏幕空间中计算三角形的有符 
号区域来实现该测试。负签名区域表示832 19.加速算法ABCABC 
视图空间图 19.10。用于确定三角形是否背面的两种不同测试。左 
图显示了如何在屏幕空间中完成测试。左边的两个三角形是正面， 
而右边的三角形是背面，可以省略进一步处理。右图显示了如何在 
视图空间中完成背面测试。三角形A和 B是正面，而C是背面。应 
该剔除三角形。这可以在屏幕映射程序发生后立即实施。确定三角 
形是否背面的另一种方法是从三角形所在的平面上的任意点（其中 
一个顶点是最简单的选择）到观察者的位置创建一个矢量。对于正 
交投影，将眼睛位置的矢量替换为负视图方向，该视图方向对于场 
景是恒定的。计算此向量的点积和三角形的法线。负点积意味着两 
个矢量之间的角度大于π/ 2弧度，因此三角形不面向观察者。该测 
试相当于计算从观察者的位置到三角形平面的有符号距离。如果符 
号为正，则三角形为正面。请注意，只有在法线标准化的情况下才 
能获得距离，但这在这里并不重要，因为只有标志才有意义。或者， 
在应用投影矩阵之后，在剪辑空间中形成顶点v = （vx，vy，vw） 
并计算行列式d =|v0，v1，v2 |[1317]。如果d≤0，则可以剔除 
三角形。这些剔除技术如图 19.10所示。Blinn指出这两个测试在 
几何上是相同的[165]。理论上，这些测试的不同之处在于计算测试 
的空间 - 没有别的。实际上，屏幕空间测试通常更安全，因为在视 
图空间中看起来面向略微向后的边缘三角形可以在屏幕空间中稍微 
向前。发生这种情况是因为视图空间坐标四舍五入到屏幕空间子像 
----------------------- Page 880-----------------------
素坐标。使用诸如OpenGL或 DirectX之类的API，背面剔除通常 
由一些功能控制，这些功能可以启用背面或正面剔除或禁用所有剔 
除。请注意，镜像变换（即负缩放操作）会将三角形背面转换为前 
面的三角形，反之亦然[165] （第4.1.3节）。最后，可以在像素着 
色器中找出三角形是否是正面。在OpenGL中，这是通过测试gl 
FrontFacing来完成的，在 DirectX中它被称为SV IsFrontFace。 
在此之前添加主要方式来显示双面物体 19.3。背面剔除833cc图 
19.11。左：一组三角形及其法线。中左：收集法线 （顶部），并构 
造由一个法线 n和半角α定义的最小锥（底部）。中右：锥体锚定 
在点c处，并被截断，以便它还包含三角形上的所有点。右图：截 
头圆锥的横截面。顶部的浅灰色区域是正面锥体，底部的浅灰色区 
域是背面锥体。点f和 b分别是前面和后面锥体的顶点。适当地渲 
染它们两次，首先剔除背面然后剔除正面并反转法线。关于标准背 
面剔除的一个常见误解是它将渲染的三角形数量减少了大约一半。 
虽然背面剔除将删除许多对象中大约一半的三角形，但它对某些类 
型的模型提供的收益很小。例如，室内场景的墙壁，地板和天花板 
通常面向观众，所以在这样的场景中，这些类型的背面相对较少。 
类似地，通过地形渲染，大多数三角形通常都是可见的，只有山丘 
或沟壑背面的三角形才能从这种技术中受益。虽然背面剔除是一种 
避免光栅化单个三角形的简单技术，但如果可以通过单个测试决定 
是否可以剔除整组三角形，那么背板剔除会更快。这些技术称为聚 
类背面剔除算法，其中一些将在此处进行审查。许多此类算法使用 
----------------------- Page 881-----------------------
的基本概念是法线锥[1630]。对于曲面的某些部分，会创建一个包 
含所有法线方向和所有点的截锥。请注意，需要沿法线的两个距离 
来截断锥体。有关示例，请参见图 19.11。可以看出，锥体由法线， 
n和半角α和锚点c以及沿截断锥体的法线的一些偏移距离限定。在 
图19.11的右侧部分中，显示了正常锥体的横截面。Shirman和 
Abi-Ezzi [1630]证明，如果观察者位于前面锥体中，则锥体中的所 
有面都是正面，并且类似地用于背面锥体。Engel[433]使用一种类 
似的概念，称为排除体积，用于GPU剔除。对于静态网格物体， 
Haar和Aaltonen [625]建议在 n个三角形周围计算最小立方体， 
并将每个立方体面分成r×r “像素”，每个立方体编码一个n位掩 
模，指示相应的三角形是否可见超过 834 19.加速算法像素{图 
19.12。一组五个静态三角形，从边缘看，被二维方形包围。左边的 
方形面被分成4个 “像素”，我们从顶部开始聚焦一秒钟，盒子外 
面的平截头体呈蓝色。由三角形平面形成的正半空间用半圆（红色 
和绿色）表示。在正半空间中没有蓝色平截头体任何部分的所有三 
角形都是从平截头体中的所有点保守地背面（标记为红色）。绿色 
表示那些正面。 “像素。”如图 19.12所示。如果摄像机位于立方 
体之外，则可以找到摄像机所在的相应平截头体，并且可以立即查 
找其位掩码并知道哪些三角形正在背面（保守地）。如果相机在立 
方体内，所有三角形都被认为是可见的（除非有人想要进行进一步 
的计算）。Haar和Aaltonen每个立方体面只使用一个位掩码，一 
次编码n=64个三角形。通过计算位掩码中设置的位数，可以以有 
----------------------- Page 882-----------------------
效的方式为非剔除三角形分配存储器。这项工作已被用于刺客的信 
条团结。接下来，我们将使用非截断的法线圆锥，与图 19.11中的 
相比，因此它仅由中心点c，法线n和角度α定义。要计算多个三角 
形的这种法线圆锥体，取三角形平面的所有法线，将它们放在相同 
位置，并在单位球面上计算包含所有法线的最小圆[101]。作为第一 
步，假设从一个点e我们想要背面测试所有法线，在锥体中共享相 
同的原点c。如果以下情况属实，则正常锥体从e背面[1883,1884]： 
n· （e.c）<cos？α+π2？|{z}.sin？..n· （c.e）<sinα。 （19.2）但 
是，此测试仅在所有几何图形都位于c时有效。接下来，我们假设 
所有几何都在具有中心点c和半径r的球体内。然后测试成为n·（e.c） 
<cos？α+β+π2？|{z}.sin （？+）..n· （c.e）<sin（α+β）， （19.3） 
19.4。查看 FrustumCulling835ceβrnαα图19.13。这种情况显示 
了当由c，n和α定义的法线锥体即将从半径为r且中心点为c的圆 
内的最关键点变为e时的极限。当从e到圆上的点的矢量之间的角 
度使得矢量与圆相切，并且法线圆锥的边是π/2弧度时，会发生这 
种情况。请注意，法线锥体已从c向下平移，因此其原点与球体边 
界重合。其中sinβ=r/ ||c。Ë||。导出该测试所涉及的几何结构如 
图19.13所示。量化法线可以以8×4位存储，这对于某些应用可能 
是足够的。总结本节，我们注意到运动模糊三角形的背面剔除，其 
中每个顶点在一个帧上具有线性运动，并不像人们想象的那么简单。 
随着时间的推移，具有线性移动顶点的三角形可以在帧的开始处反 
面，转向前面，然后再次转向背面，所有这些都在同一帧内。因此， 
----------------------- Page 883-----------------------
如果由于运动模糊三角形在帧的开始和结束处背面而剔除三角形， 
则将生成不正确的结果。Munkberg和Akenine-M'oller [1246] 
提出了一种方法，其中标准背面测试中的顶点被线性移动的三角形 
顶点替换。该测试用伯恩斯坦形式重写，B'ezier曲线的凸性用作保 
守测试。对于景深，如果整个镜头处于三角形的负半空间（换句话 
说，在其后面），则可以安全地剔除三角形。19.4查看Frustum剔 
除如2.3.3节所示，只需要渲染完全或部分位于视锥体内的基元。 
加速渲染过程的一种方法是将每个对象的边界体积与视锥体进行比 
较。如果 BV在平截头体之外，那么它所包含的几何体可以从渲染 
中省略。相反，如果BV在平截头体内或与平截头体相交，那么该 
BV的内容可能是可见的并且必须通过渲染管道发送。有关测试各种 
边界体积与视锥体之间相交的方法，请参阅第22.14节。通过使用 
空间数据结构，可以分层次地应用这种剔除[272]。对于边界体积层 
次结构，来自根836的前序遍历[292]19.加速算法图 19.14。左侧 
显示了一组几何体及其边界体积（球体）。这个场景用视锥体从眼 
睛的角度剔除来渲染。BVH显示在右侧。根的BV与平截头体相交， 
并且遍历继续测试其子女的 BV。左子树的 BV相交，其中一个子树 
的子项相交（因此被渲染），另一个子的BV在外部，因此不通过 
管道发送。根的中间子树的 BV完全在内部并立即呈现。根的右子 
树的 BV也完全在内部，因此可以在不进行进一步测试的情况下呈 
现整个子树。做的工作。具有边界体积的每个节点针对平截头体进 
行测试。如果节点的 BV在平截头体之外，则不进一步处理该节点。 
----------------------- Page 884-----------------------
树被修剪，因为BV的内容和孩子在视野之外。如果 BV完全位于平 
截头体内，其内容必须全部位于平截头体内。遍历继续，但是这个 
子树的其余部分不需要进一步的视锥体测试。如果 BV与平截头体 
相交，则遍历继续并且其子节点被测试。当发现叶节点相交时，其 
内容（即其几何形状）通过管道发送。叶子的原语不能保证在视锥 
体内。视锥体剔除的一个例子如图 19.14所示。也可以对对象或单 
元使用多个 BV测试。例如，如果发现细胞周围的球体 BV与平截头 
体重叠，那么如果知道这个盒子比球体小得多，那么也可能值得进 
行更准确（尽管更昂贵）的OBB对平截头体测试。 [1600]。 “相 
交截锥体”情况的一个有用优化是跟踪 BV完全位于哪个平截头体 
平面[148]。这些信息通常存储为位掩码，然后可以与传感器一起传 
递，用于测试该 BV的孩子。这种技术有时被称为平面掩蔽，因为 
只有那些与 BV相交的平面需要针对儿童进行测试。根 BV将首先针 
对所有6个平截头体平面进行测试，但是通过连续测试，每个孩子 
进行的平面/ BV测试的数量将下降。Assarsson和 Molol[83]注意 
到时间一致性可以达到 19.5。也可以使用PortalCulling837。拒 
绝BV的平截头体平面可以与BV一起存储，然后是在下一帧中测试 
拒绝的第一个平面。Wihlidal [1883,1884]指出，如果在CPU上的 
每个对象级别上进行视锥体剔除，那么就可以对左，右，底部执行 
视锥体剔除，在GPU上进行细粒度剔除时的顶层和顶层平面。此外， 
为了提高性能，可以使用称为顶点图的构造来提供更紧密的边界体 
积。第22.13.4节对此进行了更详细的描述。有时在远处使用雾来 
----------------------- Page 885-----------------------
避免物体在远处平面突然消失的影响。对于大型场景或某些摄像机 
视图，只有一小部分场景可见，并且只有这一部分需要通过渲染管 
道发送。在这种情况下，可以预期速度的大幅增加。视锥体剔除技 
术利用场景中的空间相干性，因为位于彼此附近的物体可以被包围 
在 BV中，并且附近的 BV可以分层地聚类。应该注意的是，一些游 
戏引擎不使用分层 BVH，而只是一个BV的线性列表，一个用于场 
景中的每个对象[283]。主要动机是使用SIMD和多线程实现算法更 
简单，因此可以提供更好的性能。但是，对于某些应用程序（如 
CAD），大多数或所有几何体都在平截头体内，在这种情况下应避 
免使用这些类型的算法。仍然可以应用分层视图平截头体剔除，因 
为如果节点在平截头体内，则可以立即绘制其几何形状。19.5门户 
剔除对于架构模型，有一组算法以门户网站剔除的名义进行。其中 
第一个由 Airey 等人介绍。[17,18]。后来，Teller 和 S'equin 
[1755,1756]以及Teller和 Hanrahan [1757]构建了更有效和更复 
杂的门户剔除算法。所有门户剔除算法的基本原理是墙壁通常在室 
内场景中充当大型遮挡物。因此，门户剔除是一种遮挡剔除，将在 
下一节中讨论。该遮挡算法使用通过每个入口（例如，门或窗）的 
视锥体剔除机制。在穿过门户时，截头锥体会缩小以紧密贴合门户。 
因此，该算法也可视为视锥体剔除的扩展。视图截头体外的门户被 
丢弃。门户剔除方法以某种方式预处理场景。场景分为通常对应于 
建筑物中的房间和走廊的单元。连接相邻房间的门窗称为门户。单 
元格中的每个对象和单元格的墙都存储在与单元格关联的数据结构 
----------------------- Page 886-----------------------
中。我们还存储相邻单元格的信息以及在邻接图中连接它们的门户。 
Teller提出了用于计算该图的算法[1756]。虽然这种技术在 1992年 
推出时可以使用，但对于现代复杂的场景来说，自动化这一过程非 
常困难。因此，定义单元格和创建图形目前是手动完成的。83819. 
加速算法眼图 19.15。门户剔除：从A到 H枚举单元格，门户是连 
接单元格的开口。仅呈现通过门户网站看到的几何体。例如，细胞 
F中的星被剔除。Luebke和Georges[1090]使用一种简单的方法， 
只需要少量的预处理。如上所述，唯一需要的信息是与每个小区相 
关联的数据结构。关键的想法是每个门户将视图定义到其房间内外。 
想象一下，你正在通过一个有三个窗户的房间的门口。门口定义了 
一个平截头体，用于剔除房间中不可见的物体，并渲染那些可以看 
到的物体。您无法通过门口看到两个窗户，因此可以忽略通过这些 
窗口可见的窗格。第三个窗口可见但被门框部分阻挡。只需通过门 
口和此窗口可见的单元格中的内容需要沿管道发送。单元格渲染过 
程依赖于以递归方式跟踪此可见性。门户剔除算法如图 19所示。 
15举个例子。观察者或眼睛位于细胞 E中，因此与其内容一起呈现。 
相邻的单元格是C，D和 F.原始平截头体不能看到单元格 D的入口， 
因此省略了进一步处理。单元格F是可见的，因此视锥体减少，以 
便它通过连接到 F的门户。然后F的内容用减少的平截头体进行渲 
染。然后，检查 F的相邻单元格 - 从减小的平截头体中看不到G， 
因此省略，而H是可见的。同样，截头体在 H的入口处减少，然后 
呈现H的内容。H没有任何未被访问过的邻居，因此遍历就此结束。 
----------------------- Page 887-----------------------
现在，递归回到了进入单元格C的门户。截锥体被缩小以适合C的 
门户，然后在C中渲染对象，用截头锥体剔除。没有更多门户可见， 
因此渲染已完成。每个对象在渲染时都可以被标记，以避免渲染对 
象多次。例如，如果有两个窗户进入房间，内容为19.6。细节和小 
三角剔除839图19.16。门户剔除。左图是BrooksHouse的俯视 
图。正确的图像是主卧室的视图。门户网站的剔除框为白色，镜像 
为红色。 （图片由DavidLuebke和ChrisGeorges，UNC-Chapel 
Hill提供。）房间分别与每个视锥体一起被剔除。没有标记，通过 
两个窗口可见的对象将呈现两次。这既低效又可能导致渲染错误， 
例如当一个物体是透明的。为了避免每帧都清除这个标签列表，每 
个对象在访问时都用帧号标记。仅访问了存储当前帧编号的对象。 
值得实施的优化是使用模板缓冲区进行更精确的剔除。在实践中， 
门户网站被AABB高估;真正的门户网站很可能会更小。模板缓冲区 
可用于屏蔽真实门户之外的渲染。同样，可以为GPU设置门户周围 
的剪刀矩形以提高性能[13]。使用模板和剪刀功能也不需要执行标 
记，因为透明对象可能会呈现两次，但会影响每个门户中的可见像 
素一次。见图 19。16用于门户网站使用的另一种观点。这种门式 
剔除形式也可用于修剪平面反射的内容 （第 11.6.2节）。左图显示 
了从顶部看的建筑物; 白线表示每个门户减少平截头体的方式。通过 
在镜子处反射平截头体来创建红线。实际视图显示在右侧的图像中， 
其中白色矩形是门户，镜子是红色。请注意，它只是被渲染的任何 
截头内的对象。其他转换可用于创建其他效果，例如简单的折射。 
----------------------- Page 888-----------------------
19.6细节和小三角形剔除细节剔除是一种牺牲速度质量的技术。细 
节剔除的基本原理是场景中的小细节对渲染的840几乎没有贡献。 
加速算法图 19.17。使用任何小圆角剔除（圆（最小）==圆（最大））。 
剔除红色三角形，同时需要渲染绿色三角形。左：绿色三角形与样 
本重叠，因此无法剔除。红色三角形将所有AABB坐标都围绕到相 
同的像素角。右：可以剔除红色三角形，因为AABB坐标之一被舍 
入到相同的整数。绿色三角形不与任何样本重叠，但不能通过此测 
试进行剔除。观众在运动时的图像。当观察者停止时，通常禁用细 
节剔除。考虑具有边界体积的对象，并将此BV投影到投影平面上。 
然后以像素估计投影的面积，并且如果像素的数量低于用户定义的 
阈值，则从进一步处理中省略该对象。出于这个原因，细节剔除有 
时被称为屏幕尺寸剔除。细节剔除也可以在场景图上分层次地完成。 
这些类型的技术通常用于游戏引擎[283]。在每个像素的中心处有一 
个样本，小三角形很可能落在样本之间。另外，小三角形光栅化效 
率相当低。一些图形硬件实际上是在样本之间剔除三角形，但是当 
使用GPU上的代码进行剔除时（第 19.8节），添加一些代码来剔 
除小三角形可能是有益的。Wihlidal [1883,1884]提出了一种简单 
的方法，首先计算三角形的AABB。如果满足以下条件，则可以在 
着色器中剔除三角形：any （round （min）==round （max））， 
 （19.4）其中min和 max表示三角形周围的二维AABB。如果任 
何向量组件为真，则函数any返回true。还记得像素中心位于 （x + 
0.5，y +0.5），这意味着如果x坐标或y坐标或两者都围绕相同 
----------------------- Page 889-----------------------
的坐标，则公式19.4为真。一些例子如图 19.17所示。19.7遮挡 
剔除正如我们所见，可见性可以通过z缓冲区来解决。即使它正确 
地解决了可见性，z缓冲区也相对简单而且非常强大，因此并不总 
是 19.7。遮挡剔除 841 10球体深度复杂度渲染图像查看器图 
19.18。遮挡剔除如何有用的说明。十个球体排成一行，观察者沿着 
这条线（左）看透视。中间的深度复杂度图像显示一些像素被写入 
多次，即使最终图像 （右侧）仅显示一个球体。最有效的解决方案。 
例如，假设观察者正在沿着放置 10个球体的线看。如图 19.18所 
示。从该视点渲染的图像将显示一个球体，即使所有10个球体都将 
被光栅化并与z缓冲区进行比较，然后可能会写入颜色缓冲区和z 
缓冲区。图 19.18的中间部分从给定的角度显示了该场景的深度复 
杂度。深度复杂度是像素覆盖的表面数量。在 10个球体的情况下， 
假设背面剔除打开，所有 10个球体都位于那里，中间像素的深度复 
杂度为 10。如果场景被渲染回到前面，则中间的像素将被像素着色 
10次，即，有9个不必要的像素着色器执行。即使场景从前到后渲 
染，所有 10个球体的三角形仍将被栅格化，并且将计算深度并与z 
缓冲区中的深度进行比较，即使生成单个球体的图像。这种无趣的 
场景不太可能在现实中找到，但它描述了（从给定的角度来看）一 
个人口稠密的模型。这些类型的配置可以在真实场景中找到，例如 
雨林，引擎，城市和摩天大楼内部。有关示例，请参见图 19.19。 
鉴于前一段中的示例，似乎有理由认为避免这种低效率的算法方法 
可能会在性能上得到回报。这种方法以遮挡剔除算法的名义进行， 
----------------------- Page 890-----------------------
因为它们试图剔除被遮挡的对象，即被场景中的其他对象隐藏。最 
佳遮挡剔除算法将仅选择可见的对象。从某种意义上说，z-buffer 
只选择和渲染那些可见的对象，但不必通过大部分管道发送视锥体 
内的所有对象。高效遮挡剔除算法背后的想法是尽早执行一些简单 
的测试来剔除隐藏对象集。从某种意义上说，背面剔除是一种简单 
的遮挡剔除形式。如果我们事先知道物体是实心的并且是不透明的， 
然后背面被前面遮挡，因此不需要渲染。84219.加速算法图 19.19。 
一个名为 NeuRungholt的Minecraft场景，遮挡剔除可视化，观 
察者位于右下角。剔除轻微阴影的几何体，同时渲染颜色较深。最 
终图像显示在左下角。 （经Jon Hasselgren，MagnusAndersson 
和TomasAkenine-M'oller以及英特尔公司许可转载，版权所有英 
特尔公司，2016年.NeuRungholt地图由kescha提供。）有两种 
主要形式的遮挡剔除算法，即点 - 基于和基于细胞。这些如图19.20 
所示。基于点的可见性正是渲染中通常使用的，即从单个查看位置 
看到的内容。另一方面，基于单元的可见性，对于一个单元格是完 
成的，单元格是包含一组查看位置的空间区域，通常是一个盒子或 
一个球体。基于单元格的可见性中的不可见对象必须在单元格内的 
所有点都不可见。优点图 19.20。左图显示了基于点的可见性，而 
右图显示了基于单元格的可见性，其中单元格是一个框。可以看出， 
圆圈从视点左侧被遮挡。然而，在右边，圆圈是可见的，因为光线 
可以从单元格内的某个地方绘制到圆圈而不会与任何遮挡物相交。 
19.7。遮挡剔除843OcclusionCullingAlgorithm （G）1：OR = 
----------------------- Page 891-----------------------
空2：P=空3：对于每个对象g∈G4：if （isOccluded （g，OR）） 
5：Skip g（）6：else7：Render g（）8：添加 g（，P）9：if LargeEnough（ 
 （P））10：更新（OR，P）11：P=空 12：结束13：结束14： 
结束图 19.21。用于一般遮挡剔除算法的伪代码。G包含场景中的 
所有对象，OR是遮挡表示。P是一组潜在的遮挡物，当它包含足够 
多的物体时会合并到OR中。 （在Zhang [1965]之后。）基于单元 
格的可见性是，一旦为单元格计算它，它通常可以用于几帧，只要 
观察者在单元格内。但是，计算通常比基于点的可见性更耗时。因 
此，它通常作为预处理步骤完成。基于点和基于单元的可见性在本 
质上类似于点和面光源，其中光可被视为观看场景。对于不可见的 
对象，这相当于它在本影区域，即完全在阴影中。还可以将遮挡剔 
除算法分类为在图像空间，对象空间或射线空间中操作的算法。图 
像空间算法在一些投影之后进行二维可见性测试，而对象空间算法 
使用原始三维对象。射线空间方法[150,151,923]在双空间中进行测 
试。每个感兴趣的点（通常是二维的）在这个双重空间中被转换为 
光线。对于实时图形，三者中，图像空间遮挡剔除算法是最广泛使 
用的。一种类型的遮挡剔除算法的伪代码如图 19.21所示，其中函 
数isOccluded （通常称为可见性测试）检查对象是否被遮挡。G是 
要渲染的几何对象集，OR是遮挡表示，P是一组可以与OR合并的 
潜在封堵器。根据特定算法，OR表示某种遮挡信息。OR在开头设 
置为空。之后，处理所有对象（通过视锥体剔除测试）。考虑一个 
特定的对象。首先，我们测试对象是否因遮挡表示OR而被遮挡。 
----------------------- Page 892-----------------------
如果它被遮挡，则不进行处理844 19.加速算法进一步，因为我们 
知道它不会对图像有贡献。如果无法确定对象被遮挡，则必须渲染 
该对象，因为它可能对图像有贡献（在渲染的那一点）。然后将对 
象添加到 P，如果P中的对象数足够大，然后我们可以将这些对象 
的遮挡力合并到OR中。因此，P中的每个对象可以用作封堵器。 
请注意，对于大多数遮挡剔除算法，性能取决于绘制对象的顺序。 
例如，考虑一辆内置电机的汽车。如果首先拉动汽车的引擎盖，那 
么电动机（可能）将被剔除。另一方面，如果先拉动电机，则不会 
剔除任何东西。以粗略的前后顺序进行排序和渲染可以获得可观的 
性能提升。此外，值得注意的是，小物体可能是优秀的遮挡物，因 
为到封堵器的距离决定了它可以遮挡多少。例如，如果观众足够靠 
近火柴盒，火柴盒可以遮挡金门大桥。19.7。1遮挡查询GPU通过 
使用特殊渲染模式支持遮挡剔除。当与z缓冲区的当前内容相比时， 
用户可以查询GPU以查明一组三角形是否可见。三角形通常形成更 
复杂对象的边界体积 （例如，框或k-DOP）。如果这些三角形都不 
可见，则可以剔除该对象。GPU光栅化查询的三角形并将其深度与 
z缓冲区进行比较，即它在图像空间中操作。生成这些三角形可见 
的像素数n的计数，但实际上没有像素或任何深度被修改。如果n 
为零，则所有三角形都被遮挡或剪裁。但是，计数为零还不足以确 
定边界体积是否不可见。更确切地说，相机平截头体的可见近平面 
的任何部分都不应位于边界体积内。假设满足该条件，则整个边界 
体积被完全遮挡，并且可以安全地丢弃所包含的对象。如果n>0， 
----------------------- Page 893-----------------------
那么一小部分像素未通过测试。如果n小于阈值数量的像素，则可 
以丢弃该对象，因为不太可能对最终图像贡献很多[1894]。通过这 
种方式，可以交换速度以防止可能的质量损失。另一个用途是让 n 
帮助确定对象的LOD （第19.9节）。如果n很小，则对象的较小 
部分 （可能）可见，因此可以使用不太详细的LOD。当发现边界体 
被遮挡时，我们通过避免通过渲染管道发送可能复杂的对象来获得 
性能。但是，如果测试失败，我们实际上会失去一些性能，因为我 
们花了额外的时间测试这个边界体积没有任何好处。这个测试有变 
种。对于剔除目的，不需要确切数量的可见片段 - 它足以指示是否 
至少为 19.7的布尔值。遮挡剔除845一个片段通过深度测试。 
OpenGL3.3和 DirectX11及更高版本支持这种类型的遮挡查询， 
枚举为OpenGL[1598]中的任何样本。这些测试可以更快，因为只 
要一个片段可见，它们就可以终止查询。OpenGL4.3及更高版本 
还允许此查询的更快变体，称为 ANY SAMPLES PASSED 
CONSERVATIVE。实施可以选择提供不太精确的测试，只要它是保 
守的并且在正确的方面是错误的。例如，硬件供应商可以通过仅针 
对粗略深度缓冲区 （第23.7节）而不是针对每像素深度执行深度测 
试来实现此目的。查询的延迟通常是相对长的时间。通常，在这段 
时间内可以渲染数百或数千个三角形 - 有关延迟的更多信息，请参 
见第23.3节。因此，当边界框包含大量对象并且发生相对大量的遮 
挡时，这种基于GPU的遮挡剔除方法是值得的。GPU使用遮挡查 
询模型，其中CPU可以向GPU发送任意数量的查询，然后定期检 
----------------------- Page 894-----------------------
查是否有任何结果可用，即查询模型是异步的。就其本身而言，GPU 
执行每个查询并将结果放入队列中。CPU的队列检查速度非常快， 
并且 CPU 可以继续发送查询或实际可渲染对象而不必停顿。 
DirectX和OpenGL都支持谓词/条件遮挡查询，其中查询和相应绘 
图调用的ID同时提交。只有在指示遮挡查询的几何形状可见时， 
GPU才会自动处理相应的绘制调用。这使得模型实际上更有用。通 
常，应该对最有可能被遮挡的对象执行查询。Koval`e'.k和Sochor 
[932]在应用程序运行时收集每个对象的几个帧的查询的运行统计 
信息。发现隐藏对象的帧数会影响将来测试遮挡的频率。那是，可 
见的对象可能保持可见，因此可以不那么频繁地进行测试。如果可 
能，隐藏对象会在每个帧中进行测试，因为这些对象最有可能从遮 
挡查询中受益。Mattausch等。[1136]呈现针对遮挡查询（OC） 
的若干优化而没有预测/条件渲染。他们使用OC的批处理，将几个 
OC组合成一个OC，使用几个边界框而不是一个更大的边界框，并 
使用时间抖动采样来调度先前可见的对象。这里讨论的方案给出了 
遮挡剔除方法的潜力和问题。什么时候使用遮挡查询，或者一般使 
用大多数遮挡方案，通常不清楚。如果一切都是可见的，遮挡算法 
只会花费额外的时间，永远不会保存。一个挑战是迅速确定算法没 
有帮助，因此削减其无效的尝试以节省时间。另一个问题是决定w 
帽子组的对象用作封堵器。在视锥体内的第一个对象必须是可见的， 
因此在这些上花费查询是浪费的。决定渲染的顺序以及何时测试遮 
挡是实现大多数遮挡剔除算法的难点。846 19.加速算法 19.7.2分 
----------------------- Page 895-----------------------
层Z-缓冲分层z-缓冲（HZB）[591,593]对遮挡剔除研究有显着影 
响。尽管很少使用原始的CPU端形式，但该算法是z硬件的GPU 
硬件方法 （第23.7节）以及使用GPU或CPU上运行的软件进行自 
定义遮挡剔除的基础。我们首先描述基本算法，然后介绍如何在各 
种渲染引擎中采用该技术。该算法将场景模型保持在八叉树中，和 
一个框架的z缓冲区作为图像金字塔，我们称之为z金字塔。因此， 
算法在图像空间中操作。八叉树允许对场景的遮挡区域进行分层剔 
除，并且z-金字塔使得能够对基元进行分层z缓冲。因此，z金字 
塔是该算法的遮挡表示。这些数据结构的示例如图 19.22所示。z 
金字塔中最精细（最高分辨率）的级别只是标准的z缓冲区。在所 
有其他级别，每个z值是相邻更精细级别的相应2×2窗口中的最远 
z。因此，每个z值表示屏幕的正方形区域的最远z。每当z值在z 
缓冲区中被覆盖时，它就会通过z-pyramid的较粗级传播。这是递 
归地完成的，直到到达图像金字塔的顶部，其中仅剩下一个z值。 
金字塔的形成如图 19.23所示。八叉树节点的分层剔除如下进行。 
以粗略的前后顺序遍历八叉树节点。使用扩展遮挡查询（第19.7.1 
节）针对z金字塔测试八叉树的边界框。我们开始在包含盒子屏幕 
投影的最粗糙的z金字塔单元进行测试。然后将盒子在单元格内的 
最近深度（znear）与z金字塔值进行比较，如果znear更远，则 
已知该盒子被遮挡。该测试沿z-金字塔递归地继续，直到发现盒子 
被遮挡，或者直到达到z-金字塔的底部水平，此时已知盒子是可见 
的。对于可见的八叉树盒，测试在八叉树中递归递归，最后潜在可 
----------------------- Page 896-----------------------
见的几何体呈现在分层的z缓冲区中。这样做是为了使后续测试可 
以使用先前渲染对象的遮挡能力。目前还没有使用完整的 HZB算 
法，但它已被简化并适用于在GPU上使用自定义剔除或在CPU上 
使用软件光栅化的计算通道。通常，大多数基于 HZB的遮挡剔除算 
法的工作方式如下：1。使用一些遮挡表示生成完整的分层z金字塔。 
2.要测试对象是否被遮挡，请将其边界体积投影到屏幕空间并估计z 
金字塔中的mip级别。3.针对选定的mip级别测试遮挡。如果结果 
不明确，可以选择使用更精细的mip级别继续测试。19.7。遮挡剔 
除847图19.22。使用HZB算法[591,593]进行遮挡剔除的示例， 
显示具有高深度复杂度的场景（右下）和相应的z金字塔（左侧） 
和八叉树细分（右上角）。通过从前到后遍历八叉树并在遇到它们 
时剔除被遮挡的八叉树节点，该算法仅访问可见的八叉树节点及其 
子节点（在右上角描绘的节点）并仅渲染可见框中的三角形。在该 
示例中，剔除被遮挡的八叉树节点将深度复杂度从84减小到2.5。 
 （图片由NedGreene/ Apple Computer提供。）图 19.23。在 
左侧，显示了4×4的z缓冲区。数值是实际的z值。这被下采样到 
2×2区域，其中每个值是左侧的四个2×2区域中最远 （最大）的区 
域。最后，计算剩余的四个z值的最远值。这三个地图组成了一个 
图像金字塔，称为分层z缓冲区。84819.加速算法大多数实现不使 
用八叉树或任何 BVH，也不会在渲染对象后更新zpyramid，因为 
这被认为太昂贵而无法执行。步骤1可以使用“最佳”遮挡物[1637] 
来完成，可以使用简化的艺术家生成的遮挡物基元，或者使用关于 
----------------------- Page 897-----------------------
可见的物体组的统计数据，将其选择为最近的n个物体组[625]。前 
一帧。或者，可以使用前一帧中的z缓冲区[856]，然而，这并不保 
守，因为有时可能会因为不正确的剔除而弹出物体，特别是在快速 
相机或物体移动时。Haar和Aaltonen [625]都渲染了最好的遮挡 
物，并将它们与前一帧深度的 1/16低分辨率的重投影结合起来。然 
后使用GPU构建z金字塔，如图19.23所示。有些人使用AMDGCN 
架构的 HTILE （第23.10.3节）来加速z-金字塔生成[625]。在步骤 
2中，将对象的边界体积投影到屏幕空间。BV的常见选择是球体， 
AABB和OBB。投影BV的最长边l （以像素为单位）用于计算mip 
水平λ，如[738,1637,1883,1884]λ=min...？log2 （max （，l 1））？， 
n。1？，（19.5）其中n是z金字塔中 mip级别的最大数量。max 
运算符用于避免获得负mip级别，并且min避免访问不存在的mip 
级别。等式 19.5选择最低整数mip级别，使得投影的 BV覆盖最多 
2×2个深度值。这种选择的原因在于它使成本可预测 - 需要读取和 
测试最多四个深度值。此外，希尔和科林[738]认为，这个测试可以 
被视为 “概率”，因为大对象比小对象更可见，因此在这些情况下 
没有理由阅读更多的深度值。当到达步骤3时，我们知道投影的 BV 
受到该 mip级别的一组最多2×2深度值的限制。对于给定大小的 
BV，它可能完全落在mip级别的一个深度纹理像素内。但是，取决 
于它如何落在电网上，它可以覆盖所有四个纹素。精确或保守地计 
算 BV的最小深度。在视图空间中使用AABB时，此深度只是框的 
最小深度，对于OBB，可以将所有顶点投影到视图矢量上并选择最 
----------------------- Page 898-----------------------
小距离。对于球体，Shopf等。[1637]将球体上的最近点计算为c。 
rc/ ||c||，其中c是视图空间中的球体中心，r是球体半径。请注意， 
如果摄像机位于 BV内，则BV覆盖整个屏幕，然后渲染对象。将 
BV的最小深度zmin与分层z缓冲器中的 （最多）2×2深度进行比 
较，并且如果zmin总是更大，则 BV被遮挡。可以在这里停止测试， 
只是在未检测到被遮挡的情况下渲染对象。人们还可以继续测试金 
字塔中的下一个更深（更高分辨率）的水平。我们可以通过使用另 
一个存储最小深度的z金字塔来查看是否需要进行此类测试。我们 
测试 BV19.7的最大距离zmax。遮挡剔除849对应此新缓冲区中 
的相应深度。如果zmax小于所有这些深度，则 BV绝对可见并且 
可以立即渲染。否则，BV的zmin和zmax与两个分级z缓冲区的 
深度重叠，在这种情况下，Kaplanyan [856]建议在更高分辨率的 
mip级别上继续测试。请注意，在分层z缓冲区中针对单个深度测 
试2×2纹素与非常接近百分比的过滤非常类似 （第7.5节）。事实 
上，可以使用双线性滤波和百分比近似滤波来完成测试，如果测试 
返回正值，则至少可以看到一个纹素。Haar和Altonen [625]也提 
出了一种两遍方法，它总是至少呈现所有可见对象。首先，针对前 
一帧的z金字塔完成所有对象的遮挡剔除，并渲染 “可见”对象。 
或者，可以使用最后一帧的可见性列表直接渲染z金字塔。虽然这 
是一个近似值，但所有渲染的对象都可以作为当前帧 “最佳”遮挡 
物的极佳猜测，尤其是在具有高帧帧一致性的场景中。第二遍传递 
这些渲染对象的深度缓冲区并创建一个新的z金字塔。然后，对第 
----------------------- Page 899-----------------------
一遍中被遮挡的遮挡物进行遮挡测试，如果没有剔除则进行渲染。 
即使相机快速移动或物体在屏幕上快速移动，此方法也会生成完全 
正确的图像。Kubisch和 Tavenrath [944]使用类似的方法。 
Doghramachi和 Bucci[363]对前一帧的深度缓冲区进行了光栅化 
定向的遮挡框的边界框，该缓冲区已被下采样并重新投影。它们强 
制着色器使用early-z （第23.7节），并且对于每个框，可见片段 
将对象标记为在缓冲区位置中可见，缓冲区位置是根据对象 ID[944] 
唯一确定的。这提供了更高的剔除率，因为使用了定向框并且因为 
进行了每像素测试，而不是使用公式 19.5对 mip级别使用自定义 
测试。Collin [283]使用256×144浮点z缓冲区（非分层）并光栅 
化具有低复杂度的艺术生成的遮挡物。这可以通过软件使用CPU或 
使用具有高度优化的SIMD代码的SPU （在PLAYSTATION3上） 
完成。为了执行遮挡测试，计算对象的屏幕空间AABB，并将其zmin 
与小z缓冲区中的所有相关深度进行比较。只有经过剔除的对象才 
会被发送到GPU。这种方法有效但不保守，因为使用的分辨率低于 
最终帧缓冲的分辨率。Wihlidal [1883]建议低分辨率z缓冲区也可 
用于将zmax值加载到GPU的HiZ（第23.7节）中，例如，在AMD 
GCN上启动 HTILE结构。或者，如果 HZB用于计算传递剔除，然 
后软件z缓冲区可用于生成z金字塔。通过这种方式，算法利用软 
件中生成的所有信息。Hasselgren等。[683]呈现了不同的方法， 
其中每个8×4瓦片具有每像素一个比特和两个zmax值[50]，导致 
每像素3比特的总成本。通过使用zmax值，可以更好地处理深度 
----------------------- Page 900-----------------------
不连续性，因为背景对象可以使用zmax值之一而前景对象使用另 
一个。这种表示称为屏蔽分层深度缓冲区（MHDB），是加速算法 
的加速算法，也可用于zmax剔除。在软件三角形光栅化期间，每 
个图块仅生成覆盖掩模和单个最大深度值，这使得对 MHDB的光栅 
化快速且有效。在将三角形光栅化到 MDHB期间，也可以对 MDHB 
进行三角形的遮挡测试，从而优化光栅化器。MDHB针对每个三角 
形进行更新，这是其他方法所具有的强度。评估两种使用模式。第 
一种是使用特殊的遮挡网格，并使用软件光栅化器将其渲染到 
MDHB。之后，遍历封闭器上的AABB树并对 MDHB进行分层测 
试。这可能非常有效，特别是如果场景中有许多小物体。对于第二 
种方法，整个场景存储在AABB树中，并且使用堆以大致从前到后 
的顺序遍历场景。在每个步骤中，对 MDHB进行视锥体剔除和遮挡 
查询。每当渲染对象时，MDHB也会更新。使用此方法渲染图 19.19 
中的场景。开源代码针对AVX2进行了大量优化[683]。还有专门用 
于剔除和遮挡剔除的中间件包。Umbra就是这样一个框架，它已经 
与各种游戏引擎广泛集成[13,1789]。19.8剔除系统剔除系统多年来 
发展很快，并且还在不断发展。在本节中，我们将描述一些总体思 
路，并指出文献的细节。有些系统可以有效地执行GPU计算着色器 
中的所有剔除，而其他系统则会在CPU上进行粗略剔除，并在GPU 
上进行更精细的剔除。典型的剔除系统适用于许多粒度，如图 19.24 
所示。对象的簇或块仅仅是对象的三角形的子集。例如，可以使用 
具有64个顶点[625]的三角形条带或256个三角形的组[1884]。在 
----------------------- Page 901-----------------------
每个步骤中，可以使用剔除技术的组合。ElMansouri[415]使用小 
三角形剔除，细节剔除，视锥体剔除和物体上的遮挡剔除。由于聚 
类在几何上比对象小，因此即使对于聚类也使用相同的剔除技术是 
有意义的，因为它们更有可能被剔除。可以使用例如细节，平截头 
体，聚类背面和聚类上的遮挡剔除。对象/实例剔除簇/块剔除三角 
形剔除图 19.24。一个示例剔除系统，适用于三种不同的粒度。首 
先，在每个对象级别上进行剔除。然后在每个集群级别上剔除生存 
对象。最后，完成三角形剔除，这将在图 19.25中进一步描述。19.8。 
剔除系统851剔除压实间接绘图图 19.25。三角剔除系统，首先将 
一组剔除算法应用于所有单个三角形。为了能够使用间接绘图，即 
没有GPU/CPU往返，将幸存的三角形压缩成更短的列表。此列表 
由GPU使用间接绘图呈现。在按群集级别完成剔除后，可以执行额 
外的步骤，在每个三角形级别上进行剔除。为了使这完全在GPU上 
发生，可以使用图 19.25中所示的方法。三角形的剔除技术包括用 
w除法后的平截头体剔除，即比较三角形的范围与±1，背面测试， 
退化三角形剔除，小三角形剔除，也可能是遮挡剔除。然后将在所 
有剔除测试之后保留的三角形压缩成最小列表，这样做是为了在下 
一步骤中仅处理幸存的三角形[1884]。我们的想法是指示剔除计算 
着色器在此步骤中从GPU向自身发送绘图命令。这是使用间接绘制 
命令完成的。这些调用在OpenGL中称为“多绘间接”，在 DirectX 
中称为 “执行间接”[433]。三角形的数量被写入GPU缓冲区中的 
位置，GPU可以使用压缩列表来渲染三角形列表。有许多方法可以 
----------------------- Page 902-----------------------
将剔除算法与它们的执行位置结合起来，即在CPU上或在GPU上， 
并且每种剔除算法也有很多种类。最终的组合尚未找到，但可以肯 
定地说，最佳方法取决于目标架构和要呈现的内容。接下来，我们 
指出了CPU/GPU剔除系统领域的一些重要工作，这些工作已经大 
大影响了该领域。Shopf等。[1637]对GPU上的角色进行了所有 
AI模拟，因此，每个角色的位置仅在GPU内存中可用。这导致他 
们使用计算着色器探索剔除和 LOD管理，并且随后的大多数系统都 
受到他们工作的严重影响。Haar和Aaltonen [625]描述了他们为 
刺客信条团结开发的系统。Wihlidal [1883,1884]解释了 Frostbite 
发动机中使用的剔除系统。Engel[433]提出了一种剔除系统，该系 
统有助于使用可见性缓冲区改善管道（第20.5节）。Kubisch和 
Tavenrath [944]描述了使用大量零件渲染大量模型并使用不同的 
剔除方法和API调用进行优化的方法。他们用于遮挡剔除框的一个 
值得注意的方法是使用几何着色器创建边界框的可见边，然后让 
early-z快速剔除遮挡几何体。85219.加速算法图 19.26。在这里， 
我们展示了C4爆炸物（顶部）和猎人（底部）模型的三个不同层 
次的细节。元素在较低的细节水平上被简化或完全删除。小插图显 
示了可能使用它们的相对大小的简化模型。（最受欢迎的图像由 
Crytek提供;底部行由Valve Corp.提供）19.9细节层次细节层次 
 （LOD）的基本思想是使用更简单的对象版本，因为它对渲染图像 
的贡献越来越少。例如，考虑一个可能由一百万个三角形组成的详 
细汽车。当观众靠近汽车时，可以使用该表示。当物体距离较远时， 
----------------------- Page 903-----------------------
例如仅覆盖200个像素时，我们不需要所有一百万个三角形。相反， 
我们可以使用仅具有 1000个三角形的简化模型。由于距离的原因， 
简化版本看起来与更详细的版本大致相同。见图 19.26。通过这种 
方式，可以预期显着的性能提升。为了减少应用LOD技术所涉及的 
总工作量，它们最好在剔除技术后应用。例如，仅针对视锥体内的 
对象计算 LOD选择。还可以使用 LOD技术，以使应用程序在具有 
不同性能的一系列设备上以期望的帧速率工作。在速度较低的系统 
上，可以使用不太详细的LOD来提高性能。请注意，虽然 LOD技 
术首先有助于减少顶点处理，但是 19.9。细节级别853它们还降低 
了像素着色成本。发生这种情况是因为模型的所有三角形边长的总 
和将更低，这意味着减少了四边形过度（第 18.2和23.1节）。第 
14章中描述的雾和其他参与媒体可以与 LOD一起使用。例如，这 
允许我们在物体进入完全不透明的雾时完全跳过对象的渲染。也， 
雾化机制可用于实现时间关键渲染 （第 19.9.3节）。通过将远平面 
移近观察者，可以在早期剔除更多物体，从而提高帧速率。此外， 
较低的 LOD通常可用于雾中。某些对象（如球体，B'ezier曲面和 
细分曲面）具有细节层次，作为其几何描述的一部分。底层几何体 
是弯曲的，并且单独的 LOD控件确定如何将其细分为可显示的三角 
形。有关适应参数曲面和细分曲面的曲面细分质量的算法，请参见 
第 17.6.2节。通常，LOD算法由三个主要部分组成，即生成，选择 
和切换。LOD生成是生成具有不同细节量的模型的不同表示的部分。 
第 16.5节中讨论的简化方法可用于生成所需数量的 LOD。另一种 
----------------------- Page 904-----------------------
方法是手工制作具有不同数量的三角形的模型。选择机制基于某些 
标准选择细节级别模型，例如屏幕上的估计区域。最后，我们需要 
从一个细节级别更改为另一个级别，此过程称为 LOD切换。本节介 
绍了不同的LOD切换和选择机制。虽然本节的重点是选择不同的几 
何表示，但 LOD背后的思想也可以应用于模型的其他方面，甚至应 
用于所使用的渲染方法。较低级别的细节模型也可以使用较低分辨 
率的纹理，从而进一步节省内存以及可能改进缓存访问[240]。着色 
器本身可以根据距离，重要性或其他因素进行简化 
[688,1318,1365,1842]。Kajiya [845]呈现了一种比例层次，显示 
了表面照明模型如何重叠纹理映射方法，而这些方法又重叠了几何 
细节。另一种技术是较少的骨骼可用于远处物体的蒙皮操作。当静 
态物体相对较远时，广告牌和冒名顶替者 （第 13.6.4节）是以低成 
本代表它们的自然方式[1097]。其他表面渲染方法（例如凹凸或浮 
雕映射）可用于简化模型的表示。图19.27给出了一个例子。Teixeira 
[1754]讨论了如何使用GPU将法线贴图烘焙到曲面上。这种简化技 
术最引人注目的缺陷是轮廓失去曲率。Loviscach[1085]提出了一 
种沿着轮廓边缘挤出翅片以产生弯曲轮廓的方法。可用于表示物体 
的一系列技术的例子来自Lengyel等人。[1030,1031]。在这项研 
究中，毛皮在非常接近时由几何体表示，在远处时由阿尔法混合折 
线表示，然后由854表示。加速度算法图 19.27。在左侧，原始模 
型由 150万个三角形组成。在右侧，模型有 1100个三角形，表面 
细节存储为高度场纹理，并使用浮雕映射进行渲染。（图片由ATI 
----------------------- Page 905-----------------------
Research，Inc。的NatalyaTatarchuk提供））与体积纹理 “贝壳” 
混合，最后通过远处的纹理贴图。见图 19.28。了解何时以及如何 
最好地从一组建模和渲染技术切换到另一组建模和渲染技术，从而 
最大化帧速率和质量仍然是一个艺术和开放的探索领域。19.9.1 
LOD切换当从一个LOD切换到另一个LOD时，突然的模型替换通 
常会引起注意并分散注意力。这种差异称为弹出。这里将描述执行 
该切换的几种不同方式，并且它们各自具有不同的弹出特性。离散 
几何 LOD在最简单类型的 LOD算法中，各种表示是包含不同数量 
的基元的同一对象的模型。该算法非常适合现代图形硬件[1092]， 
因为这些单独的静态网格物体可以存储在GPU 内存中并重复使用 
 （第16.4.5节）。更详细的 LOD具有更多的基元。物体的三个 LOD 
如图 19.26和 19.29所示。第一张图还显示了距观察者不同距离的 
LOD。19.9。细节层次855图19.28。从远处看，兔子的皮毛采用 
体积纹理进行渲染。当兔子靠近时，头发会用alpha混合折线渲染。 
当靠近时，沿着轮廓的毛皮用移植鳍呈现。（图片由微软研究院的 
Jed Lengyel和 MichaelCohen提供。）图19.29。悬崖的一部分， 
有三个不同的细节层次，从左到右分别有72,200,113,719和7,713 
个三角形。 （图片由QuixelMegascans提供。）85619。加速算 
法从一个 LOD切换到另一个LOD是突然的。也就是说，在当前帧 
上使用某个 LOD，然后在下一帧上，选择机制选择另一个LOD并 
立即使用它进行渲染。对于这种类型的 LOD方法，弹出通常是最差 
的，但是如果在渲染的 LOD中的差异几乎不可见时在距离处发生切 
----------------------- Page 906-----------------------
换，则它可以很好地工作。接下来描述更好的替代品。混合 LOD从 
概念上讲，一种简单的切换方法是在短时间内在两个LOD之间进行 
线性混合。这样做肯定会使开关更顺畅。为一个对象渲染两个LOD 
自然比仅渲染一个LOD更昂贵，因此这有点违背了LOD的目的。 
但是，LOD切换通常只在很短的时间内发生，并且通常不同时用于 
场景中的所有对象，因此质量改进可能是值得的。假设期望两个LOD 
之间的转换 - 例如 LOD1和 LOD2-，并且LOD1是正在呈现的当 
前LOD。问题在于如何以合理的方式渲染和混合两个LOD。使两个 
LOD半透明将导致呈现给屏幕的半透明（虽然稍微不透明）对象， 
这看起来很奇怪。Giegl和Wimmer [528]提出了一种在实践中运 
行良好且易于实施的混合方法。首先将 LOD1不透明地绘制到帧缓 
冲区（颜色和z）。然后通过将其alpha值从0增加到1并使用“over” 
混合模式淡入 LOD2。当LOD2已经淡入，因此它完全不透明时， 
它将变为当前LOD，然后 LOD1逐渐淡出。应该在启用z-test并禁 
用z-writes的情况下呈现正在淡入 （进入或退出）的LOD。为了避 
免稍后绘制的远处对象绘制渲染褪色 LOD的结果，只需在所有不透 
明内容之后按照排序顺序绘制所有褪色LOD，如通常对透明对象所 
做的那样。请注意，在转换过程中，两个LOD都不透明地呈现，一 
个在另一个上面。如果过渡间隔保持较短，则此技术效果最佳，这 
也有助于保持较小的渲染开销。Mittring[1227]讨论了一种类似的 
方法，除了屏幕门透明度（可能在子像素级别）用于在版本之间解 
散。Scherzer和Wimmer [1557]通过仅更新每个帧上的一个 LOD 
----------------------- Page 907-----------------------
并重新使用前一帧中的另一个 LOD来避免渲染两个 LOD。使用可 
见性纹理与组合传递一起执行前一帧的反投影。更快的渲染和更好 
的过渡是主要结果。有些对象适用于其他切换技术。例如， 
SpeedTree包[887]平滑地移动或缩放其树LOD模型的部分以避免 
爆裂。有关示例，请参见图 19.30。图19.31显示了一组LOD，以 
及用于远距离树木的广告牌 LOD技术。19.9。详细程度857 图 
19.30。当观察者远离树模型时，树枝 （及其叶子，未示出）收缩然 
后被移除。 （图片由SpeedTree提供。）Alpha LODs一种避免弹 
出的简单方法是使用我们称之为alphaLOD的方法。该技术可以单 
独使用或与其他 LOD切换技术结合使用。它用于最简单的可见 
LOD，如果只有一个 LOD可用，它可以是原始模型。由于用于LOD 
选择的度量（例如，到该对象的距离）增加，对象的整体透明度增 
加 （α减小），并且当对象达到完全透明度 （α=0.0）时最终消失。 
这发生了 16,000个三角形9,000个三角形 5,000个三角形广告牌 
图19.31。树 LOD模型，接近远。当树在远处时，它由一组广告牌 
中的一个表示，如右图所示。每个广告牌都是来自不同视图的树的 
渲染，由颜色和法线贴图组成。选择最面向观众的广告牌。在实践 
中，形成了8到 12个广告牌（这里显示了6个），并且修剪透明 
部分以避免花费时间丢弃完全透明的像素 （第 13.6.2节）。 （图片 
由SpeedTree提供。）858 19.加速算法图 19.32。中间的圆锥使 
用alphaLOD渲染。当距离锥体的距离增加时，锥体的透明度增加， 
最终消失。左侧的图像以相同的距离显示以供查看，而线条右侧的 
----------------------- Page 908-----------------------
图像以不同的尺寸显示。当度量标准值大于用户定义的不可见性阈 
值时。当达到不可见性阈值时，只要度量值保持在阈值之上，就不 
需要通过渲染管道发送对象。当一个对象不可见且其度量低于隐形 
阈值时，它会降低其透明度并再次开始可见。另一种方法是使用第 
19.9.2节中描述的滞后方法。独立使用这种技术的优势在于它经历 
了比离散几何LOD方法更连续的体验，因此避免了弹出。此外，由 
于对象最终完全消失而无需渲染，因此可以预期显着的加速。缺点 
是物体完全消失，只有在这一点上才能获得性能提升。图 19.32显 
示了alpha LOD的示例。使用Alpha透明度的一个问题是需要按 
深度排序以确保透明对象正确混合。淡出遥远的植被，Whatley 
[1876]讨论了如何将噪声纹理用于屏幕门透明度。这具有溶解的效 
果，随着距离的增加，物体上的更多纹素消失。虽然质量不如真正 
的阿尔法褪色，但屏幕门透明度意味着不需要分类或混合。19.9。 
细节级别859CLOD和GeomorphLOD网格简化过程可用于从单 
个复杂对象创建各种 LOD模型。第 16.5.1节讨论了执行此简化的 
算法。一种方法是创建一组离散 LOD并如前所述使用这些 LOD。 
但是，边缘折叠方法具有允许在 LOD之间进行转换的其他方式的属 
性。在这里，我们提出了两种利用这些信息的方法。这些作为背景 
很有用，但目前很少在实践中使用。在执行每个边缘折叠操作之后， 
模型具有两个更少的三角形。在边缘崩溃中发生的是边缘收缩直到 
其两个端点相遇并且消失。如果此过程是动画的，则原始模型与其 
略微简化的版本之间会发生平滑过渡。对于每个边折叠，单个顶点 
----------------------- Page 909-----------------------
与另一个顶点连接。在一系列边折叠中，一组顶点移动以连接其他 
顶点。通过存储一系列边缘折叠，可以颠倒这个过程，从而可以使 
简化模型随着时间的推移变得更加复杂。边折叠的反转称为顶点分 
割。因此，改变对象细节水平的一种方法是精确地基于LOD选择值 
上可见的三角形数量。距离酒店 100米该模型可能包含 1000个三 
角形，并且移动到 101米，它可能会下降到998个三角形。这种方 
案称为连续细节水平 （CLOD）技术。那时，没有一组离散的模型， 
而是一组可用于显示的模型，每个模型的三角形比其更复杂的邻居 
少两个。虽然吸引人，但在实践中使用这样的方案有一些缺点。并 
非CLOD流中的所有模型都看起来不错。与静态模型相比，使用 
CLOD技术更难以使用比单个三角形更快速渲染的三角网格。如果 
场景中有多个同一对象的实例，则每个CLOD对象需要指定自己的 
特定三角形集，因为它与其他三角形不匹配。Forsyth[481]讨论了 
解决这些问题和其他问题的方法。虽然大多数CLOD技术本质上都 
是串行技术，但它们并不适合在GPU上实现。因此，胡等人。[780] 
呈现CLOD的修改，其更好地适合GPU的并行性质。他们的技术 
也是独立的，因为如果一个物体与视锥体的左侧相交，则可以在平 
截头体外部使用更少的三角形，连接到更高密度的网格内部。在顶 
点分割中，一个顶点变为两个。这意味着复杂模型上的每个顶点都 
来自更简单版本的某些顶点。地貌 LOD[768]是通过简化创建的一 
组离散模型，维持顶点之间的连通性。从复杂模型切换到简单模型 
时，复杂模型的顶点在它们的原始位置和更简单的版本之间进行插 
----------------------- Page 910-----------------------
值。转换完成后，使用更简单的细节级别模型来表示对象。有关转 
换的示例，请参见图 19.33。地貌有几个优点。可以预先选择各个 
静态模型以获得高质量，并且可以容易地将其变成三角形网格。与 
CLOD一样，平滑过渡也可以避免弹出。主要缺点是86019.加速算 
法图 19.33。左图和右图显示了低细节模型和更高细节模型。中间 
的图像显示了在左右模型之间大约中间插入的地貌模型。请注意， 
中间的母牛具有与右侧模型相同的顶点和三角形。 （使用Melax的 
 “Polychop”简化演示[1196]生成的图像。）每个顶点都需要进行 
插值;CLOD技术通常不使用插值，因此顶点位置本身的集合永远不 
会改变。另一个缺点是物体总是看起来在变化，这可能会分散注意 
力。对于纹理对象尤其如此。Sander和 Mitchell[1543]描述了一 
种系统，其中几何变形与静态的，GPU驻留的顶点和索引缓冲区结 
合使用。还可以将 Mittring[1227] （如上所述）的屏幕门透明度与 
地貌结合起来以实现更平滑的过渡。GPU支持称为分数细分的相关 
概念。在这样的计划中，曲面的曲面细分因子可以设置为任何浮点 
数，因此可以避免弹出。例如，分数镶嵌可以用于 B'ezier贴片和位 
移贴图基元。有关这些技术的更多信息，请参见第 17.6.1节。19.9.2 
LOD选择鉴于存在不同的对象细节级别，必须选择要渲染哪一个， 
或者要混合哪一个。这是 LOD选择的任务，这里将介绍一些不同的 
技术。这些技术也可用于选择用于遮挡剔除算法的良好遮挡物。通 
常，针对当前视点和对象的位置评估度量（也称为益处函数），并 
且该度量的值选择适当的 LOD。该指标可以基于，例如，物体的边 
----------------------- Page 911-----------------------
界体积的投影面积或从视点到物体的距离。效益函数的值在此表示 
为r。另请参见第 17.6.2节，了解如何快速估计线在屏幕上的投影。 
基于范围选择 LOD的常用方法是将对象的不同LOD与不同的距离 
范围相关联。最详细的 LOD范围从零到 19.9。详细程度861图 
19.34。此图的左侧部分显示了基于范围的LOD的工作原理。请注 
意，第四个 LOD是一个空对象，因此当对象比 r3更远时，不会绘 
制任何内容，因为该对象对图像的贡献不足以使其值得付出努力。 
右侧部分显示场景图中的 LOD节点。只有一个 LOD节点的子节点 
基于r而下降。用户定义的值r1，表示当到对象的距离小于r1时， 
此 LOD可见。下一个 LOD的范围从r1到r2，其中r2>r1。如果 
到对象的距离大于或等于r1且小于r2，则使用此 LOD，依此类推。 
图19.34中示出了四个不同LOD及其范围的示例，以及场景图中使 
用的相应LOD节点。如果用于确定使用哪个LOD的度量在某个值 
ri周围的帧与帧之间变化，则可能发生不必要的弹出。可以在水平 
之间来回快速循环。这可以通过在 ri值周围引入一些滞后来解决 
[898,1508]。对于基于范围的 LOD，如图 19.35所示，但适用于任 
何类型。这里，仅当 r增加时才使用上行 LOD范围。当r减小时， 
使用底行范围。在过渡范围内混合两个 LOD如图 19.36所示。然而， 
这不是理想的，因为到对象的距离可能长时间驻留在过渡范围内， 
这增加了由于混合两个 LOD而导致的渲染负担。相反，Mittring 
[1227]在对象达到特定转换范围的有限时间内执行 LOD切换。为获 
得最佳结果，应将其与上述滞后方法结合使用。预测的基于区域的 
----------------------- Page 912-----------------------
LOD选择的另一个常见度量是边界体积的投影面积或其估计值。在 
这里，我们将展示如图 19.35所示的像素数。彩色区域说明了 LOD 
技术的滞后区域。862 19。加速算法LOD0b01LOD1b12LOD2 
b23LOD3图19.36。彩色区域示出了在两个最接近的 LOD之间进 
行混合的范围，其中b01表示例如 LOD0和 LOD1之间的混合，并 
且 LODk表示仅在相应范围中渲染 LODk。可以通过透视观察来估 
计球体和盒子的区域，称为屏幕空间覆盖。从球体开始，估计基于 
以下事实：物体投影的尺寸随着观察者沿着视线方向的距离而减小。 
这在图 19.37中示出，其示出了如果距观察者的距离加倍则投影的 
尺寸如何减半，这对于面向观察者的平面物体是成立的。我们通过 
其中心点c和半径r来定义球体。观察者位于沿着归一化方向向量d 
的v处。沿视图方向从c到v的距离就是球体中心在视图矢量上的 
投影：d·（vc）。我们还假设从观察者到视锥体的近平面的距离是n。 
在估计中使用近平面，使得位于近平面上的对象返回其原始大小。 
然后估计投影球体的半径为 p=nrd· （v.c）。 （19.6）投影的像素 
面积因此是πp2wh，其中w×h是屏幕分辨率。值越高，选择更详 
细的 LOD。这是近似值。实际上，如图 19.37所示。此图显示了当 
距离加倍时，没有任何厚度的物体投影的大小减半。19.9。详细程 
度863图19.38。投影立方体的三种情况，显示 （从左到右）一个， 
两个和三个正面。轮廓分别由四个，六个和六个顶点组成，并且为 
每个形成的多边形计算每个轮廓的面积。（Schmalstieg和Tobler 
之后的插图[1569]。）三维球体的投影是椭圆形，如 Mara和 
----------------------- Page 913-----------------------
McGuire[1122]所示。他们还推导出一种计算保守边界多边形的方 
法，即使在球体与近平面相交的情况下也是如此。通常的做法是简 
单地在对象的边界框周围使用边界球。另一个估计是使用边界框的 
屏幕边界。但是，薄或扁平物体的实际覆盖的投影面积可能会有很 
大差异。例如，想象一串意大利面，一端在屏幕的左上角，另一端 
在右下角。其边界球将覆盖屏幕，其边界框的最小和最大二维屏幕 
边界也是如此。Schmalstieg和Tobler [1569]提出了一种计算盒子 
投影面积的快速程序。该想法是将相机的视点相对于框分类，并使 
用该分类来确定哪些投影顶点包括在投影框的轮廓中。此过程通过 
查找表完成。使用这些顶点，可以计算视图中的区域。分类分为三 
大类，如图 19.38所示。实际上，这种分类是通过确定视点所在的 
边界框的平面的哪一侧来完成的。为了提高效率，将视点转换为框 
的坐标系，以便仅需要进行比较以进行分类。比较的结果被放入一 
个位掩码，用作 LUT的索引。该LUT确定从视点看到的轮廓中有多 
少个顶点。然后，使用另一个查找来实际找到轮廓顶点。将它们投 
影到屏幕后，计算轮廓区域。为了避免 （有时是激烈的）估计误差， 
将形成的多边形剪切到视锥体的两侧是值得的。源代码可在网上获 
得。Lengyel[1026]对该方案进行了优化，其中可以使用更紧凑的 
LUT。将LOD选择仅基于范围或投影并不总是一个好主意。例如， 
如果一个对象有一个特定的AABB，其中包含一些大的三角形和一 
些小三角形，那么小三角形可能会因为四边形过度阴影而变质，并 
降低性能。如果另一个对象具有完全相同的AABB但具有中等864 
----------------------- Page 914-----------------------
19.加速算法和其中的大三角形，则基于范围和基于投影的选择方法 
将选择相同的 LOD。为了避免这种情况，Schulz和 Mader[1590] 
使用几何平均值g来帮助选择 LOD：g =npt0t1···tn.1，（19.7） 
其中ti是对象三角形的大小。使用几何平均值而不是算术平均值（平 
均值）的原因是，即使存在几个大三角形，许多小三角形也会使g 
变小。此值是针对最高分辨率模型离线计算的，并用于预先计算第 
一个开关应该发生的距离。随后的切换距离是第一距离的简单函数。 
这允许他们的系统更频繁地使用较低的 LOD，这提高了性能。另一 
种方法是计算每个离散LOD的几何误差，即，估计简化模型与原始 
模型最多偏离多少米。然后可以投影该距离以确定屏幕空间中使用 
该 LOD的效果。然后选择也满足用户定义的屏幕空间错误的最低 
LOD。其他选择方法基于范围和基于投影区域的 LOD选择通常是最 
常用的指标。但是，其他许多都是可能的，我们在这里会提到一些。 
除了投影面积，Funkhouser和S'equin[508]也建议使用物体的重 
要性 （例如，墙壁比墙上的时钟更重要），运动，滞后 （当切换LOD， 
降低效益时）和焦点。最后，观众关注的焦点可能是一个重要因素。 
例如，在体育比赛中，控制球的人物是用户最关注的地方，因此其 
他人物可以具有相对较低的细节水平[898]。类似地，当在虚拟现实 
应用中使用眼睛跟踪时，应该在观看者看起来使用更高的 LOD。根 
据应用，其他策略可能会有成效。可以使用整体可见度，例如，通 
过密集的叶子看到的附近物体可以用较低的LOD渲染。更多全球指 
标是可能的，例如限制使用的高度详细的 LOD的总数，以便保持在 
----------------------- Page 915-----------------------
给定的三角形预算内[898]。有关此主题的更多信息，请参阅下一节。 
其他因素包括可见性，颜色和纹理。感知指标也可用于选择 LOD 
[1468]。McAuley[1154]提出了一种植被系统，其中树干和叶簇在 
它们成为冒名顶替者之前有三个LOD。他为每个对象在集群之间预 
处理不同视点和不同距离的可见性。由于树后面的聚类可能被更近 
的聚类隐藏，因此即使树靠近，也可以为这些聚类选择较低的 LOD。 
对于草渲染，通常使用靠近观察者的几何形状，稍微远离的广告牌 
以及在相当远的距离处的简单地面纹理[1352]。19。9.细节级别865 
19.9.3时间关键LOD渲染渲染系统通常具有恒定帧速率的理想特 
征。实际上，这通常被称为 “硬实时”或时间关键渲染。这样的系 
统被给予特定的时间量，比如16毫秒，并且必须完成其任务（例如， 
渲染图像）在那段时间内。当时间到了，系统必须停止处理。如果 
场景中的对象由 LOD表示，则硬实时渲染系统将能够向每个帧显示 
用户的更多或全部场景，而不是在分配的时间内仅绘制几个高度详 
细的模型。Funkhouser和S'equin [508]提出了一种启发式算法， 
该算法适应场景中所有可见对象的细节级别的选择，以满足恒定帧 
速率的要求。该算法在预测中是预测的，即它基于期望的帧速率和 
可见的对象来选择可见对象的LOD。这种算法与反应算法形成对比， 
反应算法的选择基于渲染前一帧所花费的时间。一个对象称为O， 
并在一个名为L的细节层次上呈现，它为对象的每个LOD提供（O， 
L）。然后定义两个启发式方法。一种启发式算法估计在特定细节级 
别渲染对象的成本：成本 （O，L）。另一个人估计了在特定细节水 
----------------------- Page 916-----------------------
平上呈现的对象的好处：效益 （O，L）。效益函数估计在某个 LOD 
处对对象的图像的贡献。假设视锥体内部或相交的对象称为S.然 
后，该算法背后的主要思想是使用启发式选择的函数来优化对象S 
的LOD的选择。具体地说，我们希望在约束XSCost （O，L）≤T， 
 （19.9）下最大化X S Benefit （O，L）（19.8），其中T是目标 
帧时间。换句话说，我们希望选择对象的细节级别，以便在所需的 
帧速率内为我们提供 “最佳图像”。接下来，我们描述如何估计成 
本和效益函数，然后我们提出上述方程的优化算法。成本函数和收 
益函数都难以定义，因此它们在所有情况下都可以工作。可以通过 
使用不同的观察参数对LOD的渲染进行多次定时来估计成本函数。 
有关不同的福利功能，请参见第 19.9.2节。在实践中，物体的 BV 
的投影面积可以作为效益函数。最后，我们将讨论如何选择场景中 
对象的细节级别。首先，我们注意到以下情况：对于某些视点，场 
景可能过于复杂，无法跟上所需的帧速率。为了解决这个问题，我 
们可以为866定义LOD19.加速算法在每个对象的最低细节级别算 
法，这只是一个没有基元的对象 - 即，我们避免渲染对象[508]。 
使用这个技巧，我们只渲染最重要的对象并跳过不重要的对象。要 
为场景选择 “最佳”LOD，必须在公式 19.9所示的约束下优化公式 
19.8。这是NP完全问题，这意味着要正确解决它，唯一要做的就 
是测试所有不同的组合并选择最佳组合。对于任何类型的算法来说， 
这显然是不可行的。一种更简单，更可行的方法是使用贪心算法， 
该算法试图最大化每个对象的Value =Benefit （O，L）/Cost （O， 
----------------------- Page 917-----------------------
L）。该算法处理视锥体内的所有对象，并选择以降序呈现对象，即 
首先具有最高值的对象。如果对象具有多个 LOD的相同值，则选择 
并呈现具有最高益处的LOD。这种方法给出了最大的收益。对于视 
锥体内的n个对象，算法在O （nlogn）时间运行，并且它产生的 
解决方案至少是最好的[507，508]。还可以利用帧到帧的一致性来 
加速值的排序。有关 LOD管理以及 LOD管理和门户剔除相结合的 
更多信息可以在 Funkhouser的博士论文[507]中找到。Maciel和 
Shirley [1097]将 LOD与冒名顶替者结合起来，并呈现用于渲染室 
外场景的近似恒定时间算法。一般的想法是使用对象的不同表示（例 
如，一组LOD和分层冒名顶替者）的层次结构。然后以某种方式遍 
历树以在给定一定时间的情况下给出最佳图像。Mason和 Blake 
[1134]提出了一种增量分层 LOD选择算法。同样，对象的不同表示 
可以是任意的。埃里克森等人。[441]呈现细节的层次级别（HLOD）。 
使用这些，场景也可以以恒定的帧速率渲染，或者渲染使得渲染错 
误是有界的。与此相关的是渲染功率预算。王等人。[1843]提出了 
一种优化框架，其选择用于降低功率使用的良好参数，这对于移动 
电话和平板电脑是重要的。与时间关键渲染相关的是另一组适用于 
静态模型的技术。当相机不移动时，将呈现完整模型，并且累积缓 
冲可用于抗锯齿，景深和柔和阴影，并具有渐进式更新。然而，当 
相机移动时，可以降低所有对象的细节水平，并且可以使用细节剔 
除来完全剔除小物体以便满足特定帧速率。19。10渲染大场景到目 
前为止，暗示要渲染的场景适合计算机的主存储器。情况可能并非 
----------------------- Page 918-----------------------
总是如此。例如，某些控制台仅具有8GB的内部存储器，而某些 
游戏世界可能包含数百GB的数据。因此，我们提出了19.10的流 
和转码方法。渲染大场景867纹理，一些通用流技术，最后是地形 
渲染算法。请注意，这些方法几乎总是与本章前面所述的剔除技术 
和详细程度方法相结合。19.10.1虚拟纹理和流媒体想象一下，您想 
要使用具有令人难以置信的大分辨率的纹理，以便能够渲染巨大的 
地形数据集，并且这个纹理太大，以至于它不适合GPU内存。作为 
示例，游戏 RAGE中的一些虚拟纹理具有128k×128k的分辨率， 
这将消耗64GB的GPU存储器[1309]。当CPU上的内存有限时， 
操作系统使用虚拟内存进行内存管理，根据需要将数据从驱动器交 
换到CPU内存[715]。此功能是稀疏纹理[109,248]提供的功能，可 
以分配巨大的虚拟纹理，也称为巨型纹理。这些技术集有时称为虚 
拟纹理或部分驻留纹理。应用程序确定每个mipmap级别的哪些区 
域 （图块）应驻留在GPU内存中。磁贴通常为64kB，其纹理分辨 
率取决于纹理格式。这里，我们提出虚拟纹理和流媒体技术。关于 
使用 mipmapping的高效纹理系统的关键观察是所需的纹理像素 
的数量理想地应该与正被渲染的最终图像的分辨率成比例，而与纹 
理本身的分辨率无关。因此，我们只要求可见的纹素位于物理GPU 
内存中，与整个游戏世界中的所有纹素相比，这是一个相当有限的 
集合。主要概念如图 19.39所示，其中整个mipmap链在虚拟和物 
理内存中分为多个区块。这些结构有时被称为虚拟mipmap或剪贴 
图[1739]，其中后一术语指的是较大的mipmap的较小部分被剪切 
----------------------- Page 919-----------------------
掉以供使用。由于物理内存的大小远小于虚拟内存，因此只有一小 
部分虚拟纹理贴片可以放入物理内存中。几何体在虚拟纹理中使用 
全局uv参数化，并且在像素着色器中使用这些uv坐标之前，需要 
将它们转换为指向物理纹理存储器的纹理坐标。这可以使用GPU支 
持的页表 （如图 19.39所示）或间接纹理 （如果在GPU上的软件中 
完成）来完成。NintendoGameCube中的GPU具有虚拟纹理支 
持。最近，PLAYSTATION4，Xbox One和许多其他GPU都支持 
硬件虚拟纹理。当瓦片被映射并且未映射到物理存储器时，需要使 
用正确的偏移来更新间接纹理。使用巨大的虚拟纹理和小的物理纹 
理效果很好，因为远程几何只需要将几个更高级别的mipmap图块 
加载到物理内存中，而靠近相机的几何图形可以加载一些较低级别 
的mipmap图块。请注意，虚拟纹理可用于从磁盘流式传输巨大纹 
理，但也可用于稀疏阴影映射[241]。868 19.加速算法页表物理纹 
理虚拟纹理 mipmap图19.39。在虚拟纹理中，具有其mipmap 
层级的大虚拟纹理被划分为（例如）每个128×128像素的区块（左）。 
只有一小部分（在这种情况下为3×3瓦片）可以放入物理内存（右）。 
为了找到虚拟纹理贴片的位置，需要从虚拟地址到物理地址的转换， 
这是通过页面表完成的。请注意，为了减少混乱，并非物理内存中 
的所有切片都具有来自虚拟纹理的箭头。（伊朗巴兹曼火山的图像 
纹理。来自美国宇航局的 “可见地球”项目。）由于物理内存有限， 
所有使用虚拟纹理的引擎都需要一种方法来确定哪些区块应该驻 
留，即位于物理内存中，哪些不应该。有几种这样的方法。Sugden 
----------------------- Page 920-----------------------
和 Iwanicki[1721]使用反馈渲染方法，其中第一个渲染过程写出了 
知道片段将访问哪个纹理图块所需的所有信息。完成该传递后，将 
纹理读回CPU并进行分析以找到所需的块。将不驻留的切片读取并 
映射到物理内存，并且不需要物理内存中不需要的切片。他们的方 
法不适用于阴影，反射和透明度。但是，屏幕门技术（第 5.5节） 
可以用于透明效果，效果相当好。vanWaveren和 Hart[1855]也 
使用反馈渲染。请注意，这样的传递可以是单独的渲染过程，也可 
以与z-prepass组合。当使用单独的通道时，可以使用仅80×60 
像素的分辨率作为近似，以减少处理时间。Hollemeersch等。[761] 
使用计算传递而不是将反馈缓冲区读回CPU。结果是在GPU上创 
建的紧凑的图块标识符列表，并发送回CPU进行映射。借助GPU 
支持的虚拟纹理，驱动程序负责创建和销毁资源，映射和取消映射 
磁贴，并确保物理分配由虚拟分配支持[1605]。利用GPU-硬件虚 
拟纹理，除了过滤后的值（对于驻留图块），稀疏纹理查找返回指 
示相应图块是否驻留的代码[1605]。借助软件支持的虚拟纹理，所 
有这些任务都会落在开发人员身上。我们参考vanWaveren的报 
告，了解有关该主题的更多信息[1856]。19.10。渲染大场景869 
图19.40。在DOOM （2016）中使用纹理流访问大型图像数据库 
的高分辨率纹理映射。 （图片来自游戏 “DOOM”，由idSoftware 
提供。）为了确保一切都符合物理记忆，vanWaveren调整全局纹 
理 LOD偏差，直到工作集适合[1854]。此外，当只有更高级别的 
mipmap图块可用时，需要使用更高级别的mipmap图块，直到更 
----------------------- Page 921-----------------------
低级别的mipmap图块变为可用。在这种情况下，可以立即升级和 
使用更高级别的mipmap图块，然后可以随时间混合新图块以在其 
变得可用时进行平滑过渡。Barb[99]总是加载小于或等于64kB的 
所有纹理，因此，如果尚未加载更高分辨率的mipmap级别，则总 
是可以进行一些纹理化，尽管质量较低。他使用离线反馈渲染为各 
种位置预先计算每个 mipmap级别在标称纹理和屏幕分辨率下为 
每种材质覆盖多少立体角度。在运行时，此信息将流入并调整为具 
有该材质的每个纹理的分辨率和最终屏幕分辨率。这产生每个纹理 
的每个纹理映射的重要性值。然后将每个重要性值除以相应的 
mipmap级别中的纹素数量，这产生合理的最终度量，因为即使纹 
理被细分为更小的，相同映射的纹理，它也是不变的。有关更多信 
息，请参阅 Barb的演示文稿[99]。示例渲染如图 19.40所示。 
Widmark [1881]描述了如何将流式传输与程序性纹理生成相结合， 
以获得更多样化和更详细的纹理。Chen扩展了Widmark的方案， 
使纹理处理的数量级更大[259]。87019。加速算法分析fetch分配 
unmap转码 GPU 内存缓存光存储或硬盘磁盘驱动器缓存映射图 
19.41。一种使用虚拟纹理和转码的纹理流系统。（vanvanren和 
Hart[1855]之后的插图。）19.10.2纹理转码为了使虚拟纹理系统 
更好地工作，它可以与转码相结合。这是从磁盘读取通常采用可变 
速率压缩方案（如JPEG）压缩的图像，对其进行解码，然后使用 
GPU支持的纹理压缩方案之一对其进行编码的过程（第6.2.6节）。 
一个这样的系统如图 19.41所示。反馈渲染过程的目的是确定当前 
----------------------- Page 922-----------------------
帧需要哪些块，以及第19.10节中描述的任一方法。这里可以使用 
1。获取步骤通过存储层次结构从光存储或硬盘驱动器（HDD）， 
通过可选的磁盘高速缓存，然后通过由软件管理的存储器高速缓存 
获取数据。取消映射是指解除分配常驻磁贴。当读取新数据时，它 
将被转码并最终映射到新的常驻磁贴。使用代码转换的优点是当纹 
理数据存储在磁盘上时可以使用更高的压缩比，并且当通过纹理采 
样器访问纹理数据时使用GPU支持的纹理压缩格式。这需要快速解 
压缩可变速率压缩格式和快速压缩到GPU支持的格式[1851]。还可 
以压缩已经压缩的纹理以进一步减小文件大小[1717]。这种方法的 
优点是，当从磁盘读取纹理并解压缩时，它已经处于可由GPU消耗 
的纹理压缩格式中。具有免费源代码的crunch库[523]使用类似的 
方法并达到每个纹素 1-2位的结果。有关示例，请参见图 19.42。 
后继，称为基础，是一种专有格式，具有块的可变位压缩，可快速 
转码为纹理压缩格式[792]。用于压缩的快速方法可用于BC1/ BC4 
[1376]，BC6H/ BC7 [933,935,1259]和 PVRTC [934]。Sugden 
和 Iwanicki[1721]使用 Malvar的压缩方案[1113]的变体用于磁盘 
上的可变速率压缩方案。对于法线，他们达到了40：1的比率19.10。 
渲染大场景871图19.42。转码质量的插图。从左到右：原始的部 
分鹦鹉图像，放大眼睛的原始图像 （每像素24位），ETC压缩图像 
 （每像素4位）和碾压的 ETC图像（每像素 1.21位）。（使用Unity 
压缩的图像）sionratio，以及使用YCoCg变换的反照率纹理60： 
1 （在第197页的公式6.6中描述）。Khronos正致力于纹理的标 
----------------------- Page 923-----------------------
准通用压缩文件格式。当需要高质感质量并且纹理加载时间需要很 
小时，Olano等人。[1321]使用可变速率压缩算法将压缩纹理存储 
在磁盘上。纹理也在GPU 内存中压缩，直到需要它们为止，此时 
GPU使用自己的算法对它们进行解压缩，之后，它们以未压缩的形 
式使用。19.10。3常规流式传输在游戏或其他具有大于物理内存的 
模型的实时渲染应用程序中，例如，实际几何体，脚本，粒子和AI 
也需要流式传输系统。可以使用三角形，正方形或六边形的规则凸 
多边形平铺平面。因此，这些也是流式系统的常用构建块，其中每 
个多边形与该多边形中的所有资产相关联。如图 19.43所示。应该 
注意的是，正方形和六边形是最常用的[134,1522]，可能是因为它 
们具有比三角形更少的直接邻居。查看器位于图 19.43中的深蓝色 
多边形中，并且流式传输系统确保将直接邻居（浅蓝色和绿色）加 
载到内存中。这是为了确保周围的几何体可用于渲染，并确保当观 
察者移动到相邻的多边形时数据就在那里。请注意，三角形和正方 
形有两种类型的邻居：一种是共享边，另一种是只共享一个顶点。 
Ruskin [1522]使用六边形，每个都具有低分辨率和高分辨率几何 
LOD。由于低分辨率LOD的内存占用量很小，因此始终会加载整个 
世界的低分辨率 LOD。因此，只有高分辨率的LOD和纹理流入和 
流出内存。宾利[134]使用正方形，每个正方形覆盖 100×100平方 
米。高分辨率mipmap与其他资产分开流式传输。该系统使用 1-3 
个 LOD进行近中距离观察，然后使用烘焙冒充者进行远程观察。对 
于赛车游戏，Tector [1753]代替872 19.加速算法图 19.43。使用 
----------------------- Page 924-----------------------
三角形（左），正方形（中间）和六边形的规则多边形的二维平面 
的天花板 (right). The tiling is typically overlaid on a game 
world seen from above, and all assets inside a polygon are 
associated with that polygon. Assuming that the viewer is 
locatedinthedarkbluepolygons,the neighboringpolygons’ 
assets are loaded as well. loads data along the racetrack as 
the car advances. He stores data compressed using the zip 
format on disk and loads blocks into a compressed software 
cache. The blocks are then decompressed as needed and 
usedbythememoryhierarchiesoftheCPUandGPU.Insome 
applications,  it  may  be  necessary to  tile  the 
three-dimensional space, instead of just  using a 
two-dimensional tiling as described above. Note that the 
cube is the only regular polyhedron that also tiles 
three-dimensional space, so it is the natural choice for such 
applications. 19.10.4Terrain RenderingTerrain renderingisan 
important partof manygamesand applications,e.g.,Google 
Earth and the Cesium open-source engine for large world 
rendering [299, 300]. An example is shown in Figure 19.44. 
We describe several popular methods that perform well on 
currentGPUs.Itshouldbenotedthatanyofthesecanaddon 
fractal noise in order to provide high levels of detail when 
----------------------- Page 925-----------------------
zooming in on the terrain. Also, many systems procedurally 
generate the terrain on the fly when the game or a level is 
loaded.One such method isthe geometry clipmap [1078]. It 
is similar to texture clipmaps [1739] in that it uses a 
hierarchical structure related to mipmapping, i.e., the 
geometry is filtered into a pyramid of coarser and coarser 
levelstowardthetop.This isillustratedinFigure19.45.When 
rendering huge terrain data sets, only n ×n samples, i.e., 
heights, are cached in memory for each level around the 
viewer.When the viewer moves,thewindows in Figure 19.45 
moveaccordingly,and newdata are loadedand old possibly 
evicted. To avoid cracks between levels, a transition region 
between every two successive levels is used. In such a 
transition level, both geometry and textures are smoothly 
interpolated intothe next coarser level.This is implemented 
in vertex and pixel shaders. Asirvatham and Hoppe [82] 
present an efficient GPU implementation where the terrain 
dataarestoredasvertextextures.Thevertex shaderaccesses 
these in order to obtain the height of the terrain. Normal 
mapscan 19.10. Rendering LargeScenes 873 Figure 19.44.A 
50 cm terrain and 25 cm imagery of Mount Chamberlin 
captured by airborne photogrammetry. (Image courtesy of 
----------------------- Page 926-----------------------
Cesium and Fairbanks Fodar.) be usedto augment the visual 
detail on the terrain, and when zooming in closely, Losasso 
and Hoppe [1078] also add fractal noise displacement for 
further details. See Figure 19.46for an example. Gollent uses 
a variant of geometry clipmaps in The Witcher 3 [555]. 
Pangerl [1348] and Torchelsen et al. [1777] give related 
methods for geometry clipmaps that also fit well with the 
GPU’s capabilities. coarsest level0 finest level Figure 19.45. 
Left: the geometry clipmap structure, where an equal-size 
squarewindow iscachedineach resolutionlevel.Right:atop 
view of the geometry, where the viewer is in the middle 
purple region. Note that the finest level renders its entire 
square, while the others are hollow inside. (Illustration after 
Asirvatham and Hoppe[82].)874 19.AccelerationAlgorithms 
Figure 19.46. Geometry clipmapping. Left: wireframe 
rendering where the different mipmap levels clearly are 
visible. Right: the blue transition regions indicate where 
interpolationbetweenlevelsoccurs.(Imagesgeneratedusing 
Microsoft ’ s  “Rendering of Terrains Using Geometry 
Clipmaps” program.)Severalschemesfocusoncreatingtiles 
and rendering them. One approach is that the heightfield 
arrayisbrokenupintotilesof,say, 17×17vertices each. Fora 
----------------------- Page 927-----------------------
highly detailed view, a single tile can be rendered instead of 
sending individual triangles or small fans to the GPU. A tile 
can have multiple levelsofdetail. Forexample, byusingonly 
everyothervertex ineachdirection,a9×9tilecanbeformed. 
Usingeveryfourthvertex givesa 5 × 5tile, every eightha 2 
× 2,andfinallythefour cornersa 1 × 1tile oftwotriangles. 
Notethattheoriginal17 × 17vertex buffercanbestoredon 
theGPUandreused;onlyadifferentindexbufferneedsto be 
provided to change the number of triangles rendered. A 
method using this data layout is presented next. Another 
method for rendering large terrain rapidly on the GPU is 
called chunked LOD [1797]. The idea is to represent the 
terrain using ndiscrete levelsofdetail,where eachfiner LOD 
is split 4× compared to its parent, as illustrated in Figure 
19.47. This structure is then encoded in a quadtree and 
traversedfromthe rootfor rendering.Whena nodeisvisited, 
itwill berenderedifitsscreen-spaceerror(whichisdescribed 
next) is belowa certain pixel-errorthreshold, τ . Otherwise, 
eachofthefour childrenarevisited recursively.This resultsin 
better resolution where needed, for example, close to the 
viewer. Ina moreadvancedvariant, terrain quads are loaded 
from disk as needed [1605, 1797].The traversal is similar to 
----------------------- Page 928-----------------------
the method described above, except that the children are 
only visited recursively if they are already loaded into 
memory (from disk). Ifthey are not loaded,they are queued 
for loading, and the current node is rendered. Ulrich [1797] 
computesthescreen-spaceerrorass =.w2dtan  2,(19.10) 
19.10. Rendering Large Scenes 875 Figure 19.47. Chunked 
LOD representation of terrain. (Images courtesy of Thatcher 
Ulrich.)where w isthe width of the screen, d is the distance 
fromthecameratotheterraintile, θ isthe horizontalfieldof 
view inradians,and.isageometricerrorinthesameunitsas 
d. For the geometric error term, the Hausdorff distance 
betweentwo meshesisoftenused[906,1605].Foreachpoint 
on the original mesh, find its closest point on the simplified 
mesh, and call the smallest of these distances d1. Now 
performthe same procedurefor each pointonthe simplified 
mesh, finding the closest point on the original, and call the 
smallest of the distances d2. The Hausdorff distance is . = 
max(d1, d2). This is illustrated in Figure 19.48. Notethat the 
closest point to the simplified mesh from o is s, while the 
closest point to the original mesh from s is a, which is the 
reason why the measurement must be done in both 
combinations, from the original to the simplified mesh and 
----------------------- Page 929-----------------------
vice versa. Intuitively, the Hausdorff distance is the error 
when using a simplified mesh instead of the original. If an 
applicationcannotaffordtocomputethe Hausdorffdistance, 
one may use constants that are manually adjusted for each 
simplification, or find the errors during simplification [1605]. 
To avoid popping effects when switching from one LOD to 
another,Ulrich[1797]proposesasimplemorphingtechnique, 
where a vertex (x, y, z) from a high-resolution tile is linearly 
interpolated with a vertex (x, y′, z), which is approximated 
from the parent tile (e.g., using bilinear interpolation). The 
linear interpolation factor is computed as 2sτ . 1, which is 
clamped to [0, 1]. Notethat only the higher-resolutiontile is 
needed during morphing, since the next-lower-resolution 
tile’svertices arealso inthe higher-resolutiontile. soriginal 
mesh o simplified mesh Hausdorff distance a Figure 19.48. 
The Hausdorff distance between an original mesh and a 
simplifiedmesh.(IllustrationafterSellersetal. [1605].)876 19. 
Acceleration Algorithms Figure 19.49.Crack avoidance using 
the chunked LOD system by Strugar [1720]. The top left 
shows a higher-resolution tile that is morphed into a 
lower-resolution terrain tile at the top right. In between, we 
show two interpolated and morphed variants. In reality,this 
----------------------- Page 930-----------------------
occurs in a smooth way as the LOD is changed, which is 
shown in the screen shot at the bottom. (Bottom image 
generated by a program by Filip Strugar [1720].) Heuristics, 
such asthe one in Equation 19.10,can beusedto determine 
the levelofdetail usedfor eachtile.The mainchallengefora 
tilingschemeiscrackrepair.Forexample,ifonetileisat33 × 
33 resolution and its neighbor is at 9 × 9, there will be 
cracking along the edge where they meet. One corrective 
measureisto removethe highlydetailedtriangles along the 
edgeandthenformsetsoftrianglesthat properlybridgethe 
gap between the two tiles [324, 1670]. Cracks will appear 
when two neighboring areas have different levels of detail. 
Ulrich describes a method using extra ribbon geometry, 
which isa reasonablesolution if τ issetto lessthan 5pixels. 
Cozzi and Bagnell [300] instead fill the cracks using a 
screen-space post-processpass,wherethefragments around 
thecrack, butnotinthecrack,areweighted usingaGaussian 
kernel. Strugar [1720] has an elegant way of avoiding cracks 
without screen-space methods or extra geometry. This is 
showninFigure19.49andcan beimplementedwith asimple 
vertex shader. Forimprovedperformance,Sellersetal. [1605] 
combinechunked LODwithview frustum cullingand horizon 
----------------------- Page 931-----------------------
culling. Kangetal. [852]presentaschemesimilartochunked 
LOD, with the largest difference being that they use 
GPU-based tessellation to tessellate a node and make sure 
that the edge tessellation factors match up to avoid cracks. 
They  also  show  how  geometry  images  with 
feature-preserving maps can be 19.10. Rendering Large 
Scenes877 Figure19.50.A restrictedquadtreeofterraintiles, 
inwhich eachtile can neighbortiles at mostone levelhigher 
or lowerinlevelofdetail. Eachtile has5 × 5vertices, except 
in the upper left corner, where there are 2 × 2 
higher-resolutiontiles.The restoftheterrain isfilled bythree 
lower-resolution tiles. On the left, there are vertices on the 
edges of the upper left tile that do not match ones on the 
adjacentlower-resolutiontiles,whichwould resultincracking. 
Onthe right,the more-detailedtile’sedgesare modifiedto 
avoidthe problem. Eachtile is renderedina single draw call. 
(IllustrationafterAndersson [40].)usedto renderterrainwith 
overhangs, which heightfield-based terrain cannot handle. 
Strugar [1720] presents an extension of the chunked LOD 
scheme, with better and more flexible distribution of the 
triangles. In contrast to Ulrich’s method, which uses a 
per-node LOD, Strugar uses morphing per vertex with 
----------------------- Page 932-----------------------
individual levels of detail. While he uses only distance as a 
measure for determining LOD, other factors can be used as 
well, e.g., how much depth variation there is in the vicinity, 
whichcangeneratebettersilhouettes.Thesourceterraindata 
are typically represented by uniform heightfield grids. 
View-independent methodsof simplification can be used on 
thesedata,asseeninFigure16.16on page705.The modelis 
simplified until some limiting criterion is met [514]. Small 
surface details can be captured by color or bump map 
textures.The resultingstaticmesh,oftencalledatriangulated 
irregular network (TIN), is a useful representation when the 
terrain area issmalland relativelyflat invarious areas [1818]. 
Andersson [40]usesa restrictedquadtreeto bridgethe gaps 
and lower the total number of draw calls needed for large 
terrains. Instead of a uniform grid of tiles rendered at 
different resolutions,heusesaquadtreeoftiles. Eachtile has 
the same base resolution of 33 × 33, but each can cover a 
different amount of area.The ideaof a restrictedquadtree is 
that eachtile’s neighborscan be nomorethan one levelof 
detail different. See Figure 19.50.This restriction meansthat 
there are a limited number of situations in which the 
resolutionsofthe neighboringtiles differ. Insteadofcreating 
----------------------- Page 933-----------------------
gaps and having additional index buffers rendered to fill 
these gaps,the idea isto store all the possible permutations 
of index buffers that create a tile that also include the gap 
transition triangles. Each index buffer is formed by 
full-resolution 878 19.Acceleration Algorithms Figure 19.51. 
Terrain renderingat many levelsofdetail inaction. (Courtesy 
of DICE,c 2016 ElectronicArts Inc.)edges (33vertices on an 
edge) and lower levelof detail edges (17vertices only, since 
the quadtreeisrestricted).An exampleofthis modernterrain 
renderingisshowninFigure19.51.Widmark [1881]describes 
a complete terrain rendering system, which is used in the 
Frostbite2engine.Ithasusefulfeatures,suchasdecals,water, 
terrain decoration, composition of different materialshaders 
usingartist-generated or procedurallygenerated masks [40], 
and proceduralterraindisplacement.A simpletechniquethat 
can beusedfor ocean renderingisto employa uniformgrid, 
transformedto cameraspaceeachframe [749].This isshown 
in Figure 19.52.Bowles [186]providesmanytricks on howto 
overcome certain quality problems. Inadditionto the terrain 
techniques above, which tend to reducethe size of the data 
setthat needsto bekeptinmemoryatanytime,onecanalso 
use compression viewer Figure 19.52. Left: a uniform grid. 
----------------------- Page 934-----------------------
Right: the grid transformed to camera space. Note how the 
transformed grid allows higher detail closer to the viewer. 
19.10. Rendering Large Scenes 879 techniques. Yusov [1956] 
compresses the vertices using the quadtree data structure, 
with a simple prediction scheme, where only the differences 
are encoded (using few bits). Schneider and Westermann 
[1573] use a compressed format that is decoded by the 
vertex shader and explore geomorphing between levels of 
detail, while maximizing cache coherency. Lindstrom and 
Cohen [1051] use a streaming codec with linear prediction 
and residual encoding for lossless compression. In addition, 
they use quantization to provide further improved 
compression rates, though the results are then lossy. 
Decompression can be done using the GPU, with 
compression rates from 3 : 1 up to 12 : 1. There are many 
other approaches to terrain rendering. Kloetzli [909] uses a 
customcomputeshaderinCivilizationVtocreateanadaptive 
tessellation for terrain, which is then fed to the GPU for 
rendering.Anothertechnique isto usetheGPU’stessellator 
to handlethe tessellation [466]perpatch. Notethat manyof 
thetechniquesusedforterrainrenderingcanalsobeusedfor 
water rendering. For example, Gonzalez- Ochoa and Holder 
----------------------- Page 935-----------------------
[560] used a variant of geometry clipmaps in Uncharted 3 , 
adapted for water. They avoid T-junctions by dynamically 
adding triangles between levels. Research on this topic will 
continue asthe GPU evolves. Further Readingand Resources 
Thoughthefocus iscollisiondetection, Ericson’sbook[435] 
has relevant materialabout forming and usingvarious space 
subdivision schemes. There is a wealth of literature about 
occlusion culling.Two good starting placesfor earlywork on 
algorithms are the visibility surveys by Cohen-Or et al. [277] 
and Durand [398]. Aila and Miettinen [13] describe the 
architecture of a commercial culling system for dynamic 
scenes. Nie.ner et al. [1283] present a survey of existing 
methods for backfacing-patch, view frustum, and occlusion 
culling of displaced subdivision surfaces. A worthwhile 
resourcefor informationonthe useof LODsisthe bookLevel 
ofDetailfor3DGraphicsbyLuebkeetal.[1092].Dietrichetal. 
[352]presentanoverviewofresearchintheareaofrendering 
massive models. Another nice overview of massive model 
renderingisprovidedbyGobbettietal. [547].The SIGGRAPH 
course by Sellers et al. [1605]is a more recent resourcewith 
excellent material. Cozzi and Ring’s book [299] presents 
techniques for terrain rendering and large-scale data set 
----------------------- Page 936-----------------------
management, along with methods dealing with precision 
issues.TheCesium blog[244]providesmanyimplementation 
details and further acceleration techniques for large world 
and terrain rendering. Chapter 20 Efficient Shading “Never 
put off till to-morrow what you can do the day after 
to-morrowjust aswell.” —MarkTwain Forsimple scenes— 
relatively little geometry, basic materials, a few lights—we 
can usethe standard GPU pipelineto renderimageswithout 
concerns about maintaining frame rate. Only when one or 
more elements become expensive do we need to use more 
involved techniques to rein in costs. Inthe previous chapter 
we focused on cullingtriangles and meshesfrom processing 
further downstream. Herewe concentrate on techniques for 
reducing costs when evaluating materials and lights. For 
many of these methods, there is an additional processing 
cost,withthe hopebeingthatthisexpenseismadeupbythe 
savings obtained. Others trade off between bandwidth and 
computation, often shifting the bottleneck. As with all such 
schemes, which is best depends on your hardware, scene 
structure, and many other factors. Evaluating a pixel shader 
for a materialcan beexpensive.This cost can be reduced by 
various shader level of detail simplification techniques, as 
----------------------- Page 937-----------------------
noted in Section 19.9. When there are several light sources 
affecting a surface,two different strategiescan beused.One 
is to build a shader that supports multiple light sources, so 
that only a single pass is needed. Another is multi-pass 
shading,wherewe createasimpleonelight pixelshaderfora 
lightandevaluateit,addingeachresulttotheframebuffer.So, 
for three lights, we would draw the primitive three times, 
changing the light for each evaluation. This second method 
might be more efficient overall than a singlepass system, 
becauseeach shader used is simpler and faster. Ifa renderer 
has many different types of lights, a one-pass pixel shader 
must include them all and test for whether each is used, 
makingfor a complex shader. InSection 18.4.5we discussed 
avoiding unnecessary pixelshaderevaluations byminimizing 
oreliminatingoverdraw. Ifwe canefficientlydeterminethata 
surface does not contribute to the final image, then we can 
save the time spent shading it. One technique performs a 
z-prepass, where the opaque geometry is renderedand only 
z-depths are written. The geometry is then rendered again 
fully shaded,andthezbuffer fromthefirst passcullsawayall 
fragments that are not visible. This type of 881 882 20. 
EfficientShading pass isan attemptto decouple the process 
----------------------- Page 938-----------------------
of finding what geometry is visible from the operation of 
subsequently shadingthat geometry.This ideaof separating 
these two processes is an important concept used 
throughout this chapter, and is employed by several 
alternative rendering schemes. For example, a problemwith 
using a z-prepass is that you have to render the geometry 
twice. This is an additional expense compared to standard 
rendering, and could cost more time than it saves. If the 
meshes are formed via tessellation, skinning, or some other 
involved process, the cost of this added pass can be 
considerable [992, 1177]. Objects with cutout alpha values 
need to have their texture’s alpha retrieved each pass, 
adding to the expense, or must be ignored altogether and 
renderedonly inthe second pass,riskingwasted pixelshader 
evaluations. For these reasons, sometimes only large 
occluders (in screen or world space) are drawn in this initial 
pass. Performingafull prepass mayalso be needed byother 
screen-space effects, such as ambient occlusion or reflection 
[1393].Someofthe accelerationtechniques presentedinthis 
chapter require an accurate z-prepass that is then used to 
help cull lists of lights. Even with no overdraw, a significant 
expense can arise from a large number of dynamic lights 
----------------------- Page 939-----------------------
evaluatedfor avisible surface. Sayyou have 50 lightsources 
in a scene. A multi-pass system can render the scene 
successfully, but at the cost of 50 vertex and shader passes 
perobject.Onetechniqueto reducecostsisto limittheeffect 
of each local lightto a sphere of some radius,cone of some 
height, or other limited shape [668, 669, 1762, 1809]. The 
assumption is that each light ’ s contribution becomes 
insignificant past a certain distance. For the rest of this 
chapter,wewill referto lights’ volumes asspheres,withthe 
understanding that other shapes can be used. Often the 
light’s intensity is used as the sole factor determining its 
radius. Karis [860] discusses how the presence of glossy 
specular materials will increase this radius, since such 
surfacesaremorenoticeablyaffected bylights.Forextremely 
smooth surfaces this distance may go to infinity, such that 
environment mapsorothertechniques may needto beused 
instead.A simple preprocess isto createfor each mesha list 
of lights that affects it. We can think of this process as 
performingcollisiondetectionbetweenameshandthe lights, 
findingthosethat mayoverlap[992].Whenshadingthe mesh, 
we use this list of lights,thus reducingthe number of lights 
applied. There are problems with this type of approach. If 
----------------------- Page 940-----------------------
objectsor lightsmove,these changesaffectthe composition 
of the lists. For performance, geometry sharing the same 
material is often consolidated into larger meshes (Section 
18.4.2),which could cause a single meshto havesome or all 
of the lights in a scene in its list [1327, 1330]. That said, 
meshes can be consolidated and then split spatially to 
provide shorter lists [1393]. Another approach is to bake 
static lightsintoworld-space data structures. Forexample, in 
the lightingsystemforJust Cause2,aworld-spacetop-down 
gridstoreslightinformationforascene.Agridcellrepresents 
a4 meter × 4 meterarea. Eachcell isstoredasatexel inan 
RGBα texture,thus holdinga listofuptofour lights.When a 
pixel is rendered, the list in its area is retrieved and the 
relevantlightsareapplied[1379].Adrawbackisthatthereisa 
fixed storage limit to the number of 20.1. Deferred Shading 
883 Figure 20.1. A complicated lighting situation. Note that 
the small light on the shoulder and every bright dot on the 
building structure are light sources. The lights in the far 
distance in the upper right are light sources, which are 
renderedaspointspritesatthatdistance.(Imagefrom “Just 
Cause 3,” courtesy of Avalanche Studios [1387].) lights 
affecting a given area. While potentially useful for carefully 
----------------------- Page 941-----------------------
designed outdoor scenes, buildingswith a numberof stories 
can quickly overwhelm this storage scheme. Our goal is to 
handle dynamic meshes and lights in an efficient way. Also 
important is predictable performance,where a small change 
inthevieworscenedoesnotcausealargechangeinthecost 
of renderingit.Some levelsin DOOM(2016) have300visible 
lights [1682]; some scenes in Ashes of the Singularity have 
10,000. See Figure 20.1 and Figure 20.15 on page 913. In 
some renderers a large number of particles can each be 
treated as small light sources. Other techniques use light 
probes (Section 11.5.4) to illuminate nearby surfaces, which 
can bethought ofasshort-range lightsources.20.1 Deferred 
Shading So far throughout this book we have described 
forward shading, where each triangle is sent down the 
pipelineand,attheendofitstravels,theimageonthescreen 
is updatedwith its shaded values. The idea behind deferred 
shading is to perform all visibility testing and surface 
propertyevaluations beforeperformingany materiallighting 
computations.Theconceptwasfirstintroducedinahardware 
architecture in 1988 [339], later included as a part of the 
experimental PixelFlowsystem [1235],and usedas an offline 
software solution to help produce non-photoreal styles via 
----------------------- Page 942-----------------------
image processing [1528].Calver’s extensive article [222] in 
mid-2003laysoutthe basic88420. EfficientShadingideasof 
using deferred shading on the GPU. Hargreaves and Harris 
[668, 669] and Thibieroz [1762] promoted its use the 
followingyear, at atimewhen the abilityto write to multiple 
render targets was becoming more widely available. In 
forwardshadingwe performasinglepassusingashaderand 
a mesh representing the object to compute the final image. 
The pass fetches material properties —              constants, 
interpolatedparameters,orvalues intextures—thenappliesa 
set of lights to these values. The z-prepass method for 
forward rendering can be seen as a mild decoupling of 
geometry rendering and shading, in that a first geometry 
pass aims at only determining visibility, while all shading 
work, including material parameter retrieval, is deferred to a 
second geometry pass performed to shade all visible pixels. 
Forinteractiverendering,deferredshadingspecificallymeans 
that all material parameters associated with the visible 
objectsaregeneratedandstoredbyaninitialgeometry pass, 
then lightsareappliedto these storedsurfacevalues usinga 
post-process. Values saved in this first pass include the 
position(storedasz-depth), normal,texturecoordinates,and 
----------------------- Page 943-----------------------
various material parameters. This pass establishes all 
geometry and material information for the pixel, so the 
objects are no longer needed, i.e., the contribution of the 
models’ geometry has beenfully decoupled from lighting 
computations. Notethat overdraw can happen in this initial 
pass, the difference being that the shader’s execution is 
considerably less—transferring values to buffers—than that 
of evaluating the effect of a set of lights on the material. 
There is also less of the additional cost found in forward 
shading,wheresometimesnotallthe pixelsina2×2quadare 
inside a triangle’s boundaries but all must befully shaded 
[1393] (Section 23.8). This sounds like a minor effect, but 
imagine a mesh where each triangle covers a single pixel. 
Four fully shaded samples will be generated and three of 
these discarded with forward shading. Using deferred 
shading, each shader invocation is less expensive, so 
discarded samples have a considerably lower impact. The 
buffersusedto storesurface propertiesarecommonly called 
G-buffers[1528],shortfor “geometricbuffers.”Suchbuffers 
are also occasionally called deep buffers, though this term 
can also meana buffer storing multiplesurfaces (fragments) 
per pixel, so we avoid it here. Figure 20.2 shows the typical 
----------------------- Page 944-----------------------
contents of some G-buffers.A G-buffer can store anything a 
programmer wants it to contain, i.e., whatever is needed to 
complete the required subsequent lighting computations. 
Each G-buffer is a separate render target. Typically three to 
five render targets are used as G-buffers, but systems have 
gone as high as eight [134]. Having moretargets uses more 
bandwidth,which increasesthe chancethat this bufferisthe 
bottleneck.After the pass creating the G-buffers, a separate 
process is used to compute the effect of illumination. One 
methodisto applyeach lightone byone, usingthe Gbuffers 
to compute its effect. Foreach lightwe draw a screen-filling 
quadrilateral (Section 12.1) and access the G-buffers as 
textures [222, 1762]. At each pixel we can determine the 
location of the closest surface and whether it is in range of 
the light. Ifitis,we computethe effectofthe lightand place 
the resultinanoutputbuffer.Wedothisforeachlightinturn, 
adding its contribution via blending.At the end, we have all 
lights’ contributions applied. 20.1. Deferred Shading 885 
Figure20.2. Geometric buffersfor deferred shading, in some 
cases converted to colors for visualization. Left column, top 
to bottom: depth map, normal buffer, roughness buffer, and 
sunlight occlusion. Rightcolumn: texture color (a.k.a. albedo 
----------------------- Page 945-----------------------
texture), light intensity, specular intensity, and near-final 
image (without motion blur). (Images from “Killzone 2,” 
courtesy of Guerrilla BV [1809].) This process is about the 
mostinefficientwayto useG-buffers,sinceeverystoredpixel 
is accessed for every light, similar to how basic forward 
rendering applies all lightsto all surface fragments. Such an 
approachcanendupbeingslowerthanforwardshading,due 
to the extra cost of writing and readingthe G-buffers [471]. 
As a start 886 20. Efficient Shading on improving 
performance, we could determine the screen bounds of a 
lightvolume (asphere)and usethemto drawascreen-space 
quadrilateral that covers a smaller part of the image [222, 
1420, 1766]. In this way, pixel processing is reduced, often 
significantly. Drawing an ellipse representingthe sphere can 
further trim pixel processing that is outside the light’s 
volume [1122].We can also use the third screen dimension, 
z-depth. Bydrawinga roughsphere meshencompassingthe 
volume, we can trim the sphere’s area of effect further still 
[222].Forexample,ifthesphereishiddenbythedepthbuffer, 
thelight’svolumeisbehindtheclosestsurfaceandsohasno 
effect. To generalize, if a sphere’s minimum and maximum 
depthsata pixeldo notoverlapthe closest surface,the light 
----------------------- Page 946-----------------------
cannot affect this pixel. Hargreaves [668] and Valient [1809] 
discuss various options and caveats for efficiently and 
correctly determining this overlap, along with other 
optimizations. We will see this idea of testing for depth 
overlap betweenthe surface and the light used in several of 
thealgorithmsahead.Which ismostefficientdependsonthe 
circumstances. For traditional forward rendering, the vertex 
andpixelshaderprogramsretrieveeachlight’sandmaterial’ 
s parameters and compute the effect of one on the other. 
Forward shading needs either one complex vertex and pixel 
shaderthat coversall possiblecombinationsof materialsand 
lights, or shorter, specialized shaders that handle specific 
combinations.Longshaderswithdynamicbranchesoftenrun 
considerably moreslowly [414],soa largenumberofsmaller 
shaders can be moreefficient, butalso require morework to 
generateandmanage.Sinceallshadingfunctionsaredonein 
a single passwith forward shading, it is more likelythat the 
shaderwill needto changewhenthe nextobject isrendered, 
leading to inefficiency from swapping shaders (Section 
18.4.2). The deferred shading method of rendering allows a 
strong separation between lighting and material definition. 
Each shader is focused on parameter extraction or lighting, 
----------------------- Page 947-----------------------
but not both. Shorter shaders runfaster, both due to length 
and the ability to optimize them. The number of registers 
used in a shader determines occupancy (Section 23.3), a key 
factor in how many shader instances can be run in parallel. 
This decoupling of lighting and material also simplifies 
shader system management. For example, this split makes 
experimentation easy, as only one new shader needs to be 
addedto the systemfor a new lightor materialtype, instead 
ofonefor each combination [222,927].This is possiblesince 
materialevaluations aredone inthe first pass,and lightingis 
then applied to this stored set of surface parameters in the 
second pass. For single-pass forward rendering, all shadow 
maps usually must be available at the same time, since all 
lightsareevaluatedatonce.Witheachlighthandledfullyina 
single pass, deferred shading permits having only one 
shadow map in memory at a time [1809]. However, this 
advantage disappears with the more complex light 
assignmentschemeswe cover later,as lightsareevaluated in 
groups [1332, 1387]. Basic deferred shading supportsjust a 
single material shader with a fixed set of parameters, which 
constrains what material models can be portrayed. One way 
to support different material descriptions is to store a 
----------------------- Page 948-----------------------
material ID or mask per pixel in 20.1. Deferred Shading 887 
R8G8 B8A8 basecolor(sRGB8)world normal(RGB10)config 
(A8) metalness (R8) glossiness (G8) cavity (B8) aliased value 
(A8) velocity.xy (RGB8) velocity.z (A8) RT0 RT1 RT2 RT3 GI 
Figure20.3.AnexampleofapossibleG-bufferlayout,usedin 
Rainbow Six Siege. In addition to depth and stencil buffers, 
four render targets (RTs) are used as well. As can be seen, 
anythingcanbeputintothesebuffers.The “GI”fieldinRT0 
is “GInormalbias(A2).”(IllustrationafterElMansouri[415].) 
some given field. The shader can then perform different 
computations basedonthe G-buffercontents.This approach 
could also modify what is stored in the G-buffers, based on 
this IDor maskvalue [414,667,992, 1064]. Forexample, one 
material might use 32 bitsto store a second layer color and 
blendfactor inaG-buffer,while another mayusethese same 
bits to store two tangent vectors that it requires. These 
schemes entail using morecomplex shaders,which can have 
performance implications. Basic deferred shading has some 
other drawbacks. G-buffer video memory requirements can 
be significant, as can the related bandwidth costs in 
repeatedly accessing these buffers [856, 927, 1766].We can 
mitigate these costs by storing lower-precision values or 
----------------------- Page 949-----------------------
compressing the data [1680, 1809].An example is shown in 
Figure 20.3. In Section 16.6 we discussed compression of 
world-space data for meshes. G-buffers can contain values 
that are in world-space or screen-space coordinates, 
dependingontheneedsoftherenderingengine.Pesce[1394] 
discusses the trade-offs in compressing screen-space versus 
world-space normals for G-buffers and provides pointers to 
related resources. A world-space octahedral mapping for 
normals is a common solution, due to its high precisionand 
quickencodinganddecodingtimes.Two importanttechnical 
limitations of deferred shading involve transparency and 
antialiasing.Transparencyisnotsupportedinabasicdeferred 
shadingsystem,sincewecanstoreonlyonesurfaceperpixel. 
One solution is to use forward rendering for transparent 
objectsafterthe opaquesurfacesare renderedwith deferred 
shading. Forearly deferred systemsthis meantthat all lights 
in a scene had to be applied to each transparent object, a 
costly process,or other simplifications hadto be performed. 
As we will explore in the sections ahead, improved GPU 
capabilitieshaveledtothedevelopmentofmethodsthatcull 
lights for both deferred and forward shading. While it is 
possible to now store lists of transparent surfaces for pixels 
----------------------- Page 950-----------------------
[1575]and usea puredeferred approach,the norm isto mix 
deferred and forward shading as desired for transparency 
andothereffects [1680].Anadvantageofforward methodsis 
thatantialiasingschemessuchas MSAAareeasilysupported. 
Forward techniques need to store only N depth and color 
samples per pixel for N× MSAA. Deferred shading could 
store all N samples per element inthe G-buffers to perform 
antialiasing, but the increases in memory cost, fill rate, and 
computation make this approach expensive [1420]. To 
overcome this limitation, 888 20. Efficient Shading 
Shishkovtsov [1631] uses an edge detection method for 
approximating edge coverage computations. Other 
morphological post-processing methods for antialiasing 
(Section 5.4.2) can also be used [1387], as well as temporal 
antialiasing. Several deferred MSAA methods avoid 
computing the shade for every sample by detecting which 
pixelsortiles haveedgesinthem [43,990, 1064,1299,1764]. 
Only those with edges need to have multiple samples 
evaluated. Sousa [1681] builds on this type of approach, 
using stenciling to identify pixelswith multiple samples that 
need more complex processing. Pettineo [1407] describes a 
newer way to track such pixels, using a compute shader to 
----------------------- Page 951-----------------------
move edge pixels to a list in thread group memory for 
efficient stream processing. Antialiasing research by Crassin 
et al. [309] focuses on high-quality results and summarizes 
other researchinthis area.Their technique performsa depth 
andnormalgeometryprepassandgroupssimilarsubsamples 
together. They then generate Gbuffers and perform a 
statistical analysis ofthe bestvalue to usefor each group of 
subsamples. These depth-bounds values are then used to 
shadeeachgroupandthe resultsareblendedtogether.While 
as of this writing such processing at interactive rates is 
impracticalfor mostapplications,thisapproachgivesasense 
of the amount of computational power that can and will be 
broughtto bearon improving imagequality. Evenwith these 
limitations,deferred shading isa practical rendering method 
used in commercial programs. It naturally separates 
geometry from shading, and lighting from materials, 
meaningthateachelementcanbeoptimizedonitsown.One 
area of particular interest is decal rendering, which has 
implicationsfor any renderingpipeline.20.2 DecalRendering 
A decal is some design element, such as a picture or other 
texture, applied ontop of a surface. Decalsare often seen in 
video games in such forms as tire marks, bullet holes, or 
----------------------- Page 952-----------------------
player tags sprayed onto surfaces. Decals are used in other 
applicationsforapplyinglogos,annotations,orothercontent. 
For terrain systems or cities, for example, decals can allow 
artists to avoid obvious repetition by layering on detailed 
textures,orbyrecombiningvarious patternsindifferentways. 
A decalcan blendwiththe underlying materialinavariety of 
ways. Itmightmodifythe underlyingcolor butnotthe bump 
map,likeatattoo.Alternately, it mightreplacejust the bump 
mapping, such as an embossed logo does. It could define a 
different materialentirely,for example, placinga stickeron a 
car window. Multiple decals might be applied to the same 
geometry, such asfootprints on a path.A single decal might 
span multiple models, such as graffiti on a subway car’s 
surfaces. These variations have implicationsfor howforward 
and deferred shading systems store and process decals. To 
begin, the decal must be mapped to the surface, like any 
other texture. Since multiple texture coordinates can be 
stored at each vertex, it is possibleto binda few decals to a 
single surface. This approach is limited, since the number of 
valuesthat20.2.DecalRendering889canbesavedpervertex 
is relatively low. Each decal needs its own set of texture 
coordinates. A large number of small decals applied to a 
----------------------- Page 953-----------------------
surface would mean saving these texture coordinates at 
every vertex, even though each decal affects only a few 
triangles in the mesh. To render decals attached to a mesh, 
one approach isto havethe pixelshader sample every decal 
and blend one atop the next. This complicates the shader, 
and if the number of decals varies over time, frequent 
recompilation or other measures may be required. Another 
approach that keepsthe shader independentfrom the decal 
system is to render the mesh again for each decal, layering 
and blending each pass over the previous one. If a decal 
spansjust afewtriangles,aseparate,shorterindexbuffercan 
be created to renderjust this decal’s sub-mesh. One other 
decal methodisto modifythe material’stexture. Ifusedon 
just one mesh, as in a terrain system, modifyingthis texture 
providesasimple “setitandforgetit” solution[447].Ifthe 
materialtexture isusedonafewobjects,we needtocreatea 
newtexturewiththe materialanddecalcompositedtogether. 
This baked solution avoids shader complexity and wasted 
overdraw, but at the cost of texture management and 
memory use [893, 1393]. Rendering the decals separately is 
the norm,as different resolutionscanthen beappliedto the 
same surface, and the base texture can be reused and 
----------------------- Page 954-----------------------
repeated without needing additional modified copies in 
memory. These solutions can be reasonable for a 
computer-aided design package, where the user may add a 
single logo and little else. They are also used for decals 
applied to animated models, where the decal needs to be 
projectedbeforethedeformationsoitstretchesastheobject 
does. However, such techniques become inefficient and 
cumbersome for morethan a few decals.A popular solution 
for static or rigid objects is to treat the decal as a texture 
orthographically projected through a limited volume [447, 
893,936, 1391,1920].An oriented boxisplacedinthe scene, 
with the decal projected from one of the box faces to its 
oppositeface, likeafilm projector.See Figure20.4.The faces 
ofthe boxarerasterized,asawaytodrivethe pixelshader’s 
execution. Any geometry found inside this volume has the 
decalappliedoveritsmaterial.This isdone byconvertingthe 
surface’s depth and screen position into a location in the 
volume, which then gives a (u, v) texture coordinate for the 
decal. Alternately, the decal could be a true volume texture 
[888, 1380]. Decals can affect only certain objects in the 
volume byassigning IDs [900],assigning a stencil bit [1778], 
or relying on the rendering order. They are also often faded 
----------------------- Page 955-----------------------
or clamped to the angle of the surface and the projection 
direction,to avoid havinga decal stretch or distortwherever 
the surface becomes more edge-on [893]. Deferred shading 
excels at rendering such decals. Instead of needing to 
illuminate and shade each decal, as with standard forward 
shading,the decal’s effect can beappliedto the G-buffers. 
For example, if a decal of a tire’s tread mark replaces the 
shading normals on a surface, these changes are made 
directlyto the appropriate Gbuffer. Each pixelis latershaded 
by lights with only the data found in the G-buffers, so 
avoiding the shading overdraw that occurs with forward 
shading [1680].Since890 20. EfficientShading Figure20.4.A 
boxdefines a decal projection,and a surface insidethat box 
has the decal applied to it. The box is shown with 
exaggeratedthickness to displaythe projectorand its effect. 
Inpracticethe boxismadeasthin andtighttothe surfaceas 
possible, to minimize the number of pixels that are tested 
during decal application.the decal’seffectcan becaptured 
entirely by G-buffer storage, the decal is then not needed 
during shading. This integration also avoids a problem with 
multi-pass forward shading, that the surface parameters of 
one pass may need to affect the lighting or shading of 
----------------------- Page 956-----------------------
another pass [1380].This simplicitywas a majorfactor inthe 
decision to switch from forward to deferred shading for the 
Frostbite2engine,forexample [43].Decalscanbethoughtof 
asthe sameas lights,inthat bothareapplied byrenderinga 
volume of space to determine its effect on the surfaces 
enclosed.As we will see in Section 20.4, by usingthis fact, a 
modified form of forward shading can capitalize on similar 
efficiencies, along with other advantages. Lagarde and de 
Rousiers [960] describe several problems with decals in a 
deferred setting. Blending is limited to what operations are 
availableduringthe mergestageinthe pipeline[1680].Ifthe 
material and decal both have normal maps, achieving a 
properly blended result can be difficult, and harder still if 
some bump texture filtering technique is in use [106, 888]. 
Black or white fringing artifacts can occur, as described in 
Section 6.5.Techniques such as signed distancefields can be 
used to sharply divide such materials [263, 580], though 
doing so can cause aliasing problems. Another concern is 
fringing along silhouetteedgesofdecals,caused bygradient 
errors due to using screen-space information projected back 
into world space. One solution is to restrict or ignore 
mipmapping for such decals; more elaborate solutions are 
----------------------- Page 957-----------------------
discussed byWronski [1920].Decalscan beusedfordynamic 
elements, such as skid marks or bullet holes, but are also 
useful for giving different locations some variation. Figure 
20.5 shows a scenewith decals appliedto buildingwalls and 
elsewhere. The wall textures can be reused,while the decals 
provide customized details that give each building a unique 
character. 20.2. Decal Rendering 891 Figure 20.5. In the top 
image the areas where color and bump decals are overlaid 
are shown with checkerboards. The middle shows the 
buildingwith nodecalsapplied.The bottomimageshowsthe 
scenewith about 200 decals applied. (Images courtesy of IO 
Interactive.) 892 20. Efficient Shading 20.3 Tiled Shading In 
basicdeferredshading,each lightisevaluatedseparatelyand 
the resultisaddedtotheoutputbuffer.Thiswasafeaturefor 
earlyGPUs,whereevaluating morethanafew lightscould be 
impossible,dueto limitationsonshadercomplexity. Deferred 
shading could handle any number of lights, at the cost of 
accessing the G-buffers each time. With hundreds or 
thousands of lights, basic deferred shading becomes 
expensive, since all lights need to be processed for each 
overlapped pixel,and each lightevaluatedat a pixelinvolves 
a separate shader invocation. Evaluating several lights in a 
----------------------- Page 958-----------------------
singleshaderinvocationismoreefficient. Inthe sectionsthat 
follow, we discuss several algorithms for rapidly processing 
largenumbersof lightsat interactive rates,for bothdeferred 
and forward shading. Various hybrid G-buffer systems have 
been developed over the years, balancing between material 
and light storage. For example, imagine a simple shading 
modelwith diffuseandspecularterms,wherethe material’s 
texture affects onlythe diffuseterm. Insteadof retrievingthe 
texture’scolorfrom aG-bufferfor each light,we couldfirst 
compute each light’s diffuse and specularterms separately 
and store these results.These accumulated terms are added 
together inlight-basedG-buffers,sometimescalled L-buffers. 
Attheend,we retrievethetexture’scoloronce,multiplyitby 
the diffuseterm,andthen add inthe specular.Thetexture’s 
effect is factored out of the equation, as it is used only a 
single time for all lights. In this way, fewer G-buffer data 
pointsare accessed per light,saving on bandwidth.A typical 
storage scheme is to accumulate the diffuse color and the 
specular intensity, meaning four values can be output via 
additive blending to a single buffer. Engel [431, 432] 
discusses several ofthese early deferred lightingtechniques, 
also known as pre-lighting or light prepass methods. 
----------------------- Page 959-----------------------
Kaplanyan [856] compares different approaches, aiming to 
minimize G-buffer storage and access. Thibieroz [1766] also 
stressesshallowerG-buffers,contrastingseveralalgorithms’ 
prosand cons. Kircher [900]describes using lower-resolution 
G-buffers and L-buffers for lighting, which are upsampled 
andbilateral-filteredduringafinalforwardshadingpass.This 
approach works well for some materials, but can cause 
artifacts if the lighting’s effect changes rapidly, e.g., a 
roughness or normal map is applied to a reflective surface. 
Sousaetal. [1681]usethe ideaofsubsamplingalongsideY’ 
CbCr color encoding of the albedo texture to help reduce 
storagecosts.Albedo affectsthediffusecomponent,which is 
less proneto high-frequency changes. There are many more 
such schemes [892, 1011, 1351, 1747], each varying such 
elementsaswhichcomponentsarestoredandfactored,what 
passes are performed, and how shadows, transparency, 
antialiasing, and other phenomena are rendered. A major 
goal of allthese isthe same—the efficient renderingof light 
sources—andsuchtechniquesarestillinusetoday [539].One 
limitation of some schemes is that they can require even 
more restricted material and lighting models [1332]. For 
example, Shulz [1589] notes that moving to a physically 
----------------------- Page 960-----------------------
based material model meant that the specular reflectance 
then neededto bestoredto computethe Fresnelterm from 
the lighting. This increase in the light prepass requirements 
helpedpushhisgroupto movefroma lightprepasstoafully 
deferred shading system. 20.3. Tiled Shading 893 Accessing 
even a small number of G-buffers per light can have 
significant bandwidth costs. Faster still would beto evaluate 
only the lightsthat affect each pixel, in a single pass.Zioma 
[1973]was one of the first to explore creating lists of lights 
for forward shading. In his scheme, light volumes are 
rendered and the light ’ s relative location, color, and 
attenuation factor are stored for each pixel overlapped. 
Depth peeling is used to handle storing the information for 
light sources that overlap the same pixels. The scene’s 
geometry is then rendered, using the stored light 
representation. While viable, this scheme is limited by how 
many lights can overlap any pixel. Trebilco [1785] takes the 
idea of creating light lists per pixel further. He performs a 
z-prepassto avoidoverdrawandto cull hiddenlightsources. 
The light volumes are rendered and stored as IDvalues per 
pixel,which are then accessed during the forward rendering 
pass.Hegivesseveralmethodsforstoringmultiplelightsina 
----------------------- Page 961-----------------------
single buffer,includinga bit-shiftingand blendingtechnique 
that allows four lights to be stored without the need for 
multiple depth-peeling passes. Tiled shading was first 
presentedby Balestraand Engstad[97]in2008for the game 
Uncharted:Drake’sFortune,soonfollowed bypresentations 
about its use in the Frostbite engine [42] and PhyreEngine 
[1727], among others. The core idea of tiled shading is to 
assign light sources to tiles of pixels, so limiting both the 
number of lights that need to be evaluated at each surface, 
andthe amount ofwork and storage required.These per-tile 
light lists are then accessed in a single shader invocation, 
insteadofdeferredshading’smethodofcallingashaderfor 
each light [990].Atilefor lightclassification isasquaresetof 
pixelsonthescreen,forexample,32 × 32pixelsinsize.Note 
that there are other ways tiling the screen is used for 
interactive rendering;for instance, mobile processors render 
animagebyprocessingtiles [145],andGPUarchitecturesuse 
screen tiles for a variety of tasks (Chapter 23). Herethe tiles 
are a construct chosen by the developer and often have 
relatively little to do with the underlying hardware. A tiled 
rendering of the light volumes is something like a 
low-resolution rendering of the scene, a task that can be 
----------------------- Page 962-----------------------
performed on the CPU or in, say, a compute shader on the 
GPU [42,43, 139, 140, 1589]. Lights that potentially affect a 
tile are recorded in a list. When rendering is performed, a 
pixelshaderinagiventileusesthetile’scorrespondinglistof 
lightsto shadethe surface.This is illustrated onthe left side 
of Figure 20.6. As can be seen, not all lights overlap with 
every tile. The screen-space bounds of the tile form an 
asymmetrical frustum, which is used to determine overlap. 
Eachlight’ssphericalvolume ofeffectcanquickly betested 
ontheCPUorinacomputeshaderforoverlapwitheachtile’ 
s frustum. Only ifthere is an overlap do we needto process 
that lightfurtherforthe pixelsinthetile. Bystoring lightlists 
per tile instead of per pixel, we err on the side of being 
conservative—a light’svolume may not overlap the whole 
tile—inexchangefor much reduced processing,storage,and 
bandwidth costs [1332]. To determine whether a light 
overlaps with a tile, we can use frustum testing against a 
sphere, which is described in Section 22.14. The test there 
assumes a large, wide frustum and relatively small spheres. 
However, since the frustum here originates from a 
screen-spacetile, itisoften long,thin,andasymmetrical.This 
decreases the 894 20. Efficient Shading 1 2 3 A C B 1 2 B 3 
----------------------- Page 963-----------------------
Figure 20.6. Illustration of tiling. Left: the screen has been 
divided into 6 × 6 tiles, and three lights sources, 1–3, are 
lightingthis scene. Lookingat tiles A–C,we seethat tile A is 
potentiallyaffected bylights1and2,tile Bbylights1–3,and 
tile C by light 3. Right:the blackoutlined rowof tiles on the 
left is visualized as seen from above. For tile B, the depth 
bounds are indicated by red lines. On the screen, tile B 
appearsto beoverlapped byall lights,butonly lights1and2 
overlapwith the depth bounds as well. efficiency ofthe cull, 
since the numberof reported intersections can increase (i.e., 
false positives). See the left part of Figure 20.7. Instead one 
can add a sphere/box test (Section 22.13.2) after testing 
against the planes of the frustum [1701, 1768], which is 
illustrated on the right in Figure 20.7. Mara and McGuire 
[1122] run through alternative tests for a projected sphere, 
including their own GPU-efficient version. Zhdan [1968] 
notes that this approach does not work well for spotlights, 
and discusses optimization techniques using hierarchical 
culling, rasterization, and proxy geometry. This light 
classification process can be used with deferred shading or 
forward rendering, and is described in detail by Olsson and 
Assarsson [1327]. For tiled deferred shading, the G-buffers 
----------------------- Page 964-----------------------
areestablishedas usual,thevolume ofeach lightis recorded 
inthe tiles itoverlaps, andthen these listsare appliedto the 
G-buffers to compute the final result. In basic deferred 
shading each light is applied by rendering a proxy object 
such as a quadrilateral to force the pixel shader to be 
evaluatedforthat light.Withtiledshading,acomputeshader 
or a quad renderedfor the screen or pertile is usedto drive 
shader evaluation for each pixel. When a fragment is then 
evaluated, all lights in the list for that tile are applied. 
Applying listsoflightshasseveraladvantages,including:.For 
each pixel the G-buffers are read at most one time total, 
insteadofonetime peroverlapping light..The output image 
bufferiswrittentoonlyonetime,insteadofaccumulatingthe 
resultsofeach light.20.3.Tiled Shading895 Figure20.7. Left: 
with a naive sphere/frustum test, this circle would be 
reportedasintersectingsinceitoverlapswiththe bottomand 
rightplanesofthe frustum. Middle:an illustrationofthe test 
tothe left,where thefrustum hasgrown andthe origin (plus 
sign)ofthe circle istested againstjust thethick blackplanes. 
Falseintersectionsare reportedinthe green regions. Right:a 
box, shown with dotted lines, is placed around the frustum, 
and a sphere/box test is added after the plane test in the 
----------------------- Page 965-----------------------
middle, forming the thick-outlined shape shown. Note how 
this test would produce other false intersections in its green 
areas, but with both tests applied these areas are reduced. 
Sincetheoriginofthesphereisoutsidetheshape,thesphere 
iscorrectly reportedas notoverlappingthefrustum. .Shader 
code can factor out any common terms in the rendering 
equationandcomputetheseonce,insteadofperlight[990].. 
Each fragment in a tile evaluates the same list of lights, 
ensuring coherent execution of the GPU warps. . After all 
opaque objects are rendered, transparent objects can be 
handled using forward shading, using the same light lists. . 
Since the effects of all lights are computed in a single pass, 
framebuffer precision can be low, if desired. This last item, 
framebuffer precision, can be important in a traditional 
deferred shading engine [1680]. Each light is applied in a 
separate pass,sothefinal resultcansufferfrom bandingand 
otherartifacts ifthe resultsareaccumulated inaframebuffer 
withonly8bitspercolorchannel.Thatsaid,beingabletouse 
a lower precision is not relevantfor many modern rendering 
systems, since these need higher-precision output for 
performing tone mapping and other operations. Tiled light 
classification can also be used with forward rendering. This 
----------------------- Page 966-----------------------
type of system is called tiled forward shading [144, 1327]or 
forward+ [665, 667]. First a zprepass of the geometry is 
performed, both to avoid overdraw in the final pass and to 
permit further light culling. A compute shader classifies the 
lights by tiles. A second geometry pass then performs 
forward shading, with each shader accessing the light lists 
based on the fragment’s screen-space location. 896 20. 
Efficient Shading Tiled forward shading has been used in 
such games asThe Order: 1886 [1267, 1405].Pettineo [1401] 
provides an open-source test suite to compare 
implementations of deferred [990]and forward classification 
of tiled shading. For antialiasing each sample was stored 
when using deferred shading. Resultswere mixed,with each 
scheme outperforming the other under various test 
conditions. With no antialiasing, deferred tended to win out 
on manyGPUs asthe numberof lightsincreased upto 1024, 
andforwarddidbetterastheantialiasing levelwas increased. 
Stewart and Thomas [1700] analyze one GPU model with a 
wider rangeoftests,findingsimilarresults.Thez-prepasscan 
alsobeusedforanotherpurpose,culling lightsbydepth.The 
idea is shown on the right in Figure 20.6. The first step is 
finding the minimumand maximumz-depths of objects ina 
----------------------- Page 967-----------------------
tile, zmin and zmax. Each of these is determined by 
performing a reduce operation, inwhich a shader is applied 
tothetile’sdataandthezminandzmaxvaluesarecomputed 
by sampling in one or more passes [43, 1701, 1768]. As an 
example, Harada et al. [667] use a compute shader and 
unorderedaccessviews to efficiently performfrustum culling 
and reduction of the tiles. These values can then be used to 
quicklycullanylightsthatdonotoverlapthisrangeinthetile. 
Empty tiles, e.g., where only the sky is visible, can also be 
ignored [1877].The type of scene and the application affect 
whether it isworthwhile to compute and usethe minimums, 
maximums, or both [144]. Culling in this way can also be 
applied to tiled deferred shading, since the depths are 
present in the G-buffers. Since the depth bounds are found 
from opaque surfaces, transparency must be considered 
separately. To handle transparent surfaces, Neubelt and 
Pettineo [1267] render an additional set of passes to create 
per-tile lights, used to light and shade only transparent 
surfaces. First, the transparent surfaces are rendered on top 
ofthe opaquegeometry’sz-prepass buffer.Thezmin ofthe 
transparent surfaces are kept,while the zmax of the opaque 
surfaces are used to cap the far end of the frustum. The 
----------------------- Page 968-----------------------
second pass performs a separate light classification pass, 
where new per-tile light lists are generated. The third pass 
sendsonlythetransparentsurfacesthroughthe renderer,ina 
similarfashion astiled forward shading.All such surfacesare 
shadedand litwiththe newlightlists.Forsceneswith a large 
numberof lights,a rangeofvalid z-values iscritical inculling 
most of these out from further processing. However, this 
optimization provideslittlebenefitforacommoncase,depth 
discontinuities. Say atile contains a nearbycharacterframed 
against a distant mountain. The z range betweenthe two is 
enormous, so is mostly useless for culling lights. This depth 
range problem can affect a large percentage of a scene, as 
illustratedinFigure20.8.Thisexampleisnotanextremecase. 
A scene in a forest orwith tall grass or othervegetation can 
contain discontinuities ina higher percentageoftiles [1387]. 
One solution isto makea single split, halfway betweenzmin 
andzmax.Calledbimodalclusters [992]orHalfZ[1701,1768], 
this test categorizes an intersected light as overlapping the 
closer,farther,orfull range,comparedtothe midpoint.Doing 
so directly attacks the case of two objects in a tile, one near 
and onefar. Itdoes notaddressall concerns,e.g.,the case of 
a light volume overlapping neither object, or 20.3. Tiled 
----------------------- Page 969-----------------------
Shading 897 Figure 20.8. A visualization of tiles where large 
depth discontinuities exist. (Image from “Just Cause 3,” 
courtesyofAvalanche Studios [1387].)morethantwoobjects 
overlappingatdifferentdepths. Nonetheless,itcan providea 
noticeable reduction in lighting calculations overall. Harada 
et al. [666, 667] present a more elaborate algorithm called 
2.5Dculling,whereeachtile’sdepthrange,zminandzmax,is 
split into n cells along the depth direction. This process is 
illustrated in Figure 20.9. A geometry bitmask of n bits is 
created,and each bitissetto 1where there isgeometry. For 
efficiency, they use n = 32. Iteration over all lights follows, 
andalightbitmaskiscreatedforevery lightthatoverlapsthe 
tile frustum. The light bitmask indicates in which cells the 
light is located. The geometry bitmask is AND:ed with the 
lightmask. Ifthe resultiszero,thenthat lightdoes notaffect 
anygeometry inthattile.This isshownonthe rightin Figure 
20.9.Otherwise,the lightisappendedto the tile’s light list. 
Forone GPU architecture, Stewart and Thomas [1700]found 
that when the number of lights rose to be over 512, HalfZ 
began outperforming basic tiled deferred, and when the 
number rose beyond 2300, 2.5D culling beganto dominate, 
though notsignificantlyso. Mikkelsen[1210]prunesthe light 
----------------------- Page 970-----------------------
listsfurtherbyusingthe pixellocationsoftheopaqueobjects. 
A list for each 16 × 16 pixel tile is generated with a 
screen-space bounding rectangle for each light, along with 
the zmin and zmax geometry bounds for culling. This list is 
then culled further by having each of 64 compute-shader 
threads compare four pixels in the tile against each light. If 
noneofthe pixels’ world-space locationsinatilearefound 
to beinsidea light’svolume,the lightisculledfromthe list. 
The resulting set of lights can be quite accurate, since only 
those lightsguaranteedto affectat leastone pixelare saved. 
Mikkelsen found that, for his scenes, further culling 
procedures using the z-axis decreased overall performance. 
898 20. Efficient Shading geometry zmax zmin 10000001 
11100 0 0 0 & 00 0 0 0 = geometry mask light mask 0 0 0 
Figure20.9. Left:a frustum for a tile in blue,some geometry 
in black,and set ofcircularyellow lightsources. Middle:with 
tiled cullingthe zmin andzmax values in redare usedto cull 
light sources that do not overlap with the gray area. Right: 
with clustered culling, the region betweenzmin and zmax is 
split into n cells, where n = 8 in this example. A geometry 
bitmask (10000001) is computed using the depths of the 
pixels, and a light bitmask is computed for each light. Ifthe 
----------------------- Page 971-----------------------
bitwise AND between these is 0, then that light is not 
considered further for that tile. The topmost light has 
11000000 and so is the only lightthat will be processed for 
lighting computations, since 11000000AND 10000001gives 
10000000,which is nonzero.With lights placed into listsand 
evaluated as a set, shader complexity for a deferred system 
can become quite complex. A single shader must be able to 
handleall materialsand all lighttypes. Tiles can help reduce 
this complexity.The idea isto store a bitmask in every pixel, 
with each bit associated with a shader feature the material 
uses in that pixel. For each tile, these bitmasks are OR:ed 
together to determine the smallest number of features used 
inthattile.The bitmaskscanalso beAND:edtogethertofind 
features that are used byall pixels, meaningthat the shader 
doesnotneedan “if” testtocheckwhethertoexecutethis 
code. A shader fulfilling these requirements is then used for 
allpixelsinthetile [273,414, 1877].Thisshaderspecialization 
is important not only because less instructions need to be 
executed, but also because the resulting shaders might 
achieve higher occupancy (Section 23.3), as otherwise the 
shader hasto allocate registersfortheworst-case code path. 
Attributes otherthan materialsand lightscan betracked and 
----------------------- Page 972-----------------------
used to affect the shader. For example, for the game 
Split/Second, Knight et al. [911] classify 4 × 4 tiles by 
whether they are fully or partially in shadow, if they contain 
polygon edges that need antialiasing, and other tests. 20.4 
Clustered Shading Tiled light classification uses the 
two-dimensional spatial extents of a tile and, optionally, the 
depthboundsofthegeometry.Clusteredshadingdividesthe 
view frustum 20.4. Clustered Shading 899 tiled shading 
clusteredshading34444 64 34 322222222322222 
2222222 Figure20.10.Tiledandclusteredshading,shown 
in two dimensions. The view frustum is subdivided and a 
scene’slightvolumesarecategorizedbywhich regionsthey 
overlap.Tiled shading subdivides in screen space,虽然群集也 
划分为z深度切片。每个卷都包含一个灯列表;显示长度为2或更多 
的列表的值。如果未根据场景的几何图形（未显示）计算平铺阴影 
的zmin和zmax，则灯光列表可能包含大量不需要的灯光。群集着 
色不需要渲染几何体来剔除其列表，尽管这样的传递可以提供帮助。 
 （图之后佩尔森[1387]。）成一组三维细胞，称为聚类。与平铺着 
色的z深度方法不同，此细分在整个视锥体上执行，与场景中的几 
何体无关。得到的算法具有较少的相机位置性能可变性[1328]，并 
且当瓦片包含深度不连续时表现更好[1387]。聚类着色可应用于前 
向和延迟着色系统。由于透视，瓷砖的横截面积随着距相机的距离 
----------------------- Page 973-----------------------
而增加。统一细分方案将为瓷砖的平截头体创建压扁或长而细的体 
素，这不是最佳的。为了弥补，Olsson等人。[1328,1329]聚类几 
何在视图空间中呈指数级，不依赖于几何的zmin和zmax，以使聚 
类更加立方体。例如，Just Cause 3的开发人员使用具有16个深 
度切片的64×64像素图块，并且沿着每个轴尝试了更大的分辨率， 
以及使用固定数量的屏幕图块而不管分辨率[1387]。虚幻引擎使用 
相同大小的图块，通常是32个深度切片[38]。见图20.10。灯光按 
照它们重叠的星团分类，和列表形成。通过不依赖于场景几何体的 
z深度，可以仅从视图和一组光来计算聚类[1387]。然后，每个表 
面（不透明或透明）使用其位置来检索相关的灯光列表。聚类提供 
了一种高效，统一的照明解决方案，适用于场景中的所有对象，包 
括透明和体积对象。与平铺方法一样，使用聚类的算法可以与前向 
或延迟着色组合。例如，ForzaHorizo​ ​ n2在GPU上计算其集 
群，90020.高效着色，然后使用前向着色，因为这提供了 MSAA 
支持而无需任何额外的工作[344,1002,1387]。虽然在单次通过中进 
行前向着色时可以进行过度绘制，但其他方法，例如粗略的前后排 
序[892，1766]或仅对一部分物体执行预通过[145,1768]，可以在 
没有第二次完整几何通过的情况下避免多次过度绘制。也就是说， 
Pettineo[1407]发现，即使使用这种优化，使用单独的z-prepass 
也会更快。或者，可以对不透明表面执行延迟着色，然后使用相同 
的光列表结构在透明表面上进行前向着色。这种方法用于正当理由 
3，它在CPU上创建光列表[1387]。Dufresne[390]还在CPU上并 
----------------------- Page 974-----------------------
行生成群集灯光列表，因为此过程不依赖于场景中的几何体。聚类 
光分配给每个列表提供更少的光，并且比平铺方法具有更少的视图 
依赖性[1328,1332]。很久了，由瓷砖定义的薄褶皱可以从相机的微 
小移动中对其内容进行相当大的改变。例如，直线的路灯可以对齐 
以填充一个瓦片[1387]。即使使用z深度细分方法，由于单个像素 
改变，从每个图块中的表面发现的近距离和远距离也可以从根本上 
移位。聚类不易受此类问题的影响。Olsson等人研究了聚类着色的 
几种优化。[1328,1329]和其他人，如上所述。一种技术是为灯形成 
BVH，然后用于快速确定哪个光量与给定的簇重叠。只要至少一个 
灯移动，就需要重建这个 BVH。可用于延迟着色的一个选项是使用 
群集中表面的量化法线方向进行剔除。奥尔森等人。通过方向将表 
面法线分类为在立方体上每面保持3×3方向集的结构，总共 54个 
位置，以形成法线锥 （第 19.3节）。然后，可以在创建群集列表时 
使用此结构进一步剔除光源，即群集中所有曲面后面的那些。对于 
大量灯光，排序可能会变得昂贵，van Oosten [1334]探索了各种 
策略和优化。当可见几何体位置可用时，如延迟着色或z-prepass， 
可以进行其他优化。可以从处理中消除不包含几何体的聚类，从而 
提供需要较少处理和存储的稀疏网格。这样做意味着必须首先处理 
场景以找到占用的簇。因为这需要访问深度缓冲区数据，所以必须 
在GPU上执行簇形成。与群集的体积相比，与群集重叠的几何体可 
能具有较小的范围。通过使用这些样品形成紧密的AABB来测试 
[1332]，可以剔除更多的光。优化的系统可以处理超过一百万个光 
----------------------- Page 975-----------------------
源，并且随着这个数量的增加可以很好地扩展，同时对于少数几个 
灯也是有效的。没有要求使用指数函数细分屏幕z轴，并且这种细 
分可能对具有许多远光的场景具有负面影响。随着指数分布，群集 
体积随深度增加，这可能导致远程群集的光列表过长。限制群集 
20.4。ClusteredShading901设置的最大距离，光聚类的 “远平 
面”是一种解决方案，更远的光线逐渐消失，表现为颗粒或眩光， 
或在[293,432,1768]中烘烤。也可以使用更简单的着色器，光切割 
[1832]或其他级别的细节技术。相反，最接近观察者的体积可能相 
对无人居住但是被严重细分。一种方法是将分类平截头体的 “近平 
面”强制到一些合理的距离，并将比该深度更近的光分类以落入第 
一深度切片[1387]。在DOOM （2016）中，开发人员[294,1682] 
使用Olsson等人的聚类方法的组合实现了他们的前向着色系统。 
[1328]和佩尔森[1387]。它们首先执行z-prepass，大约需要0.5 
ms。他们的列表构建方案可以被认为是剪辑空间体素化。光源，环 
境光探针和贴花通过测试每个插入来插入与表示每个细胞的AABB 
交叉。由于聚类前向系统获得了延迟着色对这些实体的优势，因此 
添加贴花是一项重大改进。在前向阴影期间，引擎循环遍历单元格 
中的所有贴花。如果贴图与曲面位置重叠，则会检索其纹理值并将 
其混合。贴花可以以任何所需的方式与底层曲面混合，而不是仅限 
于混合阶段中可用的操作，如延迟着色。使用聚类前向着色贴花也 
可以在透明表面上呈现。然后应用单元中的所有相关灯。CPU可用 
于构建灯光列表，因为场景的几何图形不是必需的，并且因为分析 
----------------------- Page 976-----------------------
测试轻体积球和聚类盒的重叠是便宜的。然而，如果涉及聚光灯或 
其他光体积形状，则在其周围使用球形边界体积可导致将这种光添 
加到其中没有效果的许多簇，并且精确的分析相交测试可能是昂贵 
的。沿着这些方向，Persson[1387]提供了一种将球体素化为一组 
簇的快速方法。GPU的光栅化管道可用于对轻量级进行分类以避免 
这些问题。¨Ortegren和 Persson[1340]描述了构建灯光列表的两 
遍过程。在shell传递中，每个光由包含它的低分辨率网格表示。保 
守的光栅化（第23.1.2节）用于将每个shell渲染到集群网格中， 
记录每个重叠的最小和最大簇。在填充过程中，计算着色器将灯光 
添加到这些边界之间的每个簇的链接列表中。使用网格而不是边界 
球体可以为聚光灯提供更紧密的边界，几何体可以直接遮挡光线可 
见性，进一步剔除列表。当保守的光栅化不可用时，Pettineo[1407] 
描述了一种采用表面梯度来保守地估计每个像素处的三角形的z边 
界的方法。例如，如果在像素处需要最远距离，则使用x和y深度 
梯度来选择像素的哪个角落最远并计算该点处的深度。因为这些点 
可能偏离三角形，所以他还可以整体夹紧光的z深度范围，为了避 
免有一个接近边缘的三角形，估计的z深度远远不够。Wronski 
[1922]探索了各种解决方案，基于将边界球放在902左右的想法。 
高效着色23156791110121413482,5,11,143,5，8,10,14 
1,4,7,121,6,9,13min-max 1-4 3-86-109 -12 12-14瓷砖清 
单：z-bin：对于标记的单元格， tile列表是 3,5,8,10,14，z-bin 
范围是6 -10，因此两个列表上的灯都是8和 10.图20.11。使用 
----------------------- Page 977-----------------------
z-binning，每个灯基于其z深度给出 ID。生成每个图块的列表。 
每个z-bin存储最小和最大 ID，保守范围的灯可能与切片重叠。对 
于标记单元格中的任何像素，我们检索两个列表并找到重叠。网格 
单元并对锥体执行交叉测试。当细胞接近立方体时，该测试可以快 
速评估并且效果很好，当拉长细胞时则更少。Drobot[385]描述了 
如何使用网格在 “使命召唤：无限战争”中插入灯光。想想静态的 
聚光灯。它在空间中形成一个体积，例如锥形。在没有进一步处理 
的情况下，该锥体可以延伸一些相当大的距离，或者延伸到场景的 
范围，或者延伸到为光定义的某个最大距离。现在想象一下这个聚 
光灯的阴影贴图，它是使用场景中的静态几何体生成的。此贴图定 
义光照射的每个方向的最大距离。在烘焙过程中，此阴影贴图将变 
为低分辨率网格，然后用作光线的有效体积。网格是保守的，使用 
每个阴影贴图区域中的最大深度形成，以便它完全包含由光照射的 
空间体积。聚光灯的这种表示可能会比原始锥体的体积重叠更少的 
聚类。与此过程无关，名为zbinning的灯列表存储和访问方法比聚 
簇着色占用的内存要少得多。在其中，灯光按屏幕z深度排序，并 
根据这些深度给出ID。然后使用一组z切片，每个z切片具有相同 
的深度厚度而不是指数，以对这些光进行分类。每个z切片只存储 
与其重叠的灯光的最小和最大 ID。见图20.11。还会生成平铺着色 
列表，几何剔除是可选的。然后，每个表面位置访问该二维平铺结 
构和每个切片的一维z-bin ID范围。平铺列表给出了可能影响像素 
的图块中的所有灯光。像素的深度检索可能与z切片重叠的ID范围。 
----------------------- Page 978-----------------------
这两者的重叠是在运行中计算的，并为集群提供有效的灯光列表。 
该算法不是为三维网格中的每个聚类创建和存储列表，而是每个二 
维图块只需要一个列表，而对于一组z切片只需要一个小的固定大 
小的数组。需要更少的存储，带宽使用和预计算，代价是需要更多 
的工作来确定每个像素的相关光。使用 20.4。群集着色 903 
z-binning可能会导致某些灯光被误分类，但是 Drobot发现，对 
于人造环境，在xy屏幕坐标和z深度的灯光之间通常几乎没有重叠。 
使用像素和计算着色器，此方案能够在具有深度不连续性的图块中 
进行近乎完美的剔除。用于访问对象的三维数据结构通常可以被分 
类为与卷相关的，其中网格或八叉树被施加在空间上;与对象相关 
的，其中形成了边界体积层次结构;或混合，例如使用网格单元格中 
内容周围的边界体积。Bezrati[139,140]在计算着色器中执行平铺 
着色以形成增强的光列表，其中每个光包括其最小和最大z深度。 
通过这种方式，片段可以快速拒绝任何不与其重叠的灯光。 
O'Donnell和Chajdas [1312]介绍了平铺的光树，它们在CPU端 
形成。它们使用具有每个光的深度边界的平铺光列表并形成边界间 
隔层次结构。也就是说，不像Olsson等人所做的那样，不是形成 
所有灯光的单独的三维层次结构。[1328]，它们从图块中的每个光 
的z范围创建更简单的一维层次结构。这种结构很好地映射到GPU 
的架构，并且能够更好地处理大量灯光落入单个磁贴的情况。它们 
还提供了一种混合算法，可以在将图块划分为单元格之间进行选择 
- 正常的聚类着色方法 - 或使用光树。光树在细胞与其光之间的平 
----------------------- Page 979-----------------------
均重叠率较低的情况下效果最佳。本地灯光列表的概念可以在移动 
设备上使用，但存在不同的限制和机会。例如，以传统的延迟方式 
一次渲染一个灯可能是移动设备上最有效的方法，因为移动设备将 
G缓冲区保存在本地内存中的独特属性。平铺前向着色可以在支持 
OpenGL ES2.0的设备上实现，这几乎是在移动GPU上给出的。 
借助OpenGLES3.0和称为像素本地存储的扩展，ARMGPU中可 
用的基于图块的渲染系统可用于高效生成和应用灯光列表。有关详 
细信息，请参阅Billeter的演示文稿[145]。Nummelin[1292]讨论 
了Frostbite引擎从桌面到移动的转换，包括与轻型分类方案的权 
衡，因为计算着色器对移动硬件的支持较少。由于移动设备使用基 
于图块的渲染，为延迟着色生成的G缓冲区数据可以保留在本地内 
存中。Smith和 Einig[1664]描述了使用帧缓冲提取和像素本地存 
储来实现这一点，发现这些机制将总带宽成本降低了一半以上。总 
之，平铺，聚类或其他灯列表剔除技术可以与延迟或前向着色一起 
使用，并且每个技术也可以应用于贴花。用于光量剔除的算法集中 
于最小化针对每个片段评估的光的数量，而解耦几何和阴影的想法 
可用于平衡处理和带宽成本以最大化效率。正如截头剔除将花费额 
外的时间而没有任何好处，如果所有对象总是在视野中，那么一些 
技术在各种条件下将提供很少的益处。如果太阳是唯一的光源，则 
不需要轻度剔除预处理。如果有小表面90420.高效着色传统。前 
进传统。延迟Tiled/ clust。推迟。瓷砖/ clust。FWD。几何通过 
1111-2光通过01每光 11每个网格每个网格每个网格每个网格 
----------------------- Page 980-----------------------
的光线剔除透明度容易没有w/fwd→容易 MSAA 内置硬硬内置带 
宽低高中低低变化阴影模型简单硬涉及简单小三角形慢速快速慢速 
注册压力。高低的。低可能。高阴影贴图重复使用否是否否贴花昂 
贵廉价便宜贵表20.1。对于典型的桌面GPU，使用延迟和前向着色 
比较传统的单向前向，延迟和平铺/聚类光分类。（在奥尔森之后 
[1332]。）透支和几盏灯，延迟着色可能会花费更多时间。对于具 
有许多有限效果光源的场景，无论是使用前向还是延迟着色，花费 
时间创建本地化光源列表都是值得的。当几何体处理复杂或渲染表 
面很昂贵时，延迟着色提供了一种避免过度绘制的方法，最小化驱 
动程序成本（如程序和状态切换），并使用较少的调用来渲染较大 
的合并网格。请记住，其中一些方法可用于渲染单个帧。最佳混合 
技术的不仅取决于场景，还可能因每个对象或每个灯光而异[1589]。 
总结本节，我们总结了表20.1中各方法之间的主要差异。“透明度” 
行中的右箭头表示延迟着色应用于不透明曲面，透明着色需要前向 
着色。“小三角形”注意到延迟着色的优点，即四边形阴影 （第23.1 
节）在正向渲染时效率低，因为所有四个样本都被完全评估。 “注 
册压力”是指所涉及着色器的整体复杂性。在着色器中使用许多寄 
存器意味着形成的线程更少，导致GPU的经线未被充分利用[134]。 
如果采用着色器简化方法，则平铺和聚类延迟技术可能会变低 
[273,414,1877]。当GPU内存更加有限时，阴影贴图重用通常不像 
以前那样重要[1589]。当存在大量光源时，阴影是一个挑战。一种 
反应是忽略除了最近和最亮的灯以及太阳之外的所有灯的阴影计 
----------------------- Page 981-----------------------
算，存在来自较小源的光泄漏的风险。Harada等。[667]讨论他们 
如何在平铺前向系统中使用光线投射，将每个可见表面像素的光线 
产生到每个附近的光源。奥尔森等人。[1330,1331]讨论了使用占用 
的网格单元作为几何的代理生成阴影贴图，并根据需要创建样本。 
他们还展示了一个混合系统，将这些有限的阴影贴图与光线投射相 
结合。使用世界空间而不是屏幕空间来生成灯光列表是构建聚类着 
色空间的另一种方法。这种方法在某些情况下可能是合理的，但由 
于内存控制20.5，可能值得避免大型场景。DeferredTexturing905 
straints [385]并且因为远程簇将是像素大小的，从而损害了性能。 
Persson[1386]为基本的聚类前向系统提供代码，其中静态光存储 
在三维世界空间网格中。20.5延迟纹理延迟着色避免了过度绘制以 
及计算片段阴影然后丢弃这些结果的成本。但是，当形成G缓冲液 
时，仍然会发生过度拉伸。一个对象被栅格化并且检索其所有参数， 
沿途执行多个纹理访问。如果稍后绘制另一个对象来遮挡这些存储 
的样本，则用于渲染第一个对象的所有带宽都被浪费了。一些延迟 
着色系统执行部分或完整的z-prepass以避免纹理访问以后由另一 
个对象绘制的表面[38，892,1401]。但是，如果可能的话，许多系 
统会避免使用额外的几何过程。带宽由纹理提取使用，但也由顶点 
数据访问和其他数据使用。对于详细的几何体，额外的传递可以使 
用比纹理访问成本节省的带宽更多的带宽。形成和访问的G缓冲区 
数量越多，内存和带宽成本就越高。在某些系统中，带宽可能不是 
一个问题，因为瓶颈可能主要在GPU的处理器内。正如第 18章详 
----------------------- Page 982-----------------------
细讨论的那样，总是存在瓶颈，它可以而且会随时改变。效率方案 
如此之多的一个主要原因是每个效率方案都是针对给定平台和场景 
类型而开发的。其他因素，例如实施和优化系统的难度，创作内容 
的难易程度，以及各种其他人为因素，也可以决定建造什么。虽然 
GPU的计算和带宽能力随着时间的推移而增加，但它们以不同的速 
率增加，计算上升得更快。这种趋势与GPU上的新功能相结合，意 
味着一种面向未来的系统的方法是将瓶颈作为GPU计算而不是缓 
冲区访问[217,1332]。已经开发了一些使用单个几何通道的不同方 
案，并且避免在需要之前检索纹理。Haar和Aaltonen [625]描述 
了如何在刺客的信条团结中使用虚拟延迟纹理。他们的系统管理可 
见纹理的局部8192×8192纹理图集，每个图案具有 128×128分辨 
率，从更大的集合中选择。这个地图集大小允许存储（u，v）可用 
于访问图集中任何纹素的纹理坐标。有 16位用于存储坐标;对于 
8192个位置需要 13位，这留下3位，即8个级别，用于子纹素精 
度。还存储了32位切线基础，编码为四元数[498] （第16.6节）。 
这样做意味着只需要一个64位G缓冲区。由于在几何通道中没有 
执行纹理访问，因此过度绘制可能非常便宜。在建立此G缓冲区之 
后，然后在着色期间访问虚拟纹理。mipmapping需要渐变，但不 
存储。而是，检查每个像素的邻居，并使用具有最接近（u，v）值 
的邻居90620.高效着色图20.12。在可见性缓冲区的第一次传递 
[217]中，只是三角形和实例ID被渲染并存储在单个G缓冲区中， 
这里用每个三角形的不同颜色可视化。（图片由 Graham 
----------------------- Page 983-----------------------
Wihlidal-ElectronicArts提供[1885]。）来计算飞行中的梯度。材 
料ID还通过将纹理坐标值除以 128 （即纹理分辨率）来确定访问哪 
个纹理图集图块而得到。此游戏中用于降低着色成本的另一种技术 
是以四分之一分辨率渲染并使用特殊形式的 MSAA。在使用AMD 
GCN的控制台或使用OpenGL4.5，OpenGL ES3.2或其他扩展 
[2,1406]的系统上，可以根据需要设置MSAA采样模式。Haar和 
Aaltonen为4×MSAA设置了网格图案，因此每个网格样本直接对 
应于全屏像素的中心。通过以四分之一分辨率渲染，他们可以利用 
MSAA的多重采样特性。 （u，v）和切线基础可以在表面上内插而 
没有损失，并且8×MSAA （相当于每像素2×MSAA）也是可能的。 
当渲染具有相当大的过度绘制的场景（例如树叶和树木）时，它们 
的技术显着减少了着色器调用的次数和G缓冲区的带宽成本。仅存 
储纹理坐标和基础是非常小的，但其他方案也是可能的。Burns和 
Hunt[217]描述了他们称之为可见性缓冲区的内容，它们存储两个 
数据，一个三角形ID和一个实例 ID。见图20.12。几何传递着色器 
非常快，没有纹理访问，只需要存储这两个 ID值。所有三角形和顶 
点数据位置，法线，颜色，材质等存储在全局缓冲区中。在延迟着 
色过程中，为每个像素存储的三角形和实例 ID用于检索这些数据。 
像素的视图光线与三角形相交以找到重心坐标，其用于在三角形的 
顶点数据之间进行插值。其他20.5。每个像素也必须执行通常较不 
频繁地执行的延迟纹理907计算，例如顶点着色器计算。还从头开 
始为每个像素计算纹理梯度值，而不是进行插值。然后使用所有这 
----------------------- Page 984-----------------------
些数据来对像素进行着色，使用任何所需的分类方案来应用光。虽 
然这听起来很昂贵，但请记住，计算能力的增长速度要快于带宽能 
力。该研究有利于计算繁重的管道，最大限度地减少由于过度绘制 
造成的带宽损失。如果场景中的网格少于64k，并且每个网格具有 
少于64k的三角形，则每个 ID的长度为16位，G缓冲区可以小到 
每像素32位。较大的场景将其推向48或64位。Stachowiak[1685] 
描述了可见性缓冲区的变体，其使用GCN架构上可用的一些功能。 
在初始通过期间，还计算三角形上的位置的重心坐标并且每个像素 
存储。与稍后执行每个像素的单独的光线/三角形交叉相比，GCN 
片段（即，像素）着色器可以廉价地计算重心坐标。在花费额外存 
储空间的同时，这种方法具有重要优势。对于动画网格，原始可见 
性缓冲区方案需要将任何已修改的网格数据流式传输到缓冲区，以 
便在延迟着色期间可以检索已修改的顶点位置。保存变换的网格坐 
标会消耗额外的带宽。通过在第一遍中存储重心坐标，我们完成了 
顶点位置，这些位置不必再次获取，这是原始可见性缓冲区的缺点。 
但是，如果需要距离摄像机的距离，则该值也必须存储在第一遍中， 
因为以后不能重建该值。与以前的方案类似，该管道有助于解耦几 
何和着色频率。Aaltonen [2]指出，MSAA网格采样方法可以应用 
于每个，导致进一步减少所需的平均内存量。他还讨论了存储布局 
的变化以及这三种方案的计算成本和功能的差异。Schied和 
Dachsbacher[1561,1562]走向另一个方向，建立在可见性缓冲区 
上，并使用 MSAA功能来减少内存消耗和阴影计算，以实现高质量 
----------------------- Page 985-----------------------
的抗锯齿。Pettineo[1407]指出无绑定纹理功能的可用性 （第6.2.5 
节）使得延迟纹理的实现更加简单。他的延迟纹理系统创建了一个 
更大的 G缓冲区，存储深度，单独的材质 ID和深度渐变。渲染 
Sponza模型，将该系统的性能与具有和不具有z-prepass的聚集 
前向方法进行比较。当MSAA关闭时，延迟纹理总是比正向着色更 
快，当应用 MSAA时，延迟纹理减慢。正如第5.4.2节所述，大多 
数视频游戏已逐渐远离 MSAA，因为屏幕分辨率已经增加，而是依 
赖于时间抗锯齿，所以实际上这种支持并不是那么重要。Engel[433] 
指出，由于DirectX12和Vulkan中暴露的API功能，可见性缓冲 
区概念变得更具吸引力。使用计算着色器执行的剔除三角形集（第 
19.8节）和其他删除技术可减少栅格化的三角形数量。DirectX12 
的ExecuteIndirect命令可以是90820.高效着色用于创建优化索引 
缓冲区的等效项，该缓冲区仅显示未剔除的三角形。与高级剔除系 
统一起使用[1883,1884]，他的分析确定可见性缓冲区在San 
Miguel场景的所有分辨率和抗锯齿设置上都优于延迟着色。随着屏 
幕分辨率的提高，性能差距也在增大。GPU的API和功能的未来变 
化可能会进一步提高性能。Lauritzen[993]讨论了可见性缓冲区以 
及如何进化GPU以改进在延迟设置中访问和处理材质着色器的方 
式。Doghramachi和 Bucci[363]详细讨论了他们的延迟纹理系统， 
他们称之为deferred +。他们的系统早期集成了积极的剔除技术。 
例如，前一帧的深度缓冲区被下采样并以一种为当前场景中的每个 
像素提供保守剔除深度的方式重新投影。这些深度有助于测试遮挡 
----------------------- Page 986-----------------------
以渲染截锥体中可见的所有网格的边界体积，如第 19.7.2节中简要 
讨论的那样。他们注意到，alpha剪切纹理（如果存在）必须在任 
何初始传递（或任何z-prepass）中访问，以便剪切后面的对象不 
被隐藏。它们的剔除和光栅化过程的结果是一组G缓冲区，包括深 
度，纹理坐标，切线空间，渐变和材质 ID，用于遮蔽像素。虽然其 
G缓冲区的数量高于其他延迟纹理化方案，但它确实避免了不需要 
的纹理访问。对于来自 DeusEx：MankindDivided的两个简化场 
景模型，他们发现延迟+运行速度比聚类前向阴影更快，并相信更 
复杂的材料和照明将进一步扩大差距。他们还注意到warp的使用 
明显更好，这意味着微小的三角形引起的问题更少，因此GPU镶嵌 
更好。它们对延迟纹理的实现与延迟着色相比具有其他几个优点， 
例如能够更有效地处理更广泛的材料。主要缺点是大多数延迟方案 
的常见缺点，涉及透明度和抗锯齿。20.6对象和纹理空间着色将几 
何体采样的速率与计算着色值的速率解耦的想法是本章中反复出现 
的主题。在这里，我们将介绍几种不太适合目前所涵盖类别的替代 
方法。特别是，我们讨论了利用 Reyes1批量渲染器[289]中首次出 
现的概念的混合动力，皮克斯和其他人多年来一直使用这些概念来 
制作他们的电影。现在，工作室主要使用某种形式的光线或路径追 
踪进行渲染，但就目前而言，雷耶斯以创新和有效的方式解决了几 
个渲染问题。雷耶斯的关键概念是微多边形的概念。每个表面都被 
切成极细的四边形网格。在原始系统中，切割完成 1 “雷耶斯”这 
个名字的灵感来自 PointReyes半岛，有时被称为 “REYES”，这 
----------------------- Page 987-----------------------
是一个缩写，意思是 “渲染你所见过的一切。”20.6。物体和纹理 
空间阴影909图20.13。雷耶斯渲染管道。将每个对象细分为微多 
边形，然后单独着色。将每个像素（红色）的一组抖动样本与微多 
边形进行比较，并将结果用于渲染图像。相对于眼睛，目标是使每 
个微多边形大约是像素宽度和高度的一半，以便保持奈奎斯特极限 
 （第5.4.1节）。平截头体外面或远离眼睛的四边形被剔除。在该 
系统中，微多边形被遮蔽并分配单色。这种技术演变为在微多边形 
网格中对顶点进行着色[63]。我们在这里讨论的重点是原始系统， 
它所探讨的想法。将每个微多边形插入像素 - 超采样z-缓冲器中的 
抖动的4×4样本网格中。通过产生噪声来进行抖动以避免混叠。因 
为阴影发生在微多边形的覆盖范围内，在光栅化之前，这种技术称 
为基于对象的着色。将其与前向着色进行比较，其中着色在光栅化 
期间在屏幕空间中发生，而延迟着色则在之后发生。见图20.13。 
物体空间中阴影的一个优点是材料纹理通常与它们的微多边形直接 
相关。也就是说，可以细分几何对象，使得在每个微多边形中存在 
两个幂的纹素。在着色期间，然后可以为微多边形检索精确过滤的 
mipmap样本，因为它直接与阴影的表面区域相关。原始的 Reyes 
系统还意味着发生纹理的高速缓存一致访问，因为按顺序访问微多 
边形。这个优点并不适用于所有纹理，例如，用作反射贴图的环境 
纹理必须以传统方式进行采样和过滤。运动模糊和景深效果也适用 
于这种类型的布置。对于运动模糊，在帧间隔期间在抖动时间为每 
个微多边形分配沿其路径的位置。因此，每个微多边形将沿着移动 
----------------------- Page 988-----------------------
方向具有不同的位置，从而产生模糊。以类似的方式实现景深，基 
于混淆圆分布微多边形。Reyes算法存在一些缺点。所有物体必须 
能够镶嵌细分，并且必须切成细度。在z缓冲区中的遮挡测试之前 
发生着色，因此可能由于过度绘制而浪费。奈奎斯特极限的采样并 
不意味着捕获了诸如尖锐镜面高光的高频现象，而是采样足以重建 
较低频率。通常，每个对象必须是 “可绘制的”，换句话说，必须 
具有 （u，v）顶点纹理值，这些顶点为910上的每个不同区域提供 
唯一纹理元素。高效着色模型。有关示例，请参见第23页的图2.9 
和第 173页的图6.6。基于对象的着色可以被认为是着色中的第一 
次烘焙，相机用于确定与视图相关的效果，并可能限制每个表面区 
域消耗的工作量。在GPU上执行基于对象的着色的一种简单方法是 
将对象细分为精细子像素级别，然后对网格上的每个顶点进行着色。 
这样做可能成本很高，因为每个三角形的设置成本不会在多个像素 
上摊销。由于四像素渲染 （第23.1节），因此单像素三角形会产生 
四个像素着色器调用，因此费用变得更糟。GPU被优化以呈现覆盖 
相当数量像素的三角形，例如 16或更多 （第23.10.3节）。伯恩斯 
等人。[216]通过在确定哪些对象位置可见之后执行它来探索对象空 
间着色。他们用一个 “多边形网格”来确定这些对象，这个对象被 
切块，尽可能地被剔除，然后进行栅格化。然后使用独立的物体空 
间 “阴影网格”来遮蔽可见区域，每个纹理像素对应于表面的区域。 
着色网格可以是与多边形网格不同的分辨率。他们发现精细镶嵌的 
几何表面几乎没有带来任何好处，因此将两者分离可以更有效地利 
----------------------- Page 989-----------------------
用资源。他们只在模拟器中实现了他们的工作，但他们的技术影响 
了新的研究和开发。从雷耶斯那里汲取灵感的大量研究已经针对各 
种现象研究了GPU上更快的着色方法。Ragan-Kelley等。[1455] 
提出了基于解耦采样的硬件扩展，将他们的想法应用于运动模糊和 
景深。样本有五个维度：两个用于子像素位置，两个用于镜头位置， 
一个用于时间。可见性和阴影分别进行采样。 “解耦映射”确定给 
定可见性样本所需的阴影样本。Liktor和 Dachsbacher [1042， 
1043]以类似的方式呈现延迟着色系统，其中在计算时高速缓存着色 
样本并在随机光栅化期间使用。运动模糊和景深等效果不需要高采 
样率，因此可以重复使用着色计算。Clarberg等人。[271]呈现用 
于计算纹理空间中的阴影的硬件扩展。这些消除了四边形遮蔽问题， 
因此允许更小的三角形。由于着色是在纹理空间中计算的，因此在 
从纹理中查找阴影时，像素着色器可以使用双线性滤镜或更复杂的 
滤镜。这样可以通过降低纹理分辨率来降低着色成本。对于低频术 
语，这种技术通常很有效，因为可以使用滤波。安德森等人。[48] 
采用不同的方法，称为纹理空间着色。测试每个三角形的平截头体 
和背面剔除，然后将其绘制的表面应用于输出目标的相应区域，根 
据其 （u，v）参数化对该三角形进行着色。同时，使用几何着色器， 
计算摄像机视图中每个可见三角形的大小。此大小值用于确定插入 
三角形的类似mipmap的级别。这样，对象执行的着色量与其屏幕 
覆盖范围有关。见图20.14。他们使用随机光栅化来渲染最终图像。 
生成的每个片段查找20.6。物体和纹理空间阴影911图20.14。对 
----------------------- Page 990-----------------------
象空间纹理着色。左边是最终渲染，包括运动模糊。在中间，显示 
了图表中的可见三角形。在右侧，每个三角形根据三角形的屏幕覆 
盖范围插入其正确的mipmap级别，以便在最终的基于摄像机的光 
栅化过程中使用。（经 M.Andersson [48]和英特尔公司许可，转 
载自英特尔公司版权所有，2014年。）其纹理的阴影颜色。同样， 
计算的着色值可以重复用于运动模糊和景深效果。Hillesland和 
Yang [747,748]建立在纹理空间着色概念的基础上，同时还有类似 
于 Liktor和 Dachsbacher的缓存概念。它们将几何体绘制到最终 
视图，使用计算着色器填充基于对象的着色结果的类似于mipmap 
的结构，并再次渲染几何体以访问此纹理并显示最终的阴影。三角 
形 ID可见性缓冲区也保存在第一遍中，这样他们的计算着色器可以 
稍后访问顶点属性进行插值。他们的系统包括随着时间的推移。由 
于着色在对象空间中，因此相同的区域与每个帧的相同输出纹理位 
置相关联。如果先前计算了给定mipmap级别的表面区域阴影并且 
不太旧，则重复使用它而不是重新计算。结果会随着材料，光照和 
其他因素而变化，但是他们发现每隔60帧FPS重复使用阴影样本 
会导致错误可以忽略不计。他们还确定，mipmap级别不仅可以通 
过屏幕大小来选择，还可以通过其他因素的变化来选择，例如区域 
上法线方向的变化。更高的mipmap级别意味着每个屏幕片段计算 
的阴影更少，他们发现可以带来可观的节省。贝克[94]描述了氧化 
物游戏的游戏 “灰烬之光”的渲染器。它的灵感来自雷耶斯，虽然 
实现细节有很大不同，并且每个模型都使用纹理空间着色作为一个 
----------------------- Page 991-----------------------
整体。物体可以具有覆盖其表面的任何数量的材料，这些材料通过 
使用掩模来区分。他们的过程是：。几个大的4k×4k，每通道16 
位 - “主”纹理被分配用于着色。。评估所有对象。如果在视图中， 
则计算屏幕上对象的估计区域。91220.高效遮阳。此区域用于为每 
个对象分配主纹理的一部分。如果请求的总面积大于纹理空间，则 
按比例缩小比例以使请求适合。。基于纹理的着色在计算着色器中 
执行，每个材质依次应用于模型。每种材料的结果都在指定的主纹 
理中累积。。根据需要计算主纹理的 Mipmap级别。。然后栅格化 
对象，主纹理用于遮蔽它们。每个物体使用多种材料允许具有单个 
地形模型的效果，包括泥土，道路，地面覆盖物，水，雪和冰，每 
个都具有其自身的材料 BRDF。如果需要，抗锯齿可在像素级别和 
着色器级别上工作，因为在着色期间可以访问有关对象表面区域及 
其与主纹理的关系的完整信息。例如，这种能力允许系统稳定地处 
理具有极高镜面光焦度的模型。由于着色结果作为整体附加到对象， 
无论可见性如何，还可以以与光栅化不同的帧速率计算着色。发现 
30 FPS的阴影是足够的，光栅化发生在60 FPS，或虚拟现实系统 
的90FPS。具有异步着色意味着即使着色器负载变得太高，也可以 
保持几何的帧速率。实施这样的系统存在若干挑战。与典型的游戏 
引擎相比，总体上发送的批次总数大约是两倍，因为在对象着色步 
骤期间使用计算着色器处理每个对象的 “材质四边形”，然后在光 
栅化期间绘制对象。但是，大多数批次都很简单，而DirectX12和 
Vulkan等API有助于消除开销。如何根据对象的大小将主纹理分配 
----------------------- Page 992-----------------------
给对象，这会使图像质量产生显着差异。屏幕上较大或纹理密度不 
同的对象（如地形）可能会出现问题。执行额外的拼接处理用于维 
持主纹理中的不同分辨率的地形图块之间的平滑过渡。屏幕空间技 
术，例如环境遮挡，是实施的挑战。与原始可见性缓冲区一样，影 
响对象形状的动画必须进行两次，用于着色和光栅化。物体被遮挡， 
然后被遮挡，这是浪费的来源。对于具有低深度复杂性的应用，例 
如实时策略游戏，该成本可能相对较低。与复杂的延迟着色器不同， 
每种材质都很容易评估，并在整个对象的图表上完成着色。具有简 
单着色器的对象（例如粒子和树）从这种技术中获得的好处很少。 
为了提高性能，可以使用前向着色来渲染这些效果。从图20.15中 
可以看出，能够处理许多灯光为渲染场景提供了丰富的效果。我们 
在此结束对有效着色的讨论。我们只涉及一整套专业技术，以提高 
20.6 中使用的结果的速度和质量。对象和纹理空间着色913 图 
20.15。来自奇点的灰烬的场景被大约一千盏灯照亮。这些包括每个 
车辆和每个子弹的至少一个光源。（图片由 Oxide Games和 
StardockEntertainment提供。）不同的应用程序。我们的目标是 
提供用于加速着色的流行算法，并解释它们是如何以及为什么出现 
的。随着图形硬件功能和API的发展，以及屏幕分辨率，艺术工作 
流程和其他元素随着时间的推移而变化，有效的着色技术将继续以 
新的，可能是未预料到的方式进行研究和开发。如果您已经阅读过 
本书，那么您现在已经了解了进入现代交互式渲染引擎的主要算法。 
我们的目标之一是让您加快速度，以便您能够理解现场的当前文章 
----------------------- Page 993-----------------------
和演示文稿。如果您希望了解这些元素如何协同工作，我们强烈建 
议您阅读Courr`eges[293,294]和Anagnostou [38]关于不同商业 
渲染器的优秀文章。在此之后，接下来的章节将深入研究几个领域， 
例如渲染虚拟和增强现实，交叉和碰撞检测算法，以及图形硬件的 
架构特征。进一步阅读和资源因此，这些方法的各种组合 - 延迟， 
前向，平铺，群集，可见性 - 哪个更好？每个都有自己的优势，答 
案是 “它取决于。”平台，场景特征，照明模型和设计目标等因素 
都可以发挥作用。作为起点，我们推荐 Pesce关于各种方案的有效 
性和权衡的广泛讨论[1393,1397]。91420.高效着色SIGGRAPH课 
程 “实时多光管理和带阴影阴影的阴影”[145,1331,1332，1387] 
介绍了平铺和聚类着色技术的彻底贯穿，以及它们与延迟和前向着 
色的使用，以及相关主题，如阴影映射和在移动设备上实现光分类。 
斯图尔特和托马斯[1700]的早期演讲解释了平铺阴影，并提供了丰 
富的时间结果，显示了各种因素如何影响性能。Pettineo的开源框 
架[1401]比较了平铺前向和延迟系统，并包括各种GPU的结果。有 
关实现细节，Zink等人的 DirectX11一书。[1971]关于延迟着色 
的主题有大约50页，并且包括许多代码样本。NVIDIAGameWorks 
代码示例[1299]包括用于延迟着色的 MSAA的实现。Mikkelsen 
[1210]和 “rtegrenandPersson[1340]在GPUPro7一书中的文 
章描述了基于GPU的平铺和聚类着色系统。比勒特等人。[144]给 
出了实现平铺前向着色的编码细节，Stewart [1701]遍历用于在计 
算着色器中执行平铺剔除的代码。Lauritzen[990]为平铺延迟着色 
----------------------- Page 994-----------------------
提供了完整的实现，而Pettineo[1401]构建了一个框架来将其与平 
铺前向进行比较。Dufresne [390]有聚类前向着色的演示代码。 
Persson[1386]提供了基本的世界空间聚类前向渲染解决方案的代 
码。最后，van Oosten [1334]讨论了各种优化，并给出了一个演 
示系统，其代码实现了不同形式的聚类，平铺和香草前向渲染，显 
示了性能差异。第21章虚拟和增强现实 “现实就是当你停止相信它 
时，它不会消失。” - 飞利浦 K.迪克虚拟现实（VR）和增强现实 
 （AR）是试图激发你的感官的技术就像现实世界一样。在计算机图 
形领域，增强现实技术将合成物体与我们周围的世界相结合;虚拟现 
实完全取代了世界。见图21.1。本章重点介绍特定于这两种技术的 
渲染技术，这些技术有时使用术语 “XR”组合在一起，其中X可代 
表任何字母。这里的重点将放在虚拟现实技术上，因为在撰写本文 
时，这种技术更为普遍。渲染只是这些领域的一小部分。从硬件角 
度来看，使用了某种类型的GPU，这是一个很容易理解的系统。创 
建准确和舒适的头部跟踪传感器[994,995]，有效的输入设备 （可能 
具有触觉反馈或眼睛跟踪控制），舒适的头带和光学器件以及令人 
信服的音频，是系统创建者面临的挑战。平衡性能，舒适性，运动 
自由度，价格和其他因素使其成为一个苛刻的设计空间。图21.1。 
前三位作者使用各种VR系统。托马斯使用 HTCVive; 埃里克在 
Birdlyfly-like-a-bird模拟器中; Naty使用Oculus Rift。915916 
21.虚拟现实和增强现实我们专注于交互式渲染以及这些技术影响 
图像生成方式的方式，首先简要介绍目前可用的各种虚拟和增强现 
----------------------- Page 995-----------------------
实系统。然后讨论一些系统的SDK和API的功能和目标。我们以特 
定的计算机图形技术结束，应该避免或修改这些技术以提供最佳的 
用户体验。21.1设备和系统概述除CPU和GPU外，用于图形的虚 
拟和增强现实设备可分为传感器或显示器。传感器包括检测用户旋 
转和位置的跟踪器，以及无数的输入方法和设备。为了显示，一些 
系统依赖于使用移动电话的屏幕，其在逻辑上分成两半。专用系统 
通常具有两个单独的显示器。显示器是用户在虚拟现实系统中看到 
的全部内容。对于增强现实，通过使用专门设计的光学系统将虚拟 
与现实世界的视图相结合。由于各种移动和控制台技术的可用性， 
虚拟和增强现实是旧的领域，最近经历了新的低成本系统的爆炸， 
很大程度上直接或间接[995]。电话可以用于身临其境的体验，有时 
令人惊讶的好。移动电话可放置在头戴式显示器 （HMD）内，从简 
单的观看者（如GoogleCardboard）到免提，并提供额外的输入 
设备，如GearVR。用于重力，磁北和其他机制的手机方向传感器 
允许确定显示器的方向。方向，也称为姿态，具有三个自由度，例 
如偏航，俯仰和滚转，如第4.2.1.1节所述，API可以将方向作为一 
组欧拉角，旋转矩阵或四元数返回。诸如固定视图全景图和视频之 
类的真实世界内容可以很好地与这些设备一起使用，因为为用户的 
方向呈现正确的二维视图的成本相当低。移动设备相对适中的计算 
能力以及扩展使用GPU和CPU硬件的功率要求限制了它们的功能。 
系留虚拟现实设备 （其中用户的耳机通过一组线连接到固定计算机） 
限制了移动性，但允许使用更强大的处理器。我们将简要介绍两种 
----------------------- Page 996-----------------------
系统的传感器，Oculus Rift和 HTCVive。两者都提供六个自由度 
 （6-DOF）跟踪：方向和位置。Rift通过多达三个独立的红外摄像 
机跟踪 HMD和控制器的位置。当耳机的位置由静止的外部传感器 
确定时，这称为从外向内跟踪。耳机外部的一系列红外LED可以跟 
踪它。Vive使用一对 “灯塔”，以快速的间隔将不可见光照射到房 
间，耳机中的传感器和1Many手机的惯性测量单元具有六个自由 
度，但位置跟踪误差可以迅速累积。21.1。设备和系统概述917控 
制器检测以便对其位置进行三角测量。这是一种由内向外跟踪的形 
式，其中传感器是 HMD的一部分。手动控制器是标准设备，与鼠 
标和键盘不同，可跟踪并能够与用户一起移动。基于广泛的技术， 
已经为VR开发了许多其他类型的输入设备。设备包括手套或其他 
肢体或身体跟踪设备，眼动追踪和模拟就地运动的设备，例如压力 
垫，单或全向跑步机，固定自行车和人体大小的仓鼠球，仅举几例。 
除光学系统外，还探索了基于磁，惯性，机械，深度探测和声学现 
象的跟踪方法。增强现实被定义为计算机生成的内容与用户的真实 
世界视图相结合。提供具有覆盖在图像上的文本数据的抬头显示器 
 （HUD）的任何应用是增强现实的基本形式。Yelp Monocle，于 
2009年推出，覆盖相机视图上的商业用户评级和距离。移动版 
Google翻译可以用已翻译的等价物替换标志。Pok'emonGO等游 
戏在真实环境中覆盖了虚构的生物。Snapchat可以检测面部特征并 
添加服装元素或动画。对于合成渲染更感兴趣的是，混合现实（MR） 
是增强现实的子集，其中现实世界和三维虚拟内容实时地混合和交 
----------------------- Page 997-----------------------
互[1570]。混合现实的经典用例是在外科手术中，其中患者器官的 
扫描数据与外部身体的相机视图合并。此方案假定系留系统具有相 
当大的计算能力和精度。另一个例子是用虚拟袋鼠玩 “标签”，房 
子的真实世界的墙壁可以隐藏你的对手。在这种情况下，移动性更 
重要，注册或影响质量的其他因素不那么重要。该领域中使用的一 
种技术是将摄像机安装在 HMD的正面。例如，每个HTCVive都 
有一个开发人员可以访问的前置摄像头。这种世界观被发送到眼睛， 
合成图像可以与它合成。这有时被称为直通AR或VR，或媒介现实 
[489]，其中用户不直接观看环境。使用这种视频流的一个优点是它 
允许更多地控制将虚拟对象与真实对象合并。缺点是现实世界被认 
为有一些滞后。Vrvana的Totem和Occipital's Bridge是使用这 
种类型布置的头戴式显示器的AR系统的例子。微软的 HoloLens 
是本书写作中最着名的混合现实系统。它是一个不受限制的系统， 
具有CPU，GPU以及微软所称的HPU （全息处理单元），这些都 
集成在耳机中。HPU是一个定制芯片，由24个数字信号处理核心 
组成，功耗低于 10瓦。这些内核用于处理来自Kinect的摄像机处 
理世界数据，该摄像机可以查看环境。该视图与其他传感器（如加 
速度计）一起执行由内向外跟踪，其另一个优点是不需要灯塔，QR 
码 （也称为基准点）或其他外部元件。HPU用于识别一组有限的手 
势，意味着不需要额外的输入设备91821.基本交互的虚拟和增强 
现实。在扫描环境时，HPU还会提取深度并导出几何数据，例如代 
表世界表面的平面和多边形。然后可以将该几何结构用于碰撞检测， 
----------------------- Page 998-----------------------
例如，使虚拟对象坐在真实世界的桌面上。使用HPU进行跟踪，通 
过创建称为空间锚点的真实世界航路点，可以在世界任何地方实现 
更广泛的运动。然后，相对于特定空间锚[1207]设置虚拟对象的位 
置。设备对这些锚位置的估计也可以随着时间的推移而改善。这些 
数据可以共享，这意味着少数用户可以在同一位置看到相同的内容。 
还可以定义锚点，以便不同位置的用户可以在同一模型上进行协作。 
一对透明屏幕允许用户观看世界以及投影到这些屏幕上的任何内 
容。请注意，这与手机使用增强现实技术不同，后者通过相机捕捉 
世界观。使用透明屏幕的一个优点是世界本身从不会出现延迟或显 
示问题，并且不会消耗处理能力。这种类型的显示系统的缺点是虚 
拟内容只能将亮度添加到用户的世界观。例如，暗虚拟对象不会遮 
挡其后面更明亮的现实世界对象，因为光只能增加。这可以为虚拟 
对象提供半透明的感觉。HoloLens还有一个 LCD调光器，可以帮 
助避免这种影响。通过适当的调整，系统可以有效地显示与现实融 
合的三维虚拟对象。Apple的ARKit和Google的ARCore帮助开 
发人员为手机和平板电脑创建增强现实应用。标准是显示单个（非 
立体）视图，设备与眼睛保持一定距离。物体可以是完全不透明的， 
因为它们覆盖在摄像机的世界视图上。见图21.2。对于ARKit，通 
过使用设备的运动感应硬件以及相机可见的一组显着特征来执行由 
内到外跟踪。逐帧跟踪这些特征点有助于精确确定设备的当前位置 
和方向。像 HoloLens一样，可以发现水平和垂直表面并确定范围， 
然后将这些信息提供给开发人员[65]。英特尔的 ProjectAlloy是一 
----------------------- Page 999-----------------------
款无线头戴式显示器，与 HoloLens一样，有一个传感器阵列可以 
检测房间内的大型物体和墙壁。与 HoloLens不同，HMD不会让 
用户直接观看世界。然而，它感知周围环境的能力使英特尔称之为 
 “合并现实”，现实世界中的物体可以在虚拟世界中具有令人信服 
的存在感。例如，用户可以联系虚拟世界中的控制台并触摸现实世 
界中的表格。虚拟和增强现实传感器和控制器正在快速发展，其中 
令人着迷的技术以惊人的速度出现。这些提供了更少侵入性耳机， 
更多移动性和更好体验的承诺。例如，Google的DaydreamVR 
和Qualcomm的SnapdragonVR耳机不受限制，使用内外部位 
置跟踪，无需外部传感器或设备。HP，Zotac和 MSI系统 （计算机 
安装在您的背面）可构成可提供更多计算能力的无系统系统。英特 
尔的WiGig线21.2。物理元素919图21.2。来自ARKit的图片。 
检测地平面并显示为蓝色网格。最接近的豆袋椅是添加在地平面上 
的虚拟物体。它缺少阴影，但可以为对象添加这些阴影并在场景中 
混合。（图片由Autodesk，Inc。提供）较少的网络技术使用短距 
离90GHz无线电将图像从 PC发送到耳机。另一种方法是在云上 
计算昂贵的照明计算，然后发送这个压缩信息，由耳机中较轻，功 
能较弱的GPU渲染[1187]。诸如获取点云，体素化这些以及以交互 
速率渲染体素化表示的软件方法[930]为虚拟和真实合并开辟了新 
的方式。本章大部分内容的重点是显示及其在VR和AR中的使用。 
我们首先介绍一些物理机制，了解图像在屏幕上的显示方式以及所 
涉及的一些问题。本章继续介绍SDK和硬件系统提供的内容，以简 
----------------------- Page 1000-----------------------
化编程并增强用户对场景的感知。本节后面是关于这些各种因素如 
何影响图像生成的信息，并讨论了一些图形技术如何需要修改或完 
全避免。最后，我们讨论了渲染方法和硬件增强功能，以提高效率 
和参与者的体验。21.2物理元素本节介绍现代VR和AR系统的各 
种组件和特性，特别是与图像显示有关的组件和特性。此信息提供 
了一个框架，用于理解供应商提供的工具背后的逻辑。92021.虚拟 
和增强现实21.2.1延迟减少延迟的影响在VR和AR系统中尤为重 
要，这通常是最关键的问题[5,228]。我们在第3章讨论了GPU如 
何隐藏内存延迟。由纹理提取等操作引起的延迟类型特定于整个系 
统的一小部分。我们这里的意思是整个系统的 “运动到光子”延迟。 
那是，说你开始向左转。你的头在特定方向面对的时间和从该方向 
产生的视图之间经过了多长时间？从检测用户输入（例如，您的头 
部方向）到响应（显示新图像），链中每个硬件的处理和通信成本 
都会增加数十毫秒的延迟。具有常规显示器的系统（即，没有连接 
到您的脸部）的系统的延迟在最坏情况下令人讨厌，从而打破了交 
互感和连接感。对于增强和混合现实应用程序，较低的延迟将有助 
于增加 “像素棒”，或者场景中的虚拟对象保持贴在现实世界中的 
程度。系统中的延迟越多，虚拟对象相对于现实世界的对象看起来 
游泳或浮动的次数越多。借助沉浸式虚拟现实技术，显示器是唯一 
的视觉输入，延迟可以创建更加激烈的效果。虽然不是真正的疾病 
或疾病，但它被称为模拟病，可引起出汗，头晕，恶心，甚至更严 
重。如果你开始感到不适，立即取下 HMD-你无法 “通过”这种不 
----------------------- Page 1001-----------------------
适，并且会变得更加不适[1183]。引用Carmack [650]， “不要推 
它。我们不需要在演示室清理病人。 “实际上，实际呕吐很少见， 
但效果仍然很严重且使人衰弱，并且可以长达一天。当显示图像与 
用户的期望或通过其他感官的感知（例如内耳的前庭系统的平衡和 
运动）不匹配时，VR中出现模拟疾病。头部运动与正确匹配显示图 
像之间的滞后越低越好。一些研究指出 15毫秒是难以察觉的。绝对 
可以感知到超过20毫秒的滞后并且具有有害影响[5,994,1311]。作 
为比较，从鼠标移动到显示，视频游戏通常具有50ms或更长的等 
待时间，vsync关闭时为30ms （第23.6.2节）。VR系统中显示速 
率为90FPS，帧时间为11.1ms。在典型的桌面系统上，通过电缆 
将帧扫描到显示器大约需要 11毫秒，因此即使您可以在 1毫秒内 
渲染，仍然会有 12毫秒的延迟。有各种各样的基于应用的技术可以 
预防或改善不适[1089,1183,1311,1802]。这些可以包括最小化视 
觉流动，例如不会诱使用户在向前行进时向侧面看并避免上楼梯， 
以及更多心理方法，例如播放环境音乐或渲染表示用户鼻子的虚拟 
对象[1880]。更柔和的色彩和更暗的照明也可以帮助避免模拟器疾 
病。使系统的响应与用户的行为和期望相匹配是提供21.2的关键。 
PhysicalElements921令人愉悦的VR体验。让所有物体响应头部 
运动，不要缩放相机或以其他方式改变视野，正确缩放虚拟世界， 
并且不要控制相机远离用户，列举一些指导方针。在用户周围具有 
固定的视觉参考，例如汽车或飞机驾驶舱，也可以减少模拟器疾病。 
应用于用户的视觉加速度可能引起不适，因此使用恒定速度是优选 
----------------------- Page 1002-----------------------
的。硬件解决方案也可能有用。例如，三星的 Entrim4D耳机会发 
出影响前庭系统的微小电脉冲，从而可以将用户看到的内容与他们 
的平衡感告诉他们。时间将证明这种技术的功效，但它表明正在进 
行多少研究和开发以减轻模拟器疾病的影响。跟踪姿势，或简称为 
姿势，是观察者头部在现实世界中的方向和位置（如果可用）。姿 
势用于形成渲染所需的相机矩阵。可以在帧的开始处使用姿势的粗 
略预测来执行模拟，诸如角色的碰撞检测和环境中的元素。渲染即 
将开始时，此时可以检索更新的姿势预测并用于更新摄像机的视图。 
这种预测将更加准确，因为它可以在以后检索并且持续时间更短。 
当即将显示图像时，仍然可以检索另一个更准确的姿势预测并用于 
扭曲该图像以更好地匹配用户的位置。每个后来的预测都不能完全 
补偿基于较早的，不准确的预测的计算，但是尽可能使用它们可以 
显着改善整体体验。各种装备中的硬件增强功能提供了在需要时快 
速查询和获取更新的头部姿势的能力。视觉效果以外的元素与虚拟 
环境相互作用令人信服，但是让图形错误会让用户感到不愉快。最 
大限度地减少延迟并提高应用程序的真实感可以帮助实现沉浸或存 
在，界面消失，参与者感觉身体是虚拟世界的一部分。21.2.2光学 
设计精确的物理光学系统将头戴式显示器的内容映射到视网膜上的 
相应位置是一个昂贵的主张。虚拟现实显示系统价格实惠的原因在 
于GPU生成的图像在单独的后处理过程中会被扭曲，以便它们能够 
正确地到达我们的眼睛。VR系统的镜头向用户呈现具有枕形失真的 
宽视场图像，其中图像的边缘看起来向内弯曲。如图21.3右侧所示， 
----------------------- Page 1003-----------------------
通过使用桶形失真扭曲每个生成的图像来抵消此效果。光学系统通 
常也会受到色差的影响，其中镜片会使色彩分离，就像棱镜一样。 
通过生成具有反色分离的图像，供应商的软件也可以补偿这个问题。 
它是色差 “在其他922中21.虚拟和增强现实图21.3。原始渲染目 
标（左）及其扭曲版本（右），以便在 HTCVive [1823]上显示。 
 （图片由Valve提供。）方向。 “这些单独的颜色在通过VR系统 
的光学系统显示时能够正确组合。可以在扭曲对中图像边缘周围的 
橙色边缘处看到该校正。有两种类型的显示，滚动和全局[6]。对于 
这两种类型的显示，图像以串行流的形式发送。在滚动显示中，此 
流将立即显示为已接收，扫描线按扫描线显示。在全局显示中，一 
旦接收到整个图像，它就会以单个短脉冲串显示。每种类型的显示 
器都用在虚拟现实系统中，并且每种显示器都有其自身的优点。与 
全局显示相比，全局显示必须等待整个图像在显示之前出现，滚动 
显示可以最小化延迟，因为结果会尽快显示。例如，如果图像是以 
条带形式生成的，则每个条带可以在显示之前以渲染的方式发送， 
 “比赛光束”[1104]。缺点是不同的像素在不同时间被照亮，因此 
图像可以被感知为摇摆不定，取决于视网膜和显示器之间的相对运 
动。对于增强现实系统，这种不匹配可能特别令人不安。好消息是 
合成器通常通过在扫描线块上插入预测的头部姿势来补偿。这主要 
解决了在头部快速旋转时会发生的摆动或剪切，但是无法校正在场 
景中移动的物体。全局显示器没有这种类型的定时问题，因为图像 
必须在显示之前完全形成。相反，挑战是技术性的，因为单个短时 
----------------------- Page 1004-----------------------
间突发排除了几个显示选项。有机发光二极管 （OLED）显示器目前 
是全球显示器的最佳选择，因为它们足够快以跟上VR使用的90 
FPS显示速率。21.2。3立体视觉如图21.3所示，两幅图像偏移， 
每只眼睛的视图不同。这样做可以刺激立体视觉，有两只眼睛感知 
深度。虽然重要的效果，立体视觉随着距离减弱，并且不是我们感 
知深度的唯一方式。我们根本不使用它，例如，当看图像时在标准 
显示器上。物体大小，纹理图案变化，阴影，相对运动（视差）和 
其他视觉深度线索仅用一只眼睛。21.2。物理元素923图21.4。两 
只眼睛旋转以观察物体是多少。收敛是眼睛向内移动以聚焦在物体 
上的运动，如左侧所示。分歧是指当它们改变为在页面的右边缘之 
外看远处的物体时的向外运动。用于观察远处物体的视线是有效平 
行的。眼睛必须调整多少形状以使某些东西成为焦点，这被称为适 
应性需求。例如，Oculus Rift的光学系统相当于查看距离用户约 
1.3米的屏幕。眼睛需要向内转动以聚焦于物体的程度称为聚散需 
求。见图21.4。在现实世界中，眼睛改变镜片形状并一致地向内转 
动，这种现象称为调节 - 会聚反射。对于显示器，调节需求是恒定 
的，但是当眼睛聚焦在不同感知深度的物体上时，聚散度需求改变。 
这种不匹配会导致眼睛疲劳，因此Oculus建议用户长时间看到的 
任何物体放置在0.75到3左右。5米远[1311,1802]。这种不匹配 
还可以在一些AR系统中具有感知效果，例如，用户可以聚焦在现 
实世界中的远处物体上，但是然后必须重新聚焦在眼睛附近的固定 
深度处的相关虚拟广告牌上。可以根据用户的眼睛运动调整感知焦 
----------------------- Page 1005-----------------------
距的硬件（有时称为自适应焦点或变焦显示）正在由许多团体进行 
研究和开发[976,1186,1875]。用于生成VR和AR的立体对的规则 
不同于单显示系统的规则，其中一些技术（偏振镜，快门眼镜，多 
视图显示光学器件）从同一屏幕向每只眼睛呈现单独的图像。在VR 
中，每只眼睛都有一个单独的显示，这意味着每一个都必须以投影 
到视网膜上的图像与现实紧密匹配的方式定位。从眼睛到眼睛的距 
离称为瞳孔间距 （IPD）。在一项对4000名美国陆军士兵的研究中， 
发现 IPD的范围为52毫米至78毫米，平均为63.5毫米[1311]。 
VR和AR系统具有校准方法，以确定和调整用户的IPD，从而提高 
图像质量和舒适度。系统的API控制包含此 IPD的相机型号。最好 
避免修改用户感知的 IPD以达到效果。例如，增加眼睛分离距离可 
以增强深度感，但也可能导致眼睛疲劳。92421.虚拟和增强现实头 
戴式显示器的立体渲染对于从头开始正常执行具有挑战性。好消息 
是，为每只眼睛设置和使用适当的相机变换的大部分过程由API处 
理，这是下一节的主题。21.3API和硬件让我们从一开始就这样说： 
始终使用系统提供商提供的VR软件开发工具包（SDK）和应用程 
序编程接口 （API），除非您有充分的理由不这样做。例如，您可能 
认为自己的失真着色器更快且看起来正确。然而，在实践中，它可 
能会导致严重的用户不适 - 如果没有进行大量测试，您不一定知道 
这是否属实。由于这个原因和其他原因，应用程序控制的失真已从 
所有主要API中删除;让VR显示正确是系统级任务。代表您完成了 
许多精心设计的工程，以优化性能并保持质量。本节讨论各种供应 
----------------------- Page 1006-----------------------
商的SDK和API提供的支持。将三维场景的渲染图像发送到头戴式 
耳机的过程非常简单。在这里，我们将使用大多数虚拟和增强现实 
API共有的元素来讨论它，并注意到特定于供应商的功能。首先， 
确定将要显示要渲染的帧的时间。通常支持帮助您估算此时间延迟。 
需要该值，以便SDK可以计算在看到帧时眼睛将在何处以及在哪个 
方向上的估计。鉴于此估计的延迟，将查询API的姿势，其中包含 
有关每只眼睛的相机设置的信息。如果传感器也跟踪此信息，则至 
少包括头部的方向和位置。OpenVRAPI还需要知道用户是站立还 
是坐着，这可能影响用作原点的位置，例如，跟踪区域的中心或用 
户头部的位置。如果预测是完美的，则在头部到达预测位置和方向 
的时刻将显示渲染图像。以这种方式，可以最小化延迟的影响。给 
定每只眼睛的预测姿势，您通常将场景渲染为两个单独的目标.2这 
些目标作为纹理发送到SDK的合成器。合成器负责将这些图像转换 
为最佳在耳机上观看的形式。合成器还可以将各个层合成在一起。 
例如，如果需要单视场抬头显示器，其中两个眼睛的视图相同，则 
可以提供包含该元件的单个纹理作为在每个眼睛视图上方合成的单 
独层。纹理可以是不同的分辨率和格式，合成器负责转换到最终的 
眼睛缓冲区。这样做可以允许优化，例如动态降低三维场景层的分 
辨率，以节省渲染时间[619,1357,1805]，同时保持其他层的高分辨 
率和质量[1311]。为每个2SomeAPI组成图像后，将单个目标拆 
分为两个视图。21.3。API和硬件925图21.5。在左边，显示图像 
中的红色区域显示渲染然后扭曲的像素，但HMD用户不可见。请 
----------------------- Page 1007-----------------------
注意，黑色区域位于变换后的渲染图像的边界之外。在右侧，这些 
红色区域在渲染开始时被红色边缘网格预先掩盖，导致这个渲染（预 
扭曲）图像需要更少的像素被遮蔽[1823]。将右图与原图进行比较， 
如图21.3左侧所示。（图片由Valve提供。）SDK执行眼睛，扭 
曲，色差和所需的任何其他过程，然后显示结果。如果您依赖API， 
则无需完全理解其中某些步骤背后的算法，因为供应商为您完成了 
大部分工作。然而，了解这个领域还是值得的，如果只是意识到最 
明显的解决方案并不总是最好的解决方案。首先，考虑合成。最有 
效的方法是首先将所有层合成在一起，然后在该单个图像上应用各 
种校正措施。相反，Oculus首先分别对每一层执行这些校正，然后 
合成这些扭曲的层以形成最终的显示图像。一个优点是每个层的图 
像以其自身的分辨率扭曲，这可以改善文本质量，例如，因为单独 
处理文本意味着在失真过程期间的重采样和过滤仅关注文本的内容 
[1311]。用户感知的视野大致为圆形。这意味着我们不需要渲染每 
个图像周边的一些像素，靠近角落。虽然这些像素将出现在显示器 
上，但观察者几乎检测不到它们。为了避免浪费时间生成这些，我 
们可以首先渲染网格以隐藏我们生成的原始图像中的这些像素。此 
网格将作为掩码渲染到模板缓冲区中，或者渲染到前面的z缓冲区 
中。然后在评估之前丢弃这些区域中的后续渲染片段。Vlachos 
[1823]报道，这使 HTCVive的填充率降低了约17％。见图21.5。 
Valve的OpenVRAPI将这个预渲染模板称为 “隐藏区域网格”。 
一旦我们获得了渲染图像，就需要对其进行扭曲以补偿系统光学系 
----------------------- Page 1008-----------------------
统的失真。其概念是将原始图像重新映射到所需的显示形状，如图 
21.3所示。换句话说，给定输入渲染图像上的像素样本，此样本在 
显示的图像中移动到何处？光线投射方法可以给出精确的答案并根 
据波长进行调整[1423]，但对于大多数硬件来说是不切实际的。一 
种方法是92621.虚拟和增强现实图21.6。在左侧，显示最终显示 
图像的网格。实际上，这个网格可以修剪回到右边的剔除版本，因 
为绘制黑色三角形不会给最终图像增加任何内容[1823]。（图片由 
Valve提供。）将渲染图像视为纹理，并绘制一个填充屏幕的四边 
形以运行后处理。像素着色器计算此纹理上与输出显示像素[1430] 
对应的确切位置。然而，这种方法可能很昂贵，因为该着色器必须 
评估每个像素处的失真方程。将纹理应用于三角形网格更有效。可 
以通过失真方程修改此网格的形状并进行渲染。仅对网格进行一次 
变形将无法校正色差。三组独立的（u，v）坐标用于扭曲图像，每 
个颜色通道一个[1423,1823]。也就是说，网格中的每个三角形都渲 
染一次，但是对于每个像素，渲染的图像在略微不同的位置被采样 
三次。然后，这些红色，绿色和蓝色通道值形成输出像素的颜色。 
我们可以对渲染图像应用规则间隔的网格并对显示的图像进行扭 
曲，反之亦然。将网格化网格应用于显示的图像并且回退到渲染图 
像的优点是可能生成更少的2×2个四边形，因为不会显示细的三角 
形。在这种情况下，网格位置不会变形，而是呈现为网格，并且仅 
调整顶点的纹理坐标以扭曲应用于网格的图像。典型的网格是每只 
眼睛48×48个四边形。见图21.6。通过使用每通道显示到渲染图 
----------------------- Page 1009-----------------------
像变换，为该网格计算纹理坐标一次。通过将这些值存储在网格中， 
在着色器执行期间不需要复杂的变换。GPU支持各向异性采样和纹 
理过滤可用于产生清晰的可显示图像。图21.5右侧的渲染立体声对 
被显示网格扭曲。在此图像中心删除的切片对应于扭曲变换如何生 
成可显示图像 - 请注意图21.5中左侧显示版本中图像所遇到的切 
片的缺失方式。通过将显示的变形网格修剪回仅可见区域，如图21.6 
右侧所示，我们可以将最终失真传递的成本降低约 15％。为了总结 
所描述的优化，我们首先绘制一个隐藏区域网格，以避免评估我们 
知道将无法检测或未使用的区域中的碎片（例如 21.3.API和硬件 
927中间切片）。我们为双眼渲染场景。然后，我们将此渲染图像 
应用于网格化网格，该网格已被修剪为仅包含相关的渲染区域。将 
此网格渲染到新目标会使我们显示图像。这些优化中的部分或全部 
内置于虚拟和增强现实系统的API支持中。21.3.1立体渲染渲染两 
个单独的视图似乎是渲染单个视图的两倍。然而，正如威尔逊所指 
出的[1891]，即使是一个天真的实施，也不是这样。阴影贴图生成， 
模拟和动画以及其他元素与视图无关。像素着色器调用的数量不会 
加倍，因为显示本身在两个视图之间被分成两半。同样，后处理效 
果取决于分辨率，因此这些成本也不会改变。然而，依赖于视图的 
顶点处理加倍，并且许多人已经探索了降低此成本的方法。在任何 
网格沿着GPU的管道发送之前，通常会执行Frustum剔除。单个 
平截头体可以用于包括两个眼睛截头[453,684,1453]。由于在渲染 
之前发生了剔除，因此可以在剔除之后检索要使用的精确渲染视图。 
----------------------- Page 1010-----------------------
然而，这意味着在剔除期间需要安全裕度，因为这样检索的一对视 
图可以以其他方式查看由平截头体移除的模型。Vlachos [1823]建 
议在预测剔除的视野中增加约 5度。Johansson [838]讨论了如何 
将截头剔除和其他策略（例如实例化和遮挡剔除查询）组合用于大 
型建筑模型的VR显示。渲染两个立体视图的一种方法是在一系列 
中完成，一个视图完全渲染，另一个视图渲染。实施起来微不足道， 
这具有明显的缺点，即状态变化也会加倍，这是需要避免的（第 
18.4.2节）。对于基于图块的渲染器，频繁更改视图和渲染目标 （或 
剪刀矩形）将导致可怕的性能。一个更好的选择是每次渲染每个对 
象两次，在两者之间切换摄像机变换。但是，API绘制调用的数量 
仍然增加一倍，从而导致额外的工作。我们想到的一种方法是使用 
几何着色器复制几何体，为每个视图创建三角形。例如，DirectX11 
支持几何着色器将其生成的三角形发送到单独的目标。不幸，已经 
发现这种技术可以将几何吞吐量降低三倍或更多，因此在实践中不 
使用。更好的解决方案是使用实例化，其中每个对象的几何体通过 
单个绘制调用绘制两次[838,1453]。用户定义的剪裁平面设置为使 
每个眼睛的视图分开。使用实例化比使用几何着色器快得多，并且 
除了任何额外的 GPU 支持之外是一个很好的解决方案 
[1823,1891]。另一种方法是在渲染一只眼睛的图像时形成命令列表 
 （第18.5.4节），将参考的常量缓冲移位到另一只眼睛的变换，然 
后重放该列表以渲染第二只眼睛的图像[453,1473]。92821.虚拟和 
增强现实有几种扩展可以避免在管道中发送两次（或更多）几何。 
----------------------- Page 1011-----------------------
在某些手机上，OpenGLES3。称为多视图的0扩展增加了对仅发 
送几何体并将其渲染为两个或更多视图的支持，从而调整屏幕顶点 
位置和任何视图相关变量[453,1311]。扩展为实现立体渲染器提供 
了更多自由。例如，最简单的扩展可能是在驱动程序中使用实例化， 
发布几何几何，而需要GPU支持的实现可以将每个三角形发送到每 
个视图。不同的实现具有各种优点，但由于API成本总是降低，因 
此这些方法中的任何一种都可以帮助CPU绑定应用程序。例如，更 
复杂的实现可以增加纹理高速缓存效率[678]并且仅执行与视图无 
关的属性的顶点着色。理想的情况下，可以为每个视图设置整个矩 
阵，并且还可以为每个视图着色任何每顶点属性。为了使硬件实现 
使用更少的晶体管，GPU可以实现这些功能的子集。AMD 和 
NVIDIA提供针对VR立体声渲染而调整的多GPU解决方案。对于 
两个GPU，每个GPU都会呈现一个单独的眼睛视图。使用关联掩 
码，CPU为要接收特定API调用的所有GPU设置一个位。以这种 
方 式 ， 可 以 将 呼 叫 发 送 到 一 个 或 多 个 GPU 
[1104,1453,1473,1495]。使用关联掩码，如果右眼和左眼视图之 
间的调用不同，则仍需要调用API两次。供应商提供的另一种渲染 
方式是 NVIDIA所称的广播，其中双眼渲染是使用单个绘制调用提 
供的，即，它被广播到所有GPU。恒定缓冲器用于向不同的GPU 
发送不同的数据，例如眼睛位置。广播创建双眼图像时几乎没有单 
个视图的CPU开销，因为唯一的成本是设置第二个常量缓冲区。单 
独的GPU意味着单独的目标，但合成器通常需要单个渲染图像。有 
----------------------- Page 1012-----------------------
一个特殊的子矩形传输命令，可以在一毫秒或更短的时间内将渲染 
目标数据从一个GPU移动到另一个GPU[1471]。它是异步的，这 
意味着在GPU执行其他工作时可能会发生传输。两个GPU并行运 
行时，两者也可以分别创建渲染所需的阴影缓冲区。这是重复工作， 
但比尝试并行化GPU之间的过程和传输更简单，通常更快。整个双 
GPU设置导致大约30％到35％的渲染加速[1824]。对于已针对单 
个GPU进行调整的应用，多个GPU可以将其额外计算应用于其他 
样本，以获得更好的抗锯齿结果。立体视觉的视差对于附近的模型 
很重要，但对于远处的物体则可以忽略不计。Palandri和 Green 
[1346]通过使用垂直于视图方向的分离平面在移动GearVR平台上 
利用这一事实。他们发现大约 10米的飞机距离是一个很好的默认 
值。比此更接近的不透明物体以立体声渲染，而在两个立体相机之 
间放置单像摄像机以外的物体。为了最大限度地减少透支，首先绘 
制立体视图，然后，它们的深度缓冲区的交集用于初始化单个单视 
场渲染的z缓冲区。然后，这个远距离物体的图像被合成21.3。API 
和硬件929图21.7。左边是一只眼睛的渲染图像。右侧是用于显示 
的扭曲图像。注意中心的绿色椭圆是如何保持相同的区域。在外围， 
渲染图像中的较大区域（红色轮廓）与较小的显示区域相关联 
[1473]。（图片由NVIDIA公司提供。）每个立体视图。透明内容 
最后为每个视图呈现。虽然涉及更多，并且对于跨越分离平面的物 
体需要额外的通过，该方法产生了约25％的一致的总体节省，而没 
有质量或深度感知的损失。如图21.7所示，由于光学器件所需的失 
----------------------- Page 1013-----------------------
真，在每只眼睛的图像的周边产生更高密度的像素。另外，外围通 
常不太重要，因为用户在相当长的时间内朝向屏幕的中心看。由于 
这些原因，已经开发了各种技术用于在每只眼睛视图的周边上对像 
素施加较少的努力。降低沿周边分辨率的一种方法称为NVIDIA的 
多分辨率着色和AMD的可变速率着色。我们的想法是将屏幕划分 
为例如3×3的部分，并以较低的分辨率[1473]渲染周边区域，如图 
21.8所示。自从他们的Maxwell架构以来，NVIDIA一直支持这种 
分区方案，但是在 Pascal开启的情况下，支持更普遍的投影类型。 
这称为同时多投影（SMP）。几何图形可以通过多达16个单独的 
投影处理2个独立的眼睛位置，从而允许网格复制最多32次，而 
无需在应用程序方面支付额外费用。第二眼睛位置必须等于沿x轴 
的第一眼睛位置偏移。每个投影可以围绕轴独立地倾斜或旋转 
[1297]。使用SMP，可以实现镜头匹配的着色，其目标是更好地将 
渲染的分辨率与显示的分辨率相匹配。见图21.7。四挫折93021. 
虚拟和增强现实图21.8。假设我们想要在左边渲染视图，在周边使 
用较低的分辨率。我们可以根据需要降低任何区域的分辨率，但通 
常最好在共享边缘保持相同的分辨率。在右边，我们展示了蓝色区 
域的像素数减少了 50％，红色区域减少了75％。视场保持不变， 
但用于周边区域的分辨率降低。渲染倾斜平面，如图21.9左侧所示。 
这些经过修改的投影在图像中心提供更多的像素密度，在周边提供 
更少的像素密度。这使得截面之间的过渡比多分辨率着色更平滑。 
存在一些缺点，例如，需要重新设计诸如花朵之类的效果才能正确 
----------------------- Page 1014-----------------------
显示。Unity和虚幻引擎4已将此技术集成到他们的系统中[1055]。 
Toth等人。[1782]正式比较和对比这些和其他多视图投影算法，并 
且每眼使用多达3×3个视图以进一步减少像素着色。请注意，SMP 
可以同时应用于双眼，如图21.9右侧所示。为了节省片段处理，应 
用程序级方法（称为径向密度屏蔽）以四边形的棋盘图案呈现外围 
像素。换句话说，不渲染每隔2×2个四段的片段。然后使用后处理 
过程从其邻居重建丢失的像素[1824]。该技术可以如图21.9所示。 
左：同时多投影 （SMP），一只眼睛使用四个投影平面。右：SMP 
为两只眼睛中的每只眼睛使用四个投影平面。21.3。API和硬件931 
对于具有单个低端GPU的系统特别有价值。使用此方法渲染将减少 
像素着色器调用，如果跳过然后执行重建过滤器的成本太高，可能 
无法获得任何好处。索尼的伦敦工作室在此过程中更进了一步，从 
2×2的一组中删除了一个，两个或三个四边形，数字在图像边缘附 
近下降。以类似的方式填充缺失的四边形，并且每帧都改变抖动图 
案。应用时间抗锯齿也有助于隐藏阶梯式瑕疵。索尼的系统节省了 
大约25％的GPU时间[59]。另一种方法是每只眼睛渲染两个单独 
的图像，一个是中心圆形区域，另一个是形成周边的环。然后可以 
合成和扭曲这两个图像以形成该眼睛的显示图像。可以以较低的分 
辨率生成外围图像，以节省像素着色器调用，代价是发送几何图形 
以形成四个不同的图像。这种技术与GPU支持相吻合，可以将几何 
体发送到多个视图，并为具有两个或四个GPU的系统提供自然的工 
作分工。虽然由于 HMD中涉及的光学器件意味着减少周边上的过 
----------------------- Page 1015-----------------------
度像素阴影，但是Vlachos将这种技术称为固定的foveated渲染 
[1824]。这个术语是对更先进的概念，foveated渲染的参考。21.3.2 
FoveatedRendering要理解这种渲染技术，我们必须更多地了解 
我们的眼睛。中央凹是我们每只眼睛视网膜上的一个小凹陷，其中 
包含高密度的视锥细胞，与色觉有关的光感受器。我们的视力在这 
个领域是最高的，我们转动眼睛以利用这种能力，例如跟踪飞行中 
的鸟类或阅读页面上的文本。视敏度迅速下降，前30度从中央凹中 
心每2.5度下降约 50％，并且更加陡峭。我们的眼睛具有 114度水 
平度的双目视觉（两只眼睛可以看到同一物体）的视野。第一代消 
费者耳机的视野稍微小一些，双眼大约80到 100度，这可能会上 
升。从2016年开始，中心20度视野的面积约占显示器的显示器的 
3.6％，在2020年左右的预期下降到2％[1357]。在此期间，显示 
分辨率可能会上升一个数量级[8]。在视力低的区域，眼睛可以看到 
显示器像素的巨大优势，这提供了使用 foveated rendering 
[619,1358]执行更少工作的机会。我们的想法是以高分辨率和高质 
量渲染眼睛所在的区域，而不需要花费太多精力。问题是眼睛会移 
动，因此知道要渲染的区域会发生变化。例如，当研究物体时，眼 
睛执行称为扫视的一系列快速移位，以每秒900度的速度快速移动， 
即在90FPS系统中每帧可能移动 10度。精确的眼动追踪硬件可以 
通过在中心凹区域外执行较少的渲染工作来提供大的性能提升， 
93221.虚拟和增强现实，但这样的传感器是一项技术挑战[8]。另 
外，在外围渲染 “较大”像素往往会增加混叠问题。通过尝试保持 
----------------------- Page 1016-----------------------
对比度并避免随时间的大的变化，可以潜在地改善具有较低分辨率 
的外围区域的渲染，使得这些区域在感知上更可接受[1357]。 
Stengel等人。[1697]讨论了先前的foveated渲染方法，以减少着 
色器调用的数量并呈现它们自己的。21.4渲染技术对单个世界观有 
效的方法并不一定适用于两个。即使在立体声中，与在与观看者一 
起移动的屏幕相比，在单个固定屏幕上工作的技术之间存在相当大 
的差异。在这里，我们讨论可以在单个屏幕上正常工作的特定算法， 
但是对于VR和AR来说是有问题的。我们吸取了Oculus，Valve， 
EpicGames，微软等公司的专业知识。这些公司的研究继续被纳入 
用户手册并在博客中进行讨论，因此我们建议访问他们的网站以获 
取当前的最佳实践[1207,1311,1802]。正如前一节强调的那样，供 
应商希望您了解他们的SDK和API并适当地使用它们。视图很关键， 
因此请遵循供应商提供的头部模型，并使摄像机投影矩阵完全正确。 
应避免使用频闪灯等效果，因为闪烁会导致头痛和眼睛疲劳。在视 
野边缘附近闪烁会导致模拟器疾病。闪烁效果和高频纹理（如细条 
纹）也可以触发某些人的癫痫发作。基于监视器的视频游戏通常使 
用抬头显示器，其中包含有关健康，弹药或剩余燃料的重叠数据。 
但是，对于VR和AR，双目视觉意味着靠近观察者的物体在两只眼 
睛之间的偏移更大（第21.2.3节）。如果 HUD被放置在两只眼睛 
的屏幕的同一部分上，感知提示是HUD必须远离，如图21.4在923 
页所示。但是，HUD被绘制在所有东西的前面。这种感知不匹配使 
得用户难以融合两个图像并理解他们所看到的内容，并且它可能引 
----------------------- Page 1017-----------------------
起不适[684,1089,1311]。将要渲染的 HUD内容移动到眼睛附近的 
深度可以解决这个问题，但仍然以屏幕空间为代价。见图21.10。 
如果，例如，附近的墙壁比十字准线更接近，则仍然存在深度冲突 
的风险，因为十字线图标仍然在给定深度处呈现在顶部。投射光线 
并找到给定方向的最近表面深度可以以各种方式用于调整此深度， 
可以直接使用它，也可以根据需要平滑地移动它[1089,1679]。在某 
些情况下，凹凸贴图与任何立体观察系统的效果都很差，因为它看 
起来很简单，阴影涂在平面上。它可以用于精细的表面细节和远处 
的物体，但是对于代表较大几何形状并且用户可以接近的法线贴图， 
幻觉会迅速分解。21.4。渲染技术933图21.10。一个繁忙的抬头 
显示器占据了视野。注意必须如何为每只眼睛移动 HUD元素以避 
免混淆深度线索。更好的解决方案是考虑将这些信息放入虚拟世界 
本身或玩家头像中的设备或显示器，因为用户可以倾斜或转动头部 
[1311]。要在此处查看立体效果，请靠近并在图像之间垂直于页面 
放置一张小而硬的纸张，以便一只眼睛看着每一个。（图片由Oculus 
VR，LLC提供。）见图21.11。基本视差映射的游泳问题在立体声 
中更明显，但可以通过简单的校正因子来改善[1171]。在某些情况 
下，可能需要更昂贵的技术，例如陡峭的视差映射，视差遮挡映射 
 （第6.8.1节）或位移映射[1731]，以产生令人信服的效果。图 
21.11。用于较小表面特征的法线贴图，例如左侧和中间的两个纹理， 
可以在VR 中合理地工作。代表相当大的几何特征的凹凸纹理（例 
如右边的图像）在立体视觉中将无法令人信服[1823]。（图片由Valve 
----------------------- Page 1018-----------------------
提供。）93421.虚拟现实和增强现实当用立体声观看时，广告牌和 
冒名顶替者有时候不能令人信服，因为它们缺乏表面z深度。体积 
技术或网格可能更合适[1191,1802]。需要调整天空盒的大小，使其 
在 “无限远”或其附近渲染，即眼睛位置的差异不应影响其渲染。 
如果使用色调映射，它应该同等地应用于两个渲染图像，以避免眼 
睛疲劳[684]。屏幕空间环境遮挡和反射技术可能会产生不正确的立 
体差异[344]。类似地，需要以尊重每只眼睛视图的z深度的方式生 
成诸如花朵或耀斑的后处理效果，以使图像适当地融合。水下或热 
霾变形效果也可能需要返工。屏幕空间反射技术产生可能存在匹配 
问题的反射，因此反射探测可能更有效[1802]。甚至镜面突出显示 
也可能需要修改，因为立体视觉会影响光泽材料的感知方式。两个 
眼睛图像之间的高光位置可能存在很大差异。研究人员发现，修改 
这种差异可以使图像更容易融合并更具说服力。换一种说法，当计 
算光泽分量时，眼睛位置可以彼此更接近地移动。相反，距离中物 
体的高光差异可能在图像之间难以察觉，可能导致共享阴影计算 
[1781]。如果计算完成并存储在纹理空间中，则可以在眼睛的图像 
之间共享阴影[1248]。对VR显示技术的要求非常高。而不是使用 
具有 50度水平视场的监视器，导致每度可能大约 50个像素，VR 
显示器上的 110度视野导致Vive 1080的每度约15个像素[1823] 
每只眼睛×1200像素显示。从渲染图像到显示图像的变换也使得重 
新采样和过滤的过程复杂化。用户的头部不断移动，即使只是一点 
点，导致时间混叠增加。由于这些原因，高质量抗锯齿实际上是提 
----------------------- Page 1019-----------------------
高图像质量和融合的必要条件。虽然至少有一支索尼团队已成功使 
用它，但由于潜在的模糊，通常建议使用时间抗锯齿[344][59]。他 
们发现存在权衡取舍，但删除闪烁像素比提供更清晰的图像更为重 
要。但是，对于大多数VR应用程序，MSAA提供的更清晰的视觉 
效果是首选[344]。请注意，4×MSAA是好的，8×更好，并且如果 
你能负担得起，还会更好地抖动超级采样。这种对 MSAA的偏好不 
利于使用各种延迟渲染方法，这对于每个像素的多个样本来说是昂 
贵的。在VR显示器上，在阴影表面上缓慢变换的颜色 （第23.6节） 
可能会特别明显。可以通过添加一点抖动噪声来掩盖这种伪像 
[1823]。不应使用运动模糊效果，因为它们使图像变得混乱，超出 
由于眼睛运动而产生的任何伪影。这种效果与以90FPS运行的VR 
显示器的低持久性特性不一致。因为我们的眼睛确实会进入广阔的 
视野，通常是快速（扫视），应该避免景深技术。这样的方法使得 
场景周边的内容看起来模糊，没有真正的原因，并且可能导致模拟 
器疾病[1802,1878]。21.4。渲染技术 935 CPU GPU合成器图 
21.12。抖动。连续显示四个帧，CPU和GPU尝试为每个帧计算图 
像。以粉红色显示的第一帧图像将及时计算，以将其发送到此帧的 
合成器。蓝色的下一个图像未及时完成以便在第二帧中显示，因此 
必须再次显示第一个图像。绿色第三图像再次未准备就绪，因此（现 
在完成的）第二图像被发送到第三帧的合成器。橙色的第四张图像 
及时完成，因此显示。请注意，第三帧渲染计算的结果永远不会显 
示。 （Oculus之后的插图[1311]。）混合现实系统带来了额外的挑 
----------------------- Page 1020-----------------------
战，例如将类似的照明应用于虚拟对象，就像现实环境中存在的那 
样。在某些情况下，可以预先控制真实世界的照明并将其转换为虚 
拟照明。如果不可能，您可以使用各种光估计技术来捕捉和近似环 
境的光照条件。Kronander等。[942]提供对各种照明捕获和表示方 
法的深入调查。21.4.1抖动即使在虚拟世界和现实世界之间有完美 
的跟踪和适当维护的对应关系，延迟仍然是一个问题。生成45到 
120FPS的图像需要有限的时间，这是一系列VR设备的更新速率 
[125]。当未及时生成图像以发送到合成器并显示时，会发生丢帧。 
对OculusRift早期发射标题的检查显示，它们的帧数下降了约5％ 
[125]。丢帧会增加抖动感，VR头戴式耳机中的拖尾和频闪伪影， 
当眼睛相对于显示器移动时最明显。见图21.12。如果在帧的持续 
时间内像素被照亮，则在眼睛的视网膜上接收涂片。降低持久性， 
在帧期间显示器点亮像素的时间长度，可以减少拖尾。然而，它可 
以反而导致频闪，其中如果帧之间存在大的变化，则感知到多个单 
独的图像。Abrash [7]深入讨论了颤抖以及它与显示技术的关系。 
供应商提供的方法可以帮助最大限度地减少延迟和抖动效应。 
Oculus称之为时间扭曲和空间扭曲的一组技术，可以生成图像并对 
其进行扭曲或修改，以更好地匹配用户的方向和位置。开始，想象 
我们没有丢帧，我们发现用户正在转动他们的头部。我们使用检测 
到的旋转来预测每只眼睛的位置和视线方向。通过完美预测，我们 
生成的图像完全符合要求。93621.虚拟现实和增强现实反而说用户 
正在转动并且正在放慢速度。对于这种情况，我们的预测会超调， 
----------------------- Page 1021-----------------------
生成的图像比显示时的位置略高。除了速度之外估计旋转加速度可 
以帮助改进预测[994,995]。丢帧时会出现更严重的情况。在这里， 
我们必须使用前一帧的图像，因为需要将某些内容放在屏幕上。鉴 
于我们对用户观点的最佳预测，我们可以修改此图像以近似丢失帧 
的图像。我们可以执行的一个操作是二维图像扭曲，Oculus称之为 
时间扭曲。它仅补偿头部姿势的旋转。这种扭曲操作是一种快速纠 
正措施，比无所事事要好得多。VanWaveren [1857]讨论了各种时 
间扭曲实现的权衡，包括那些在CPU和数字信号处理器 （DSP）上 
运行的实现，得出的结论是GPU是迄今为止最快的任务。大多数 
GPU可以在不到半毫秒的时间内执行此图像扭曲过程[1471]。旋转 
先前显示的图像可以使显示图像的黑色边框在用户的周边视觉中可 
见。渲染比当前帧所需的图像更大的图像是避免此问题的一种方法。 
在实践中，然而，这个边缘区域几乎不明显[228,1824,1857]。超越 
速度，纯旋转翘曲的一个优点是场景中的其他元素都是一致的。用 
户实际上处于环境天空盒的中心 （第 13.3节），仅改变视图方向和 
方向。该技术速度快，适用于它的功能。丢失的帧足够糟糕，但由 
于间歇性丢帧导致的可变和不可预测的延迟似乎会更快地导致模拟 
器疾病[59,1311]。为了提供更平滑的帧速率，Valve在检测到帧丢 
失时启动了交错重投影系统，将渲染速率降低到45 FPS并且每隔一 
帧变形。同样，PLAYSTATION上的一个VR版本具有 120Hz的刷 
新率，其中渲染以60赫兹进行，并进行重投影以填充交替帧[59]。 
仅纠正轮换并不总是足够的。即使用户没有移动或移动他们的位置， 
----------------------- Page 1022-----------------------
当头部旋转或倾斜时，眼睛也会改变位置。例如，当仅使用图像变 
形时，眼睛之间的距离看起来会变窄，因为对于指向不同方向的眼 
睛，使用眼睛分离生成新图像[1824]。这是次要的效果，但如果观 
察者附近有物体，或者观察者俯视纹理地平面，则不能正确补偿位 
置变化会导致用户迷失方向和疾病。要调整位置变化，您可以执行 
完整的三维重投影 （第 12.2节）。图像中的所有像素都具有与它们 
相关联的深度，因此可以将该过程视为将这些像素投影到它们在世 
界中的位置，移动眼睛位置，然后将这些点重新投影回屏幕。Oculus 
将此过程称为位置时间扭曲[62]。除了纯粹的费用之外，这样的过 
程有几个缺点。一个问题是当眼睛移动时，一些表面可能进入或离 
开视野。这可以以不同的方式发生，例如，立方体的面可以变得可 
见，或者视差可以导致前景中的对象21.4。渲染技术937相对于背 
景移动，因此隐藏或显示那里的细节。重投影算法尝试识别不同深 
度的物体，并使用局部图像变形来填充找到的任何间隙[1679]。这 
种技术可以导致断裂痕迹，其中翘曲使得远处细节看起来随着物体 
在它们前面经过而移动和动画。基本重投影不能处理透明度，因为 
只知道一个表面的深度。例如，这种限制可能会影响粒子系统的外 
观[652,1824]。图像扭曲和重投影技术的问题在于碎片的颜色是相 
对于旧位置计算的。我们可以改变这些碎片的位置和可见度，但任 
何镜面高光或反射都不会改变。即使表面本身完美移动，掉落的框 
架也可以从这些表面高光显示抖动。即使没有任何头部运动，这些 
方法的基本版本无法补偿场景中的物体移动或动画[62]。只知道表 
----------------------- Page 1023-----------------------
面的位置，而不是它们的速度。因此，对于外推图像，对象看起来 
不会在帧与帧之间移动。物体的运动可以在速度缓冲器中捕获，如 
第 12.5节中所述。这样做允许重投影技术也适应这些变化。旋转和 
位置补偿技术通常在单独的异步过程中运行，作为防止帧丢失的一 
种形式。Valve调用此异步重投影，以及Oculus异步时间扭曲和异 
步空间扭曲。Spacewarp通过分析先前的帧来推断遗漏的帧，考虑 
到摄像头和头部平移以及动画和控制器的运动。spacewarp中不使 
用深度缓冲区。与正常渲染一起，外推图像同时独立计算。基于图 
像，此过程需要相当可预测的时间量，这意味着如果渲染无法及时 
完成，则通常可以使用重新投影的图像。因此，不是决定是继续尝 
试完成框架还是使用timewarp或spacewarp重投影，而是完成两 
者。如果框架未及时完成，则可以使用spacewarp结果。硬件要求 
适中，这些变形技术主要是为了帮助功能较少的系统。Reed和 
Beeler[1471]讨论了可以实现GPU共享的不同方式以及如何有效 
地使用异步扭曲，Hughes等人也是如此。[783]。旋转和定位技术 
是互补的，每个都提供了自己的改进。当观看远处的静态场景或图 
像时，旋转翘曲可以很好地适应头部旋转。位置重投影适用于附近 
的动画对象[126]。方向的变化通常会引起比位置偏移更严重的配准 
问题，因此即使只是旋转校正也能提供相当大的改进[1857]。我们 
在这里的讨论涉及这些补偿过程背后的基本思想。关于这些方法的 
技术挑战和局限性，肯定有更多的文章，我们将感兴趣的读者引用 
到相关参考文献[62,125,126,228,1311,1824]。93821.虚拟和增强 
----------------------- Page 1024-----------------------
现实21.4.2时序虽然异步时间扭曲和空间扭曲技术可以帮助避免抖 
动，但保持质量的最佳建议是应用程序本身尽可能避免丢帧 
[59,1824]。即使没有颤动，我们也注意到用户在显示时的实际姿势 
可能与预测的姿势不同。因此，称为后期定向变形的技术可能有助 
于更好地匹配用户应该看到的内容。想法是获取姿势并像往常一样 
生成框架，然后在框架中生成框架以检索姿势的更新预测。如果此 
新姿势与用于渲染场景的原始姿势不同，则在该帧上执行旋转扭曲 
 （timewarp）。由于翘曲通常不到半毫秒，这种投资通常是值得的。 
在实践中，这种技术通常是合成器本身的责任。通过使用称为延迟 
锁定[147,1471]的技术使该过程在单独的CPU线程上运行，可以最 
小化获得此后期方向数据所花费的时间。该CPU线程周期性地将预 
测的姿势发送到GPU的私有缓冲区，该私有缓冲区在扭曲图像之前 
的最后可能时刻获取最新设置。延迟锁存可用于将所有头部姿势数 
据直接提供给GPU。这样做的局限性在于，当时只有GPU提供了 
此信息，因此每个眼睛的视图矩阵都不可用于应用程序。AMD有一 
个名为最新数据锁存器的改进版本，这允许GPU在需要这些数据时 
抓取最新的姿势[1104]。您可能已经在图21.12中注意到CPU和 
GPU存在相当长的停机时间，因为CPU在合成器完成之前不会开 
始处理。这是单CPU系统的简化视图，其中所有工作都在一个帧中 
进行。如第 18.5节所述，大多数系统都有多个CPU，可以通过多 
种方式保持工作。在实践中，CPU经常处理冲突检测，路径规划或 
其他任务，并为GPU准备数据以在下一帧中进行渲染。完成流水线 
----------------------- Page 1025-----------------------
操作，其中GPU可以处理CPU在前一帧中设置的任何内容[783]。 
为了有效，每帧的CPU和GPU工作应该少于一帧。见图21.13。 
合成器通常使用一种方法来知道GPU何时完成。称为围栏，它由应 
用程序作为命令发出，并在完全执行之前完成所有GPU调用时发出 
信号。Fences对于了解GPU何时完成各种资源非常有用。图中所 
示的GPU持续时间表示渲染图像所花费的时间。一旦合成器完成创 
建并显示最终帧，GPU就可以开始渲染下一帧。CPU需要等到合成 
完成才能在下一帧向GPU发出命令。但是，如果我们等到显示图像， 
那么当应用程序在CPU上生成新命令时会花费时间，这些命令由驱 
动程序解释，并且命令最终发布到GPU。在这段时间，这可能高达 
2毫秒，GPU处于空闲状态。Valve和Oculus通过提供称为21.4 
的支持来避免这种停机。渲染技术939CPUGPU合成器图21.13。 
流水线。为了最大限度地利用资源，CPU在一帧中执行任务，GPU 
用于在下一帧中进行渲染。通过使用前面的运行启动/自适应队列， 
可以将底部显示的间隙添加到每个帧的GPU执行时间。分别在前面 
运行启动和自适应队列。这种技术可以在任何系统上实现。目的是 
让GPU在完成前一帧之后立即开始工作，通过预期完成前一帧的时 
间并在此之前发出命令。大多数VRAPI提供了一些隐式或显式机 
制，用于以常规节奏释放应用程序以在下一帧上工作，并且有足够 
的时间来最大化吞吐量。我们在此流水线部分和此差距中提供了简 
化视图，以便了解此优化的好处。有关流水线和时间策略的深入讨 
论，请参阅Vlachos的[1823]和 Mah的[1104]演讲。我们在此结 
----------------------- Page 1026-----------------------
束对虚拟和增强现实系统的讨论。考虑到写作和出版之间的滞后， 
我们期望出现任何数量的新技术并取代这里提出的技术。我们的主 
要目标是提供这个快速发展的领域所涉及的渲染问题和解决方案的 
感觉。最近研究探索的一个迷人方向是使用光线投射进行渲染。例 
如，Hunt[790]讨论了可能性，并提供了一种开源CPU/ GPU混 
合光线施法者，每秒评估超过 100亿条光线。Raycast直接解决了 
基于光栅化器的系统面临的许多问题，例如宽视场和镜头失真，同 
时也适用于foveated渲染。McGuire[1186]注意到在滚动显示器 
显示它们之前如何在像素处投射光线，从而将系统中该部分的延迟 
减少到几乎没有。这一点，以及许多其他研究计划，使他得出结论， 
我们将来会使用VR而不是称之为VR，因为它只是每个人的计算界 
面。进一步阅读和资源Abrash的博客[5]有关于虚拟现实显示，延 
迟，抖动和其他相关主题的基础知识的有价值的文章。对于有效的 
应用程序设计和渲染技术，Oculus最佳实践网站[1311]和博客[994] 
提供了许多有用的信息，EpicGames的虚幻VR页面[1802]也是如 
此。您可能希望学习94021.虚拟和增强现实OpenXR作为跨平台 
虚拟现实开发的代表性API和架构。Ludwig将Team Fortress2 
转换为VR [1089]的案例研究涵盖了一系列用户体验问题和解决方 
案。McGuire[1186,1187]概述了 NVIDIA在VR和AR的许多领域 
的研究工作。Weier等。[1864]提供了一份全面的最新报告，该报 
告讨论了人类视觉感知以及如何在计算机图形学中利用其局限性。 
由Patney[1358]组织的SIGGRAPH2017课程包括与视觉感知相 
----------------------- Page 1027-----------------------
关的虚拟和增强现实研究的演示。Vlachos 的 GDC 演示文稿 
[1823,1824]讨论了有效渲染的具体策略，并提供了我们仅简要介绍 
的几种技术的更多细节。NVIDIA的GameWorks博客[1055]包含 
有关VR的GPU改进以及如何最好地使用它们的有价值的文章。休 
斯等人。[783]提供有关使用XPerf，ETW和GPUView工具调整 
VR渲染系统以获得良好性能的深入教程。Schmalstieg和 Hollerer 
最近的着作 “增强现实”[1570]涵盖了与该领域相关的各种概念， 
方法和技术。第22章交叉口测试方法 “我会坐下来看看那个小帆船 
是否会撞到或错过月球。 “-RobertFrostIntersection测试通常用 
于计算机图形学。我们可能希望确定两个物体是否发生碰撞，或者 
找到到地面的距离，以便我们可以将相机保持在恒定的高度。另一 
个重要用途是找出是否应该将对象发送到管道中。所有这些操作都 
可以通过相交测试来执行。在本章中，我们将介绍最常见的光线/ 
对象和对象/对象相交测试。在也构建在层次结构上的冲突检测算法 
中，系统必须决定两个原始对象是否发生冲突。这些对象包括三角 
形，球体，轴对齐边界框（AABB），定向边界框（OBB）和离散 
定向多面体 （k-DOP）。正如我们在第 19.4节中看到的，视锥体剔 
除是一种有效地丢弃视锥体外的几何体的方法。使用此方法需要测 
试以确定边界体积 （BV）是完全在外部，完全在内部还是部分在平 
截头体内部。在所有这些情况下，我们遇到了一类需要相交测试的 
问题。交点测试确定两个对象A和 B是否相交，这可能意味着A完 
全在 B内（或反之亦然），A和 B的边界相交，或者它们是不相交 
----------------------- Page 1028-----------------------
的。但是，有时可能需要更多信息，例如与某个位置的最近交叉点， 
或穿透的数量和方向。在本章中，我们将重点介绍快速交叉测试方 
法。我们不仅介绍基本算法，同时也就如何构建新的高效交叉口测 
试方法提出建议。当然，本章介绍的方法也可用于离线计算机图形 
应用程序。例如，第22.6至22.9节中介绍的光线交叉算法用于光 
线追踪程序。在简要介绍硬件加速拣选方法之后，本章继续介绍一 
些有用的定义，然后是形成边界体积的算法94194222.基元周围 
的交叉测试方法。接下来介绍构建有效交叉测试方法的经验法则。 
最后，本章的大部分内容包括交叉测试方法的食谱。22。1GPU加 
速拣选通常希望让用户通过用鼠标或任何其他输入设备拾取 （点击） 
某个对象来选择某个对象。当然，这种操作的性能需要很高。如果 
您需要屏幕上某点或更大区域的所有对象，无论可见性如何，都可 
以保证CPU端选择解决方案。有时会在建模或CAD软件包中看到 
这种类型的拾取。它可以通过使用边界体积层次结构在CPU上有效 
地解决 （第 19.1.1节）。在像素的位置处形成光线，从视锥体的近 
平面到远平面。然后根据需要测试该光线与边界体积层次的交集， 
类似于在全局照明算法中加速跟踪光线所做的操作。对于由用户在 
屏幕上定义矩形而形成的矩形区域，我们将创建一个平截头体而不 
是光线，并根据层次结构对其进行测试。根据要求，CPU上的交叉 
点测试有几个缺点。除非在网格本身上施加诸如层次结构或网格之 
类的加速结构，否则具有数千个三角形的网格可能变得昂贵以三角 
形测试三角形。如果精度很重要，则需要通过CPU匹配由位移映射 
----------------------- Page 1029-----------------------
或GPU细分生成的几何体。对于树映射对象 （例如树叶），用户不 
应该选择完全透明的纹理像素。需要对CPU进行大量的工作来模拟 
纹理访问，以及因任何原因丢弃纹素的任何其他着色器。通常我们 
只需要在屏幕的像素或区域中可见的内容。对于此类选择，请使用 
GPU管道本身。Hanrahan和 Haeberli[661]首先提出了一种方法。 
为了支持拾取，使用具有唯一标识符值的每个三角形，多边形或网 
格对象来渲染场景，该标识符值可以被认为是颜色。这个想法与可 
见性缓冲区的意图类似，形成类似于第906页的图20.12中的图像。 
所形成的图像存储在屏幕外，然后用于极快速的拾取。当用户点击 
像素时，在该图像中查找颜色标识符并立即识别该对象。在使用简 
单着色器执行标准渲染时，可以将这些标识符值渲染到单独的渲染 
目标，因此成本相对较低。主要费用可能是从GPU读取像素到CPU。 
像素着色器接收或计算的任何其他类型的信息也可以存储在屏幕外 
目标中。例如，法线或纹理坐标是明显的候选者。通过利用插值， 
使用这样的系统[971]也可以找到三角形内的点的相对位置。在单独 
的渲染目标中，每个三角形都呈现为三角形顶点的颜色为红色22.2。 
定义和工具943 （255,0,0），绿色 （0,255,0）和蓝色 （0,0,255）。 
假设所选像素的插值颜色为 （23,192,40），这意味着红色顶点的贡 
献为23/255，绿色为192/255，红色为40/255。值是重心坐标， 
这些将在第22.8.1节中进一步讨论。使用GPU的挑选最初是作为 
三维绘画系统的一部分呈现的。这种拾取特别适用于这样的系统， 
其中相机和物体不移动，因为整个拾取缓冲器可以产生一次并重复 
----------------------- Page 1030-----------------------
使用。对于相机移动时的拾取，另一种方法是使用聚焦在屏幕的微 
小部分上的离轴相机将场景再次渲染到微小的目标，例如3×3。CPU 
侧平截头体剔除应该消除几乎所有的几何形状，并且只有几个像素 
被遮挡，使得这种通过相对较快。对于拾取所有对象（不仅仅是可 
见对象），可以使用深度剥离或仅仅渲染先前选择的对象来执行这 
种小窗口方法多次[298]。22。2定义和工具本节介绍对整章有用的 
符号和定义。射线r （t）由原点o和方向矢量d定义 （为方便起见， 
通常归一化，因此||d || =1）。其数学公式如公式22.1所示，光 
线图示如图22.1所示：r （t）=o +td。（22.1）标量t是一个变 
量，用于在射线上产生不同的点，其中小于零的t值据说位于射线 
原点后面（因此不是射线的一部分），并且正面t值位于它前面。 
此外，由于光线方向被归一化，因此t值在光线上产生与光线原点 
相距t个单位的点。在实践中，我们通常还存储当前距离l，这是我 
们想要沿着光线搜索的最大距离。例如，在拾取时，我们通常希望 
沿着光线最近的交叉点;可以安全地忽略此交叉点之外的对象。r（t） 
=o +tdod图22.1。一个简单的射线及其参数：o （射线原点）， 
d （射线方向）和t，它在射线上产生不同的点，r （t）=o +td。 
94422.交叉点测试方法距离l从∞开始。当对象成功交叉时，l用交 
叉点距离更新。设置 l后，光线成为用于测试的线段。在我们将讨 
论的射线/物体交叉测试中，我们通常不会在讨论中包括 l。如果你 
想使用 l，你所要做的就是进行普通的射线/物体测试，然后根据计 
算的交叉点距离检查 l并采取适当的操作。在谈论曲面时，我们将 
----------------------- Page 1031-----------------------
隐式曲面与显式曲面区分开来。隐式表面由公式22.2定义：f （p） 
=f （px，py，pz）=0. （22.2）这里，p是表面上的任何点。这意 
味着，如果你有一个位于曲面上的点并将此点插入f，则结果将为0. 
否则，f的结果将为非零。隐式表面的示例是p2x +p2y +p2z= 
r2，其描述位于具有半径r的原点的球体。很容易看出，这可以改 
写为f （p）=p2x +p2y +p2z。r2=0，这意味着它确实是隐含 
的。第 17.3节简要介绍了隐式曲面，而Gomes等人则详细介绍了 
使用各种隐式曲面类型进行建模和渲染。[558]和deAra'ujo等人。 
[67]。另一方面，显式表面由矢量函数f和一些参数 （ρ，φ）定义， 
而不是表面上的点。这些参数在表面上产生点p。下面的公式22.3 
显示了一般概念：p =。。pxpypz。。=f （ρ，φ）=。。fx （ρ， 
φ）fy （ρ，φ）fz （ρ，φ）。.. （22.3）显式曲面的一个例子是球 
体，这个时间以球坐标表示，其中ρ是纬度和经度，如公式22.4所 
示：f （ρ，φ）=。。rsinρcosφrsinρsinφrcosρ。.. （22.4）作为 
另一个例子，三角形△v0v1v2可以用这样的显式形式描述：t （u，v） 
= （1.u.v）v0 +uv1 +vv2，其中u≥0，v ≥0且 u +v≤1必须保 
持。最后，我们将给出除球体之外的一些常见边界体积的定义。定 
义。轴对齐的边界框（也称为矩形框），简称AABB，是一个面， 
其面具有与标准基轴重合的法线。例如，AABBA 由两个对角相对 
的点amin和amax描述，其中amini≤amaxi，.i∈{x，y，z}。图 
22.2包含三维AABB和符号的图示。22.2。定义和工具945xyz 
aminamax图22.2。三维AABB，A，具有极值点，amin和amax， 
----------------------- Page 1032-----------------------
以及标准基础的轴。定义。定向边界框 （简称OBB）是一个框，其 
面具有全部成对正交的法线 - 即，它是任意旋转的AABB。OBB， 
B，可以通过框的中心点bc和描述盒子侧面方向的三个归一化矢量 
bu，bv和 bw来描述。它们各自的正半长度表示为 hBu，hBv和 
hBw，其是从bc到相应面的中心的距离。三维OBB及其表示法如 
图22.3所示。定义。k-DOP （离散定向多面体）由k/ 2 （其中k 
是偶数）定义的归一化法线（取向），ni，1≤i≤k/2，并且每个ni 
两个相关的标量值dmini和dmaxi定义，其中dmini <dmaxi。 
每个三元组（ni，dmini，dmaxi）描述了一个平板Si，它是两个 
平面之间的体积，πmini：ni·x +dmini=0和πmaxi：ni·x +dmax 
i =0，并且所有板的交点T1≤l≤k/2 Sl是实际的 k-DOP体积。 
k-DOP被定义为绑定图22.3的最紧密的平板组。三维OBB，B， 
其中心点，bc及其归一化的正向侧向量bu，bv和bw。如图所示， 
侧面的半长度hBu，hBv和hBw是从盒子中心到面部中心的距离。 
94622。交点测试方法minmax图22.4。用于茶杯的二维8-DOP 
的示例具有所有法线ni，与第一板S1一起示出，S1和板的“尺寸”： 
dmin1和dmax1。对象[435]。AABB和OBB可以表示为6-DOP， 
因为每个具有由三个板定义的六个平面。图22.4描绘了二维的 
8-DOP。对于凸多面体的定义，使用平面的半空间的概念是有用的。 
正半空间包括所有点x，其中n·x +d≥0，负半空间为n·x +d≤0。 
定义。凸多面体是由p平面的负半空间的交点定义的有限体积，其 
中每个平面的法线指向远离多面体。AABB，OBB和k-DOP，以及 
----------------------- Page 1033-----------------------
任何视锥体，都是凸多面体的特殊形式。更复杂的k-DOP和凸多面 
体主要用于碰撞检测算法，其中计算底层网格的精确交叉可能是昂 
贵的。用于形成这些边界体积的额外平面可以修剪来自对象的额外 
体积，从而证明所涉及的额外成本是合理的。另外两个感兴趣的边 
界体积是线扫掠球体和矩形扫掠球体。这些通常也分别称为胶囊和 
锭剂，实例如图22.5所示。分离轴指定一条线，其中两个不重叠的 
对象（不相交）在该线上具有也不重叠的投影。类似地，在可以在 
两个三维物体之间插入平面的情况下，该平面的法线定义分离轴。 
接下来是一个重要的交叉测试工具[576,592]，它适用于凸多面体， 
如AABB，OBB和k-DOP。这是分离超平面定理的一个方面[189].1 
1这个测试有时被称为计算机图形学中的 “分离轴定理”，这是我 
们在之前版本中帮助推出的误称。它不是一个定理本身，而是分离 
超平面定理的一个特例。22.2。定义和工具947图22.5。一条线扫 
过球体和矩形扫掠球体，又称胶囊和锭剂。分离轴测试（SAT）。 
对于任意两个任意的，凸的，不相交的多面体A和 B，存在至少一 
个分离轴，其中在轴上形成间隔的多面体的投影也是不相交的。如 
果一个物体是凹的，则不成立。例如，一个井和一个桶内的墙壁可 
能不会接触，但没有飞机可以分开它们。此外，如果A和 B是不相 
交的，那么它们可以被正交的轴（即，通过平行的平面）分开到以 
下之一[577]：1。A面.2。面B.每个多面体的边缘 （例如，叉积）。 
前两个测试表明，如果一个物体完全位于另一个物体任何面的远侧， 
则它们不能重叠。由前两个测试处理的面，最后一个测试基于对象 
----------------------- Page 1034-----------------------
的边缘。为了将对象与第三次测试分开，我们希望在一个平面（其 
法线是分离轴）中尽可能地靠近两个对象，并且这样的平面不能靠 
近一个对象而不是一个边缘。所以，待测试的分离轴各自由来自两 
个物体中的每一个的边缘的叉积形成。该测试如图22.6中的两个框 
所示。请注意，凸多面体的定义在这里是自由的。线段和诸如三角 
形的凸多边形也是凸多面体（尽管是简并的，因为它们不包围体积）。 
线段A没有面，因此第一个测试消失。该测试用于推导第22.12节 
中的三角形/盒重叠测试和第22.13.5节中的OBB/OBB重叠测试。 
Gregorius[597]注意到使用分离轴的任何相交测试的重要优化：时 
间相干性。如果在此帧中找到分离轴，则将此轴存储为第一个，以 
测试下一帧中的对象对。94822.交叉口试验方法图22.6。分离轴。 
调用蓝色方框A和黄色方框B.第一个图像显示B完全位于A右侧的 
右侧，第二个显示A完全位于B的左下方面。在第三个图像中没有 
形成一个排除的平面另一个盒子，因此由A的右上边缘和B的左下 
角的叉积形成的轴限定了分隔两个物体的平面的法线。为了回到对 
可以采用的方法的讨论，优化交叉点测试的常用技术是尽早进行一 
些简单的计算，以确定光线或物体是否错过了另一个物体。这样的 
测试称为拒绝测试，如果测试成功，则认为交叉点被拒绝。本章中 
经常使用的另一种方法是将三维对象投影到 “最佳”正交平面 （xy， 
xz或yz）上，并在两个维度上解决问题。最后，由于数值不精确， 
我们经常在交叉测试中使用一个小数字。这个数字表示。（epsilon）， 
其值将因测试而异。然而，通常选择适用于程序员问题情况的 
----------------------- Page 1035-----------------------
epsilon （Press等人[1446]称之为 “方便小说”），而不是进行仔 
细的舍入误差分析和epsilon调整。由于条件不同，在其他设置中 
使用的此类代码可能会中断。Ericson的书[435]在几何计算的背景 
下讨论了深度数值稳健性的领域。这个警告牢固到位，我们有时会 
尝试提供至少是 “正常”数据，小规模（比如小于 100，大于0.1） 
和原点附近的合理起始值的epsilons。22.3边界体积创建给定一组 
对象，找到一个紧密的边界体积对于最小化交叉点成本非常重要。 
任意射线撞击任何凸起物体的可能性与该物体的表面积成正比（见 
第22.4节）。最小化该区域可以提高任何交叉算法的效率，因为拒 
绝的计算速度从不比交叉点慢。相反，通常最好使用于碰撞检测算 
法的每个 BV的体积最小化。本节简要介绍了在给定多边形集合的 
情况下查找最佳或接近最佳边界体积的方法。22.3。边界体积创建 
949图22.7。边界球体。最简单的是，在左边，一个对象可以在其 
边界框周围有一个边界球体。如果对象没有延伸到边界框的任何角 
落，则可以通过使用框的中心并遍历所有顶点来找到最远的空间来 
设置球体的半径，就像在中间图像中一样。通过移动球体的中心可 
以实现更小的半径，如右图所示。22.3.1AABB和k-DOP创建要创 
建的最简单的边界卷是AABB。沿每个轴获取多边形顶点集的最小 
和最大范围，并形成AABB。k-DOP是AABB的扩展：将顶点投影 
到 k-DOP的每个法线ni上，并且这些投影的极值（min，max） 
存储在dimin和dimax中。这两个值定义了该方向最紧密的板。 
所有这些值一起定义了最小k-DOP。22.3.2球体创建边界球体的形 
----------------------- Page 1036-----------------------
成并不像确定板块范围那样简单。有许多算法可以执行此任务，这 
些算法具有速度与质量权衡的关系。快速，恒定时间单程算法是为 
多边形集形成AABB，然后使用该框的中心和对角线来形成球体。 
这有时会导致不合适，这可能会通过另一次传递得到改善：从AABB 
的中心开始作为球体BV的中心，再次遍历所有顶点并找到距离该 
中心最远的顶点（比较距离的平方，避免取平方根）。这是新的半 
径。见图22.7。如果要在父球体内嵌套子球体，则只需稍微修改这 
两种技术。如果所有子球体具有相同的半径，则可以将中心视为顶 
点，并且在任一过程结束时将此子半径添加到父球体的半径。如果 
半径变化，可以通过在边界计算中包括这些半径来找到AABB边界 
以找到合理的中心。如果执行第二次传递，则将每个半径添加到距 
父级中心的点的距离。95022.交叉测试方法Ritter[1500]提出了一 
种简单的算法，可以创建近似最佳的边界球。我们的想法是沿着x 
轴，y轴和z轴中的每一个找到最小的顶点和最大的顶点。对于这 
三对顶点，找到它们之间距离最大的那对。使用此对形成一个球体， 
其中心位于它们之间的中点，半径等于它们的距离。浏览所有其他 
顶点并检查它们与球体中心的距离d。如果顶点位于球体半径r之 
外，则将球体的中心向顶点移动 （d.r）/2，将半径设置为 （d+r） 
/2，然后继续。此步骤具有将顶点和现有球体包围在新球体中的效 
果。在第二次通过列表之后，保证边界球体包围所有顶点。Welzl 
[1867]提出了一种更复杂的算法，该算法由 Eberly [404,1574]和 
Ericson[435]等人在网上实现。我们的想法是找到一组定义球体的 
----------------------- Page 1037-----------------------
支撑点。球体可以通过其表面上的一组两个，三个或四个点来定义。 
当发现顶点在当前球体之外时，其位置被添加到支撑集（并且可能 
从集合中移除旧支撑顶点），计算新球体，并且再次运行整个列表。 
重复此过程，直到球体包含所有顶点。虽然比以前的方法更复杂， 
但该算法保证找到最佳边界球。Ohlarik [1315]比较了 Ritter和 
Welzl算法的变体速度。Ritter的简化形式只比基本版本高出20％， 
但有时可能会产生更糟糕的结果，因此同时运行它们是值得的。对 
于一个随机的点列表，Eberly对Welzl算法的实现预计是线性的， 
但运行速度要慢一个数量级左右。22.3.3凸多面体的创建边界体的 
一种通用形式是凸多面体。凸面对象可与分离轴测试一起使用。 
AABB，k-DOP和OBB都是凸多面体，但可以找到更严格的边界。 
正如 k-DOP可以被认为是通过添加额外的平面对来从对象中修剪 
更多的体积，可以通过任意一组平面来定义凸多面体。通过修剪额 
外的体积，可以避免涉及封闭的多边形物体的整个网格的更昂贵的 
测试。我们希望 “收缩 - 包裹”我们的多边形对象并找到这组形成 
凸包的平面。图22.8显示了一个示例。凸壳可以用例如Quickhull 
算法[100,596]找到。尽管名字，该过程比线性时间慢，因此通常作 
为复杂模型的离线预处理执行。可以看出，该过程可能导致大量平 
面，每个平面由凸包上的多边形限定。在实践中，我们可能不需要 
这种精确度。首先创建原始网格的简化版本，可能向外扩展以完全 
包围原始网格，将产生不太准确但更简单的凸包。还要注意，对于 
k-DOP，随着k的增加，BV越来越像凸包。22.3。边界体积创建 
----------------------- Page 1038-----------------------
951图22.8。使用Quickhull [596]计算的茶壶的凸包。（图片由 
Valve Corporation的 DirkGregorius提供。）22.3.4 OBB创建 
一个对象可能有一个自然的OBB，因为它以AABB开始，然后进行 
旋转，从而使AABB成为OBB。但是，然后使用的OBB可能不是 
最佳的。想象一下，一个旗杆建模，从一个角度延伸到建筑物。围 
绕它的AABB不像沿其长度延伸的OBB那么紧。对于没有明显最 
佳轴的模型，具有任意基础方向的OBB形成甚至比找到合理的边界 
球更复杂。在为此问题创建算法方面已经做了大量工作。O'Rourke 
[1338]从 1985年开始的确切解决方案在 O （n3）时间运行。 
Gottschalk [577]提出了一种更快，更简单的方法，可以给出最佳 
OBB的近似值。它首先计算多边形网格的凸包，以避免该体积内的 
模型顶点偏向结果。然后使用以线性时间运行的主成分分析 （PCA） 
来找到合理的OBB轴。这种方法的缺点是盒子有时是松散的[984]。 
Eberly描述了一种使用最小化技术计算最小体积OBB的方法。他 
为盒子采样了一组可能的方向，并使用OBB最小的轴作为数值最小 
化器的起点。然后使用 Powell的方向集方法[1446]来找到最小音量 
框。Eberly在网上有这个操作的代码[404]。还有其他算法;Chang 
等。[254]对以前的工作进行了合理的概述，并提出了自己的最小化 
技术，该技术使用遗传算法来帮助搜索解空间。95222.交叉口试验 
方法图22.9。近乎最佳的OBB形成;请记住，所有点都是三维的。 
对于每个k-DOP的平板 （由一对彩色线标记），在其极限处有一对 
点，标记为黑色;底部的两个顶点分别位于两个平板平面的极端。标 
----------------------- Page 1039-----------------------
有灰色的其他顶点不会用于以下步骤。在这四对中，最远的两个顶 
点用于形成边缘。距离该边缘线最远的极值点用于与边缘形成三角 
形。形成三个盒子，每个盒子使用三角形边缘来定义其轴线，并使 
用剩余的极值点来定义其边界。在这三个中，最好的盒子被保存。 
在这里，我们提出了一个来自 Larsson和 K¨allberg[984]的算法， 
这是一种近似最优的方法，不需要凸包并在线性时间内执行。它通 
常提供比Gottschalk基于PCA的方法更好的质量，执行速度更快， 
适合SIMD并行化，并且代码由作者提供。首先，为物体形成k-DOP， 
并且保存接触每个k-DOP板的相对侧的一对 （任何一对）顶点。所 
有这些顶点对称在一起称为对象的极值点。因此，例如，26-DOP 
生成 13对点，并且这些点中的一些可以指定相同的顶点，可能给出 
较小的整体集。 “最佳OBB”初始化为围绕对象的AABB。然后， 
算法通过找到可能提供更好拟合的OBB方向来进行。构造一个大的 
基础三角形，并从其表面延伸出两个四面体。这些创建了一组七个 
三角形，可以产生可能接近最佳的OBB。彼此相距最远的一对点形 
成基本三角形的一个边缘。距离该边缘线最远的剩余极值点的顶点 
形成三角形的第三个点。每个三角形边和三角形平面中边缘的法线 
用于形成潜在新OBB的两个轴。将剩余的极值点投影到这些轴上， 
以找到三个OBB中的每一个的平面中的二维边界。见图22.9。最 
小的周围二维矩形用于从三个中选择最佳OBB。由于三个OBB中 
任何一个的高度，三角形正常的距离都是相同的，每个周围的二维 
边界框足以决定哪个是最好的。然后使用剩余的极值点通过对三角 
----------------------- Page 1040-----------------------
形法线的投影来三维地找到该OBB的范围。根据初始AABB检查 
完全形成的OBB以查看哪个更好。在此过程中发现的两个极值点， 
一个在最大值，一个在最小高度，22.4。然后使用几何概率953形 
成两个四面体，其中原始的大三角形作为每个的基础。每个四面体 
又形成三个额外的三角形，并且对于原始三角形执行评估三角形的 
三个候选OBB的过程。每个三角形的最佳二维OBB同样沿其高度 
延伸，如前所述，但只是为了获得候选OBB的最终大小，而不是形 
成更多的三角形。形成总共七个三角形，并且生成一个完整OBB并 
且从每个三角形进行比较。找到最佳OBB后，原始对象中的所有点 
都会投影到其轴上，以根据需要增加其大小。对原始AABB进行最 
终检查，以确定该OBB是否实际上更合适。整个过程比以前的技术 
更快，并且从大多数步骤使用一小组极值点中获益。值得注意的是， 
由于我们在下一节中介绍的原因，作者更喜欢基于表面积而不是体 
积来优化边界框。22.4几何概率常见的几何运算包括平面或光线是 
否与物体相交，以及点是否在其内部。一个相关的问题是点，射线 
或平面与物体相交的相对概率是多少。空间中随机点在物体内的相 
对概率是相当明显的：它与物体的体积成正比。因此，1×2×3盒子 
包含随机选择的点的可能性是 1×1×1盒子的6倍。对于空间中的 
任意射线，射线与一个物体相交的相对机会是多少？这个问题与另 
一个问题有关：当使用正交投影时，任意定向对象所覆盖的平均像 
素数是多少？正交投影可以被认为是视图体积中的一组平行光线， 
其中光线穿过每个像素。给定一个随机的对象，覆盖的像素数等于 
----------------------- Page 1041-----------------------
与对象相交的光线数。答案非常简单：任何凸实体的平均投影面积 
是其表面积的四分之一。对于屏幕上的球体来说，这显然是正确的， 
其正交投影总是一个面积为πr2且表面积为4πr2的圆。该相同的比 
率保持为任何其他任意定向的凸对象 （例如框或k-DOP）的平均投 
影。有关非正式证据，请参阅 Nienhuys的文章[1278]。球体，盒 
子或其他凸起物体在每个像素处始终具有正面和背面，因此深度复 
杂度为2。概率测量可以扩展到任何多边形，因为（双面）多边形 
的深度复杂度总是为1。因此，任何多边形的平均投影面积是其表 
面积的一半。该度量在射线追踪文献中被称为表面区域启发式 
 （SAH）[71,1096,1828]，并且对于形成数据集的有效可见性结构 
是重要的。一个用途是比较边界体积效率。例如，相对于内切立方 
体（即，其角落接触球体的立方体），相交测试方法球体具有被射 
线击中的相对概率 1.57 （π/2）。类似地，立方体的相对概率为 1.91 
 （6/π）被击中，相对于其内部刻有球体。这种类型的概率测量在 
诸如细节计算级别的区域中可能是有用的。例如，想象一个长而薄 
的物体，它比一个圆形物体覆盖的像素少得多，但它们都具有相同 
的边界球体大小。从边界框的区域预先知道命中率，可以认为长而 
细的物体在视觉冲击中相对不太重要。我们现在有一个点的封闭概 
率与体积有关，而射线的交叉概率与表面积有关。平面与盒子相交 
的机会与三维盒子范围的总和成正比[1580]。此总和称为对象的平 
均宽度。例如，边长为 1的立方体的平均宽度为1 +1 +1=3.框 
的平均宽度与其被平面击中的可能性成比例。因此，1×1×1的盒子 
----------------------- Page 1042-----------------------
具有3的度量，并且1×2×3的盒子具有6的度量，这意味着第二 
个盒子与任意平面相交的可能性是两倍。然而，该总和大于真实的 
几何平均宽度，该平均宽度是在所有可能的方向的集合上沿着固定 
轴的对象的平均投影长度。对于平均宽度计算，不同的凸对象类型 
之间没有简单的关系（例如表面区域）。直径为d的球体的几何平 
均宽度为d，因为球体跨越任何方向的相同长度。我们将通过简单 
地说明将一个盒子的尺寸（即它的平均宽度）的总和乘以0.5得到 
它的几何平均宽度来保留这个主题，这可以直接与球体的直径进行 
比较。因此，具有度量3的1×1×1盒具有3×0.5 =1.5的几何平 
均宽度。限定此框的球体直径为√3= 1.732。因此，围绕立方体的 
球体是 1.732/ 1.5=1。任意平面相交的可能性是 155倍。这些关 
系对于确定各种算法的好处很有用。Frustum剔除是一个主要的候 
选者，因为它涉及具有边界体积的交叉平面。另一个用途是确定是 
否以及最佳地分割包含对象的BSP节点，以使截锥体剔除性能变得 
更好 （第 19.1.2节）。22.5经验法则在我们开始研究特定的交叉方 
法之前，这里有一些经验法则可以导致更快，更强大和更精确的交 
叉测试。在设计，发明和实施交叉路线时，应牢记这些：。尽早进 
行计算和比较，这可能会轻易地拒绝或接受各种类型的交叉点，以 
便尽早逃避进一步的计算。22.6。Ray/ SphereIntersection955。 
如果可能，请利用先前测试的结果。。如果使用多个拒绝或验收测 
试，则尝试更改其内部顺序（如果可能），因为可能会导致更有效 
的测试。不要认为看似微小的改变不起作用。。推迟昂贵的计算 （尤 
----------------------- Page 1043-----------------------
其是三角函数，平方根和除法），直到它们真正需要为止 （第22.8 
节推迟了一个昂贵的部门）。。通过减少问题的维度，通常可以大 
大简化交叉点问题（例如，从三维到二维甚至一维）。有关示例， 
请参见第22.9节。。如果一次将单个光线或对象与许多其他对象进 
行比较，请在测试开始之前查找可以执行一次的预先计算。。每当 
交叉点测试都很昂贵时，通常可以从围绕对象的球体或其他简单 BV 
开始，以提供第一级别的快速拒绝。。养成习惯总是在计算机上进 
行时序比较，并使用真实数据和测试情况来确定时间。。利用前一 
帧的结果，例如，如果发现某个轴将前一帧中的两个对象分开，那 
么首先在下一帧上尝试该轴可能是个好主意。。最后，尝试使您的 
代码健壮。这意味着它应该适用于所有特殊情况，并且它对尽可能 
多的浮点精度错误不敏感。请注意它可能存在的任何限制。有关数 
值和几何稳健性的更多信息，请参阅 Ericson的书[435]。最后，我 
们强调的是，很难确定特定测试是否存在 “最佳”算法。为了评估， 
经常使用具有一组不同的预定命中率的随机数据，但这仅显示部分 
事实。该算法将在真实场景中使用，例如，在游戏中，并且最好在 
该上下文中进行评估。使用的测试场景越多，就越能更好地理解性 
能问题。一些架构，例如GPU和宽SIMD实现，由于需要执行多 
个拒绝分支，可能会失去性能。最好避免做出假设，而是制定一个 
可靠的测试计划。22.6射线/球体交点让我们从数学上简单的交叉测 
试开始 - 即在射线和球体之间。正如我们稍后将看到的，如果我们 
开始考虑所涉及的几何结构，可以更快地进行直接的数学解决方案 
----------------------- Page 1044-----------------------
[640]。95622.交叉口试验方法dododot2t1t1 =t2图22.10。 
左图显示了一个错过球体的光线，因此显示了b2。c <0。中间图像 
显示了在由标量t1和t2确定的两个点 （b2.c>0）处与球体相交的 
光线。右图说明了 b2的情况。c =0，表示两个交点重合。22.6。 
1数学解决方案球体可以由中心点c和半径 r定义。然后，对于球 
体，更紧凑的隐式公式（与先前引入的公式相比）是f （p）=||p。 
ç||。r =0，（22.5）其中p是球体表面上的任何点。为了求解射 
线和球体之间的交叉点，射线r （t）简单地替换等式22.5中的p， 
得到f （r （t））=||r （t）。ç||。r=0. （22.6）使用公式22.1，r 
 （t）=o+td，公式22.6简化如下：||r （t）。ç||。r=0..||o+ 
td。ç||=r.. （o+td.c）· （o+td.c）=r2...t2 （d·d）+2t （d· （o.c）） 
+ （o.c）· （o。C）。r2=0...t2 +2t （d· （o.c））+ （o.c）· （o.c）。 
r2=0. （22.7）最后一步来自假设d被归一化的事实，即d·d=||d 
||2=1.毫不奇怪，得到的方程是二阶多项式，这意味着如果光线与 
球体相交，它最多可以达到两个点。见图22.10。如果方程的解是 
虚数，那么射线就会错过球体。如果不是，则可以将两个解t1和t2 
插入到射线方程中以计算球面上的交点。22.6。Ray/ Sphere 
Intersection957得到的公式22.7可以写成二次方程：t2 +2bt+ 
c =0，（22.8）其中b =d· （o.c）和c = （o.c）· （o。 C） 。 
R2。二阶方程的解如下所示：t =.b±pb2。C。 （22.9）注意，如 
果b2.c <0，则射线错过球体并且可以拒绝交叉并避免计算 （例如， 
平方根和一些加法）。如果通过该测试，则t0 =.b。√b2。c和t1 
----------------------- Page 1045-----------------------
=.b+√b2。c可以计算。需要进行额外的比较以找到t0和t1的最 
小正值。请参阅realtimerendering.com上的碰撞检测章节，了解 
另一种解决这个数值稳定的二次方程的方法[1446]。如果从几何角 
度来看这些计算，则可以发现更好的拒绝测试。下一小节描述了这 
样的例程。22.6.2优化解决方案对于射线/球体交叉问题，我们首先 
观察不需要射线原点后面的交叉点。例如，这通常是采摘的情况。 
为了在早期检查这种情况，我们首先计算向量l =c。o，是从射线 
原点到球体中心的矢量。所有使用的符号如图22所示。此外，计算 
该向量的平方长度，l2=1·l。现在，如果l2<r2，这意味着射线原 
点位于球体内部，这反过来意味着射线被保证击中球体，如果我们 
只想检测射线是否击中球体，我们就可以退出;否则，我们继续。接 
下来，计算l在光线方向上的投影d：s=l·d。现在，第一次拒绝测 
试：如果s <0并且射线原点在球体之外，则球体在射线原点后面， 
我们可以拒绝交叉点。否则，使用毕达哥拉斯定理计算从球心到投 
影的平方距离：m2 =l2。S2。第二次拒绝测试甚至比第一次更简 
单：如果m2>r2射线肯定会错过球体，其余的计算可以安全地省 
略。如果球体和射线通过了最后一次测试，那么射线将保证击中球 
体，如果我们有兴趣找到它，我们就可以退出。要找到真正的交叉 
点，还需要做更多的工作。首先，平方距离q2 =r2。计算m2.2 
见图22.11。由于m2≤r2，q2大于或等于零，这意味着可以计算q 
=pq2。最后，到交叉点的距离是t =s±q，其解决方案非常类似 
于在先前的数学解决方案部分中获得的二阶方程。2标量r2可以计 
----------------------- Page 1046-----------------------
算一次并存储在球体的数据结构中，以试图获得进一步的效率。在 
实践中，这样的 “优化”可能更慢，因为随后访问更多的存储器， 
这是算法性能的主要因素。958.交叉口试验方法os +qs-qqrms = 
l。ds =l。d <0oldlcccloddl2 =l。l <r2图22.11。优化光线/ 
球体交叉点几何的表示法。在左图中，光线在两个点上与球体相交， 
其中沿光线的距离为t =s±q。中间案例表明当球体位于射线原点 
后面时发生了拒绝。最后，在右侧，射线原点位于球体内部，在这 
种情况下，射线始终击中球体。如果我们只对第一个正交点感兴趣， 
那么我们应该使用t1 =s。q对于射线原点位于球体外部并且当射 
线原点位于内部时t2 =s+q的情况。通过将t值插入射线方程 （方 
程22.1）找到真正的交叉点。优化版本的伪代码显示在下面的框中。 
例程返回一个布尔值，如果光线错过了球体则为 REJECT，否则为 
INTERSECT。如果光线与球体相交，则还会返回从光线原点到交叉 
点的距离t以及交点p。RaySphereIntersect （o，d，c，r）返回 
 （{REJECT，INTERSECT}，t，p）1：l =c。o2：s =l·d3：l2= 
l·l4：if （s <0和l2>r2）返回（REJECT，0,0）; 5：m2=l2。s2 
6：if （m2>r2）返回 （REJECT，0,0）; 7：q=√r2。m28：if （l2> 
r2）t =s。问9：否则t =s+q10：返回 （INTERSECT，t，o+td）;请 
注意，在第3行之后，我们可以测试p是否在球体内部，如果我们 
想要知道的是光线和球体是否相交，则例程可以在它们这样做时终 
止。此外，在第6行之后，射线可以保证击中球体。如果我们进行 
操作计数（计数加，乘，比较等），我们发现几何解决方案，当完 
----------------------- Page 1047-----------------------
成后，几乎等于前面提出的代数解。重要的区别在于拒绝22.7。Ray 
/ BoxIntersection959测试在此过程中提前完成，使得该算法的 
总体成本平均降低。存在用于计算射线与一些其他二次曲面和混合 
对象之间的交叉的优化几何算法。例如，有圆柱[318,713,1621]， 
圆锥[713,1622]，椭圆体，胶囊和菱形[404]的方法。22.7Ray/ Box 
交叉点下面给出了确定光线是否与实心框相交的三种方法。第一个 
处理AABB和OBB。第二种是通常更快的变体，但只处理更简单的 
AABB。第三种是基于第947页的分离轴测试，仅处理线段与AABB。 
在这里，我们使用第22.2节中 BV的定义和符号。22.7.1平板方法 
一种用于射线/ AABB交叉的方案基于 Kay和 Kajiya的平板方法 
[640,877]，其反过来受到Cyrus-Beck线裁剪算法的启发[319]。我 
们扩展此方案以处理更一般的OBB卷。它返回最接近的正t值（即， 
从射线原点o到交叉点的距离（如果存在的话）。在介绍一般情况 
后，将对AABB的优化进行处理。通过计算光线的所有t值和属于 
OBB面的所有平面来解决该问题。该盒子被认为是一组三块板，如 
图22.12左侧的两个维度所示。对于每个板，存在最小和最大t值， 
这些被称为tmin i和tmax i，max max min min max min max 
maxOBB板图22.12。左图显示了由两个板形成的二维OBB，而 
右图显示了两个与OBB交叉测试的光线。显示所有t值，它们用u 
表示绿色板，用v表示橙色。极端t值用方框标记。由于tmin <tmax， 
左射线击中OBB，并且由于tmax <tmin，右射线未命中。96022. 
交叉测试方法.i∈{u，v，w}。下一步是计算公式22.10中的变量： 
----------------------- Page 1048-----------------------
tmin =max （tminu，tminv，tminw），tmax =min （tmaxu， 
tmaxv，tmaxw）。（22.10）现在，聪明的测试：如果tmin≤tmax， 
那么射线定义的线与盒子相交;否则它会错过。换句话说，我们找到 
每个板的近和远交叉距离。如果找到的最远 “近”距离小于或等于 
最近的 “远”距离，则由射线定义的线击中该框。您应该通过检查 
图22.12右侧的插图来说服自己。这两个距离定义了线的交叉点， 
因此如果最近的 “远”距离不是负的，射线本身击中了盒子，即盒 
子不在射线后面。下面是OBB （A）和射线 （由公式22.1描述）之 
间的射线/ OBB相交测试的伪代码。代码返回一个布尔值，指示光 
线是否与OBB （INTERSECT或 REJECT）相交，以及到交叉点的距 
离 （如果存在）。回想一下，对于OBBA，中心表示为ac，而au， 
av和aw是框的标准化侧向; hu，hv和hw是正半长 （从中心到盒 
面）。RayOBBIntersect （o，d，A）返回 （{REJECT，INTERSECT}， 
t）; 1：tmin =.∞2：tmax =∞3：p =ac。o4：对于每个i∈{u， 
v，w} 5：e =ai·p6：f =ai·d7：if （|f |>。）8：t1 = （e +hi） 
/ f 9 ：t2 = （e.hi）/ f 10：if （t1>t2）swap （t1，t2）; 11：if 
 （t1>tmin）tmin =t1 12：if t2（<tmax）tmax =t2 13：if tmin>（ 
tmax）返回（REJECT，0）; 14：if （tmax <0）返回（REJECT， 
0）; 15：否则if （例如，hi>0或.e+hi<0）返回 （REJECT，0）; 16： 
if tmin>（ 0）返回 （INTERSECT，tmin）; 17：否则返回 （INTERSECT， 
tmax）;第7行检查光线方向是否不垂直于当前正在测试的板坯的 
法线方向。换句话说，它测试光线是否与平板平面不平行，因此可 
----------------------- Page 1049-----------------------
以与它们相交。注意 。这里是一个微不足道的数字，22.7。Ray/ Box 
Intersection961的数量级为10.20，只是为了避免在发生除法时 
溢出。第8行和第9行显示f除以;实际上，计算 1/ f一次并乘以 
该值通常会更快，因为除法通常很昂贵。第 10行确保t1和t2的最 
小值存储在t1中，因此，这些中的最大值存储在t2中。在实践中， 
不必进行交换;相反，可以为分支重复行 11和 12，并且t1和t2可 
以在那里改变位置。如果第 13行返回，那么光线会错过该框，同样， 
如果第 14行返回，则该框位于光线原点后面。如果光线平行于平板 
 （并且因此不能与平面相交），则执行第 15行;它测试光线是否在 
平板之外。如果是这样，则光线错过了框并且测试终止。对于更快 
的代码，Haines讨论了一种解开循环的方法，从而避免了一些代码 
[640]。伪代码中没有显示额外的测试，值得在实际代码中添加。正 
如我们定义光线时所提到的，我们通常希望找到最近的对象。因此， 
在第 15行之后，我们还可以测试tmin是否为 l，其中l是当前光线 
长度。这有效地将光线视为线段。如果新交叉点不近，则交叉点被 
拒绝。该测试可以推迟到整个射线/ OBB测试完成之后，但通常在 
循环内尝试早期拒绝更有效。对于作为AABB的OBB的特殊情况， 
还有其他优化。第5行和第6行变为e =pi和f =di，这使得测试 
更快。通常，AABB的amin和amax角用于第8和第9行，因此 
避免了加法和减法。Kay和 Kajiya[877]以及Smits[1668]注意到， 
通过允许除以0并正确解释处理器的结果，可以避免第7行。Kensler 
[1629]给出了该测试的最小版本的代码。威廉姆斯等人。[1887]提 
----------------------- Page 1050-----------------------
供实现细节以正确处理0除以及其他优化。艾拉等人。[16]显示了 
如何在一些 NVIDIA架构上的单个GPU操作中执行最小值测试，反 
之亦然。也可以使用SAT为光线和框导出测试，但是交叉距离不是 
结果的一部分，这通常是有用的。平板法的推广可用于计算射线与 
k-DOP，平截头体或任何凸多面体的交点;代码可在网上找到[641]。 
22.7.2雷斜率方法2007年 Eisemann等。[410]提出了一种交叉框 
的方法，该方法看起来比以前的方法更快。而不是三维测试，射线 
在两个维度上针对盒子的三个投影进行测试。关键的想法是，对于 
每个二维测试，有两个盒角定义了光线 “看到”的极端范围，类似 
于模型的轮廓边缘。为了与盒子的这个投影相交，光线的斜率必须 
在由光线原点和这两个点定义的两个斜率之间。如果此测试通过所 
有三个投影，则光线必须击中该框。该方法非常快，因为一些比较 
96222.交叉测试方法术语完全依赖于射线的值。通过计算这些术语 
一次，可以有效地将射线与大量的盒子进行比较。这种方法可以返 
回只是框被击中，或者还可以返回交叉点距离，只需要一点额外费 
用。22.8 Ray/ Triangle Intersection在实时图形库和API中，三 
角形几何通常存储为一组具有相关阴影法线的顶点，每个三角形由 
三个这样的顶点定义。通常不存储三角形所在平面的法线，在这种 
情况下必须根据需要进行计算。存在许多不同的光线/三角形相交测 
试，并且其中许多测试首先计算光线和三角形平面之间的交叉点。 
此后，交叉点和三角形顶点投影在轴对齐平面（xy，yz或xz）上， 
其中三角形的面积最大化。通过这样做，我们将问题简化为二维， 
----------------------- Page 1051-----------------------
我们只需要确定（二维）点是否在（二维）三角形内。存在几种这 
样的方法，Haines[642]对它们进行了审查和比较，在网上提供代 
码。有关使用此技术的一种流行算法，请参见第22.9节。已经针对 
不同的CPU架构，编译器和命中率评估了大量算法[1065]，并且不 
能断定在所有情况下都存在单个最佳测试。在这里，重点将放在一 
个算法上，该算法不会假定法线是预先计算的。对于三角网格，这 
可以节省大量内存。对于动态几何，我们不需要每帧重新计算三角 
形的平面方程。不是在三角形的平面上测试光线，然后检查交叉点 
是否包含在三角形的二维版本中，而是仅针对三角形的顶点执行检 
查。M？oller和Trumbore [1231]讨论了这种算法以及优化算法， 
他们的演讲在这里使用。Kensler和Shirley [882]指出，直接在三 
维中操作的大多数射线/三角测试在计算上是等效的。他们使用SSE 
开发新的测试来测试四角形的四条射线，并使用遗传算法在这个等 
效测试中找到最佳操作顺序。最好的测试代码在他们的论文中。请 
注意，有很多不同的方法。例如，Baldwin和Weber [96]提供了一 
种具有不同空速权衡的方法。这类测试的一个潜在问题是可以判断 
与三角形边缘或顶点精确相交的光线错过三角形。这意味着光线可 
能通过击中由两个三角形共享的边缘而穿过网格。Woop等。[1906] 
呈现在边缘和顶点上都是水密的光线/三角形相交测试。性能稍低， 
具体取决于使用的遍历类型。公式22.1的光线用于测试与由三个顶 
点p1，p2和p3定义的三角形的交点，即△p1p2p3。22.8。Ray/ 
Triangle Intersection963u =0.4v =0.5w =0.1 u =0.3v =0 
----------------------- Page 1052-----------------------
w =0.7u =0v =1w =0 u =1u =0w =0w =1v =0v =1 
图22.13。三角形的重心坐标，以及示例点值。值u，v和w都在 
三角形内从0到 1变化，并且这三个的总和在整个平面上始终为 1。 
这些值可用作三个顶点中每个顶点的数据如何影响三角形上任何点 
的权重。注意在每个顶点，一个值是 1，其他值是0，沿着边，一个 
值始终为0.22.8.1交点算法三角形上的一个点f （u，v）由显式公 
式f （u，v）= （1.u.v）p0+给出up1+vp2， （22.11）其中 （u， 
v）是两个重心坐标，必须满足u≥0，v≥0和u +v≤1。注意（u， 
v）可用于运算例如纹理映射和法线或颜色插值。也就是说，u和v 
是加权每个顶点对特定位置的贡献的量，其中w = （1.u.v）是第三 
个权重。这些坐标通常在其他工作中表示为α，β和γ。我们在这里 
使用 u，v和w来表示符号的可读性和一致性。见图22.13。计算 
射线，r （t）和三角形f （u，v）之间的交点相当于r （t）=f （u， 
v），它产生o +td = （1.u。v）p0 +up1 +vp2。（22.12）重 
新安排条款给出。。.dp1。p0p2。p0。。。。tuv。。=o。P0。 
 （22.13）这意味着通过求解这个线性方程组可以找到重心坐标 （u， 
v）和从射线原点到交点的距离t。96422.交叉点测试方法p0p1- 
p0p1p2p2-p0o-p0 （o） -p0odvuM-1M-1图22.14。 
射线起源基地的平移和变化。这种操作可以被认为是几何上将三角 
形平移到原点并将其转换为y和z中的单位三角形，其中光线方向 
与x对齐。如图22.14所示。如果 M = （。d p1.p0p2.p0）是公 
式22.13中的矩阵，则通过将公式22.13与M.1相乘得到解。表示 
----------------------- Page 1053-----------------------
e1=p1.p0，e2=p2.p0，并且s=o.p0，使用Cramer的规则得 
到方程22.13的解：。。tuv。。=1det （.d，e1，e2）。。det 
 （s，e1，e2）det （.d，s，e2）det （.d，e1，s）。.. （22.14） 
从线性代数中，我们知道det （a，b，c）=|abc|=。 （a×c）·b=。 
 （c×b）·a。因此，公式22.14可以重写为。。t uv。。=1 （d× 
e2）·e1。。（s×e1）·e2 （d×e2）·s （s×e1）·d。。=1q·e1。。 
r·e2q·sr·d。。， （22.15）其中q =d×e2且r=s×e1。这些因素 
可用于加速计算。如果您能够提供额外的存储空间，可以重新配置 
此测试以减少计算次数。公式22.15可以改写为。。t uv。。=1 
 （d×e2）·e1。。（s×e1）·e2 （d×e2）·s （s×e1）·d。。=1。 
 （e1×e2）·d。。 （e1×e2）·s （s×d）·e2。 （s×d）·e1。。=1.n·d。。 
n·sm·e2.m·e1。。， （22.16）22.8。Ray/Triangle Intersection 
965其中n=e1×e2是三角形的非标准化法线，因此是常数 （对于 
静态几何），m =s×d。如果我们为每个三角形存储p0，e1，e2 
和 n，我们可以避免许多光线三角形交叉计算。大部分收益来自避 
免交叉产品。应该注意的是，这违背了算法的最初想法，即用三角 
形存储最小信息。但是，如果速度是最重要的，这可能是一个合理 
的选择。权衡是额外的存储器访问是否超过了计算的节省。只有仔 
细的测试才能最终显示出最快的速度。22.8.2实现该算法总结在下 
面的伪代码中。除了返回光线是否与三角形相交之外，算法还返回 
先前描述的三元组 （u，v，t）。代码不会剔除背面三角形，它会返 
回负t 值的交叉点，但如果需要，也可以剔除这些交叉点。 
----------------------- Page 1054-----------------------
RayTriIntersect（o，d，p0，p1，p2）返回 （{REJECT，INTERSECT}， 
u，v，t）; 1：e1 =p1。p02：e2 =p2。p03：q =d×e24：a 
=e1·q5：if （a>..和a <。）返回（REJECT，0,0,0）; 6：f =1/ 
a7：s =o。p08：u =f （s·q）9：if （u <0.0）返回（REJECT， 
0,0,0）; 10：r=s×e111：v =f （d·r）12：if （v <0.0或u+v> 
1.0）返回 （REJECT，0,0,0）; 13：t =f （e2·r）14：返回 （INTERSECT， 
u，v，t）;几行可能需要一些解释。第4行计算a，它是矩阵M的 
行列式。接下来是一个避免决定因素接近于零的测试。通过适当调 
整的。值，该算法非常强大。对于浮点精度和 “正常”条件，。=10.5 
工作正常。在第9行中，u的值与三角形的边缘 （u=0）进行比较。 
该算法的C代码，包括剔除和非剔除版本，可在网上获得[1231]。 
C代码有两个分支：一个有效地剔除所有背面三角形，另一个对双 
面三角形进行相交测试。所有计算都会延迟，直到需要它们为止。 
例如，v的值是96622.交叉测试方法直到发现u的值在允许范围内 
才计算（这也可以在伪代码中看到）。单侧交叉例程消除了行列式 
的值为负的所有三角形。此过程允许例程的唯一除法运算延迟，直 
到确认交叉点。22.9射线/多边形交点即使三角形是最常见的渲染基 
元，计算射线和多边形之间交点的例程也很有用。n个顶点的多边 
形由有序顶点列表{v0，v1，...定义。。。，vn.1}，其中顶点vi与 
vi +1形成边，0≤i<n。1，多边形由vn.1到v0的边缘闭合。多边 
形的平面表示为πp：np·x +dp=0.我们首先计算光线 （公式22.1） 
和πp之间的交点，这可以通过用光线替换x来轻松完成。解决方案 
----------------------- Page 1055-----------------------
如下：np· （o +td）+dp =0..t =.dp。np·o np·d。（22.17） 
如果分母|np·d| <。，在哪里。是一个微小的数字，然后光线被认 
为是与多边形平面平行，没有发生交叉。在这个计算中，10.20或 
更小的epsilon可以工作，因为目标是避免在分割时溢出。我们忽 
略了光线在多边形平面中的情况。否则，计算射线和多边形平面的 
交点p：p=o+td，其中t值是来自等式22.17的t值。此后，确 
定p是否在多边形内部的问题从三维减少到二维。这是通过将所有 
顶点和 p投影到xy-，xz-或yz-平面之一来完成的，其中投影多边 
形的面积最大化。换句话说，对应于max （|np，x |，|np，y |，| 
np，z |）可以跳过，其他的保持为二维坐标。例如，给定法线 
 （0.6，.0.692,0.4），y分量具有最大幅度，因此忽略所有y坐标。 
选择最大幅度以避免投射到可能产生退化的零区域三角形的平面 
上。请注意，此组件信息可以预先计算一次并存储在多边形内以提 
高效率。在此投影期间保留多边形和交叉点的拓扑（假设多边形确 
实是平坦的;有关此主题的更多信息，请参见第 16.2节）。投影程 
序如图22.15所示。剩下的问题是二维射线/平面交点p是否包含在 
二维多边形中。在这里，我们将只回顾一个更有用的算法 - “交叉” 
测试。Haines[642]和Schneider和 Eberly[1574]对二维多边形点 
策略进行了广泛的调查。在计算几何文献[135,1339,22.9]中可以找 
到更正式的治疗方法。Ray/ PolygonIntersection967图22.15。 
多边形顶点和交点p在xyplane上的正投影，其中投影多边形的面 
积最大化。这是使用降维来获得更简单计算的示例。1444。Lagae 
----------------------- Page 1056-----------------------
和Dutr'e[955]提供了一种基于M？olller和Trumbore射线/三角 
测试的快速射线/四边形交叉方法。Walker [1830]提供了一种快速 
测试具有 10个以上顶点的多边形的方法。Nishita等。[1284]讨论 
具有弯曲边缘的形状的点包含测试。22.9。1交叉口测试交叉口测 
试基于Jordan曲线定理，这是拓扑结果。从中，如果来自该点的光 
线在平面中的任意方向上穿过奇数个多边形边缘，则点在多边形内。 
JordanCurve定理实际上将自身局限于非自相交循环。对于自相交 
循环，此射线测试会使多边形内部的某些区域被视为外部。如图 
22.16所示。该测试也称为奇偶校验或偶数奇数测试。交叉算法通 
过从正x方向 （或任何方向上的点p的投影）拍摄光线来工作;x方 
向对编码简单有效。然后计算多边形边缘与该光线之间的交叉数。 
正如Jordan Curve定理所证明的那样，奇数个交叉点表示该点位 
于多边形内。测试点p也可以被认为是在原点，并且（平移的）边 
缘相对于正x轴进行测试。该选项如图22.17所示。如果多边形边 
的y坐标具有相同的符号，则该边不能越过x轴。否则，它可以， 
然后检查x坐标。如果两者都是正数，那么交叉的数量会增加，因 
为测试射线必须达到此边缘。如果它们的符号不同，则必须计算边 
缘和x轴之间的交点的x坐标，如果它是正的，则交叉的数量会增 
加。96822.交叉口试验方法图22.16。一个自相交和凹陷的一般多 
边形，但所有封闭区域都不在内部（只有棕色区域在里面）。顶点 
标有大的黑点。显示了测试的三个点以及它们的测试射线。根据 
JordanCurve定理，如果多边形边缘的交叉数是奇数，则内部有一 
----------------------- Page 1057-----------------------
个点。因此，最上面和最下面的点在内部（分别为一个和三个交叉 
点）。两个中间点分别穿过两条边，因此被认为是在多边形之外。 
在图22.17中，所有封闭区域也可以归类为内部。该变量测试找到 
绕组数，多边形循环绕测试点的次数。参见海恩斯的文章[642]进行 
治疗。p图22.17。多边形已被.p翻译（p是多边形中包含的测试 
点），因此，具有正x轴的交叉数确定p是否在多边形内。边缘e0， 
e2，e3和e4不与x轴交叉。必须计算边e1和x轴之间的交点， 
但不会产生交叉，因为交点具有负x分量。边缘e7和e8将各自增 
加交叉的数量，因为每个边缘的两个顶点具有正x分量和一个负y 
分量和一个正y分量。最后，边e5和e6共享一个顶点，其中y =0 
且x>0，它们将一起增加交叉数。通过考虑x轴上的顶点作为射线 
上方，e5被分类为穿过射线，e6被分类为射线上方。22.9。Ray/ 
Polygon Intersection969测试光线与顶点相交时可能会出现问 
题，因为可能会检测到两个交叉点。通过考虑射线上方无限小的顶 
点来解决这些问题，实际上，这是通过将y≥0的顶点解释为也位于 
x轴（射线）之上来完成的。代码变得更简单，更快速，因为没有 
顶点相交[640]。以下是用于有效形式的交叉测试的伪代码。它的灵 
感来自JosephSamosky[1537]和MarkHaigh-Hutchinson的作 
品，该代码可在网上找到[642]。比较具有顶点v0到vn.1的二维测 
试点t和多边形 P.bool PointInPolygon （t，P）返回（{TRUE， 
FALSE}）; 1：boolinside=FALSE2：e0=vn.13：booly0 = （e0y 
≥ty）4：对于i =0到n。15：e1 =vi 6：booly1 = （e1y≥ty） 
----------------------- Page 1058-----------------------
7：if （y06=y1）8：if （（（e1y.ty） （e0x.e1x）≥ （e1x.tx） （e0y。 
e1y））==y1）9：inside=.inside10：y0 =y1 11：e0 =e112： 
返回内部;第3行检查多边形中最后一个顶点的y值是否大于或等于 
测试点t的y值，并将结果存储在布尔值y0 中。换句话说，它测试 
我们将测试的第一个边缘的第一个端点是高于还是低于x轴。第7 
行测试端点e0和e1是否位于由测试点形成的x轴的不同侧。如果 
是，则第8行测试x截距是否为正。实际上，它比这快一点：为了 
避免计算截距通常需要的除法，我们在这里执行符号取消操作。通 
过内部反转，第9行记录了发生了交叉。第 10行到第 12行移动到 
下一个顶点。在伪代码中，我们不在第7行之后执行测试，以查看 
两个端点与测试点相比是否具有更大或更小的x坐标。虽然我们使 
用快速接受或拒绝这些类型的边缘来呈现算法，但是基于所呈现的 
伪代码的代码通常在没有该测试的情况下运行得更快。一个主要因 
素是测试的多边形中的顶点数 - 具有更多顶点，首先检查x坐标差 
异可以更有效。交叉测试的优点是它相对快速和稳健，并且不需要 
额外的信息或多边形的预处理。这种方法的一个缺点是它不会产生 
超出97022指示的任何东西。交叉测试方法一个点在多边形内部 
或外部。其他方法，例如22.8.1节中的射线/三角测试，也可以计 
算可用于插入关于测试点的附加信息的重心坐标[642]。注意，可以 
扩展重心坐标以处理具有多于三个顶点的凸多边形和凹多边形 
[474,773]。Jim'enez等人。[826]提供基于重心坐标的优化算法， 
其旨在包括沿多边形边缘的所有点并且与交叉测试竞争。确定点是 
----------------------- Page 1059-----------------------
否在由线段和B'ezier曲线曲线形成的闭合轮廓内的更一般的问题！ 
B'ezier可以以类似的方式执行，计算射线交叉。Lengyel [1028] 
为该过程提供了鲁棒算法，在像素着色器中使用它来渲染文本。22。 
10平面/框交点我们可以通过将点插入平面方程π：n·x +d =0来 
知道点到平面的距离。结果的绝对值是到平面的距离。然后平面/ 
球体测试很简单：将球体的中心插入平面方程中，看看绝对值是否 
小于或等于球体的半径。确定框是否与平面相交的一种方法是将框 
的所有顶点插入平面方程。如果获得正和负结果（或零），则顶点 
位于平面的两侧（或上），因此，已检测到交叉点。有更智能，更 
快速的方法来进行此测试，这些方法将在接下来的两个部分中介绍， 
一个用于AABB，另一个用于OBB。两种方法背后的想法是，八个 
角中只有两个需要插入平面方程中。对于任意定向的盒子，与平面 
相交或不相交，当沿平面法线测量时，盒子上有两个对角相对的角， 
它们是最大距离。每个盒子都有四个对角线，由角落形成。取每个 
对角线方向的点积与平面的法线，最大值用这两个最远点标识对角 
线。通过仅测试这两个角，整个盒子在平面上进行测试。22.10.1 
AABB假设我们有一个AABB，B，由中心点c和正半对角矢量h定 
义。注意，c和h可以很容易地从 B的最小和最大角，bmin和bmax 
导出，即c= （bmax+bmin）/2，并且h= （bmax。BMIN）/2。 
现在，我们想要针对平面 n·x +d =0测试 B.有一种令人惊讶的快 
速方式来执行此测试。这个想法是当投影到平面法线n时计算框的 
 “范围”，这里用e表示。理论上，这可以通过将盒子的所有八个 
----------------------- Page 1060-----------------------
不同的半对角线投影到法线上并且选择最长的一半来完成。然而， 
在实践中，这可以快速实现为e =hx|nx|+hy|ny|+hz|nz|。 
 （22.18）22.10。平面/盒子交叉点971nhsg1g2g3g4ec正半 
空间xy图22.18。轴对齐的b这可以通过将盒子的所有八个不同的 
半对角线投射到法线上，并选择最长的一半来完成。然而，在实践 
中，这可以快速实现为e=hx|nx|+hy|ny|+hz|nz|。（22.18） 
22.10。平面/盒子交叉点971nhsg1g2g3g4ec正半空间xy图 
22.18。轴对齐的b这可以通过将盒子的所有八个不同的半对角线 
投射到法线上，并选择最长的一半来完成。然而，在实践中，这可 
以快速实现为e =hx|nx|+hy|ny|+hz|nz|。 （22.18）22.10。 
平面/盒子交叉点971nhsg1g2g3g4ec正半空间xy图22.18。 
轴对齐的b具有中心，c和正半对角线h的牛对平面π进行测试。这 
个想法是计算从盒子中心到平面的有符号距离s，并将其与盒子的 
 “范围”e进行比较。矢量gi是二维盒的不同可能对角线，其中h 
在该示例中等于g1。还要注意，带符号距离s为负，其大小大于e， 
表示该框位于平面内（s +e <0）。为什么这相当于找到八个不同 
的半对角线投影的最大值？这八个半对角线是组合：gi= （±hx，± 
hy，±hz），我们想要计算所有八个i的gi·n。当点积中的每个项 
为正时，点积gi·n将达到其最大值。对于x-term，当nx与hix具 
有相同的符号时会发生这种情况，但由于我们知道 hx已经是正数， 
我们可以将最大项计算为hx|nx|。对y和z执行此​ ​ 操作也可 
以得到公式22.18。接下来，我们计算从中心点c到平面的有符号 
----------------------- Page 1061-----------------------
距离s。这可以通过以下方式完成：s=c·n+d。s和e都如图22.18 
所示。假设飞机的 “外部”是正半空间，我们可以简单地测试是否 
为s。e>0，然后表示该盒子完全在飞机外面。同样，s +e <0表 
示盒子完全在里面。否则，框与平面相交。这项技术基于Ville 
Miettinen 的想法和他聪明的实施。伪代码如下： 
PlaneAABBIntersect （B，π）返回（{OUTSIDE，INSIDE， 
INTERSECTING}）; 1：c= （bmax+bmin）/22：h= （bmax。 
bmin）/ 23：e =hx|nx|+hy|ny|+hz|nz|4：s =c·n+d 
5：if s.e>（ 0）返回 OUTSIDE（ ）;9：if s（+e <0）返回 （INSIDE）; 10： 
退货（交叉）; 972 22.交叉口试验方法22.10.2OBB对平面测试 
OBB与上一节中的AABB/平面测试略有不同。只需计算需要更改 
的框的 “范围”，即e =hBu|n·bu|+hBv|n·bv|+hBw|n·bw 
|。 （22.19）回想一下， （bu，bv，bw）是OBB的坐标系轴 （参 
见第22.2节中OBB的定义），（hBu，hBv，hBw）是沿这些轴 
的框长度。22.11三角/三角交点由于图形硬件使用三角形作为其最 
重要（和优化）的绘图基元，对这类数据进行碰撞检测测试也是很 
自然的。因此，碰撞检测算法的最深层通常具有确定两个三角形是 
否相交的例程。给定两个三角形，T1 =△p1p2p3和T2 =△q1q2q3 
 （分别位于平面π1和π2），我们想确定它们是否相交。从高层开 
始，通常首先检查T1是否与π2相交，以及T2是否与π1相交[1232]。 
如果这些测试中的任何一个失败，就不会有交集。假设三角形不是 
共面的，我们知道平面的交点π1和π2将是一条线 L.这在图22.19 
----------------------- Page 1062-----------------------
中说明。从图中可以得出结论，如果三角形相交，它们在L上的交 
点也必须重叠。否则，将没有交叉点。有不同的方法来实现这一点， 
我们接下来介绍Guigue和 Devillers [622]的方法。图22.19。三 
角形和它们所在的平面。两个图中的交叉间隔都标记为红色。左： 
沿着线L的间隔重叠，以及三角形。右：没有交叉点;两个间隔不重 
叠。22.11。三角/三角交叉口973bacd图22.20。螺丝传染媒介b 
的例证。a朝d方向 C。在该实现中，大量使用来自四个三维向量a， 
b，c和d的4×4个行列式：[a，b，c，d]=。axbxcxdxaybycy 
dyazbzczdz1111= （d.a）· （（b.a）× （c.a））。（22.20） 
几何上，公式22.20具有直观的解释。交叉乘积 （b.a）× （c.a）可 
以看作计算三角形的法线，即？abc。通过取这个法线和矢量从a 
到d之间的点积，如果d在三角形平面的正半空间中，我们得到一 
个正值，即？abc。另一种解释是，行列式的符号告诉我们ba方向 
的螺钉是否与dc所示的方向相同，如图22.20所示。我们首先测 
试T1是否与π2相交，反之亦然。这可以通过评估[q1，q2，q3， 
p1]，[q1，q2，q3，p2]和[q1，q2，q3，p3]使用来自方程22.20 
的专门决定因素来完成。第一个测试相当于计算T2的法线，然后测 
试点 p1所在的半空间。如果这些决定因素的符号相同且非零，没 
有交叉点，测试结束。如果全部为零，则三角形是共面的，并且执 
行单独的测试来处理这种情况。否则，我们继续测试T2是否与π1 
相交，使用相同类型的测试。此时，计算 L上的两个间隔I1=[i，j] 
和 I2 =[k，l]，其中I1由T1计算，I2由T2计算。为此，每个三 
----------------------- Page 1063-----------------------
角形的顶点都会重新排序，因此第一个顶点在另一个三角形平面的 
一侧是唯一的。如果 I1与 I2重叠，则两个三角形相交，这仅在k≤ 
j 且i≤l时发生。为了实现k≤j，我们可以使用行列式的符号检验 （公 
式22.20），并注意j 来自 p1p2，k来自q1q2。使用行列式计算 
的 “螺旋测试”的解释，我们可以得出结论k≤j 如果[p1，p2，q1， 
q2]≤0。然后最终测试变为[p1，p2，q1，q2]≤0且[p1，p3，q3， 
q1]≤0。 （22.21）整个测试从六个行列式测试开始，并且前三个共 
享第一个参数，因此可以共享许多计算。原则上，行列式可以是974 
22.交叉测试方法使用许多较小的2×2子确定子计算，并且当这些 
在多于一个4×4行列式中出现时，可以共享计算。Web上有代码 
用于此测试[622]，并且还可以扩充代码以计算实际的交叉线段。如 
果三角形是共面的，则将它们投影到轴对齐的平面上，其中三角形 
的面积最大化（第22.9节）。然后，执行简单的二维三角形 - 三 
角形重叠测试。首先，测试所有封闭边缘 （即，包括T1的端点）用 
于与T2的闭合边缘相交。如果找到任何交叉点，则三角形相交。否 
则，我们必须测试T1是否完全包含在T2中，反之亦然。这可以通 
过针对T2的T1的一个顶点执行三角形点测试（第22.8节）来完 
成，反之亦然。请注意，分离轴测试 （参见第947页）可用于导出 
三角形/三角形重叠测试。我们改为由Guigue和 Devillers [622] 
进行测试，这比使用SAT更快。存在用于执行三角形/三角形交叉 
[713,1619,1787]的其他算法。架构和编译器的差异以及预期命中率 
的变化意味着我们不能推荐总是性能最佳的单一算法。请注意，与 
----------------------- Page 1064-----------------------
任何几何测试一样，可能会出现精度问题。Robbins和Whitesides 
[1501]使用Shewchuk [1624]的精确算法来避免这种情况。22.12 
三角形/框交点本节介绍一种确定三角形是否与轴对齐框相交的算 
法。这种测试对于体素化和碰撞检测是有用的。Green和 Hatch 
[581]提出了一种算法，可以确定任意多边形是否与框重叠。 
Akenine-M'oller [21]开发了一种更快的方法，该方法基于分离轴 
测试 （第947页），我们在此提出。也可以使用此测试执行三角形 
/球形测试，有关详细信息，请参阅 Ericson的文章[440]。我们专 
注于测试由中心c定义的轴对齐边界框（AABB）和半长度为h的 
矢量 （对齐三角形？u0u1u2）。为了简化测试，我们首先移动框和 
三角形，使框以原点为中心，即vi =ui。c，i∈{0,1,2}。此转换和 
使用的符号如图22.21所示。为了测试一个定向框，我们首先通过 
反向框变换旋转三角形顶点，然后在这里使用测试。基于分离轴测 
试 （SAT），我们测试以下 13个轴：1。[3个测试]e0= （1,0,0）， 
e1 = （0,1,0），e2 = （0,0， 1）（AABB的法线）。换句话说， 
测试AABB与三角形周围的最小AABB。2. [1测试] n，正常的？ 
u0u1u2。我们使用快速平面/AABB重叠测试（第22.10.1节）， 
该测试仅测试对角线的两个顶点，其方向与三角形的法线最接近。 
22.12。三角/盒交叉口975e0= （1,0，0）e1= （0,1,0）图22.21。 
用于三角形/框重叠测试的符号。在左侧，显示了框的初始位置和三 
角形，而在右侧，框和三角形已被翻译，使得框中心与原点重合。3. 
[9个测试]ai​ ​ j =ei×fj，i，j∈{0,1,2}，其中f0 =v1。v0，f1 = 
----------------------- Page 1065-----------------------
v2。v1，和f2 =v0。v2，即边缘矢量。这些测试的形式相似，我 
们只展示i=0和j =0的情况的推导 （见下文）。一旦找到分离轴， 
算法就会终止并返回 “无重叠”。如果所有测试都通过，即没有分 
离轴，则三角形与框重叠。在这里，我们在步骤3中推导出九个测 
试中的一个，其中i=0且j =0.这意味着a00=e0×f0 = （0，.f0z， 
f0y）。所以，现在我们需要将三角形顶点投影到a00 （以下称为a）： 
p0=a·v0 = （0，.f0z，f0y）·v0 =v0zv1y。v0yv1z，p1=a·v1 = 
 （0，.f0z，f0y）·v1 =v0zv1y。v0yv1z =p0， （22.22）p2=a·v2 
= （0，.f0z，f0y）·v2 = （v1y.v0y）v2z。 （v1z.v0z）v2y。通常， 
我们必须找到min （p0，p1，p2）和max （p0，p1，p2），但幸 
运的是p0 =p1，这简化了计算。现在我们只需要找到min （p0， 
p2）和max （p0，p2），这明显更快，因为条件语句在现代CPU 
上很昂贵。在将三角形投影到a上之后，我们需要将框投影到a上。 
我们计算投影在a上的框的 “半径”r为r=hx|ax |+hy|ay |+ 
hz|az | =hy|ay |+hz|az |，（22.23）其中最后一步来自该特 
定轴的ax =0。然后，如果（min （p0，p2）>r或 max （p0， 
p2）<。r）返回false，则此轴测试变为; （22.24）代码可在网上 
获得[21]。97622.交叉口试验方法图22.22。显示对象的球体 （左）， 
AABB （中左），OBB （中右）和 k-DOP （右），其中OBB和k-DOP 
的空白空间明显少于其他对象。22.13边界体积/边界体积交点边界 
体积的目的是提供更简单的交叉测试并提高排斥效率。例如，要测 
试两辆车是否发生碰撞，首先找到他们的BV并测试这些是否重叠。 
----------------------- Page 1066-----------------------
如果他们不这样做，那么保证汽车不会碰撞（我们假设这是最常见 
的情况）。然后我们避免测试一辆汽车的每个原语与另一个汽车的 
每个原语，从而节省计算。基本操作是测试两个边界体积是否重叠。 
测试AABB，k-DOP和OBB重叠的方法将在以下章节中介绍。有 
关在基元周围形成 BV的算法，请参见第22.3节。使用比球体和 
AABB更复杂的 BV的原因是更复杂的BV通常具有更紧密的拟合。 
如图22.22所示。当然，其他边界量也是可能的。例如，圆柱体和 
椭圆体有时用作对象的边界体积。此外，可以放置几个球体来包围 
单个物体[782,1582]。对于胶囊和锭剂 BV，计算最小距离是相对快 
速的操作。因此，它们通常用于公差验证应用，在哪里想要验证两 
个（或更多）对象是否至少相隔一定距离。Eberly[404]和 Larsen 
等人。[979]导出这些类型的边界体积的公式和有效算法。22.13.1 
球体/球体交点对于球体，相交测试简单快捷：计算两个球体中心之 
间的距离，如果该距离大于两个球体半径的总和，则拒绝。否则， 
他们相交。在实现该算法时，最好使用这两个量的平方距离，因为 
所需要的只是比较的结果。以这种方式，避免了计算平方根（昂贵 
的22.13。边界体积/边界体积交点977操作）。Ericson[435]给出 
了SSE代码，用于同时测试四对独立的球体。22.13。2球体/盒子 
交点Arvo [70]首次提出了一种测试球体和AABB是否相交的算法， 
这种算法非常简单。我们的想法是在AABB上找到最接近球体中心 
的点，c。使用一维测试，一个用于AABB的三个轴中的每一个。轴 
的球体中心坐标将根据AABB的边界进行测试。如果它在边界之外， 
----------------------- Page 1067-----------------------
则计算球面中心与沿该轴的方框之间的距离（减法）并求平方。在 
沿三个轴完成此操作之后，将这些平方距离的总和与球体的平方半 
径r2进行比较。如果总和小于平方半径，则最近的点在球体内，并 
且框重叠。正如Arvo所示，可以修改此算法以处理空心框和球体， 
以及轴对齐的椭圆体。拉尔森等人。[982]呈现该算法的一些变体， 
包括相当快的SSE矢量化版本。他们的见解是尽早使用简单的拒绝 
测试，无论是每轴还是一开始都是如此。拒绝测试是查看沿轴的中 
心到盒子的距离是否大于半径。如果是这样，测试可以提前结束， 
因为球体不可能与盒子重叠。当重叠的可能性很低时，这种早期拒 
绝方法明显更快。接下来是他们测试的QRI （快速拒绝交织）版本。 
早期测试在第4和第7行，如果需要可以删除。boolSphereAABB 
相交（c，r，A）返回（{OVERLAP，DISJOINT}）; 1：d =02： 
对于每个i∈{x，y，z}3：if （（e =ci.aminmin）<0）4：if （e <。 
r）return （DISJOINT）; 5：d =d+e2;6：否则if （（e=ci.amax 
i）>0）7：if （e>r）return （DISJOINT）;8：d =d +e2;9：if 
 （d> r2）返回（DISJOINT）; 10：返回（OVERLAP）;对于快速 
矢量化（使用SSE）实现，Larsson等人。建议消除大部分分支机 
构。该想法是使用以下表达式同时评估线3和6：e =max （amin 
i.ci，0）+max （ci.amaxi，0）。 （22.25）97822.交叉测试方法 
通常，我们会将d更新为d =d+e2。但是，使用SSE，我们可以 
并行计算公式22.25的x，y和z。完整测试的伪代码如下。bool 
SphereAABB相交 （c，r，A）返回 （{OVERLAP，DISJOINT}）; 1： 
----------------------- Page 1068-----------------------
e= （max （aminx.cx，0），max （aminy.cy，0），max （amin 
z.cz，0））2：e =e + （max （cx.amaxx，0），max （cy.amax 
y，0），max （cz.amaxz，0））3：d =e·e4：if （d> r2）返 
回 （DISJOINT）; 5：退货 （OVERLAP）;注意，可以使用并行SSE 
max函数来实现第1行和第2行。即使在这个测试中没有早期出局， 
它仍然比其他技术更快。这是因为已经消除了分支并且使用了并行 
计算。SSE的另一种方法是对对象进行矢量化。Ericson[435]提出 
了SIMD代码，用于同时比较四个球体和四个AABB。对于球/OBB 
交点，首先将球体的中心转换为OBB的空间。也就是说，使用OBB 
的标准化轴作为转换球体中心的基础。现在该中心点相对于OBB的 
轴表示，因此OBB可以被视为AABB。然后使用球体/AABB算法 
来测试交叉点。Larsson[983]给出了椭球/OBB相交测试的有效方 
法。首先，缩放两个对象，使椭圆体成为球体，OBB成为平行六面 
体。可以执行球/板交叉测试以快速接受和拒绝。最后，测试球体与 
仅面对它的那些平行四边形的交叉点。22.13.3AABB/AABB交叉 
点顾名思义，AABB是一个面，其面与主轴方向对齐。因此，两点 
足以描述这样的体积。这里我们使用第22.2节中介绍的AABB的定 
义。由于它们的简单性，AABB通常用于碰撞检测算法和场景图中 
节点的边界体积。两个AABB，A和 B之间的交叉测试是微不足道 
的，总结如下：boolAABB 相交（A，B）返回（{OVERLAP， 
DISJOINT}）; 1：对于每个i∈{x，y，z} 2：if （amin i> bmaxi 
或 bmin i> amax i）3 ：return （DISJOINT）; 4 ：返回 
----------------------- Page 1069-----------------------
 （OVERLAP）; 22.13。边界体积/边界体积交点979第 1行和第2 
行在所有三个标准轴方向x，y和z上循环。Ericson[435]提供SSE 
代码，用于同时测试四对独立的AABB。22.13.4 k-DOP/ k-DOP 
交点k-DOP与另一个 k-DOP的交点测试仅包含k/ 2个区间重叠 
测试。Klosowski等。[910]已经表明，对于中等的k值，两个k-DOP 
的重叠测试比两个OBB的测试快一个数量级。在第946页的图22.4 
中，描绘了简单的二维k-DOP。请注意，AABB是6-DOP的特殊 
情况，其中法线是正主轴方向和负主轴方向。OBB也是6-DOP的 
一种形式，但只有当两个OBB共享相同的轴时才能使用此快速测 
试。接下来的交叉测试简单，快速，不精确但保守。如果要测试两 
个k-DOP，A和 B （上标有索引A和 B），则测试所有平行的平板 
对（SAi，SBi）是否重叠;si =SAi∩SBi是一维间隔重叠测试，可 
以轻松解决。这是降维的一个例子，正如第22.5节中的经验法则所 
推荐的那样。这里，将三维板坯试验简化为一维间隔重叠试验。如 
果在任何时候si =。（即空集），那么BV是不相交的，测试终止 
了。否则，板坯重叠测试继续进行。当且仅当所有si6 =。，1≤i≤ 
k/2时，则BV被认为是重叠的。根据分离轴测试（第22.2节）， 
还需要测试平行于每个k-DOP的一个边的叉积的轴。但是，这些测 
试经常被省略，因为它们的成本高于它们在性能上的回报。因此， 
如果下面的测试返回 k-DOP重叠，那么它们实际上可能是不相交 
的。这是k-DOP/ k-DOP重叠测试的伪代码：kDOP相交（dA， 
min1，...，dA，mink/ 2，dA，max1，...，dA，maxk/ 2 ， 
----------------------- Page 1070-----------------------
dB，min1，...，dB，mink/2，dB，max1，...，dB，maxk/2） 
返回 （{OVERLAP，DISJOINT}）; 1：对于每个i∈{1,. 。。，k/2} 
2：if （dB，mini>dA，maxi或dA，mini>dB，maxi）3：return 
 （DISJOINT）;4：返回 （OVERLAP）;注意，每个k-DOP实例只 
需要存储k个标量值 （normals，ni，对于所有k-DOP都存储一次， 
因为它们是静态的）。如果k-DOP分别由tA和tB平移，则测试变 
得更复杂一些。将tA投影到法线上，ni，例如，pAi=tA·ni （注意， 
这与任何k-DOP无关，因此每个tA或tB只需计算一次）并将pAi 
加到dA，mini和dA ，if-statement中的maxi。对于tB也是如 
此。换句话说，平移改变了k-DOP沿每个法线方向的距离。98022. 
交叉测试方法Laine和Karras[965]提出了称为顶点图的k-DOP的 
扩展。想法是将一组平面法线映射到k-DOP上的各个点，这样存储 
的每个点代表沿该方向的最远位置。该点和方向形成一个平面，该 
平面完全包含一个半空间中的模型，即该点位于模型的k-DOP的顶 
点。在测试期间，针对给定方向检索的顶点可用于更精确的k-DOP 
之间的交叉测试，用于改进平截头体剔除，以及用于在旋转之后找 
到更紧密的AABB，作为一些示例。22.13.5OBB/ OBB交点在本 
节中，我们简要概述了一种测试两个OBBA和 B之间交叉的快速方 
法[436,576,577]。该算法使用分离轴测试，并且比使用最接近的特 
征或线性编程的先前方法快约一个数量级。OBB的定义可以在第 
22.2节中找到。测试在由A的中心和轴形成的坐标系中完成。这意 
味着原点是ac = （0,0,0）并且该坐标系中的主轴是au = （1,0,0）， 
----------------------- Page 1071-----------------------
av= （0,1,0）和aw= （0 ，0,1）。此外，假设 B相对于A定位， 
具有平移t和旋转（矩阵）R。根据分离轴测试，找到分离A和 B 
的一个轴以确保它们是不相交的就足够了。 （不要重叠）。必须测 
试 15个轴：三个来自A面，三个来自 B面，3·3 =9来自A和 B 
边缘的组合。这在图22.23中以二维显示。没有重叠图22.23。为 
了确定两个OBB是否重叠，可以使用分离轴测试。这里，它以二维 
显示。四个分离轴与两个OBB的面正交，每个盒两个轴。然后将 
OBB投影到轴上。如果两个投影在所有轴上重叠，则OBB重叠;否 
则，他们没有。因此，找到一个分隔投影的轴就足以知道OBB不重 
叠就足够了。在此示例中，左下轴是唯一分隔投影的轴。（图2之 
后的 Ericson[436]。）22.14。查看 FrustumIntersection981由 
于矩阵A = （auavaw）的正交性，应该与A的面正交的潜在分离 
轴仅仅是轴au，av和aw。对于 B来说同样如此。剩下的九个潜在 
轴，由A和 B各自形成一个边，然后是cij =ai×bj，.i∈{u，v，w} 
和.j∈{u，v，白}。幸运的是，这里有优化的代码[1574]。22.14查 
看 Frustum交叉点如第 19.4节所示，分层视锥体剔除对于快速渲 
染复杂场景至关重要。在 boundingvolume-层次结构剔除遍历期 
间调用的少数操作之一是视锥体和边界体积之间的交叉测试。因此， 
这些操作对于快速执行至关重要。理想情况下，他们应该确定 BV 
是完全在内 （包含），它是完全在外 （排除），还是与截头锥相交。 
要回顾一下，视锥体是一个金字塔，被近平面和远平面（平行）截 
断，使得体积有限。事实上，它变成了一个多面体。如图22.24所 
----------------------- Page 1072-----------------------
示，其中标记了六个平面的名称，即近，远，左，右，顶部和底部。 
视锥体体积定义了应该可见并因此呈现的场景部分（对于锥体截锥 
体的透视）。用于层次结构中的内部节点（例如，场景图）和用于 
封闭几何的最常见的边界体积是球体，AABB和OBB。因此，此处 
将讨论并推导出平截头体/球体和平截头体/AABB/ OBB测试。为 
了了解为什么我们需要三个返回结果在 outside / inside / 
intersect之外，我们将检查在遍历边界卷层次结构时会发生什么。 
如果发现 BV完全在视锥体之外，那么BV的子树将不会被进一步遍 
历并且不会渲染其几何体。另一方面，如果 BV完全位于内部，则 
不需要为该子树计算平截头体/ BV测试，并且将绘制每个可渲染叶。 
对于部分可见的 BV，即与平截头体相交的BV，BV的子树递归地对 
平截头体进行测试。如果 BV用于叶子，那么必须渲染该叶子。无 
限金字塔相机视图视锥体左下方右上方截断远图22.24。左边的插 
图是一个无限金字塔，然后由平行的近和远平面裁剪，以构造视锥 
体。还显示了其他平面的名称，并且摄像机的位置位于金字塔的顶 
点。98222.交叉测试方法完整测试称为排除/包含/交叉测试。有时， 
第三个状态交叉点可能被认为计算成本太高。在这种情况下，BV被 
归类为 “可能在里面。”我们将这种简化算法称为排除/包含测试。 
如果无法成功排除 BV，则有两种选择。一种是将 “可能内部”状态 
视为包含，意味着 BV内的所有内容都被渲染。这通常是低效的， 
因为不执行进一步的剔除。另一种选择是依次测试子树中的每个节 
点以进行排除。这种测试通常没有任何好处，因为很多子树可能确 
----------------------- Page 1073-----------------------
实在平截头体内。因为这两种选择都不是特别好，所以即使测试不 
完善，一些尝试快速区分交叉和包含也是值得的。重要的是要意识 
到快速分类测试不一定要精确地用于场景图剔除，只是保守。为了 
区分排除与包含，所需要的只是测试错误包含。那是，可能会错误 
地包含实际应被排除的对象。这样的错误只会花费额外的时间。另 
一方面，应该包含的对象永远不应被快速分类为测试排除，否则将 
发生渲染错误。对于包含与交叉，任何类型的错误分类通常是合法 
的。如果完全包含的BV被分类为交叉，则浪费时间测试其交叉子 
树。如果将相交的 BV视为完全内部，则通过渲染所有对象（其中 
一些可能已被剔除）浪费时间。在我们介绍平截头体和球体，AABB 
或OBB之间的测试之前，我们将描述平截头体和一般物体之间的交 
叉测试方法。该测试如图22.25所示。我们的想法是将测试从 BV/ 
视锥测试转换为点/体积测试。首先，选择相对于 BV的点。然后 BV 
沿着平截头体的外侧移动，尽可能接近它而不重叠。在此移动过程 
中，跟踪相对于BV的点，并且其轨迹形成一个新体积（图22.25 
中具有粗边的多边形）。BV尽可能靠近平截头体移动的事实意味着 
如果相对于 BV的点 （在其原始位置）位于跟踪体积内，则 BV与截 
锥体相交或在锥体内。因此，不是测试 BV与平截头体的交点，而 
是针对另一个新的体积测试相对于 BV的点，该体积由该点追踪。 
以同样的方式，BV可沿平截头体内侧移动，尽可能靠近平截头体。 
这将描绘出一个新的，较小的平截头体，其平面与原始平截头体平 
行[83]。如果相对于对象的点位于此新体积内，则 BV完全位于平截 
----------------------- Page 1074-----------------------
头体内。该技术用于在后续章节中导出测试。请注意，新体积的创 
建与实际 BV的位置无关 - 它仅取决于点相对于BV的位置和BV 
的形状。这意味着可以针对相同的体积测试具有任意位置的 BV。只 
保存父 BV与每个孩子的交集状态是一个有用的优化。如果已知父 
母完全位于视锥体内，则后代都不需要任何进一步的视锥体测试。 
平面掩蔽和时间相干技术dis 22.14。查看Frustum Intersection 
983图22.25。左上图显示平截头体（蓝色）和一般边界体积（绿 
色），其中选择了相对于对象的点 p。通过追踪物体在平截头体的 
外侧（右上方）和内侧（左下方）移动的点 p，尽可能接近平截头 
体，可以将平截头体/ BV重新形成为测试点p对外部和内部容积。 
这显示在右下方。如果点 p在橙色体积之外，那么 BV在平截头体 
之外。如果 p在橙色区域内，BV与平截头体相交，如果 p在紫色 
区域内，则 BV完全在平截头体内。在第 19.4节中讨论的内容也可 
以明显改进针对边界卷层次结构的测试，虽然对SIMD实现不太有 
用[529]。首先，我们推导出平截头体的平面方程，因为这些是这些 
类型的测试所需要的。接下来介绍 Frustum/球体交叉点，然后解 
释平截头体/盒子交叉点。22.14.1Frustum平面提取为了观察平截 
头体剔除，需要平截头体的六个不同侧面的平面方程。我们在这里 
介绍了一种巧妙而快速的方法。假设视图矩阵是V并且投影矩阵是 
P.复合变换则是 M=PV。点s （其中sw=1）被转换为t，因为t = 
Ms.此时，由于例如透视投影，t可以具有tw 6 =1。因此，t中的 
所有分量除以tw以获得uw=1的点u。对于视锥体内的点，它保 
----------------------- Page 1075-----------------------
持.1≤ui≤1，对于i∈x，y，z，即点u在984内.22。交点测试方法 
单位立方体。这适用于OpenGL类型的投影矩阵 （第4.7节）。对 
于 DirectX，除了0≤uz≤1之外，同样适用。平截头体的平面可以 
直接从复合变换矩阵的行导出。将焦点集中在单位立方体左平面右 
侧的体积上，其中.1≤ux。这扩展如下：.1≤ux...1≤txtw..tx +tw≥ 
0.... （m0，·s）+ （m3，·s）≥0.. （m0，+m3， ）·s≥0。 （22.26） 
在推导中，mi表示in中的第i行。实际上，最后一步 （m0，+m3，）·s 
≥0表示视锥体的左平面的 （半）平面方程。这是因为单位立方体中 
的左平面已经变换回世界坐标。另请注意，sw =1，这使得方程成 
为一个平面。为了使平面点的法线从平截头体向外，必须否定该等 
式（因为原始等式描述了单位立方体的内部）。对于平截头体的左 
平面 （我们使用 （x，y，z，1）而不是使用平面方程，给出。 （m3， 
+m0，）· （x，y，z，1）=0形式：ax +by+cz +d =0）。总 
而言之，所有平面都是。 （m3，+m0，）· （x，y，z，1）=0[左]，。 
 （m3，.m0，）· （x，y，z，1）=0[右]，。 （m3，+m1，）· （x， 
y，z，1）=0[bottom],. （m3，.m1，）· （x，y，z，1）=0[top],. 
 （m3，+m2，）· （x，y，z，1）=0[near],. （m3，.m2，）· （x， 
y，z，1）=0 [far] 。（22.27）在OpenGL和 DirectX中执行此 
操作的代码可在网上获得[600]。22.14.2Frustum/ Sphere交叉点 
正交视图的平截头体是一个盒子，因此，在这种情况下，重叠测试 
成为球/ OBB交叉点，可以使用第22.13.2节中介绍的算法求解。 
为了进一步测试球体是否完全在盒子内，我们首先检查球体的中心 
----------------------- Page 1076-----------------------
是否在每个轴的盒子边界之间的距离大于其半径。如果它在所有三 
个维度之间，则它是完全包含的。有关此修改算法的有效实现以及 
代码，请参阅Arvo的文章[70]。按照导出平截头体/ BV测试的方 
法，对于任意平截头体，我们选择球体的中心作为要跟踪的点p。 
如图22.26所示。如果半径为 r的球体沿着平截头体的内侧和外侧 
移动并尽可能靠近平截头体，然后，p的轨迹为我们提供了重新构 
造平截头体/球体测试所需的体积。实际体积显示在图22.26的中间 
部分。和以前一样，如果 p在橙色 22.14之外。查看 Frustum 
Intersection985图22.26。在左侧，显示了平截头体和球体。精 
确的平截头体/球体测试可以表示为针对中图中的橙色和紫色体积 
的测试p。右边是中间体积的合理近似值。如果球体的中心位于圆 
角外，但在所有外平面内，即使它位于平截头体之外，它也会被错 
误地分类为相交。体积，然后球体在平截头体之外。如果p在紫色 
区域内，则球体完全位于平截头体内。如果该点位于橙色区域内， 
球体与平截头体侧面相交。通过这种方式，可以进行精确的测试。 
但是，为了提高效率，我们使用了图22.26右侧的近似值。这里， 
橙色体积已经扩展，以避免圆角需要的更复杂的计算。注意，外部 
体积包括平截头体在平截头体平面法线方向上向外移动的距离单位 
的平面，并且内部体积可以通过将平截头体距离单元的平面向内移 
动而形成。平截头体平面法线。假设平截头体的平面方程使得正半 
空间位于平截头体之外。然后，实际的实现将环绕平截头体的六个 
平面，并且对于每个平截头体平面，计算从球体中心到平面的有符 
----------------------- Page 1077-----------------------
号距离。这是通过将球心插入平面方程来完成的。如果距离大于半 
径r，则球体位于平截头体之外。如果到所有六个平面的距离小于.r， 
则球体在平截头体内;否则球体与它相交。更准确地说，我们说球体 
与平截头体相交，但球体中心可能位于圆角外的一个尖角区域，如 
图22.26所示。这意味着球体位于平截头体之外，但我们报告它是 
相交的，保守地说是正确的。为了使测试更准确，如果球体在外面， 
可以添加额外的平面用于测试。但是，为了快速剔除场景图节点， 
偶尔的错误命中只会导致不必要的测试，而不是算法失败，而这种 
额外的测试将花费更多的时间。第20.3节描述了另一种更精确但不 
精确的方法，这种方法适用于这些尖角区域很重要的情况。98622. 
交叉测试方法对于有效的着色技术，截头锥体通常是高度不对称的， 
其特殊方法如图20.7 第（895页）所述.Assarsson和 Mololler[83] 
提供了一种方法，可以消除每个测试中的三个平面通过将平截头体 
分成八分圆并找到物体中心所在的八分圆。22.14.3Frustum/ Box 
交叉点如果视图的投影是正交的（即平截头体有一个盒子形状）， 
可以使用OBB/OBB交叉测试进行精确测试 （第22.13.5节）。对 
于一般的平截头体/盒子交叉点测试，通常使用两种方法。一种简单 
的方法是通过使用视锥体的视图和投影矩阵将所有八个盒角转换为 
视锥体的坐标系。对沿每个轴延伸[.1,1]的规范视图体积执行剪辑测 
试 （第4.7.1节）。如果所有点都在一个边界之外，则拒绝该框;如 
果全部都在，则框完全包含[529]。由于此方法模拟剪切，因此它可 
用于由一组点分隔的任何对象，例如线段，三角形或k-DOP。该方 
----------------------- Page 1078-----------------------
法的一个优点是不需要平截头平面提取。其独立的简洁性使其有效 
地用于计算着色器[1883,1884]。在CPU上更有效的方法是使用第 
22.10节中描述的平面/盒子相交测试。与平截头体/球体测试一样， 
OBB或AABB针对六个视锥体平面进行检查。我们不是计算平面上 
所有八个角的有符号距离，而是在平面/盒子测试中检查最多两个 
角，由平面法线确定。如果最近的角落在飞机外，则盒子完全在外 
面并且测试可以提前结束。如果每个平面的最远角落在里面，那么 
盒子就包含在平截头体内。注意，可以共享近平面和远平面的点积 
距离计算，因为这些平面是平行的。第二种方法的唯一额外成本是 
必须首先推导出平截头体的平面，如果要测试几个方框则需要付出 
微不足道的费用。与平截头体/球体算法一样，测试会将盒子分类为 
交叉，实际上完全在外面。这些错误如图22.27所示。Qu'.lez[1452] 
指出，对于固定大小的地形网格或其他大型对象，这种情况可能会 
更频繁发生。当报告交叉点时，他的解决方案是然后还测试平截头 
体的角对着形成边界框的每个平面。如果所有点都在盒子的平面之 
外，则平截头体和盒子不相交。此附加测试等同于分离轴测试的第 
二部分，其中测试的轴与第二个对象的面正交。也就是说，这样的 
额外测试可能比产生的效益更昂贵。对于他的GIS渲染器，Eng[425] 
发现这种优化每帧 CPU耗时 2毫秒，只能节省几个绘制调用。 
Wihlidal [1884]采用平截头体剔除的另一个方向，仅使用四个平截 
头体侧面并且不执行近距离和远距离平面剔除测试。他指出，这两 
架飞机对电子游戏没什么帮助。近飞机大多是22.15。线/线交点987 
----------------------- Page 1079-----------------------
图22.27。粗黑线是平截头体的平面。当使用所提出的算法测试框 
 （左）对平截头体时，当框在外面时，框可能被错误地分类为交叉。 
对于图中的情况，当盒子的中心位于红色区域时会发生这种情况。 
冗余，因为侧面平面几乎修剪掉它所做的所有空间，并且远平面通 
常设置为查看场景中的所有对象。另一种方法是使用分离轴测试（见 
第22.13节）来导出交叉例程。一些作者使用分离轴测试来获得两 
个凸多面体的一般解[595,1574]。然后，单个优化测试可用于线段， 
三角形，AABB，OBB，k-DOP，截头和凸多面体的任何组合。22.15 
线/线交点在本节中，导出并检查了二维和三维线/线交点测试。线 
条，光线和线段彼此相交，并且描述了快速和优雅的方法。22.15.1 
二维第一种方法从理论的角度来看，计算一对二维线之间交点的第 
一种方法确实很美观。考虑两条线，r1 （s）=o1 +sd1和r2 （t） 
=o2+td2。由于aa=0 （来自 1.2.1节的perp点积[735]），r1 
 （s）和r2 （t）之间的交集计算变得优雅和简单。注释98822.交 
叉点测试方法所有向量在本节中是二维的：1：r1 （s）=r2 （t）..2： 
o1 +sd1 =o2 +td2..3:?sd1·d⊥2= （o2.o1）·d⊥2td2·d⊥1= 
 （o1.o2）·d⊥1..4：.......s = （o2.o1）·d ⊥2d1·d⊥2t= （o1。 
o2）·d⊥1d2·d⊥1 （22.28）如果d1·d⊥2=0，则这些线是平行的， 
不会发生交叉。对于无限长度的行，s和t的所有值都是有效的，但 
是对于线段 （具有标准化方向），例如长度为l1和l2 （从s=0开 
始，t =0，结束于s=l1和t =l2），当且仅当0≤s≤l1且0≤t≤l2 
时，我们才有一个有效的交点。或者，如果设置o1 =p1且d1 =p2。 
----------------------- Page 1080-----------------------
p1（意思是线段从p1开始并在p2结束）并且对于具有起点和终点 
q1和q2的r2同样如此，当且仅当0≤s≤1且0≤t≤1时才发生有 
效交叉。对于具有原点的光线，有效范围为s≥0且t≥0。通过将s 
插入r1或将t插入r2可获得交点。第二种方法安东尼奥[61]描述了 
另一种决定两个线段（即有限长度）是否相交的方法，即通过做更 
多的比较和早期拒绝以及避免前面公式中昂贵的计算（划分）。因 
此这种方法更快。再次使用先前的符号，即，第一线段从 p1到p2， 
第二线从q1到q2。这意味着r1 （s）=p1+s （p2.p1），r2 （t） 
=q1 +t （q2.q1）。公式22的结果。28用于获得 r1 （s）=r2 
 （t）的解：...........s=.c·a⊥b·a⊥=c·a⊥a·b⊥=df，t =c·b⊥a·b 
⊥=ef。（22.29）在公式22.29中，a =q2。q1，b =p2。p1， 
c =p1。q1，d =c·a⊥，e =c·b⊥，f =a·b⊥。因子s的简化步 
骤来自a⊥·b =.b⊥·a和a·b⊥=b⊥·a的事实。如果a·b⊥=0，那 
么这些线是共线的。Antonio [61]观察到s和t的分母是相同的， 
并且由于s和t不是明确需要的，因此可以省略除法运算。定义s= 
d/f和t =e/f。要测试0≤s≤1，使用以下代码：22.15。线/线交 
点9891：if f>（0）2：if d（<0或d>f）返回 NOINTERSECTION;3： 
否则4：if （d>0或d <f）返回NOINTERSECTION;经过这个测 
试，保证0≤s≤1。然后对t =e/ f （通过在代码中用e替换d）进 
行相同的操作。如果在该测试之后例程没有返回，则线段确实相交， 
因为t值也是有效的。该例程的整数版本的源代码可在Web [61] 
上获得，并且可以轻松转换以用于浮点数。22.15.2三维说我们想要 
----------------------- Page 1081-----------------------
在三维中计算两条线之间的交点 （由光线定义，公式22.1）。这些 
行再次被称为 r1 （s）=o1 +sd1和 r2 （t）=o2 +td2，对t的 
值没有限制。在这种情况下，perp点积的三维对应物是叉积，因为 
a×a =0，因此三维版本的推导非常类似于二维版本的推导。两行 
之间的交集如下：1：r1 （s）=r2 （t）..2：o1 +sd1=o2+td2 .. 
3:?sd1×d2= （o2.o1）×d2td2×d1= （o1.o2）×d1..4:?s （d1 
×d2）· （d1×d2）=.. （o2.o1）×d2？· （d1×d2）t （d2×d1）· （d2 
×d1）=.. （o1.o2）×d1？· （d2×d1）..5：...........s=det （o2.o1， 
d2，d1×d2）||d1×d2||2t =det （o2.o1 ，d1，d1×d2）||d1 
×d2||2 （22.30）步骤3来自两侧减去o1 （o2）然后与d2 （d1） 
交叉，步骤4通过点缀d1×d2得到（d2×d1）。最后，通过将右 
侧重写为决定因素（并改变底部方程中的一些符号），然后除以位 
于s （t）右侧的项，找到步骤5，解决方案。99022。交叉测试方 
法Goldman [548]注意到，如果分母||d1×d2 ||2等于0，那么这 
些线是平行的。他还观察到，如果线是倾斜的（即，它们不共享公 
共平面），则s和t参数表示最接近的点。如果要将线条视为线段， 
长度为l1和l2 （假设方向矢量d1和d2已归一化），则检查0≤s 
≤l1和 0≤t≤l2是否均为保持。如果不是，那么交叉点被拒绝。 
Rhodes[1490]深入解决了两条线或线段相交的问题。他提供了处 
理特殊情况的强大解决方案，并讨论了优化并提供了源代码。22.16 
三个平面之间的交叉给定三个平面，每个平面由标准化法向量 ni描 
述在平面上的任意点pi，i=1,2和3，这些平面之间的交点的唯一 
----------------------- Page 1082-----------------------
点p由公式22.31给出[549]。注意，如果两个或多个平面平行，则 
分母（三个平面法线的行列式）为零：p= （p1·n1）（n2×n3）+ 
 （p2·n2） （n3×n1）+ （p3· n3） （n1×n2）|n1n2n3|。 （22.31） 
该公式可用于计算由一组平面组成的 BV的角。一个例子是k-DOP， 
它由k个平面方程组成。公式22.31可以计算凸多面体的角，如果 
它是用适当的平面进行的。如果像通常那样以隐式形式给出平面， 
即πi：ni·x +di=0，那么我们需要找到点pi以便能够使用该等式。 
可以选择飞机上的任意点。我们计算最接近原点的点，因为这些计 
算很便宜。给定来自原点的光线指向平面的法线，将其与平面相交 
以得到最接近原点的点：ri （t）=tni ni·x +di =0？。ni·ri （t）+ 
di=0..tni·ni+di =0..t =.di。pi=ri （.di）=。dini。 （22.32） 
这个结果不应该让人感到意外，因为平面方程中的di​ ​ 只是保持 
从原点到平面的垂直负距离（如果这是真的，则法线必须是单位长 
度）。进一步阅读和资源 Ericson的实时碰撞检测[435]和 Eberly 
的3D游戏引擎设计[404]涵盖了各种各样的对象/对象交叉测试和 
层次遍历方法，以及其他许多方法，并包括源代码。施奈德和埃伯 
利的 22.16。三平面之间的交点991用于计算机图形的几何工具 
[1574]提供了许多用于二维和三维几何相交测试的实用算法。开放 
存取的计算机图形技术期刊发布了交叉口测试的改进算法和代码。 
较早的实用线性代数[461]是二维交叉例程和许多其他在计算机图 
形中有用的几何操作的良好来源。Graphics Gems 系列 
[72,540,695,902,1344]包括许多不同类型的交叉例程，并且代码可 
----------------------- Page 1083-----------------------
在Web上获得。免费的 Maxima[1148]软件适用于操纵方程和推 
导 公 式 。 本 书 的 网 站 包 含 一 个 页 面 ， 
realtimerendering.com/intersections.html，总结可用于许多对 
象/对象相交测试的资源。第23章图形硬件 “当我们得到最终的硬 
件时，性能就会飙升。” -J.Allard虽然图形硬件正在快速发展， 
但它的设计中常常使用一些通用概念和架构。我们在本章中的目标 
是了解图形系统的各种硬件元素以及它们之间的相互关系。本书的 
其他部分讨论了它们与特定算法的使用。在这里，我们以自己的方 
式呈现硬件。我们首先描述如何栅格化线条和三角形，然后介绍 
GPU的大规模计算功能如何工作以及如何安排任务，包括处理延迟 
和占用。然后，我们讨论内存系统，缓存，压缩，颜色缓冲以及与 
GPU中深度系统相关的所有内容。然后介绍有关纹理系统的详细信 
息，然后介绍有关GPU的体系结构类型的部分。第23.10节介绍了 
三种不同架构的案例研究，最后简要讨论了光线跟踪架构。23.1光 
栅化任何GPU的一个重要特征是它绘制三角形和线条的速度。如 
2.4节所述，光栅化由三角形设置和三角形遍历组成。此外，我们将 
描述如何在三角形上插入属性，该三角形与三角形遍历紧密相关。 
我们以保守的光栅化结束，这是标准光栅化的扩展。回想一下，像 
素的中心由 （x +0.5，y +0.5）给出，其中x∈[0，W.1]和y∈[0， 
H。1]是整数，W×H是屏幕分辨率，例如3840×2160。让非变换 
顶点称为vi，i∈{0,1,2}和变换顶点，包括投影但不包括除以w，是 
qi=Mvi。那么二维屏幕空间坐标是pi=.. （qix/qiw +1）W/2， 
----------------------- Page 1084-----------------------
 （qiy/ qiw +1）H/ 2？即，执行由w分量进行的透视分割，并 
且对该值进行缩放和平移以匹配屏幕分辨率。此设置如图23.1所 
示。99399423.图形硬件 （0,0） （16,8） （0.5,0.5） （1,1）p0xy 
p1p2图23.1。一个三角形，在屏幕空间中有三个二维顶点p0， 
p1和p2。屏幕尺寸为16×8像素。请注意，像素（x，y）的中心 
是（x +0.5，y +0.5）。底边的法线向量（长度缩放0.25）以红 
色显示。只有绿色像素在三角形内。黄色的辅助像素属于四边形 （2 
×2像素），其中至少一个像素被认为是内部，并且辅助像素的采样 
点（中心）位于三角形之外。需要辅助像素来使用有限差分来计算 
导数。可以看出，像素网格被分成2×2像素的组，称为四边形。为 
了能够计算纹理细节级别所需的导数 （第23.8节），计算所有四边 
形内部至少有一个像素位于三角形内部的像素着色（也在第3.8节 
中讨论）。这是大多数 （如果不是全部）GPU的核心设计，并影响 
以下许多阶段。三角形越小，辅助像素与三角形内像素的比率越大。 
这种关系意味着在执行像素着色时，小三角形是昂贵的（与三角形 
区域成比例）。最糟糕的情况是覆盖单个像素的三角形，这意味着 
它需要三个辅助像素。辅助像素的数量有时被称为四边形过度遮蔽。 
为了确定像素中心或任何其他样本位置是否在三角形内，硬件对每 
个三角形边缘使用边缘函数[1417]。这些基于线方程，即n·..（x，y）。 
p？=0， （23.1）其中n是矢量，有时称为边缘的法线，与边缘正 
交，p是线上的点。这些方程可以重写为ax +by +c =0.接下来， 
我们将导出边函数e2 （x，y）到p0和p1。边矢量是p1。p0，因 
----------------------- Page 1085-----------------------
此法线是逆时针旋转90度的边，即n2=。（（p1y.p0y），p1x.p0x）， 
它指向三角形的内部，如图23.1所示。通过将 n2和 p0插入等式 
23.1，e2（x，y）变为e2（x，y）=。（p1y.p0y）（x.p0x）+（p1x.p0x） 
 （y.p0y）=。 （p1y。 p0y）x + （p1x.p0x）y + （p1y.p0y）p0x。 
 （p1x.p0x）p0y =a2x +b2y +c2。（23.2）23.1。光栅化995 
对于精确地在边缘上的点（x，y），我们有e （x，y）=0.具有到 
三角形内部的法线点意味着对于打开的点，e （x，y）>0与正常点 
相同的边缘。边缘将空间分为两部分，e （x，y）>0有时称为正半 
空间，e （x，y）<0称为负半空间。可以利用这些属性来确定点是 
否在三角形内。调用三角形ei的边，i∈{0,1,2}。如果采样点 （x，y） 
在三角形内或边缘上，那么对于所有i，它必须保持ei （x，y）≥0。 
图形API规范通常要求屏幕空间中的浮点顶点坐标转换为定点坐 
标。这是为了以一致的方式定义决胜局规则（稍后描述）。它还可 
以使样本的内部测试更有效。pix和 piy都可以存储在例如 1.14.8 
位，即1个符号位，14位用于整数坐标，以及8位用于像素内的分 
数位置。在这种情况下，这意味着像素内的x和y都可以有28个可 
能的位置，整数坐标必须在[。 （214.1），214.1]的范围内。实际 
上，这种捕捉是在计算边缘方程之前完成的。边缘函数的另一个重 
要特征是它们的增量属性。假设我们已经在某个像素中心（x，y） 
= （xi +0.5，yi +0.5）评估了边函数，其中（xi，yi）是整数像素 
坐标，即我们已经评估了e （x，y） =ax +by +c。例如，为了 
评估右边的像素，我们想要计算e （x +1，y），它可以被重写为e 
----------------------- Page 1086-----------------------
 （x +1，y）=a （x +1）+by+c=a+ax +by+c=a +e （x， 
y）， （23.3）即，这只是在当前像素e （x，y）处评估的边缘函数 
加上a。可以在y方向上应用类似的推理，并且经常利用这些属性 
来快速评估小像素块中的三个边缘方程，例如，8×8像素，用于 “标 
记”每个像素一位的覆盖掩模，指示像素是否在内部。这一类的分 
层遍历将在本节稍后解释。重要的是要考虑当边缘或顶点完全穿过 
像素中心时会发生什么。例如，假设两个三角形共享边缘，并且该 
边缘穿过像素中心。它应该属于第一个三角形，第二个，还是两个？ 
从效率的角度来看，两者都是错误的答案，因为像素首先被其中一 
个三角形写入然后被另一个三角形覆盖。为此，通常使用 
tie-breaker规则，这里我们介绍 DirectX中使用的左上角规则。对 
于所有i∈{0,1,2}，ei （x，y）>0的像素始终被认为是在内部。当 
边缘穿过像素时，左上角的规则开始起作用。如果像素的中心位于 
上边缘或左边缘的边缘，则将像素视为内部。如果边缘是水平边缘 
而其他边缘在其下方，则边缘是顶边缘。如果边缘是非水平的并且 
位于三角形的左侧，则边缘是左边缘，这意味着三角形可以具有最 
多两个左边缘。它99623.图形硬件n = （a，b）e （x，y）>0e 
 （x，y）<0xye （x，y）=0图23.2。边函数的负半空间e （x，y） 
<0始终被认为是在三角形之外。这里，4×4像素图块的角投影到 
边缘的法线上。只有具有黑色圆圈的角需要针对该边缘进行测试， 
因为它对n的投影最大。然后可以得出结论，该瓦片在三角形之外。 
很容易检测边缘是顶部还是左边。顶边具有=0 （水平）并且b<0， 
----------------------- Page 1087-----------------------
而左边缘具有>0.用于确定样本点（x，y）是否在三角形内的整个 
测试有时被称为内部测试。我们还没有解释如何遍历行。通常，线 
可以呈现为椭圆形，像素宽的矩形，其可以由两个三角形组成，或 
者可以将另外的边缘方程用于矩形。这种设计的优点是边缘方程的 
相同硬件也用于线。点数被绘制为四边形。为了提高效率，通常以 
分层方式执行三角形遍历[1162]。通常情况下，硬件计算屏幕空间 
顶点的边界框，然后确定哪些图块位于边界框内并且还与三角形重 
叠。确定瓦片是否在边缘之外可以使用第22.10.1节中的AABB/ 
平面测试的二维版本的技术来完成。一般原理如图23.2所示。为了 
使其适应于平铺三角形遍历，可以首先确定在遍历开始之前应该针 
对边缘测试哪个平铺角[24]。要使用的切片角对于特定边的所有切 
片都是相同的，因为最接近的切片边角仅取决于边缘法线。对这些 
预定角点评估边缘方程，如果这个选定角落在其边缘之外，然后整 
个磁贴在外面，硬件不需要在该磁贴中执行任何每像素内部测试。 
要移动到相邻图块，可以按照图块使用上述增量属性。例如，要向 
右水平移动8个像素，需要添加8a。通过平铺/边缘交叉测试，可 
以分层地遍历三角形。如图23.3所示。瓷砖也需要以某种顺序遍历， 
这可以以Z字形顺序或使用一些空间填充曲线[1159]来完成，这两 
者都倾向于增加相干性。如果需要，可以添加分层遍历中的其他级 
别。例如，可以首先访问 16×16个区块，并且对于与三角形重叠的 
每个这样的区块，然后测试4×4个子区域[1599]。23.1。光栅化 
997234 6 15图23.3。使用4×4像素图块的平铺遍历时可能的 
----------------------- Page 1088-----------------------
遍历顺序。在此示例中，遍历从左上角开始，并继续向右。每个顶 
部瓦片与三角形重叠，但右上方的瓦片没有像素。遍历继续直接位 
于下方的区域，这完全在外部，因此不需要在每个像素内部测试。 
遍历然后继续向左，并且发现以下两个图块与三角形重叠，而左下 
图块则没有。例如，以扫描线顺序遍历三角形的平铺遍历的主要优 
点是像素以更连贯的方式处理，因此，也更加连贯地访问纹素。它 
还具有在访问颜色和深度缓冲区时更好地利用局部性的好处。例如， 
考虑以扫描线顺序遍历的大三角形。高速缓存特征码，以便最近访 
问的特征码保留在高速缓存中以供重用。假设mipmapping用于纹 
理化，这增加了缓存中纹素的重用级别。如果我们以扫描线顺序访 
问像素，则在到达扫描线的末尾时，扫描线开始处使用的纹素可能 
已经从高速缓存中逐出。由于在缓存中重用纹理元素更有效，而不 
是重复从内存中取出它们，因此通常在平铺中遍历三角形 
[651,1162]。这为纹理[651]，深度缓冲[679]和颜色缓冲[1463]提 
供了很大的好处。事实上，由于同样的原因，纹理和深度以及颜色 
缓冲区也存储在图块中。这将在第23.4节中进一步讨论。在三角形 
遍历开始之前，GPU通常具有三角形设置阶段。此阶段的目的是计 
算在三角形上保持不变的因子，以便遍历可以有效地进行。例如， 
此处计算三角形的边缘方程'（方程23.2）常数ai，bi，ci，i∈{0,1,2}， 
然后在当前三角形的整个遍历步骤中使用。三角设置还负责计算与 
属性插值相关的常量 （第23.1.1节）。随着讨论的继续，我们还将 
发现在三角形设置中可以计算一次的其他常数。必要时，剪切在三 
----------------------- Page 1089-----------------------
角​ ​ 形设置之前完成，因为剪切可以生成更多三角形在剪辑空间 
中剪切视图体积的三角形是一个昂贵的过程，因此如果不是绝对必 
要，GPU会避免这样做。总是需要在近平面上进行剪切，这可以产 
生一个或两个三角形99823.图形硬件保护带剔除剪切可见屏幕图 
23.4。防护带试图避免完全削波。假设保护带区域在x和y两者中 
都是±16K像素。中间的屏幕大约是6500×4900像素，这表明这 
些三角形是巨大的。底部的两个绿色三角形作为三角形设置的一部 
分或在之前的步骤中被剔除。常见的情况是中间的蓝色三角形，它 
与屏幕区域相交并完全位于防护带内。不需要完全剪切操作，因为 
只处理可见的图块。红色三角形位于防护带之外并与屏幕区域相交， 
因此需要剪裁。请注意，右侧的红色三角形被剪切为两个三角形。 
GLES。对于屏幕的边缘，大多数GPU然后使用保护带剪切，这是 
一种更简单的方案，可以避免更复杂的完整剪辑过程。该算法在图 
23.4中可视化。23.1.1插值在第22.8.1节中，重心坐标是作为计算 
光线和三角形的交点的副产品而生成的。任何每顶点属性ai，i∈ 
{0,1,2}都可以使用重心坐标 （u，v）作为 （u，v）= （1.u.v）a0+ 
ua1+va2进行插值， （23.4）其中a （u，v）是三角形上 （u，v） 
处的插值属性。重心坐标的定义是u=A1A0 +A1 +A2，v =A2 
A0 +A1 +A2， （23.5）其中Ai是图23.5左侧所示的子三角形的 
区域。第三坐标w =A0/ （A0 +A1 +A2）也是定义的一部分， 
其表示u+v +w =​ ​  1，即w =1。你v。我们使用术语 1。你v 
而不是w。公式23.2中的边缘方程可以使用边的法线表示，n2 = 
----------------------- Page 1090-----------------------
 （a2，b2），因为e2 （x，y）=e2 （p）=n2·.. （x，y）。p0？= 
n2· （p.p0），（23.6）23.1。光栅化999 p2，a2A0A1A2 p， 
au =0v =1v =0 p1，a1 p0，a0e2 （x，y）uvhbn2A2au = 
1图23.5。左：顶点处具有标量属性 （a0，a1，a2）的三角形。点 
p处的重心坐标与带符号区域（A1，A2，A0）成比例。中间：重 
心坐标（u，v）如何在三角形上变化的图示。右：正常n2的长度 
是逆时针旋转90度的边缘 p0p1。区域A2则为bh/ 2。其中p = 
 （x，y）。从定义点积的ition，这可以改写为e2 （p）=||n2|||| 
p。P0||cosα， （23.7）其中α是 n2和p之间的角度。P0。注意b 
=||n2||等于边缘p0p1的长度，因为n2是旋转90度的边缘。第 
二项的几何解释，||p.p0||cosα，是投影p时获得的矢量的长度。 
p0到n2，该长度恰好是面积为A2的子三角形的高度h。这显示在 
图23.5的右侧。值得注意的是，我们有e2 （p）=||n2||||p。P0 
||cosα=bh=2A2，这是很好的，因为我们需要子三角形的区域来 
计算重心坐标。这意味着..u （x，y），v （x，y）？=..A1，A2？ 
A0 +A1 +A2 =..e1 （x，y），e2 （x，y）？e0 （x，y）+e1 （x， 
y）+e2 （x，y）。 （23。8）三角形设置通常计算1/ （A0 +A1 + 
A2），因为三角形的面积不变，这也避免了每个像素的划分。因此， 
当我们使用边缘方程遍历三角形时，我们将方程23.8的所有项都作 
为内部测试的副产品。这些在插值深度时非常有用，我们将会看到， 
或者用于正交投影，但对于透视投影，重心坐标不会产生预期的结 
果，如图23.6所示。透视校正重心坐标需要每像素分割[163,694]。 
----------------------- Page 1091-----------------------
这里省略了推导[26,1317]，而是总结了最重要的结果。由于线性插 
值很便宜，而且我们知道如何计算（u，v），我们希望尽可能在屏 
幕空间中使用线性插值，即使是透视矫正。有些令人惊讶的是，事 
实证明可以在三角形上线性插值a/ w和 1/ w，其中w是所有变 
换后的顶点的第四个分量。恢复插值属性a，100023.图形硬件投 
影平面投影平面图23.6。左图：在透视图中，几何图形的投影图像 
随距离缩小。中间：边缘三角形投影。注意三角形的上半部分如何 
覆盖投影平面上比下半部分小的部分。右：具有棋盘纹理的四边形。 
顶部图像使用重心坐标进行纹理化，而底部图像使用透视正确的重 
心坐标。是使用这两个插值的问题，线性插值z} |{a/w 1/w |{z} 
线性插值=aww =a。（23.9）这是前面提到的每像素分区。具体 
示例显示了该效果。假设我们沿水平三角形边缘插值，左端a0=4， 
右边a1 =6。这两个端点之间的中点值是多少？对于正交投影 （或 
当端点处的w值匹配时），答案只是a=5，即a0和a1之间的值。 
换句话说，端点的w值是w0 =1和w1 =3.在这种情况下，我们 
需要插值两次，得到a/w和 1/w。对于a/w，左端点是4/1 =4， 
右边是6/3=2，所以中点值是3.对于 1/w我们有 1/1和 1/3，所 
以中点是2/ 3。将3除以2/3给出了我们对于透视中点值的=4.5。 
在实践中，我们经常需要使用三角形上的透视校正来插值几个属性。 
因此，通常计算透视校正重心坐标，我们将其表示为 （.u，.v），然 
后将这些坐标用于所有属性插值。为此，我们引入了以下辅助函数 
[26]：f0 （x，y）=e0 （x，y）w0，f1 （x，y）=e1 （x，y）w1， 
----------------------- Page 1092-----------------------
f2 （x，y） =e2 （x，y）w2。（23.10）注意，由于e0 （x，y） 
=a0x +b0y +c0，三角形设置可以计算并存储a0/w0和其他类 
似项，以使每个像素的评估更快。或者，所有23.1。光栅化1001 
个fi函数可以乘以w0w1w2;例如，我们存储w1w2f0 （x，y）， 
w0w2f1 （x，y）和w0w1f2 （x，y）[1159]。透视校正重心坐标是..。 
 （x，y），。v （x，y）？=..f1 （x，y），f2 （x，y）？f0 （x，y） 
+f1 （x，y）+f2 （x，y），（23.11），每个像素需要计算一次， 
然后可以用于插入具有正确透视缩短的任何属性。注意，这些坐标 
与子三角形的面积不成比例，如（u，v）的情况。另外，分母不是 
恒定的，重心坐标的情况也是如此，这就是为什么必须对每个像素 
执行这种除法的原因。最后，请注意，由于深度为z/w，我们可以 
在公式23.10中看到我们不应该使用这些方程，因为它们已经被w 
除。因此，应该按顶点计算zi/wi，然后使用（u，v）进行线性插 
值。这具有几个优点，例如，用于压缩深度缓冲器（第23.7节）。 
23.1.2保守的光栅化从 DirectX11到在OpenGL中使用扩展，可 
以使用称为保守光栅化（CR）的新型三角遍历。CR有两种类型， 
称为过高的CR （OCR）和低估的CR （UCR）。有时它们也被称为 
外保守光栅化和内部保守光栅化。这些如图23.7所示。简而言之， 
使用OCR访问所有重叠或位于三角形内的像素，并且仅使用 UCR 
访问完全位于三角形内部的像素。OCR和 UCR都可以通过将平铺 
尺寸缩小到一个像素来使用平铺遍历来实现[24]。当硬件中没有可 
用的支持时，可以使用几何着色器或使用三角形扩展来实现OCR 
----------------------- Page 1093-----------------------
[676]。有关CR的更多信息，请参阅相应API的规范。CR可用于 
图像空间中的碰撞检测，遮挡剔除，阴影计算[1930]和抗锯齿等算 
法。图23.7。保守的三角形光栅化。使用外部保守光栅化时，所有 
彩色像素都属于三角形。黄色和绿色像素使用标准光栅化在三角形 
内部，并且仅使用内部保守光栅化生成绿色像素。100223.图形硬 
件最后，我们注意到所有类型的光栅化都是几何和像素处理之间的 
桥梁。为了计算三角形顶点的最终位置并计算像素的最终颜色，GPU 
中需要大量灵活的计算能力。接下来解释这一点。23.2大规模计算 
和调度为了提供可用于任意计算的大量计算能力，大多数（如果不 
是全部）GPU架构采用统一着色器架构，使用多线程的SIMD处理， 
有时称为SIMT处理或超线程。有关术语线程，SIMD处理，warp 
和线程组的更新，请参见第3.10节。请注意，我们使用术语warp， 
这是 NVIDIA术语，但在AMD硬件上，这些术语称为wave或 
wavefronts。在本节中，我们将首先看一下GPU中使用的典型统 
一算术逻辑单元（ALU）。ALU是在该上下文中针对一个实体（例 
如，顶点或片段）执行程序而优化的硬件。有时我们使用术语SIMD 
lane而不是ALU。GPU的典型ALU在图23.8的左侧可视化。主 
计算单元是浮点 （FP）单元和整数单元。FP单元通常符合IEEE754 
FP标准，并支持融合乘法和加法 （FMA）指令作为其最复杂的指令 
之一。除了超越运算之外，ALU通常还包含移动/比较和加载/存储 
功能以及分支单元，例如余弦，正弦和指数。然而，应该注意，这 
些中的一些可以位于某些架构上的单独硬件单元中，例如，一小组， 
----------------------- Page 1094-----------------------
例如，超越硬件单元可以操作到操作数收集器 FP单元int单元结果 
队列调度端口ALU调度器 RFL1LDSTXSU多处理器图23.8。左： 
为一次执行一个项目而构建的算术逻辑单元的示例。调度端口接收 
有关当前要执行的指令的信息，操作数收集器读取指令所需的寄存 
器。右图：此处，8×4个ALU与其他几个硬件单元组装成一个称为 
多处理器的块。32个ALU （有时称为SIMD通道）将以锁步方式 
执行相同的程序，即它们构成SIMD引擎。还有一个寄存器文件， 
L1高速缓存，本地数据存储，纹理单元和用于ALU 中未处理的各 
种指令的特殊单元。23.2。大规模计算和调度1003服务于更多数 
量的ALU。对于不像其他人那样经常执行的操作，可能就是这种情 
况。它们组合在特殊单元（SU）块中，如图23.8右侧所示。ALU 
架构通常使用一些硬件流水线级构建，即，在硅中构建多个并行执 
行的实际块。例如，当前指令执行乘法运算时，下一条指令可以获 
取寄存器。对于n个流水线级，理想情况下，吞吐量可以增加n倍。 
这通常称为管道并行性。流水线的另一个重要原因是流水线处理器 
中最慢的硬件块决定了块可以执行的最大时钟频率。增加流水线级 
数会使每个流水线级的硬件块数量变小，这通常可以提高时钟频率。 
然而，为了简化设计，ALU通常具有很少的流水线级，例如4-10。 
统一的ALU与CPU核心的不同之处在于它没有许多花里胡哨的东 
西，例如分支预测，寄存器重命名和深度指令流水线。相反，大部 
分芯片区域用于复制ALU以提供大量计算能力和增加的寄存器文件 
大小，以便可以切换和切换warp。例如，NVIDIAGTX1080Ti有 
----------------------- Page 1095-----------------------
3584个ALU。为了有效地调度发布给GPU的工作，大多数GPU 
将ALU分组，例如32个。它们以锁定步骤执行，这意味着整个32 
个ALU集合是SIMD引擎。不同的供应商为这样的组使用不同的名 
称以及其他硬件单元，并且我们使用通用术语多处理器 （MP）。例 
如，NVIDIA使用术语流式多处理器，英特尔使用执行单元，和AMD 
使用计算单位。MP的一个例子如图23.8右侧所示。MP通常具有 
调度程序，其将工作分派给SIMD引擎，并且还存在 L1高速缓存， 
本地数据存储 （LDS），纹理单元 （TX）以及用于处理未在ALU中 
执行的指令的特殊单元。 。MP将指令分派到ALU，其中指令以锁 
定步骤执行，即SIMD处理 （第3.10节）。请注意，MP的确切内 
容因供应商和一代架构而异。SIMD处理对于图形工作负载是有意 
义的，因为存在许多执行相同程序的相同（例如，顶点和片段）。 
在这里，架构利用线程级并行性，即顶点和片段的事实，比方说， 
可以独立于其他顶点和片段执行其着色器。此外，对于任何类型的 
SIMD/SIMT处理，由于对SIMD机器中的所有通道执行指令，因 
此利用数据级并行性。还存在指令级并行性，这意味着如果处理器 
可以找到彼此独立的指令，则可以同时执行它们，前提是存在可以 
并行执行的资源。接近MP是一个 （warp）调度程序，它接收要在 
该MP上执行的大量工作。warp调度程序的任务是将warp中的工 
作分配给 MP，将寄存器文件（RF）中的寄存器分配给warp 中的 
线程，然后以最佳方式对工作进行优先级排序。通常，下游工作有 
100423。图形硬件优先于上游工作。例如，像素着色位于可编程 
----------------------- Page 1096-----------------------
阶段的末尾，并且具有比顶点着色更高的优先级，顶点着色在管道 
中更早。这避免了停滞，因为到最后的阶段不太可能阻止早期阶段。 
有关图形管道图的更新，请参见第34页的图3.2。MP可以处理数 
百甚至数千个线程，以隐藏例如存储器访问的延迟。调度程序可以 
在 MP上切换当前正在执行 （或等待）的warp，以获得准备执行的 
warp。由于调度器是在专用硬件中实现的，因此通常可以零开销来 
完成[1050]。例如，如果当前warp执行纹理加载指令，预期该指 
令具有长延迟，调度程序可以立即切换当前warp，将其替换为另一 
个warp，然后继续执行该warp。通过这种方式，可以更好地利用 
计算单元。请注意，对于像素着色工作，warp调度程序会调度几个 
完整四边形，因为像素以四边形粒度着色以计算导数。这在第23.1 
节中提到过，将在第23.8节中进一步讨论。因此，如果warp的大 
小为32，则可以安排执行32/4 =8个quad。这里有一个建筑设 
计选择，人们可以选择将整个经线锁定到一个三角形，或者可以让 
经线中的每个四边形属于不同的三角形。前者更容易实现，但对于 
较小的三角形，效率会受到影响。后者更复杂，但对于较小的三角 
形更有效。通常，MP也被复制以在芯片上获得更高的计算密度， 
因此，GPU通常也具有更高级别的调度器。它的任务是根据提交给 
GPU的工作将工作分配给不同的warp调度程序。在warp中有许 
多线程通常也意味着线程的工作需要独立于其他线程的工作。当然， 
这通常是图形处理的情况。例如，对顶点进行着色通常不依赖于其 
他顶点，并且片段的颜色通常不依赖于其他片段。请注意，架构之 
----------------------- Page 1097-----------------------
间存在许多差异。其中一些将在第23.10节中突出显示，其中提供 
了一些不同的案例研究。在此刻，我们知道如何完成光栅化以及如 
何使用许多重复的统一ALU计算着色。剩余的大部分是内存系统， 
所有相关的缓冲区和纹理。这些是从第23.4节开始的以下部分的主 
题，但首先我们提供有关延迟和占用的更多信息。23.3延迟和占用 
通常，延迟是进行查询和接收结果之间的时间。例如，可以询问内 
存中某个地址的值，从查询到获得结果所花费的时间是延迟。另一 
个例子是从纹理单元请求过滤的颜色，从请求的时间到值可用，这 
可能需要数百甚至数千个时钟周期。这23.3。需要隐藏延迟和占用 
1005延迟以有效地使用GPU中的计算资源。如果不隐藏这些延迟， 
则内存访问很容易控制执行时间。一种隐藏机制是SIMD处理的多 
线程部分，如第 31页的图 3.1所示。通常，MP可以处理的最大 
warp数。活动warp的数量取决于寄存器的使用，也可能取决于纹 
理采样器的使用，L1缓存，插值和其他因素。在这里，我们将占用 
率o定义为o =wactivewmax，（23.12）其中wmax是 MP上 
允许的最大扭曲数，wactive是当前活动扭曲的数量。也就是说，o 
是衡量计算资源保持使用情况的指标。例如，假设wmax =32，着 
色器处理器具有256 kB寄存器，单个线程的一个着色器程序使用 
27个32位浮点寄存器，另一个使用 150.此外，我们假设寄存器使 
用决定了活动warp的数量。假设SIMD宽度为32，我们可以分别 
计算这两种情况的有效扭曲数，因为wactive =256·102427·4·32 
≈75.85，wactive =256·1024150·4·32≈13.65。（23.13）在第 
----------------------- Page 1098-----------------------
一种情况下，即对于使用27个寄存器的短程序，wactive>32，因 
此占用率为o =1，这是理想的，因此预示着隐藏延迟。然而，在 
第二种情况下，wactive≈13.65，所以o≈13.65/32≈0.43。由于活 
动扭曲较少，占用率较低，这可能会妨碍延迟隐藏。因此，设计一 
个具有均衡数量的最大warp，最大寄存器和其他共享资源的架构非 
常重要。如果你的着色器使用许多内存访问，有时占用率太高会导 
致缓冲，因为它可能会破坏缓存[1914]。另一种隐藏机制是在存储 
器请求之后继续执行相同的warp，如果存在与存储器访问的结果无 
关的指令，则这是可能的。虽然这使用了更多的寄存器，但有时候 
低占用率会更有效[1914]。一个例子是循环展开，这为指令级并行 
性提供了更多可能性，因为经常生成更长的独立指令链，这使得在 
切换warp之前执行更长时间成为可能。然而，这也会使用更多的 
临时寄存器。一般规则是在更高的入住率后努力。例如，低占用率 
意味着当着色器请求纹理访问时，不太可能切换到另一个扭曲。不 
同类型的延迟是从将数据从GPU读回到CPU。一个好的心理模型 
是将GPU和CPU视为异步工作的独立计算机，两者之间的通信需 
要付出一些努力。改变信息流动方向的延迟会严重影响性能。当从 
GPU读回数据时，可能必须在读取之前刷新管道。在此期间，CPU 
正在等待GPU完成其工作。对于100623.图形硬件架构，例如 Intel 
的GEN架构[844]，在GPU和CPU位于同一芯片上并使用共享内 
存模型的情况下，这种类型的延迟会大大减少。较低级别的高速缓 
存在CPU和GPU之间共享，而较高级别的高速缓存则不是。共享 
----------------------- Page 1099-----------------------
缓存的延迟减少允许不同类型的优化和其他类型的算法。例如，此 
功能已用于加速光线跟踪，其中光线在图形处理器和CPU内核之间 
来回传递，无需任何费用[110]。不产生CPU停顿的回读机制的示 
例是遮挡查询。见19.7.1节。对于遮挡测试，机制是执行查询，然 
后偶尔检查GPU以查看查询的结果是否可用。在等待结果的同时， 
可以在CPU和GPU上完成其他工作。23.4内存架构和总线在这里， 
我们将介绍一些术语，讨论几种不同类型的内存架构，然后介绍压 
缩和缓存。端口是用于在两个设备之间发送数据的通道，总线是用 
于在两个以上设备之间发送数据的共享信道。带宽是用于描述端口 
或总线上数据吞吐量的术语，以每秒字节数B/s来度量。端口和总 
线在计算机图形学架构中很重要，因为简单地说，它们将不同的构 
建块粘合在一起。同样重要的是带宽是稀缺资源，因此在构建图形 
系统之前必须进行仔细的设计和分析。由于端口和总线都提供数据 
传输功能，因此端口通常称为总线，这是我们将遵循的惯例。对于 
许多GPU，通常在图形加速器上具有独占的GPU存储器，并且该 
存储器通常被称为视频存储器。访问该存储器通常比让GPU通过总 
线访问系统存储器快得多，例如 PC中使用的PCIExpress （PCIe）。 
16通道 PCIev3可以在两个方向上提供 15.75GB/ s，而PCIev4 
可以提供31.51GB/s。但是，用于图形的 Pascal架构 （GTX1080） 
的视频内存提供320GB/ s。传统上，纹理和渲染目标存储在视频 
内存中，但它也可用于存储其他数据。场景中的许多对象在帧与帧 
之间不会明显改变形状。甚至人类角色通常也会使用一组在关节处 
----------------------- Page 1100-----------------------
使用GPU侧顶点混合的不变网格进行渲染。对于这种类型的数据， 
纯粹通过建模矩阵和顶点着色器程序进行动画制作，通常使用静态 
顶点和索引缓冲区，它们放在视频内存中。这样做可以让GPU快速 
访问。对于每帧由CPU更新的顶点，使用动态顶点和索引缓冲区， 
这些顶点放置在可通过总线访问的系统内存中，例如 PCIExpress。 
PCIe的一个不错的属性是查询可以流水线化，因此在结果返回之前 
可以请求多个查询。23.5。缓存和压缩1007Gen9图形处理器英特 
尔酷睿处理器CPU核心CPU核心LLC片式LLC片式显示控制器内 
存控制器 PCIeEDRAM控制器图形技术接口 L1L2调度/执行单元 
L3缓存SoC环互连固定功能单元命令流传输全局线程调度器L1L2 
调度/执行单元L1L2调度/执行单元图23.9。英特尔片上系统 SoC（ ） 
Gen9图形架构的内存架构的简化视图，该架构与CPU内核和共享 
内存模型相连。请注意，最后一级缓存 （LLC）在图形处理器和CPU 
内核之间共享。（Junkins之后的插图[844]。）大多数游戏机，例 
如所有Xbox和 PLAYSTATION4，都使用统一的内存架构 （UMA）， 
这意味着图形加速器可以使用主机内存的任何部分来表示纹理和不 
同类型的缓冲区[889]。CPU和图形加速器都使用相同的内存，因此 
也使用相同的总线。这与使用专用视频存储器明显不同。英特尔还 
使用 UMA，以便在CPU内核和GEN9图形架构[844]之间共享内 
存，如图23.9所示。但是，并非所有缓存都是共享的。图形处理器 
有自己的一组 L1缓存，L2缓存和 L3缓存。最后一级缓存是内存层 
次结构中的第一个共享资源。对于任何计算机或图形架构，拥有缓 
----------------------- Page 1101-----------------------
存层次结构非常重要。如果访问中存在某种类型的位置，这样做会 
减少对内存的平均访问时间。在下一节中，我们将讨论GPU的缓存 
和压缩。23.5缓存和压缩缓存位于每个GPU的几个不同部分，但 
它们在架构之间存在差异，我们将在第23.10节中看到。通常，向 
架构添加缓存层次结构的目的是通过利用内存访问模式的位置来减 
少内存延迟和带宽使用。也就是说，如果GPU访问一个项目，则很 
可能它很快将访问该相同或附近的项目[715]。大多数缓冲区和纹理 
格式以平铺格式存储，这也有助于增加局部性[651]。假设高速缓存 
行由512位（即64字节）组成，并且当前使用的颜色格式使用每 
像素4B。一种设计选择是将所有像素存储在4×4 区域内，在64B 
中也称为瓦片。也就是说，整个颜色缓冲器将被分成4×4瓦片。图 
块也可以跨越多个缓存行。100823.图形硬件压缩缓冲区块压缩缓 
冲区块硬件单元访问缓冲区解压缩器压缩器缓存非压缩缓冲区块非 
压缩缓冲区块瓦片表读取写入存储器层次结构压缩缓冲区块压缩缓 
冲区块硬件单元访问缓冲区高速缓存压缩缓冲区块压缩缓冲区tile 
tiledecompressor压缩器表读写内存层次结构图23.10。用于压缩 
和缓存GPU中渲染目标的硬件技术的框图。左：缓存后压缩，压缩 
器/解压缩器硬件单元位于缓存之后 （下方）。右：预缓存压缩，压 
缩器/解压缩器硬件单元位于缓存之前 （上方）的位置。要获得高效 
的GPU架构，需要在所有方面开展工作以减少带宽使用。大多数 
GPU包含硬件单元，用于动态地压缩和解压缩渲染目标，例如，在 
渲染图像时。重要的是要意识到这些类型的压缩算法是无损的;也就 
----------------------- Page 1102-----------------------
是说，始终可以准确地再现原始数据。这些算法的核心是我们称之 
为tile表，它具有为每个tile存储的附加信息。这可以存储在芯片 
上或通过存储器层次结构通过高速缓存访​ ​ 问。这两种系统的框 
图如图23.10所示。通常，相同的设置可用于深度，颜色和模板压 
缩，有时会有一些修改。tile表中的每个元素存储帧缓冲区中像素 
块的状态。每个图块的状态可以是压缩的，未压缩的或清除的（下 
面讨论）。通常，还可以存在不同类型的压缩块。例如，一种压缩 
模式可能压缩至25％，另一种压缩至50％。重要的是要意识到压 
缩级别取决于GPU可以处理的内存传输的大小。假设特定架构中最 
小的内存传输是32B.如果瓷砖尺寸选择为64B，那么它只能压缩 
到50％。然而，瓦片尺寸为128B时，可以压缩至75％ （96B）， 
50％ （64B）和25％ （32B）。tile表通常还用于实现渲染目标的 
快速清除。当系统发出清除渲染目标时，表中每个图块的状态将被 
设置为清除，并且不会触及适当的帧缓冲。当访问渲染目标的硬件 
单元需要读取清除的渲染目标时，解压缩器单元首先检查表中的状 
态以查看该块是否被清除。如果是这样，则渲染目标切片放置在高 
速缓存中，所有值都设置为清除值，而无需读取和解压缩实际的渲 
染目标数据。这样，访问23.6。在清除期间，颜色缓冲1009渲染 
目标本身被最小化，这节省了带宽。如果未清除状态，则必须读取 
该图块的渲染目标。读取磁贴的存储数据，如果压缩，则在发送之 
前通过解压缩器。当访问渲染目标的硬件单元已经完成写入新值， 
并且最终从高速缓存中逐出区块时，将其发送到压缩器，在压缩器 
----------------------- Page 1103-----------------------
处尝试压缩它。如果存在两种压缩模式，则可以尝试两种压缩模式， 
并且使用能够以最少位压缩该块的压缩模式。由于API需要无损渲 
染目标压缩，因此如果所有压缩技术都失败，则需要使用未压缩数 
据。这也意味着无损渲染目标压缩永远不会减少实际渲染目标中的 
内存使用 - 这种技术只会减少内存带宽使用。如果压缩成功，则将 
磁贴的状态设置为压缩，并以压缩形式发送信息。否则，它将被解 
压缩并且状态将设置为未压缩。请注意，压缩器和解压缩器单元可 
以在缓存之后（称为postcache）或之前（预缓存），如图23.10 
所示。预缓存压缩可以大大增加有效缓存大小，但它通常也会增加 
系统的复杂性[681]有特定的算法用于压缩深度[679,1238,1427]和 
颜色[1427,1463,1464,1716] 。后者包括对有损压缩的研究，然而， 
在我们所知的[1463]的任何硬件中都没有。大多数算法编码锚值， 
其表示图块中的所有像素，然后差异以相对于该锚值的不同方式编 
码。对于深度，通常存储一组平面方程[679]或使用差异差分技术 
[1238]，由于深度在屏幕空间中是线性的，因此两者都给出了 
良23.6颜色缓冲使用GPU进行渲染涉及访问多个不同的缓冲区， 
例如颜色，深度和模板缓冲区。请注意，虽然它被称为 “颜色”缓 
冲区，但任何类型的数据都可以呈现并存储在其中。颜色缓冲区通 
常具有一些颜色模式，基于表示颜色的字节数。这些模式包括：。 
每个像素高2个字节，其中 15或 16位用于颜色，分别给出32,768 
或65,536种颜色。。真彩色或RGB彩色 - 每像素3或4个字节， 
其中24位用于颜色，提供 16,777,216≈1680万种不同的颜色。。 
----------------------- Page 1104-----------------------
深色 - 每像素30,36或48位，至少提​ ​ 供十亿种不同的颜色。 
高色彩模式具有16位的色彩分辨率。通常，对于红色，绿色和蓝色， 
该量被分成至少 5位，每个颜色通道给出32个级别。101023.图 
形硬件图23.11。当矩形从白色变为黑色时，会出现条带。虽然32 
个灰度条中的每一个都具有固定的强度等级，但由于马赫带错觉， 
左边的每个都看起来更暗，右边更亮。这留下一个比特，通常给予 
绿色通道，导致5-6-5分割。选择绿色通道是因为它对眼睛具有最 
大的亮度效果，因此需要更高的精度。高色彩比真实和深色具有速 
度优势。这是因为每个像素的2个字节的存储器通常可以比每个像 
素的三个或更多个字节更快地被访问。那说，在这一点上，使用高 
色彩模式是非常罕见的。相邻颜色水平的差异很容易辨别，每个通 
道只有32或64级颜色。这个问题有时被称为条带或海报。由于称 
为马赫条带的感知现象[543,653]，人类视觉系统进一步放大了这些 
差异。见图23.11。相邻水平混合的抖动[102,539,1081]可以通过 
交换空间分辨率来增加有效颜色分辨率来减轻效果。即使在24位监 
视器上，也可以注意到渐变上的条带。向帧缓冲区图像添加噪声可 
用于掩盖此问题[1823]。真彩色使用24位 RGB颜色，每个颜色通 
道 1个字节。在 PC系统上，订购有时会逆转到 BGR。在内部，这 
些颜色通常使用每像素32位存储，因为大多数存储器系统都针对访 
问4字节元素进行了优化。在某些系统上，额外的8位也可用于存 
储alpha通道，从而为像素提供 RGBA值。24位颜色（无alpha） 
表示也称为压缩像素格式，与32位未压缩的对应物相比，可以节省 
----------------------- Page 1105-----------------------
帧缓冲存储器。对于实时渲染，使用24位颜色几乎总是可以接受的。 
仍然可以看到颜色的条带，但比仅有 16位的可能性要小得多。深色 
每种颜色使用30,36或48位 RGB，即每通道10,12或 16位。如 
果添加alpha，则这些数字会增加到40/48/64。HDMI1.3开启支 
持所有30/36/48模式，DisplayPort标准还支持每通道高达16位。 
颜色缓冲区通常按照第23.5节中的描述进行压缩和缓存。此外，在 
第23.10节的每个案例研究中进一步描述了将输入的片段数据与颜 
色缓冲器混合。混合由光栅操作 （ROP）单元处理，并且每个ROP 
通常使用例如广义棋盘图案[1160]连接到存储器分区。接下来我们 
将讨论视频显示控制器，它带有一个颜色缓冲区并使其出现在显示 
屏上。然后检查单次，双次和三次缓冲。23.6。颜色缓冲 101123.6.1 
视频显示控制器在每个GPU中，都有一个视频显示控制器 （VDC）， 
也称为显示引擎或显示界面，负责在显示屏上显示颜色缓冲区。这 
是GPU中的硬件单元，它可以支持各种接口，例如高清多媒体接口 
 （HDMI），DisplayPort，数字视频接口（DVI）和视频图形阵列 
 （VGA）。要显示的颜色缓冲区可以位于CPU用于其任务的相同存 
储器中，专用帧缓冲存储器或视频存储器中，后者可以包含任何 
GPU数据但不能直接访问CPU。每个接口都使用其标准协议来传输 
部分颜色缓冲区，定时信息，有时甚至是音频。VDC还可以执行图 
像缩放，降噪，多个图像源的合成以及其他功能。显示器（例如LCD） 
更新图像的速率通常在每秒60到 144次（赫兹）之间。这也称为 
垂直刷新率。大多数观众注意到频率低于72赫兹的闪烁。有关此主 
----------------------- Page 1106-----------------------
题的更多信息，请参见第 12.5节。监控技术在几个方面取得了进展， 
包括刷新率，每个组件的比特数，色域和同步。刷新率曾经是60Hz， 
但 120Hz变得越来越普遍，并且高达600Hz是可能的。对于高刷 
新率，通常多次显示图像，并且有时插入黑色帧，以最小化由于在 
帧显示期间眼睛移动引起的拖尾伪影[7,646]。监视器每个通道也可 
以有超过8位，HDR监视器可能是显示技术的下一个重点。这些可 
以使用每通道10位或更多。杜比采用 HDR显示技术，使用较低分 
辨率的 LED背光阵列来增强其 LCD监视器。这样做可以使其显示 
亮度的 10倍和典型监视器的对比度的 100倍[1596]。具有更宽色 
域的监视器也变得越来越普遍。通过使纯光谱色调变得可表现，例 
如更鲜艳的绿色，这些可以显示更宽范围的颜色。有关色域的更多 
信息，请参见第8.1.3节。为了减少撕裂效应，公司开发了自适应 
同步技术，如AMD的FreeSync和 NVIDIA的G-sync。这里的想 
法是使显示器的更新速率适应GPU可以产生的而不是使用固定的 
预定速率。例如，如果一帧占用 10毫秒而下一帧占用30毫秒，则 
在每个图像完成渲染后，将立即开始对显示器的图像更新。使用这 
些技术渲染看起来更顺畅。另外，如果图像没有更新，则不需要将 
颜色缓冲器发送到显示器，这节省了电力。23.6.2单次，双次和三 
次缓冲在2.4节中，我们提到双缓冲可确保在渲染完成之前图像不 
会显示在显示器上。在这里，我们将描述单缓冲，双缓冲甚至三重 
缓冲。101223.图形硬件假设我们只有一个缓冲区。此缓冲区必须 
是当前显示在显示屏上的缓冲区。随着绘制框架的三角形，当监视 
----------------------- Page 1107-----------------------
器刷新时会出现越来越多的三角形 - 这是一种令人难以置信的效 
果。即使我们的帧速率等于监视器的更新速率，单缓冲也存在问题。 
如果我们决定清除缓冲区或绘制一个大三角形，然后，当视频显示 
控制器传输正在绘制的颜色缓冲区的那些区域时，我们将能够短暂 
地看到颜色缓冲区的实际部分更改。有时称为撕裂，因为显示的图 
像看起来好像被短暂撕成两半，这对于实时图形来说不是一个理想 
的特征。在一些古老的系统中，例如Amiga，您可以测试光束的位 
置，从而避免在那里绘制，从而允许单个缓冲工作。目前，很少使 
用单缓冲，虚拟现实系统可能除外，其中 “竞速光束”可以减少延 
迟[6]。为避免撕裂问题，通常使用双缓冲。完成的图像显示在前缓 
冲区中，而屏幕外缓冲区包含当前正在绘制的图像。然后，图形驱 
动程序交换后缓冲区和前缓冲区，通常在将整个图像传输到显示器 
之后，以避免撕裂。交换通常只需交换两个颜色缓冲区指针即可完 
成。对于CRT显示器，此事件称为垂直回扫，此时的视频信号称为 
垂直同步脉冲，或简称为vsync。对于 LCD显示器，没有光束的物 
理回扫，但我们使用相同的术语来表示整个图像刚刚被传输到显示 
器。渲染完成后立即交换后缓冲区和前缓冲区对于对渲染系统进行 
基准测试非常有用，并且还可以在许多应用程序中使用，因为它可 
以最大化帧速率。不同步vsync也会导致撕裂，但因为有两个完全 
形成的图像，神器没有单缓冲那么糟糕。在交换之后，（新）后台 
缓冲区立即成为图形命令的接收者，并向用户显示新的前台缓冲区。 
该过程如图23.12所示。缓冲区0前方前方前方前方缓冲区0前方 
----------------------- Page 1108-----------------------
后方前方后方缓冲区1前方后方前方缓冲区0待定前方缓冲区1前 
方后方前方缓冲区2前方后方待处理待处理状态图23.12。对于单 
缓冲（顶部），始终显示前缓冲区。对于双缓冲（中间），第一个 
缓冲区0在前面，缓冲区 1在后面。然后他们从前到后交换，反之 
亦然。三重缓冲（底部）也可以通过挂起缓冲区来工作。这里，首 
先清除缓冲区并开始渲染（待定）。第二，系统继续使用缓冲区进 
行渲染，直到图像完成 （返回）。最后，显示缓冲区 （正面）。23.6。 
颜色缓冲 1013双缓冲可以使用第二个缓冲区进行扩充，我们将其 
称为挂起缓冲区。这称为三重缓冲[1155]。挂起缓冲区就像后台缓 
冲区一样，它也在屏幕外，并且可以在显示前缓冲区时修改它。挂 
起缓冲区成为三缓冲区循环的一部分。在一帧期间，可以访问挂起 
的缓冲区。在下一次交换时，它将成为后台缓冲区，完成渲染。然 
后它成为前缓冲区并向观众显示。在下一次交换时，缓冲区再次变 
为挂起缓冲区。这一事件过程在图23.12的底部可视化。三重缓冲 
与双缓冲相比具有一个主要优势。使用它，系统可以在等待垂直回 
扫的同时访问挂起的缓冲区。通过双缓冲，在等待垂直回扫以便进 
行交换时，构造必须保持等待。这是因为必须向观察者显示前缓冲 
区，并且后缓冲区必须保持不变，因为它有一个完成的图像，等待 
显示。三重缓冲的缺点是延迟增加到整个帧。这种增加延迟了对用 
户输入的反应，例如击键和鼠标或操纵杆移动。控件可能会感觉迟 
缓，因为这些用户事件在呈现在挂起缓冲区中开始后会延迟。理论 
上，可以使用三个以上的缓冲区。如果计算帧的时间量变化很大， 
----------------------- Page 1109-----------------------
则更多的缓冲区可以提供更多的平衡和更高的显示速率，但代价是 
更多的潜在延迟。概括地说，多缓冲可以被认为是循环结构。有一 
个渲染指针和一个显示指针，每个指针指向不同的缓冲区。渲染指 
针引导显示指针，在计算当前渲染缓冲区时移动到下一个缓冲区。 
唯一的规则是显示指针永远不应与渲染指针相同。实现PC图形加 
速器的附加加速的相关方法是使用SLI模式。早在 1998年，3dfx 
就使用SLI作为扫描线交错的首字母缩写，其中两个图形芯片组并 
行运行，一个处理奇数扫描线，另一个处理偶数。NVIDIA （购买了 
3dfx的资产）使用这个缩写来完全不同的方式连接两个（或更多） 
图形卡，称为可扩展链接接口。AMD将其称为CrossFireX.这种并 
行形式通过将屏幕分成两个（或更多）水平部分，每个卡一个，或 
者通过让每个卡完全呈现其自己的帧，交替输出来划分工作。还有 
一种模式允许卡加速同一帧的抗锯齿。最常见的用途是让每个GPU 
渲染一个单独的帧，称为交替帧渲染（AFR）。虽然这个方案听起 
来好像应该增加延迟，但它通常很少或没有影响。假设一个GPU系 
统以 10FPS呈现。如果GPU是瓶颈，则使用AFR的两个GPU可 
以以20 FPS呈现，或者甚至以40 FPS呈现四个GPU。每个GPU 
花费相同的时间来渲染其帧，因此延迟不一定会改变。屏幕分辨率 
继续增加，对基于每像素采样的渲染器构成严重挑战。保持帧速率 
的一种方法是在屏幕[687,1805]和表面[271]上自适应地改变像素 
着色率。101423.图形硬件样本覆盖和z-插值正向 HiZ更新粗略光 
栅化器粗深度测试早期深度测试像素着色器深度测试 HiZ缓存反馈 
----------------------- Page 1110-----------------------
HiZ更新深度缓存 HiZ单元深度单位压缩解压缩存储器层次瓦片表 
图23.13。深度流水线的可能实现，其中z-interpolate使用插值简 
单地计算深度值。 （Andersson等人[46]之后的插图。）23.7深度 
剔除，测试，和缓冲在本节中，我们将介绍与深度有关的所有内容， 
包括分辨率，测试，剔除，压缩，缓存，缓冲和早期z。深度分辨 
率很重要，因为它有助于避免渲染错误。例如，假设您建模了一张 
纸并将其放在桌子上，远远低于桌面的表面。通过计算桌面和纸张 
的z深度的精确限制，桌子可以在各个位置戳穿纸张。这个问题有 
时被称为z-fighting。请注意，如果纸张放置在与桌子完全相同的 
高度，即纸张和桌子是共面的，那么没有关于其关系的其他信息就 
没有正确的答案。此问题是由于建模不良而无法通过更好的z精度 
来解决。正如我们在2.5.2节中看到的那样，z缓冲区 （也称为深度 
缓冲区）可用于解析可见性。这种缓冲器通常具有每像素24位或 
32位 （或样本），并且可以使用浮点或定点表示[1472]。对于正交 
观察，距离值与z值成比例，因此获得均匀分布。但是，对于透视 
观察，分布是不均匀的，正如我们在第99-102页上看到的那样。 
在应用透视变换（等式4.74或4.76）之后，需要除以w分量（等 
式4.72）。然后深度分量变为 pz=qz/qw，其中q是乘以投影矩 
阵之后的点。对于定点表示，值pz=qz/qw从其有效范围 （例如， 
对于 DirectX的[0,1]）映射到整数范围[0,2b。1]并存储在z缓冲区 
中，其中b是位数。有关深度精度的更多信息，请参见第99-102 
页。硬件深度管道如图23.13所示。此管道的主要目标是测试栅格 
----------------------- Page 1111-----------------------
化基元时生成的每个传入深度，深度缓冲区，并可能将传入深度写 
入深度缓冲区（如果为23.7）。深度剔除，测试和缓冲1015片段 
通过深度测试。同时，这条管道需要高效。图的左侧部分以粗糙光 
栅化开始，即在图块级别进行光栅化 （第23.1节）。此时，只有与 
基元重叠的切片才会传递到下一个阶段，称为 HiZ单元，执行 
z-culling技术。HiZ装置以称为粗深度测试的块开始，这里经常进 
行两种类型的测试。我们首先描述zmax-culling，它是Greene的 
分层z缓冲算法[591]的简化，在第19.7.2节中给出。该想法是存 
储每个瓦片内所有深度的最大值，称为zmax。图块大小取决于架 
构，但通常使用8×8像素[1238]。这些zmax值可以存储在固定的 
片上存储器中，也可以通过高速缓存访​ ​ 问。在图23.13中，我 
们将其称为 HiZ缓存。简而言之，我们想测试三角形是否完全遮挡 
在一个图块中。为此，我们需要计算图块内三角形的最小z值ztri 
min。如果ztri min>zmax，则保证三角形被该图块中先前渲染的 
几何体遮挡。可以终止对该图块中三角形的处理，这节省了每像素 
深度测试。请注意，它不会保存任何像素着色器执行，因为每个样 
本深度测试将消除管道中稍后隐藏的片段。在实践中，我们不能计 
算ztri min的精确值，因此，计算保守估计。计算ztri min的几种 
不同方法是可能的，每种方法都有其自身的优点和缺点：1。可以使 
用三角形的三个顶点的最小z值。这并不总是准确的，但开销很小。 
2.使用三角形的平面方程评估图块四角的z值，并使用其中的最小 
值。如果将这两种策略结合起来，则可以获得最佳的淘汰性能。这 
----------------------- Page 1112-----------------------
是通过获取两个zmin值中较大的一个来完成的。另一种类型的粗 
深度测试是zmin-culling，并且想法是将所有像素的zmin存储在 
图块中[22]。这有两个用途。首先，它可以用于避免z缓冲区读取。 
如果正在渲染的三角形肯定位于所有先前渲染的几何体的前面，则 
不需要逐像素深度测试。在某些情况下，可以完全避免z缓冲区读 
取，这进一步提高了性能。其次，它可以用于支持不同类型的深度 
测试。对于zmax剔除方法，我们假设标准 “小于”深度测试。但 
是，如果剔除也可以与其他深度测试一起使用将是有益的，并且如 
果zmin和zmax都可用，则可以使用该剔除过程支持所有深度测 
试。深度管道的更详细的硬件描述可以在Andersson的博士论文 
[49]中找到。图23.13中的绿框表示更新图块的zmax和zmin值 
的不同方法。如果三角形覆盖整个图块，则可以直接在HiZ单元中 
完成更新。否则，需要读取整个图块的每个样本深度并将其减小到 
最小值和最大值并发送回 HiZ单元，这会引入一些延迟。安德森等 
人。[50]提出了一种执行 1016的方法。图形硬件这没有来自深度缓 
存的更昂贵的反馈，并且仍然能够保留大部分的剔除效率。对于经 
过粗深度测试的瓷砖，确定像素或样品覆盖率 （使用第23.1节中描 
述的边缘方程），并计算每个样品的深度 （在图23.13中称为z-插 
值）。这些值被转发到深度单位，如右图所示。根据API描述，应 
遵循像素着色器评估。但是，在下面将介绍的某些情况下，可以在 
不改变预期行为的情况下执行称为early-z[1220,1542]或早期深度 
的附加测试。Early-z实际上只是在像素着色器之前执行的每样本深 
----------------------- Page 1113-----------------------
度测试，并且被遮挡的片段被丢弃。因此，该过程避免了像素着色 
器的不必要的执行。早期z测试经常与z-culling混淆，但它由完全 
独立的硬件执行。两种技术都可以在没有其他技术的情况下使用在 
许多情况下，GPU会自动使用所有zmax-culling，zmin-culling 
和early-z。但是，如果像素着色器写入自定义深度，则必须禁用这 
些，使用丢弃操作，或将值写入无序访问视图[50]。如果不能使用 
early-z，则在像素着色器之后进行深度测试 （称为深度测试）。在 
较新的硬件上，可以对着色器的图像执行原子读取 - 修改 - 写入 
操作，加载和存储。在这些情况下，您可以显式启用early-z并覆 
盖这些约束，如果您知道这样做是安全的。在像素着色器输出自定 
义深度时可以使用的另一个功能是保守深度。在这种情况下，如果 
程序员保证自定义深度大于三角形深度，则可以启用early-z。对于 
此示例，也可以启用 zmax-culling ，但不能启用早期z 和 
zmin-culling。与往常一样，遮挡剔除有利于从前到后渲染。具有 
相似名称和类似意图的另一种技术是z-prepass。这个想法是程序 
员首先渲染场景，同时只写入深度，禁用像素着色，并写入颜色缓 
冲区。渲染后续传递时，使用 “相等”测试，这意味着由于z缓冲 
区已经初始化，因此只有最前面的表面将被着色。见 18.4.5节。最 
后，我们将简要介绍深度管道的缓存和压缩，如图23.13右下方所 
示。通用压缩系统类似于第23.5节中描述的系统。每个磁贴都可以 
压缩为几个选择的大小，并且总是会回退到未压缩的数据，这在压 
缩无法达到任何选定的大小时使用。快速清除用于在清除深度缓冲 
----------------------- Page 1114-----------------------
区时节省带宽使用。由于深度在屏幕空间中是线性的，典型的压缩 
算法要么存储高精度的平面方程，要使用差分差分技术和delta编 
码，要么使用一些锚方法[679,1238,1427]。瓦片表和HiZ高速缓 
存可以完全存储在片上缓冲器中，或者它们可以通过存储器层次结 
构的其余部分进行通信，深度高速缓存也是如此。在芯片上存储是 
昂贵的，因为这些缓冲器需要足够大以处理最大支持的分辨率。 
23.8。纹理101723.8纹理虽然纹理操作（包括提取，过滤和解压 
缩）当然可以在GPU多处理器上运行的纯软件中实现，已经证明， 
用于纹理化的固定功能硬件可以快40倍[1599]。纹理单元执行纹理 
格式的寻址，过滤，钳位和解压缩（第6章）。它与纹理缓存结合 
​ ​ 使用以减少带宽使用。我们首先讨论过滤以及纹理单元上的结 
果。为了能够使用缩小滤波器，例如mipmapping和各向异性滤波， 
需要屏幕空间中纹理坐标的导数。也就是说，为了计算细节λ的纹理 
水平，我们需要.u/.x，.v/.x，.u/.y和.v/.y。这些告诉我们片段 
表示纹理的区域或功能的程度。如果从顶点着色器传递的纹理坐标 
用于直接访问纹理，然后可以通过分析计算衍生物。如果使用某种 
函数来转换纹理坐标，例如（u'，v'）= （cosv，sinu），则分析 
计算导数变得更加复杂。然而，仍然可以使用链式规则或符号区分 
[618]。尽管如此，图形硬件并未使用这些方法，因为情况可能是任 
意复杂的。想象一下，使用环境贴图计算曲面上的反射，法线是凹 
凸贴图。难以分析地计算，例如，反射矢量的衍生物从法线图反弹， 
然后用于访问环境地图。结果，衍生物通常使用四边形上的x和y 
----------------------- Page 1115-----------------------
的有限差分，即超过2×2像素，以数字方式计算。这也是GPU架 
构专注于调度四边形的原因。通常，衍生计算发生在引擎盖下，即 
它们对用户是隐藏的。实际的实现通常使用四边形上的跨通道指令 
 （shuffle/swizzle）来完成，并且这些指令可以由编译器插入。有 
些GPU使用固定功能硬件来计算这些衍生产品。没有关于如何计算 
衍生物的确切规范。一些常用方法如图23.14所示。OpenGL4.5 
和 DirectX11支持粗略和精细导数的函数[1368]。所有GPU都使 
用纹理缓存[362,651,794,795]来减少纹理的带宽使用。一些架构使 
用专用缓存进行纹理处理，甚至使用两个专用级别的纹理缓存，而 
其他人在所有类型的访问之间共享缓存，包括纹理。通常，使用小 
型片上存储器（通常为SRAM）来实现纹理高速缓存。此缓存存储 
最近纹理读取的结果，并且访问速度很快。替换策略和大小取决于 
体系结构。如果相邻像素需要访问相同或位​ ​ 置相近的纹素，则 
它们很可能在缓存中找到它们。如第23.4节所述，内存访问通常以 
平铺方式完成，因此不是以扫描线顺序存储纹素，而是将它们存储 
在小块中，例如4×4纹素，这样可以提高效率[651]101823.图形 
硬件粗细左上右上左下左下图23.14。如何计算衍生物的插图。箭 
头表示在箭头结束的像素和开始的像素之间计算差异。例如，左上 
水平差被计算为右上像素减去左上像素。对于粗导数（左），单个 
水平差和单个垂直差用于四边形内的所有四个像素。对于精细导数 
 （右），使用最接近像素的差异。（Penner[1368]之后的插图。） 
纹素一起被提取。以字节为单位的瓦片大小通常与高速缓存行大小 
----------------------- Page 1116-----------------------
相同，例如，64字节。存储纹理的另一种方法是使用混合模式。假 
设纹理坐标已经变换为定点数： （u，v），其中u和v中的每一个 
都有n位。具有u的数字i的位表示为ui。然后重新映射（你，v） 
到一个混合的纹理地址，A，是A （u，v）=B+ vn.1un.1vn.2un.2（ ... 
v1u1v0u0）·T， （23.14）其中 B是纹理的基地址T是一个纹素所 
占的字节数。这种重新映射的优点是它产生了图23.15所示的纹理 
元素顺序。可以看出，这是一个空间填充曲线，称为莫顿序列[1243]， 
并且已知它可以改善相干性[1825]。在这种情况下，曲线是二维的， 
因为纹理通常也是。纹理单元还包含自定义硅片，可以解压缩几种 
不同的纹理格式（第6.2.6节）。与软件实现相比，这些在固定功 
能硬件中实现时通常效率高出许多倍。请注意，将纹理用作渲染目 
标和纹理贴图时，其他压缩机会发生。如果启用了颜色缓冲区的压 
缩 （第23.5节），则在将此类渲染目标作为纹理访问时，有两个设 
计选项。当渲染目标完成其渲染时，一个选项是从其颜色缓冲区压 
缩格式解压缩整个渲染目标，并将其解压缩存储以用于后续纹理访 
问。第二种选择是在纹理单元中添加硬件支持以解压缩颜色缓冲压 
缩格式[1716]。后者是更有效的选项，因为渲染目标即使在作为纹 
理访问期间也可以保持压缩。有关缓存和压缩的更多信息，请参见 
第23.4节。Mipmapping对纹理缓存局部性很重要，因为它强制 
实现最大纹素像素比。当遍历三角形时，每个新像素表示大约一个 
纹素的纹理空间中的一个步骤。Mipmapping是渲染技术改善视觉 
效果和性能的少数几种情况之一。23.9。建筑 1019048121620 
----------------------- Page 1117-----------------------
24283236404448 525660646872768084889296 100 
104 108 112 116 120 124 128 132 136 140 144 148 152 156 
160 164 168 172 176 180 184 188 192 196200 204 208 212 
216220224228232236240244248252图23.15。纹理混合 
增加了纹理元素内存访问的一致性。请注意，此处的纹素大小为4 
个字节，并且纹素地址显示在每个纹素的左上角。23.9架构实现更 
快图形的最佳方法是利用并行性，这可以在GPU的几乎所有阶段完 
成。我们的想法是同时计算多个结果，然后在稍后阶段合并这些结 
果。通常，并行图形架构的外观如图23.16所示。应用程序将任务 
发送到GPU，并且在一些调度之后，几何处理在几个几何单元中并 
行开始。几何处理的结果将转发到一组光栅化器单元，这些单元执 
行光栅化。然后，通过一组像素处理单元也并行地执行像素着色和 
混合。最后，将得到的图像发送到显示器以供查看。对于软件和硬 
件，重要的是要意识到如果存在代码或硬件的串行部分，它将限制 
可能的总性能量GGGR RRPPP应用程序显示图23.16。高性能 
并行计算机图形架构的通用架构，由几个几何单元（G），光栅化 
器单元（R）和像素处理单元（P）组成。102023.图形硬件改进。 
这由Amdahl定律表示，即a （s，p）=1s+1.sp，（23.15）其 
中s是程序/硬件的序列百分比，因此 1.s是适合的百分比并行化。 
此外，p是通过并行化程序或硬件可以实现的最大性能改善因素。 
例如，如果我们最初有一个多处理器并增加了三个，那么p =4.这 
里， （s，p）是你从改进中得到的加速因子。如果我们有一个架构， 
----------------------- Page 1118-----------------------
比如10％被序列化，即s =0.1，并且我们改进了我们的架构，以 
便剩余的（非串行）部分可以提高20倍，即 p =20，然后我们得 
到a=1/ （0.1 +0.9/20）≈6.9。可以看出，我们没有得到20的 
加速，原因是代码/硬件的串行部分严重限制了性能。事实上，当p 
→∞时，我们得到a=10.是否更好地花费精力来改进并联部分或串 
行部分并不总是很清楚，但是在并行部分得到实质性改进之后，串 
行部分将会限制性能更多。对于图形体系结构，并行计算多个结果， 
但绘制调用中的原语应按CPU提交的顺序进行处理。因此，必须进 
行某种排序，以便并行单元一起呈现用户想要的图像。具体而言， 
所需的分类是从模型空间到屏幕空间（第2.3.1和2.4节）。应注意， 
几何单元和像素处理单元可以映射到相同的单元，即统一的ALU。 
我们案例研究部分中的所有体系结构都使用统一着色器体系结构 
 （第23.10节）。即使是这种情况，重要的是要了解这种排序的位 
置。我们提出了并行体系结构的分类[417,1236]。排序可以发生在 
管道中的任何位置，这会在并行体系结构中产生四种不同类型的工 
作分布，如图23.17所示。这些称为排序优先，排序中间，排序最 
后片段和排序最后图像。请注意，这些体系结构产生了在GPU中的 
并行单元之间分配工作的不同方式。基于排序优先的体系结构在几 
何阶段之前对基元进行排序。策略是将屏幕划分为一组区域，并将 
区域内的基元发送到 “拥有”该区域的完整管道。见图23.18。最 
初处理基元以足以知道需要发送哪个区域 - 这是排序步骤。 
Sort-first是单个机器中探索最少的架构[418,1236]。当驱动具有多 
----------------------- Page 1119-----------------------
个屏幕的系统或投影仪形成大显示器时，确实看到了这种方案，因 
为单个计算机专用于每个屏幕[1513]。已经开发了一种称为 
Chromium [787]的系统，其可以使用工作站集群实现任何类型的 
并行渲染算法。例如，sort-first和sort-last可以以高渲染性能实 
现。Mali架构 （第23.10.1节）属于sort-middle类型。给几何处 
理单元提供大致相同的几何形状以进行处理。23.9。架构 1021GR 
P将三角形排序到箱柜GGRRPPA显示GRP排序三角形GGRRPPA 
显示G RP排序片段GGRRPPA显示G RPGGRRPPA显示合并颜 
色/z图23.17。并行图形架构的分类。A是应用程序，G是几何单 
元，R是光栅化器单元，P是像素处理单元。从左到右，架构是 
sort-f架构1021GRP将三角形排序到箱柜GGRRPPA显示GRP 
排序三角形 GGRRPPA显示G R P排序片段 GGRRPPA显示G R 
PGGRRPPA显示合并颜色/ z 图23.17。并行图形架构的分类。A 
是应用程序，G是几何单元，R是光栅化器单元，P是像素处理单 
元。从左到右，架构是sort-f架构 1021G RP将三角形排序到箱 
柜GGRRPPA显示GRP排序三角形GGRRPPA显示GRP排序片 
段GGRRPPA显示G RPGGRRPPA显示合并颜色/ z图23.17。并 
行图形架构的分类。A是应用程序，G是几何单元，R是光栅化器 
单元，P是像素处理单元。从左到右，架构是sort-first，sort-middle， 
sort-lastfragment和sort-last image。（Eldridge等人[417]之 
后的插图。）然后，变换的几何体被分类为非重叠的矩形，称为瓦 
片，它们一起覆盖整个屏幕。注意，变换的三角形可以与几个瓦片 
----------------------- Page 1120-----------------------
重叠，因此可以由几个光栅化器和像素处理单元处理。这里效率的 
关键是每对光栅化器和像素处理单元在芯片上都有一个瓦片尺寸的 
帧缓冲器，这意味着所有帧缓冲器访问都很快。当所有几何体已经 
被分类到瓦片时，每个瓦片的光栅化和像素处理可以彼此独立地开 
始。对于不透明几何体，某些中间体系结构为每个图块执行 
z-prepass，这意味着每个像素仅被着色一次。然而，并非所有排序 
中间架构都这样做。排序最后片段架构在光栅化（有时称为片段生 
成）之后和像素处理之前对片段进行排序。一个例子是GCN架构， 
如第23.10.3节所述。就像sort-middle一样，基元在几何单元中 
尽可能均匀地分布。分选器片段的一个优点是不会有任何重叠，这 
意味着生成的片段仅被发送到一个像素处理单元，这是最佳的。如 
果一个光栅化器单元处理大三角形，而另一个光栅化器单元仅处理 
小三角形，则可能发生不平衡。最后，排序最后的图像架构在像素 
处理之后进行排序。可视化如图23.19所示。这种架构可以看作是 
一组独立的管道。基元遍布管道，每个管道渲染深度图像。在最终 
的合成阶段，所有图像都相对于它们的z缓冲区合并。应该注意的 
是，排序最后的图像系统不能完全实现诸如OpenGL和 DirectX之 
类的API，因为它们需要基元102223.图形硬件图23.18。Sort-first 
将屏幕拆分为单独的图块，并为每个图块分配处理器，如此处所示。 
然后将基元发送到它们重叠的区块的处理器。这与排序中间体系结 
构形成对比，排序中间体系结构需要在几何处理发生后对所有三角 
形进行排序。只有在对所有三角形进行排序后才能开始逐像素光栅 
----------------------- Page 1121-----------------------
化。（图片由 MarcusRoth和 DirkReiners提供。）按照发送顺 
序呈现。PixelFlow [455，图1235是排序最后图像架构的示例。 
PixelFlow架构也值得注意，因为它使用延迟着色，这意味着它仅遮 
蔽可见片段。然而，应该注意，由于在管道末端的大量带宽使用， 
当前的架构没有使用排序最后图像。用于大型平铺显示系统的纯排 
序最后图像方案的一个问题是需要在渲染节点之间传输的大量图像 
和深度数据。Roth和 Reiners[1513]通过使用每个处理器结果的屏 
幕和深度边界来优化数据传输和组合成本。埃尔德里奇等人。 
[417,418]呈现石榴，一种无处不在的建筑。简而言之，它在几何阶 
段和光栅化器单元（R）之间插入排序阶段，在R和像素处理单元 
 （P）之间，以及在P和显示器之间。因此，随着系统的扩展 （即， 
添加更多管道），工作将保持更加平衡。排序阶段实现为具有点对 
点链接的高速网络。模拟显示随着更多管道的增加，性能几乎呈线 
性增长。23.9。架构 1023图23.19。在排序最后图像中，场景中的 
不同对象被发送到不同的处理器。合成单独的渲染图像时难以处理 
透明度，因此透明对象通常会发送到所有节点。（图片由 Marcus 
Roth和 DirkReiners提供。）图形系统中的所有组件（主机，几 
何处理，光栅化和像素处理）连接在一起，为我们提供了一个多处 
理系统。对于这样的系统，存在两个众所周知的问题，并且几乎总 
是与多处理相关联：负载平衡和通信[297]。FIFO （先进先出）队列 
通常插入到管道中的许多不同位置，因此可以对作业进行排队以避 
免停止管道的某些部分。例如，可以在几何体和光栅化器单元之间 
----------------------- Page 1122-----------------------
放置 FIFO，以便如果光栅化器单元由于例如巨大的三角形尺寸而无 
法跟上几何单元的速度，则可以缓冲几何体处理的三角形。所描述 
的不同排序架构具有不同的负载平衡优点和缺点。请参阅Eldridge 
的博士论文[418]或 Molnar等人的论文。[1236]有关这些的更多信 
息。程序员也可以影响负载平衡;第 18章讨论了这样做的技术。如 
果总线的带宽太低或者使用不明智，通信可能会成为一个问题。因 
此，设计应用程序的渲染系统是非常重要的，以便瓶颈不会出现在 
任何总线中，例如从主机到图形硬件的总线。第 18.2节涉及检测瓶 
颈的不同方法。102423.图形硬件23.10案例研究在本节中，将介 
绍三种不同的图形硬件架构。首先介绍面向移动设备和电视的ARM 
MaliG71Bifrost架构。接下来是 NVIDIA的Pascal架构。我们最 
后描述了名为Vega的AMDGCN架构。请注意，图形硬件公司通 
常将其设计决策基于尚未构建的GPU的大量软件模拟。也就是说， 
几个应用程序（例如游戏）通过其具有若干不同配置的参数化模拟 
器运行。例如，可能的参数是 MP的数量，时钟频率，高速缓存的 
数量，光栅引擎/曲面细分器引擎的数量和ROP的数量。模拟用于 
收集有关性能，功耗和内存带宽使用等因素的信息。在一天结束时， 
选择在大多数用例中效果最佳的最佳配置，并根据该配置构建芯片。 
此外，模拟可以帮助找到架构中的典型瓶颈，然后可以解决这些瓶 
颈，例如，增加高速缓存的大小。对于特定的GPU，各种速度和数 
量的单位的原因很简单， “它以这种方式工作得最好。”23.10.1 
案例研究：ARM MaliG71 BifrostMali产品线包含ARM 的所有 
----------------------- Page 1123-----------------------
GPU架构，Bifrost是这种架构的目标是移动和嵌入式系统，例如移 
动电话，平板电脑和电视。2015年，出货了7.5亿台基于 Mali的 
GPU。由于其中许多都是由电池供电，因此设计节能架构非常重要， 
而不是仅仅关注性能。因此，使用排序中间架构是有意义的，其中 
所有帧缓冲器访问都保留在芯片上，这降低了功耗。所有 Mali架构 
都属于中间类型，有时称为平铺架构。GPU的高级概述如图23.20 
所示。可以看出，G71最多可支持32个统一着色器引擎。ARM使 
用术语着色器核心而不是着色器引擎，但我们使用术语着色器引擎 
来避免与本章其余部分混淆。着色器引擎能够一次执行 12个线程的 
指令，即它具有 12个ALU。32个着色引擎的选择专门针对G71， 
但该架构可以扩展到超过32个引擎。驱动程序软件为GPU提供工 
作。然后，作业管理器 （即调度程序）将此工作划分为着色器引擎。 
这些引擎通过GPU结构连接，GPU结构是引擎可以与GPU中的其 
他单元通信的总线。所有内存访问都通过内存管理单元 （MMU）发 
送，它从虚拟内存地址转换为物理地址。着色器引擎概述如图23.21 
所示。可以看出，它包含三个执行引擎，以四边形执行着色为中心。 
因此，它们被设计为SIMD宽度为4的小型通用处理器。每个23.10。 
案例研究 1025GPU架构平铺器 MMUL2缓存段驱动程序软件作 
业管理器着色器引擎0着色器引擎 1着色器引擎2着色器引擎 31 
ACE内存总线L2缓存段L2缓存段L2缓存段图23.20。BifrostG71 
GPU架构，可扩展至32个着色器引擎，其中每个着色器引擎如图 
23.21所示。 （戴维斯之后的插图[326]。执行引擎0四元状态四元 
----------------------- Page 1124-----------------------
控制执行引擎 1四元状态执行引擎2四元状态四元管理器片段前端 
计算前端着色器核心结构加载/存储单元属性单元变化单元纹理单 
元混合器和区块访问区块存储区块写回深度和模板单元 L2缓存深 
度和模板内存quadcreatorquadcreator图23.21。Bifrost着色 
器引擎架构，其中磁贴存储器位于芯片上，这使得快速本地帧缓冲 
器访问成为可能。 （戴维斯[326]之后的插图。）102623.图形硬件 
执行引擎包含四个用于 32位浮点和四个 32位加法器的融合乘加 
 （FMA）单元等。这意味着每个着色器引擎有3×4个ALU，即12 
个SIMD通道。四边形相当于经线，在我们这里使用的术语中。例 
如，为了隐藏纹理访问的延迟，架构可以在每个着色器引擎中保留 
至少256个线程。请注意，着色器引擎是统一的，可以执行计算， 
顶点和像素着色，仅举几例。执行引擎还包含对许多超越函数的支 
持，例如正弦和余弦。此外，使用 16位浮点精度时性能高达2倍。 
当寄存器结果仅用作后续指令的输入时，这些单元还支持绕过寄存 
器内容。这节省了功率，因为​ ​ 不需要访问寄存器文件。此外， 
例如，当执行纹理或其他存储器访问时，可以通过四元组管理器切 
换单个四元组，类似于其他架构隐藏此类操作的延迟。请注意，这 
发生在小粒度级别，交换4个线程而不是全部 12个。加载/存储单 
元负责一般的内存访问，内存地址转换和相干缓存[264]。属性单元 
处理属性索引和寻址。它将其访问发送到加载/存储单元。变化单元 
执行不同属性的插值。平铺体系结构 （sort-middle）的核心思想是 
首先执行所有几何处理，以便找到要渲染的每个图元的屏幕空间位 
----------------------- Page 1125-----------------------
置。同时，为帧缓冲区中的每个图块构建包含指向与图块重叠的所 
有图元的指针的多边形列表。在该步骤之后，已知与图块重叠的图 
元集。因此，可以对图块中的图元进行栅格化和着色，并将结果存 
储在片上图块存储器中。当图块完成所有图元的渲染后，图块存储 
器中的数据将通过 L2缓存写回外部存储器。这减少了内存带宽使 
用。然后对下一个图块进行栅格化，依此类推，直到渲染完整个帧。 
第一个拼贴架构是 Pixel-Planes5[502]，该系统与Mali架构有一 
些高级相似之处。几何处理和像素处理在图23.22中可视化。可以 
看出，顶点着色器被分割为一个仅执行位置着色的部分，另一个部 
分称为变化着色，这是在平铺之后完成的。与ARM以前的架构相 
比，这节省了内存带宽。执行合并所需的唯一信息，即确定图元重 
叠的图块，是顶点的位置。执行分箱的Tiler单元以分层方式工作， 
如图23.23所示。这有助于使分箱的内存占用更小且更可预测，因 
为它不再与原始大小成比例。当铺位器完成对场景中的所有图元进 
行分级时，确切地知道哪些图元与某个图块重叠。因此，只要存在 
可以并行工作的可用着色器引擎，就可以对任意数量的块平行地执 
行剩余的光栅化，像素处理和混合。通常，将图块提交给着色器引 
擎，该引擎处理该图块中的所有图元。虽然这项工作是针对所有瓷 
砖完成的，也可以从几何处理23.10开始。案例研究 1027平铺索 
引位置变换位置位置着色片段着色多边形列表属性变化着色着色内 
存GPU图23.22。几何如何流过Bifrost建筑的插图。顶点着色器 
由贴砖机使用的位置着色和在贴砖后仅在需要时执行的变化着色组 
----------------------- Page 1126-----------------------
成。（Choi [264]之后的插图。）和下一帧的平铺。此处理模型意 
味着平铺体系结构中可能存在更多延迟。此时，光栅化，像素着色 
器执行，混合和其他每像素操作如下。平铺架构最重要的一个特点 
是帧缓冲（包括颜色，深度和模板，例如，对于单个磁贴，可以存 
储在快速片上存储器中，这里称为磁贴存储器。这是实惠的，因为 
瓷砖很小 （16×16像素）。当拼贴中的所有渲染都已完成时，拼贴 
的所需输出（通常是颜色，可能是深度）被复制到与屏幕大小相同 
的片外帧缓冲区（在外部存储器中）。这意味着在每像素处理期间 
对帧缓冲区的所有访问都是有效的免费访问。避免使用外部总线是 
非常需要的，因为这种使用带来了高能源成本[22]。当将片上瓦片 
存储器的内容驱逐到片外帧缓冲器时，仍然可以使用帧缓冲器压缩。 
Bifrost支持像素本地存储（PLS），这是一组通常在排序中间体系 
结构上支持的扩展。使用 PLS，可以让像素着色器访问帧缓冲的颜 
色，从而实现自定义混合技术。相反，混合通常使用API​ ​ 配置， 
在图23.23中不可编程。Bifrost架构的分层排序器。在此示例中， 
在三个不同的级别上完成分级，其中每个三角形已被分配到与单个 
正方形重叠的级别。（Bratt[191]之后的插图。）102823.图形硬 
件像素着色器的方式。还可以使用区块存储器为每个像素存储任意 
固定大小的数据结构。这允许程序员有效地实现例如延迟着色技术。 
G缓冲区（例如，法线，位置和漫射纹理）在第一遍中存储在 PLS 
中。第二遍执行照明计算并将结果累积到PLS中。第三遍使用PLS 
中的信息来计算最终像素颜色。注意，对于单个图块，所有这些计 
----------------------- Page 1127-----------------------
算都发生在整个图块存储器保留在芯片上时，这使得它很快。所有 
Mali架构都是从头开始设计的，考虑了多重采样抗锯齿 （MSAA）， 
它们实现了第143页所述的旋转网格超级采样（RGSS）方案，每 
个像素使用四个样本。排序中间体系结构非常适合抗锯齿。这是因 
为过滤是在磁贴离开GPU之前完成的，并且被发送到外部存储器。 
因此，外部存储器中的帧缓冲器需要每个像素仅存储单个颜色。标 
准体系结构需要帧缓冲器的四倍大。对于平铺体系结构，您需要仅 
将片上平铺缓冲区增加四倍，或者有效地使用较小的平铺（宽度和 
高度的一半）。MaliBifrost架构还可以选择性地选择在一批渲染基 
元上使用多重采样或超级采样。这意味着可以在需要时使用更昂贵 
的超级采样方法，即为每个样本执行像素着色器。一个示例是渲染 
带有alpha映射的纹理树，您需要高质量的采样以避免视觉伪像。 
对于这些原语，可以启用超级采样。当这种复杂情况结束并且要渲 
染更简单的对象时，可以切换回使用较便宜的多重采样方法。该架 
构还支持8×和 16×MSAA。Bifrost （以及之前称为Midgard的架 
构）也支持一种称为事务消除的技术。这个想法是为了避免存储器 
从磁贴存储器转移到片外存储器，以用于不逐帧改变的场景部分。 
对于当前帧，当瓦片被逐出到片外帧缓冲器时，为每个瓦片计算唯 
一签名。此签名是一种校验和。对于下一帧，将为即将被驱逐的区 
块计算签名。如果来自前一帧的签名与特定块的当前帧的签名相同， 
则该架构避免将颜色缓冲区写出到片外存储器，因为已经存在正确 
的内容。这对于休闲手机游戏特别有用（例如，愤怒的小鸟），每 
----------------------- Page 1128-----------------------
帧更新场景的一小部分。还要注意，这种类型的技术很难在排序最 
后的体系结构上实现，因为它们不是基于每个块操作。G71还支持 
智能组合，即应用于用户界面组合的事务消除。如果所有源都与前 
一帧相同并且操作相同，则可以避免读取，合成和写入像素块。在 
这种架构中也大量使用低级节能技术，例如时钟门控和电源门控。 
这意味着管道的未使用或不活动部分在较低能耗下关闭或保持空闲 
以减少电力使用。23.10。案例研究 1029为减少纹理带宽，有一个 
带有ASTC和 ETC专用解压缩单元的纹理缓存。此外，压缩纹理以 
压缩形式存储在缓存中，而不是解压缩它们然后将纹素放入缓存中。 
这意味着当发出纹素的请求时，硬件从缓存中读取块，然后在运行 
中解压缩块的纹素。此配置增加了缓存的有效大小，从而提高了效 
率。通常，拼接结构的一个优点是它本身就是瓷砖的并行处理。例 
如，可以添加更多着色器引擎，其中每个着色器引擎负责一次独立 
渲染到单个图块。平铺体系结构的缺点是需要将整个场景数据发送 
到GPU以进行平铺和处理的几何流输出到存储器。通常，排序中间 
体系结构对于处理几何体放大（例如应用几何着色器和曲面细分） 
并不理想，因为更多几何体会增加来回移动几何体的内存传输量。 
对于 Mali架构，几何着色 （第 18.4.2节）和曲面细分都在GPU上 
的软件中处理，而Mali最佳实践指南[69]建议不要使用几何着色器。 
对于大多数内容，排序中间体系结构适用于移动和嵌入式系统。 
23.10.2案例研究：NVIDIAPascalPascal是由NVIDIA构建的GPU 
架构。它既作为图形部分[1297]又作为计算部分[1298]存在，后者 
----------------------- Page 1129-----------------------
针对高性能计算和深度学习应用程序。在本演示中，我们将主要关 
注图形部分，特别是关于GeForceGTX1080的特定配置。我们将 
以自下而上的方式呈现架构，从最小的统一ALU开始，然后向整个 
GPU。我们将在本节末尾简要介绍一些其他芯片配置。用于Pascal 
图形架构的NVIDIA术语中的统一ALU-CUDA核心与图23.8 （第 
1002页）左侧的ALU具有相同的高级图.ALU的焦点是浮点和整数 
运算，但是他们还支持其他行动。为了增加计算能力，将几个这样 
的ALU组合成流式多处理器 （SM）。在 Pascal的图形部分中，SM 
由四个处理块组成，每个块具有32个ALU。这意味着SM可以同 
时执行4个32个线程的warp。如图23.24所示。每个处理块，即 
宽度为32的SIMT引擎，还具有8个加载/存储 （LD/ ST）单元和 
8个特殊功能单元（SFU）。加载/存储单元处理寄存器文件中寄存 
器的读取和写入值，每个处理块为 16,384×4字节，即64kB，每个 
SM的总和为256kB。SFU处理超越函数指令，例如正弦，余弦， 
指数 （基数2），对数 （基数2），倒数和倒数平方根。他们还支持 
属性插值[1050]。103023但遗漏了部分复制品。（NVIDIA白皮 
书[1297]之后的插图。）SM中的所有ALU共享单个指令高速缓存， 
而每个SIMT引擎具有其自己的指令缓冲区，其具有本地最近加载 
的指令集以进一步增加指令高速缓存命中率。warp调度器能够在每 
个时钟周期调度两个warp指令[1298]，例如，可以在相同的时钟 
周期中将工作调度到ALU和 LD/ST单元。注意，每个SM还有两 
个 L1高速缓存，每个高速缓存具有24kB的存储空间，即每个SM 
----------------------- Page 1130-----------------------
48kB。拥有两个 L1高速缓存的原因可能是较大的 L1高速缓存需要 
更多的读写端口，这增加了高速缓存的复杂性并使得芯片上的实现 
更大。此外，每个SM有8个纹理单元。23.10。案例研究 1031因 
为着色必须在2×2像素四边形中完成，所以warp调度程序找到8 
个不同像素四边形的工作并将它们组合在一起以便在32个SIMT通 
道中执行[1050]。由于这是统一的ALU设计，因此warp调度程序 
可以将顶点，像素，基元或计算着色器工作之一分组为warp。请注 
意，SM可以同时处理不同类型的warp （例如顶点，像素和基元）。 
该架构还具有零开销，用于为准备执行的warp切换当前正在执行 
的warp。接下来选择在Pascal上执行的warp的细节不公开，但 
之前的NVIDIA架构给了我们一些提示。在2008年的NVIDIATesla 
架构[1050]中，记分板用于在每个时钟周期对每个warp进行限定。 
记分板是一种通用机制，允许无序执行而不会发生冲突。warp调度 
程序在准备执行的warp中选择，例如，不等待纹理加载返回，并 
选择具有最高优先级的warp。Warp类型，指令类型和 “公平性” 
是用于选择最高优先级扭曲的参数。SM与多态引擎 （PM）一起工 
作。该单元在费米芯片的第一个版本中被引入[1296]。PM执行几 
个与几何相关的任务，包括顶点提取，曲面细分，同时多重投影， 
属性设置和流输出。第一个阶段从全局顶点缓冲区中提取顶点，并 
将warp调度到SM以进行顶点和外壳着色。然后是可选的镶嵌阶 
段 （第 17.6节），其中新生成的 （u，v）色块坐标被分派到SM以 
进行域着色和可选的几何着色。第三阶段处理视口变换和透视校正。 
----------------------- Page 1131-----------------------
此外，这里执行可选的同时多投影步骤，例如，可以用于有效的VR 
渲染 （第21.3.1节）。接下来是可选的第四阶段，其中顶点被流式 
传输到内存。最后，结果被转发到相关的栅格引擎。光栅引擎有三 
个任务，即三角形设置，三角形遍历和z剔除。三角形设置获取顶 
点，计算边缘方程，并执行背面剔除。三角遍历使用分层平铺遍历 
技术来访问与三角形重叠的切片。它使用边缘方程来执行平铺测试 
并执行内部测试。在 Fermi上，每个光栅化器每个时钟周期最多可 
以处理8个像素[1296]。Pascal上没有公开号码。z-culling单元使 
用第23.7节中描述的技术处理每个区块的剔除。如果剔除图块，则 
立即终止该图块的处理。对于幸存的三角形，每个顶点属性被转换 
为平面方程，以便在像素着色器中进行有效评估。与多态引擎耦合 
的流处理器称为纹理处理簇（TPC）。在更高级别上，五个TPC被 
分组到图形处理集群 （GPC）中，该集群具有服务于这五个TPC的 
单个光栅引擎。GPC可以被认为是一个小型GPU，它的目标是为图 
形提供一组平衡的硬件单元，例如顶点，几何，光栅，纹理，像素 
和 ROP单元。正如我们将在本节末尾看到的那样，创建单独的功能 
单元使设计人员能够更轻松地创建具有一系列功能的GPU芯片系 
列。103223.图形硬件L2缓存光栅引擎图形处理集群GigaThread 
引擎PCIexpressv3主机界面光栅引擎图形处理集群光栅引擎图形 
处理集群光栅引擎图形处理集群 mem。控制器记忆控制器记忆控 
制器记忆 控制器记忆 控制器记忆 控制器记忆 控制器记忆 控制器 
图23.25。采用GTX 1080配置的 PascalGPU，具有20个SM， 
----------------------- Page 1132-----------------------
20个多态引擎，4个光栅引擎，8×20 =160个纹理单元（峰值速 
率为277.3Gtexels/ s），256×20 =5120kB寄存器文件，以及 
总共20×128=2560个统一ALU。（在NVIDIA白皮书之后的插 
图[1297]。）此时，我们拥有GeForceGTX1080的大部分构建模 
块。它由四个GPC组成，这个常规设置如图23.25所示。请注意， 
这里有另一个级别的调度，由GigaThread引擎驱动，以及PCIev3 
的接口。GigaThread引擎是一个全局工作分发引擎，它为所有GPC 
调度线程块。光栅操作单元也显示在图23.25中，尽管有些隐藏。 
它们位于图中间的L2缓存的正上方和下方。每个蓝色块是一个ROP 
单元，有8个组，每组有8个 ROP，总共64个。ROP单元的主要 
任务是将输出写入像素和其他缓冲区，并执行各种操作，如混合。 
从图中的左侧和右侧可以看出，总共有8个32位存储器控制器， 
总计为256位。8个 ROP单元连接到单个内存控制器和256kBL2 
缓存。这为整个芯片提供了总共2 MB的L2缓存。每个 ROP都绑 
定到某个内存分区，这意味着 ROP处理缓冲区中某个像素子集。 
ROP单元还可以处理无损压缩。有三种不同的压缩模式23.10。案 
例研究 1033图23.26。渲染图像显示在左侧，而压缩结果可视化为 
Maxwell （中），Pascal之前的架构和 Pascal （右）。图像越紫， 
缓冲区压缩的成功率就越高。（来自 NVIDIA白皮书[1297]的图片。） 
除了支持未压缩和快速清除之外[1297]。对于2：1压缩 （例如，从 
256B到 128B），每个图块存储参考颜色值，并且差异在像素之间 
编码，其中每个差异用比未压缩形式更少的比特编码。然后4：1 
----------------------- Page 1133-----------------------
压缩是2：1模式的扩展，但是只有在可以使用更少的比特编码差异 
时才能启用此模式，并且它仅适用于具有平滑变化内容的那些瓦片。 
还有一种8：1模式，它是2×2像素块的4：1恒定颜色压缩与上 
述2：1模式的组合。8：1模式的优先级高于4：1，优先级高于2： 
1，即总是使用压缩率最高的压缩率模式。如果所有这些压缩尝试 
都失败，则必须传送磁贴并将其作为未压缩存储在存储器中。Pascal 
压缩系统的效率如图23.26所示。使用的视频存储器是GDDRX5， 
时钟频率为10GHz。上面我们看到八个内存控制器总共提供256 
位=32B。这总共提供了320GB/s的总峰值内存带宽，但是许多 
级别的缓存与压缩技术相结合会给人一种更高有效率的印象。芯片 
的基本时钟频率为1607MHz，当有足够的功率预算时，它可以在 
升压模式 1733（  MHz）下工作。峰值计算能力为|{2z}FMA·|25{z60} 
num。SP·|17{3z3}时钟频率。=8，872,960MFLOPS≈8.9TFLOPS， 
 （23.16）其中2来自融合乘法和加法通常被计为两个浮点运算的事 
实，我们除以 106以从 MFLOPS转换为TFLOPS。GTX 1080Ti 
有3584个ALU，结果是12.3TFLOPS。NVIDIA已经开发了排序 
最后的片段架构很长一段时间了。但是，自从麦克斯韦以来，他们 
还支持一种称为平铺缓存的新型渲染，它有点介于sort-middle和 
sort-last 片段之间。该架构如图 23.27所示。这个想法是利用 
locality和 L2缓存。以足够小的块处理几何，以便输出可以保留在 
此缓存中。此外，只要与该图块重叠的几何图形尚未完成像素着色， 
帧缓冲区也会保留在L2中。图23.25中有四个光栅引擎，但我们知 
----------------------- Page 1134-----------------------
道图形API必须（在大多数情况下）遵循原始提交顺序[1598]。帧 
缓冲是 103423.图形硬件前端几何处理 binner光栅化像素处理 
ROPxy属性转换后几何体片上 L2缓存存储器层次结构（L3， 
GDDRX5）图块图23.27。平铺缓存引入了一个binner，可将几何 
体分类为tile，并使转换后的几何体保留在 L2缓存中。当前处理的 
图块也保持在L2中，直到完成当前图块的图块中的几何图形。经常 
使用广义棋盘图案分割成图块[1160]，并且每个光栅引擎 “拥有” 
一组图块。当前三角形被发送到每个栅格引擎，其至少一个瓦片与 
三角形重叠，它解决了每个瓷砖独立的排序问题。这样可以实现更 
好的负载平衡。GPU架构中通常还有几个 FIFO队列，可以减少硬 
件单元的不足。这些队列未在我们的图表中显示。显示控制器每个 
颜色分量有 12位，并具有 BT.2020宽色域支持。它还支持 HDMI 
2.0b和 HDCP2.2。对于视频处理，它支持SMPTE2084，这是高 
动态范围视频的传输功能。Venkataraman [1816]描述了Fermi的 
NVIDIA架构以及之后如何拥有一个或多个复制引擎。这些是可以 
执行直接内存访问 （DMA）传输的内存控制器。在CPU和GPU之 
间发生DMA传输，并且这种传输通常在这些中的任何一个上开始。 
启动处理单元可以在传输期间继续进行其他计算。复制引擎可以在 
CPU和GPU内存之间启动数据的DMA传输，并且它们可以独立 
于GPU的其余部分执行。因此，GPU可以呈现三角形并执行其他 
功能，同时信息从CPU传输到GPU，反之亦然。Pascal架构还可 
以配置用于非图形应用程序，例如用于训练神经网络或大规模数据 
----------------------- Page 1135-----------------------
分析。特斯拉 P100就是这样一种配置[1298]。与GTX 1080的一 
些不同之处包括它使用高带宽内存2 （HBM2），内存总线为4096 
位，总内存带宽为720GB/ s。此外，它们具有原生的16位浮点 
支持，具有高达2×32位浮点的性能，并且双精度处理速度大大加 
快。SM配置也不同，以及寄存器文件设置[1298]。GTX 1080Ti 
 （钛）是一种高端配置。它具有3584个ALU，352位内存总线， 
484GB/s的总内存带宽，88个 ROP和224个纹理单元，而GTX 
1080则为2560,256位，320GB/ s，64和 160.23.10。案例研 
究 1035L1缓存 16kB矢量 RF调度器分支和msg单位标量 RF标 
量单位纹理滤波器单位纹理加载和存储单元本地数据共享64kB矢 
量单位SIMD16矢量 RF矢量 RF矢量 RF{12.5kB图23.28。Vega 
架构的GCN计算单元。每个矢量寄存器文件的容量为64kB，而标 
量RF的容量为12.5kB，和本地数据共享有64kB。请注意，有四 
个单元的 16个SIMD通道 （浅绿色），具有32位浮点，用于在每 
个CU中进行计算。Mah（ [1103]和AMD 白皮书[35]之后的插图。） 
它使用六个GPC进行配置，即它有六个光栅引擎，而GTX1080则 
有四个。四个GPC完全相同。 GTX1080，而剩下的两个稍微小一 
些只有四个TPC而不是五个。1080Ti由120亿个晶体管构成，而 
1080则使用72亿个。Pascal架构非常灵活，因为它也可以缩小。 
例如，GTX 1070是GTX 1080减去一个GPC，GTX 1050由两个 
GPC组成，每个GPC有三个SM。23.10.3案例研究：AMDGCN 
VegaAMD图形核心下一代 （GCN）架构用于几个AMD显卡产品 
----------------------- Page 1136-----------------------
以及XboxOne和 PLAYSTATION4.这里，我们描述了GCNVega 
架构的一般元素[35]，这是一个演变这些控制台中使用的架构。GCN 
架构的核心构建块是计算单元（CU），如图23.28所示。CU有四 
个 SIMD单元，每个单元具有 16个 SIMD通道，即 16个统一的 
ALU （使用第23.2节中的术语）。每个SIMD单元执行64个线程 
的指令，称为波前。每个SIMD单元可以发出每个时钟周期一个单 
精度浮点指令。由于该架构每个SIMD单元处理64个线程的波前， 
因此在完全发布波前之前需要4个时钟周期[1103]。另请注意，CU 
可以同时运行来自不同内核的代码。由于每个SIMD单元具有 16 
个通道，并且每个时钟周期可以发出一条指令，因此整个CU的最 
大吞吐量为每个CU4个SIMD单元×每个单元 16个SIMD通道= 
每个时钟周期64个单精度 FP操作。与单精度FP相比，CU还可以 
执行两倍半精度 （16位浮点）指令，这对于需要较低精度的情况非 
常有用。例如，这可以包括机器学习和着色器计算。请注意，两个 
16位 FP值被打包到一个 103623.图形硬件32位 FP寄存器中。每 
个SIMD单元有一个64kB的寄存器文件，每个线程相当于65,536 
/ （4·64）=256个寄存器，因为单精度 FP使用4个字节，每个波 
前有64个线程。ALU有四个硬件流水线阶段[35]。每个CU具有指 
令高速缓存（图中未示出），其在多达四个SIMD单元之间共享。 
相关指令被转发到SIMD单元的指令缓冲器 （IB）。每个IB都有用 
于处理 10个波前的存储器，可以根据需要切换进出SIMD单元以 
隐藏延迟。这意味着CU可以处理40个波前。反过来，这相当于 
----------------------- Page 1137-----------------------
40·64=2560个线程。因此，图23.28中的CU调度程序一次可以 
处理2560个线程，其任务是将工作分配给CU的不同单元。每个 
时钟周期，当前CU上的所有波前都被考虑用于指令发布，并且可 
以向每个执行端口发出最多一条指令。CU的执行端口包括分支，标 
量/向量ALU，标量/向量存储器，本地数据共享，全局数据共享或 
导出，以及特殊指令[32]，也就是说，每个执行端口大致映射到CU 
的一个单元。标量单元是一个64位ALU，也在SIMD单元之间共 
享。它有自己的标量寄存器文件和标量数据缓存（未显示）。标量 
RF每个SIMD单元有800个32位寄存器，即800·4·4 =12.5kB。 
执行紧密耦合到波前。由于完全向SIMD单元发出指令需要四个时 
钟周期，因此标量单元可以仅在每四个时钟周期服务一个特定的 
SIMD单元。标量单元处理控制流，指针算术以及可在warp 中的 
线程之间共享的其他计算。从标量单元发送条件和无条件分支指令， 
以便在分支和消息单元中执行。每个SIMD单元都有一个在通道之 
间共享的48位程序计数器（PC）。这就足够了，因为它们都执行 
相同的指令。对于已采用的分支，程序计数器会更新。可由本机发 
送的消息包括调试消息，特殊图形同步消息和CPU中断[1121]。 
Vega 10架构[35]如图23.29所示。顶部包括图形命令处理器，两 
个硬件调度程序（HWS）和八个异步计算引擎（ACE）[33]。GPC 
的任务是将图形任务分配到GPU的图形管线和计算引擎上。HWS 
的缓冲区在尽可能快地分配给ACE的队列中工作。ACE的任务是将 
计算任务安排到计算引擎上。还有两个 DMA引擎可以处理复制任 
----------------------- Page 1138-----------------------
务（图中未显示）。GPC，ACE和 DMA引擎可以并行工作并将工 
作提交给GPU，从而提高利用率，因为任务可以从不同的队列交错。 
可以从任何队列调度工作，而无需等待其他工作完成，这意味着独 
立任务可以同时在计算引擎上执行。ACE可以通过缓存或内存进行 
同步。它们可以一起支持任务图，因此一个ACE的任务可以依赖于 
另一个ACE的任务，也可以依赖于图形管道的任务。建议较小的计 
算和复制任务与较重的图形任务交错[33]。23.10。ACEACEACE 
ACEACEACE图23.29。采用64个CU构建的Vega 10GPU。请 
注意，每个CU包含图 23.28中所示的硬件。（AMD 白皮书[35] 
之后的插图。）如图23.29所示，有四个图形管道和四个计算引擎。 
每个计算引擎有 16个CU，总计为64个CU。图形管道有两个块， 
即几何引擎和绘制流分箱光栅化器 （DSBR）。几何引擎包括几何装 
配器，曲面细分单元和顶点装配器。此外，还支持新的原始着色器。 
原始着色器的想法是实现更灵活的几何处理和更快速的基元剔除 
[35]。DSBR结合了sort-middle和sortlast体系结构的优点，这 
也是平铺缓存的目标（第23.10.2节）。图像在屏幕空间中被划分 
为图块，并且在几何图形处理之后，每个图元被分配给它们重叠的 
图块。在区块的光栅化期间，所需的所有数据 （例如，区块缓冲区） 
保持在 L2高速缓存中，这提高了性能。可以自动延迟像素着色，直 
到处理了图块中的所有几何图形。因此，z-prepass在引擎盖下完 
成，像素仅阴影一次。延迟着色可以打开和关闭;例如，对于透明几 
何体，它需要关闭。为了处理深度，模板和颜色缓冲区，GCN架构 
----------------------- Page 1139-----------------------
有一个称为颜色和深度块（CDB）的构建块。它们处理颜色，深度 
和模板 103823.图形硬件寄存器 （SRAM）L1 （SRAM）L2 （SRAM） 
高带开关高速缓存（HBM2）系统存储器（DRAM）HBCC存储器 
段图23.30。Vega架构的缓存层次结构。读取和写入，以及颜色混 
合。CDB可以使用第23.5节中描述的一般方法压缩颜色缓冲区。 
使用增量压缩技术，其中每个图块的未压缩存储一个像素的颜色， 
并且相对于该像素颜色编码其余的颜色值[34,1238]。为了提高效 
率，可以基于访问模式动态地选择瓦片大小。对于最初使用256字 
节存储的图块，最大速率为8：1，即压缩到32字节。压缩的颜色 
缓冲器可以用作后续通道中的纹理，在这种情况下，纹理单元将对 
压缩的瓦片进行解压缩，这提供了进一步的带宽节省[1716]。光栅 
化器每个时钟周期可以栅格化多达四个基元。连接到图形管道和计 
算引擎的CDB可以在每个时钟周期写入 16个像素。也就是说，小 
于16个像素的三角形会降低效率。光栅化器还可以处理粗深度测试 
 （HiZ）和分层模板测试。用于HiZ的缓冲器被称为HTILE并且可 
以由开发者编程，例如，用于将遮挡信息馈送到GPU。Vega的缓 
存层次结构如图23.30所示。在层次结构的顶部（图中最右边）， 
我们有寄存器，然后是 L1和 L2缓存。然后，还有高带宽存储器2 
 （HBM2），它也位于图形卡上，最后是位于CPU侧的系统存储器。 
Vega的一个新功能是高带宽缓存控制器 （HBCC），如图23.29所 
示。它允许视频内存的行为类似于最后一级缓存。这意味着如果进 
行存储器访问并且相应的内容不在视频存储器中，即 HBM2，则 
----------------------- Page 1140-----------------------
HBCC将自动通过 PCIe总线获取相关的系统存储器页面并将其放 
入视频存储器中。因此，可以交换视频存储器中最近使用较少的页 
面。HBM2和系统内存之间共享的内存池称为 HBCC 内存段 
 （HMS）。所有图形块也通过L2缓存访问内存，这与以前的体系 
结构不同。该架构还支持虚拟内存 （第 19.10.1节）。23.11。Ray 
TracingArchitectures 1039请注意所有片上模块，例如 HBCC， 
XDMA （CrossFireDMA），PCIExpress，显示引擎和多媒体引擎， 
通过称为 InfinityFabric （IF）的互连进行通信。AMDCPU也可以 
连接到 IF。InfinityFabric可以连接不同芯片裸片上的模块。IF也 
是连贯的，这意味着所有块都可以看到内存中内容的相同视图。芯 
片的基本时钟频率为1677MHz，即峰值计算能力为|{2z}FMA·|40 
{9z6} num SPs | | 16 {z77}时钟频率。= 13,737,984MFLOPS≈ 
13.7TFLOPS，（23.17）其中FMA和TFLOPS计算与公式23.16 
中的计算匹配。该架构灵活且可扩展，因此预计会有更多配置。23.11 
光线跟踪体系结构本节将简要介绍光线跟踪硬件。我们不会列出有 
关此主题的所有最新参考，而是提供一组鼓励读者遵循的指针。该 
领域的研究由Schmittler等人开始。[1571]在2002年，重点是遍 
历和交叉，并且使用固定功能单元计算着色。这项工作后来由Woop 
等人跟进。[1905]，他提出了一个带可编程着色器的架构。在过去 
几年中，对该主题的商业兴趣大大增加。可以看出，诸如 
Imagination Technologies [1158]，LG Electronics [1256]和 
Samsung [1013]等公司已经展示了他们自己的用于实时光线跟踪 
----------------------- Page 1141-----------------------
的硬件架构。但是，在撰写本文时，只有 ImaginationTechnologies 
发布了商业产品。这些体系结构中有几个共同特征。第一，它们通 
常使用基于轴对齐边界框的边界体积层次结构。其次，它们倾向于 
通过降低光线/盒子相交测试的精度来降低硬件复杂性（第22.7节）。 
最后，他们使用可编程内核来支持可编程着色，这或多或少是当前 
的要求。例如，ImaginationTechnologies通过添加光线跟踪单元 
来扩展其传统芯片设计，例如，可以利用着色器核心进行着色。光 
线跟踪单元包括光线交叉处理器和相干引擎[1158]，其中后者收集 
具有相似属性的光线并将它们一起处理以利用局部性来实现更快的 
光线跟踪。ImaginationTechnologies的架构还包括一个用于建造 
BVH的专用单元。该领域的研究继续探索若干领域，包括有效实施 
遍历的精度降低[1807]，BVH的压缩表示[1045]和能效[929]。毫 
无疑问，还有更多的研究要做。104023.图形硬件进一步阅读和资 
源Akeley和 Hanrahan[20]以及Hwu和 Kirk[793]关于计算机图 
形学架构的课程笔记提供了大量资源。Kirk和 Hwu[903]的书也是 
有关在GPU上使用CUDA进行编程的信息的绝佳资源。年度高性 
能图形和SIGGRAPH会议论文集是新架构特征演示的良好来源。对 
于想要了解更多有关GPU细节的人来说，Giesen的图形管道之旅 
是一个很棒的在线资源[530]。我们还将感兴趣的读者引用到 
Hennessy和 Patterson的书[715]，以获取有关存储系统的详细信 
息。有关移动呈现的信息分散在许多来源中。值得注意的是，GPU 
Pro5一书有七篇关于移动渲染技术的文章。第24章未来 “很快， 
----------------------- Page 1142-----------------------
计算机就会很快。” -BillyZelsnack “预测很困难，特别是对未来 
的预测。”-Niels Bohr或Yogi Berra “预测未来的最好方法就是 
创造它。” - 阿兰凯未来有两个部分：你和其他一切。本章是关于 
两者的。首先，我们将做出一些预测，其中一些甚至可能成真。更 
重要的是第二部分，关于你可以去哪里。这是一个扩展的进一步阅 
读和资源部分，但它也讨论了从这里开始的方式 - 一般信息来源， 
会议，代码等。但首先是图像：见图24.1。图24.1。通过游戏 Destiny 
2一瞥未来。 （图片c2017Bungie，Inc。保留所有权利。）1041 
104224.未来24.1其他所有图形有助于销售游戏，游戏有助于销售 
芯片。从芯片制造商的营销角度来看，实时渲染的最佳功能之一是 
图形会消耗大量的处理能力和其他资源。与帧速率，分辨率和颜色 
深度等硬件相关的功能也可以在一定程度上增长，从而进一步增加 
负载。最低固帧速率为90FPS是虚拟现实应用的标准，而4k像素 
显示器已经在测试图形系统跟上的能力[1885]。模拟场景中光线效 
果的复杂任务本身就足以吸收计算能力。向场景添加更多对象或灯 
光是渲染显然变得更加昂贵的一种方式。对象的类型 （实体和体积， 
例如雾），描绘这些对象的表面的方式以及所使用的灯的类型只是 
复杂性可以增加的一些因素。如果我们可以采用更多样本，评估更 
准确的方程式或仅使用更多内存，许多算法都会提高质量。复杂性 
的增加使得图形几乎无法用于处理填充的功率。为了从长远来看解 
决业绩问题，乐观的乐观主义者喜欢转向摩尔定律。这个观察结果 
给出了每 1。5年2倍的加速度，或者更有用的是，每5年约 10倍 
----------------------- Page 1143-----------------------
加速[1663]。但是，处理器速度通常不是瓶颈，随着时间的推移可 
能会更少。带宽是，每 10年增加 10倍，而不是5[1332]。来自电 
影行业的算法经常进入实时渲染，因为这些领域共享生成逼真图像 
的相同目标。看看他们的实践，我们看到统计数据，例如2016年 
电影 “丛林之书”的一个框架在某些场景中包含数百万个头发，每 
帧的渲染时间为30到40小时[1960]。虽然GPU专为实时渲染而 
设计，因此具有明显优于CPU的优势，从 1/ （40×60×60）= 
0.00000694FPS到60FPS约为7个数量级。我们承诺了一些预测。 
 “更快，更灵活”是一个简单的方法。就GPU架构而言，一种可能 
性是z缓冲区三角形光栅化流水线将继续统治栖息地。除了最简单 
的游戏外，所有游戏都使用GPU进行渲染。即使明天有一些令人难 
以置信的技术取代了当前的管道，其速度要快一百倍，而且包括下 
载系统补丁，但这个行业仍需要数年时间才能采用这种新技术。一 
个问题是新方法是否可以使用与现有方法完全相同的API。如果没 
有，采用将需要一段时间。复杂的游戏需要花费数千万美元甚至更 
多才能开发并需要数年时间。目标平台是在流程的早期阶段选择的， 
它可以决定所使用的算法和着色器，以及所生成的艺术作品的大小 
和复杂性。除了这些因素之外，还需要制作处理或生产这些元素所 
需的工具，并且用户需要熟练使用它们。当前光栅化器管道背后的 
动力使其具有数年的使用寿命，即使出现了奇迹。24.1。其他一切 
1043变化仍然发生。实际上，简单的 “一个光栅化者统治它们”的 
想法已经开始消退。在本书中，我们已经讨论了计算着色器如何能 
----------------------- Page 1144-----------------------
够承担各种任务，证明光栅化不是GPU可以提供的唯一服务。如果 
新技术引人注目，那么工作流程的重组将会发生，从游戏公司渗透 
到商业引擎和内容创建工具。那么，长期呢？专用的固定功能GPU 
硬件，用于渲染三角形，访问纹理，并且混合所得样品仍然可以提 
高性能。移动设备的需求改变了这个等式，因为功耗成为原始性能 
的一个重要因素。然而，基本管道的 “即发即忘”概念，我们在管 
道中发送一个三角形并完全用它来完成该框架，这不是现代渲染引 
擎中使用的模型。变换，扫描，阴影和混合的基本流水线模型已经 
发展得几乎无法识别。GPU已经成为一个基于流的处理器的大型集 
群，可以根据需要使用。API和GPU共同适应这一现实。口头禅是 
 “灵活性”。研究人员探索方法，然后由开发人员在现有硬件上实 
施，他们确定了他们希望的功能。独立硬件供应商可以利用这些发 
现和他们自己的研究来开发一个良性循环的一般功能。优化任何单 
个算法都是一个愚蠢的错误。创建新的，灵活的方式来访问和处理 
GPU上的数据不是。考虑到这一点，我们将光线/物体交叉视为具 
有多种用途的通用工具。我们知道使用路径追踪的完全无偏的采样 
最终会产生正确的地面实况图像，达到场景描述的极限。这是 “最 
终”这个词。如第 11.7节所述，目前路径追踪作为一种可行的算法 
存在严峻挑战。主要问题是获得不嘈杂的结果所需的大量样本，并 
且在动画时不会闪烁。那说，路径追踪的纯洁性和简洁性使其极具 
吸引力。而不是当前的交互式渲染状态，其中针对特定情况定制了 
多种专用技术，只需一种算法就能完成所有这些。电影工作室肯定 
----------------------- Page 1145-----------------------
已经意识到这一点，因为在过去的十年里，他们完全转向光线和路 
径追踪方法。这样做可以让他们优化一组几何操作来进行光传输。 
实时渲染 - 所有渲染 - 最终都是关于采样和过滤。除了提高射线 
射击的效率之外，路径追踪还可以从更智能的采样和滤波中受益。 
实际上，无论市场营销文献如何，几乎所有离线路径追踪都是有偏 
见的[1276]。关于在哪里发送样本光线的合理假设，大大提高了性 
能。路径跟踪可以受益的另一个领域是智能过滤 - 字面意思。深度 
学习目前是一个白热化的研究和开发领域，由于2012年大幅超过 
用于图像识别的手动调整算法，令人印象深刻的兴趣最初重新兴起 
[349]。使用神经网进行去噪[95,200,247]和抗锯齿[1534]是令人着 
迷的发展。见图24.2。我们已经是104424.未来图24.2。用神经 
网络重建图像。在左侧，通过路径跟踪生成噪声图像。在右侧，图 
像使用 GPU加速的降噪器以交互速率清理。（图片由 NVIDIA 
Corporation[200]提供，使用Amazon LumberyardBistro场景。 
看到使用神经网络渲染相关任务的研究论文数量大幅增加，更不用 
说建模和动画了。1987年可追溯到AT＆T的PixelMachine，长 
时间以来，对于小场景，低分辨率，少量灯光以及仅具有锐利反射， 
折射和阴影的合成，交互式光线追踪一直是可能的。微软为 DirectX 
API增加了光线跟踪功能，称为 DXR，简化了射线射线的过程，并 
可能激发硬件供应商增加对光线交叉的支持。通过去噪或其他滤波 
增强的射线拍摄首先将是另一种用于改善各种元素（例如阴影或反 
射）的渲染质量的技术。它将与许多其他算法竞争，每个渲染引擎 
----------------------- Page 1146-----------------------
根据速度，质量和易用性等因素做出选择。见图24.3。在撰写本文 
时，分层射线拍摄作为基本操作并不是任何主流商业GPU的明确部 
分。我们将 PowerVR的向导GPU[1158]作为一个好兆头，因为移 
动设备公司正在考虑硬件支持，以针对分层场景描述测试光线。直 
接支持拍摄光线的较新GPU将改变效率方程，并可创建良性循环， 
其中各种渲染效果不太定制和专业化。对于几乎所有其他事物而言， 
光线和光线跟踪或计算着色器的光栅化是一种方法，已经在各种 
DXR演示中使用[1,47,745]。通过改进的去噪算法，更快的GPU跟 
踪光线，以及之前的研究重新应用以及新的研究，我们预计很快就 
会看到相当于 10倍的性能提升。我们希望 DXR能够以其他方式为 
开发人员和研究人员带来福音。对于游戏，投射光线的烘焙系统现 
在可以在GPU上运行并使用类似的24.1。其他一切 1045图24.3。 
这些图像以交互速率渲染，每个像素有两个反射光线反射，屏幕位 
置和两个反射的阴影光线，以及两个环境遮挡光线，每个像素总共 
七条光线。去噪滤镜用于阴影和反射。（图片由NVIDIA公司提供。） 
或与交互式渲染器中的着色器相同，因此性能得到改善。可以更容 
易地生成地面实况图像，从而使测试甚至自动调整算法变得更加简 
单。允许更灵活地生成GPU任务的体系结构更改的想法 （例如，着 
色器创建着色器工作）似乎是一个可能具有其他应用程序的强大功 
能。GPU肯定会有其他令人着迷的可能性。另一种理想化的世界观 
是所有物质都被体素化的观点。如第 13.10节所述，这种表示对于 
光传输和模拟具有许多优点。所需的大量数据存储以及场景中动态 
----------------------- Page 1147-----------------------
对象的困难使得完全切换的可能性极小。尽管如此，我们相信体素 
可能会受到更多的关注，因为它们可用于广泛的领域，包括高质量 
的体积效果，3D打印和无约束的物体修改（例如，Minecraft）。 
鉴于由自动驾驶汽车系统，激光雷达和其他传感器产生的大量此类 
数据，当然相关的表示点云将成为未来几年更多研究的一部分。有 
符号距离场（SDF）是另一种有趣的场景描述方法。与体素类似， 
SDF可以实现对场景的无约束修改，并且还可以加速光线跟踪。有 
时，给定应用程序的独特约束允许其开发人员 “打破模具”并使用 
先前被认为具有异国情调或不可行的技术。如图24.4所示，Media 
Molecule'sDreams和ClaybookbySecondOrder等游戏可以让 
我们对非正统算法占据主导地位的可能渲染未来进行有趣的瞥见。 
104624.未来图24.4。Claybook是一款基于物理的益智游戏，拥 
有粘土世界，可以由用户自由雕刻。粘土世界使用带符号的距离场 
进行建模，并使用光线跟踪进行渲染，包括主光线以及光线跟踪阴 
影和AO。在GPU上模拟固体和液体物理。（Claybook.c 2017 
SecondOrder，Ltd。）虚拟和混合现实值得一提。VR运行良好时， 
令人叹为观止。混合现实具有与现实世界融合的合成内容的迷人演 
示。每个人都想要两种轻型眼镜，这两种眼镜在短期内可能属于 “个 
人喷气背包，水下城市”类别。但谁知道呢？鉴于这些努力背后的 
大量研究和开发[1187]，可能会有一些突破，可能是改变世界的突 
破。24.2你这样，当你和你孩子的孩子在等待TheSingularity时， 
你在此期间做了什么？当然是程序：发现新算法，创建应用程序或 
----------------------- Page 1148-----------------------
做任何你喜欢的事情。几十年前，一台机器的图形硬件成本高于豪 
华车;现在几乎所有带有CPU的设备都内置了这些设备，这些设备 
通常都适合您。图形哈cking是廉价和主流的。在本节中，我们将 
介绍我们发现的各种资源，这些资源可用于更多地了解实时渲染领 
域。这本书不存在于真空中;它利用了大量的信息来源。如果您对特 
定算法感兴趣，请查看原始出版物。我们的网站有一个我们引用的 
所有文章的页面，因此您可以在那里查找资源的链接（如果有）。 
大多数研究文章都可以使用 24.2找到。您是作者网站上的 1047 
Google学术搜索，或者，如果其他方法都失败了，请向作者索取 
一份副本 - 几乎每个人都喜欢阅读和欣赏他们的作品。如果没有免 
费找到，ACM数字图书馆等服务可以提供大量文章。如果您是 
SIGGRAPH的会员，你可以自动免费访问他们的许多图形文章和谈 
话。有几种期刊发表技术文章，例如ACM 图形交易（现在包括 
SIGGRAPH程序作为一个问题），计算机图形技术期刊 （可开放访 
问），IEEE可视化和计算机图形学，计算机图形论坛，以及 IEEE 
计算机图形和应用程序，仅举几例。最后，一些专业博客拥有出色 
的信息，Twitter上的图形开发人员和研究人员经常指出精彩的新资 
源。学习和认识他人的最快方法之一是参加会议。另一个人正在做 
你正在或可能会感兴趣的事情的可能性很高。如果钱很紧，联系组 
织者并询问志愿者机会或奖学金。SIGGRAPH和SIGGRAPH亚洲 
年会是新想法的首要场所，但不是唯一的。其他技术会议，如 
Eurographics会议和 Eurographics渲染研讨会（EGSR），交互 
----------------------- Page 1149-----------------------
式3D图形和游戏研讨会 （I3D）以及高性能图形 （HPG）论坛，展 
示并发布了大量与之相关的材料。实时渲染。还有特定于开发人员 
的会议，例如完善的游戏开发者大会（GDC）。当你排队等候或参 
加活动时，向陌生人问好。特别是在SIGGRAPH，请留意您感兴趣 
的地区的鸟类（BOF）聚会。面对面地与人交流和交流思想既有回 
报又充满活力。有一些与交互式渲染相关的电子资源。特别值得注 
意的是，GraphicsCodex [1188]是一种高质量的纯电子参考，具 
有不断更新的优点。网站沉浸式线性代数[1718]，部分由本书的合 
着者创建，包括互动演示，以帮助学习该主题。Shirley[1628]有一 
系列关于光线追踪的优秀短篇 Kindle书籍。我们期待这种更便宜和 
快速访问的资源。印刷书籍仍然有它们的位置。除了一般文本和特 
定领域的卷之外，编辑的文章集包括大量的研究和开发信息，其中 
许多我们在本书中参考。最近的例子是GPUPro和GPUZen书籍。 
游戏编程宝石，GPU宝石（免费在线）和ShaderX系列等较旧的 
书籍仍有相关文章 - 算法不会腐烂。所有这些书籍都允许游戏开发 
者在不必撰写正式会议论文的情况下展示他们的方法。此类收藏还 
允许学者讨论不适合研究论文的有关其工作的技术细节。对于专业 
开发人员来说，通过阅读文章中的一些实现细节来节省一个小时， 
而不仅仅是支付整本书的成本。如果您不能等待交付书籍，使用亚 
马逊上的 “LookInside”功能或在GoogleBooks上搜索文本可能 
会产生摘录以帮助您入门。104824.未来当一切都说完了，需要编 
写代码。随着GitHub，Bitbucket和类似存储库的兴起，有一个丰 
----------------------- Page 1150-----------------------
富的仓库可供借鉴。困难的部分是知道什么不属于斯特金定律。诸 
如虚幻引擎之类的产品已经使其源开放访问，因此是一种令人难以 
置信的资源。ACM现在鼓励发布任何技术文章的代码。您尊重的作 
者有时会提供他们的代码。搜索一下。一个特别值得注意的地方是 
Shadertoy，它经常在像素着色器中使用光线行进来展示各种技术。 
虽然许多程序首先是眼睛糖果，但该网站有许多教育演示，所有代 
码都可见，并且所有程序都可以在您的浏览器中运行。基于浏览器 
的演示的另一个来源是three.js存储库和相关站点。“Three”是围 
绕WebGL的包装器，它鼓励实验，因为只需几行代码即可生成渲 
染。能够在网络上发布演示以供任何人运行和剖析，只需点击一下 
超链接，这对于教育用途和分享想法非常有用。本书的作者之一根 
据three.js[645]为Udacity创建了一个入门图形课程。我们再次向 
您推荐我们的网站realtimerendering.com。在那里你会发现许多 
其他资源，例如推荐和新书的清单（包括一些免费和高质量的书 
[301,1729]），以及有价值的博客，研究网站，课程演示等许多指 
南其他信息来源。快乐狩猎！我们最后的建议是去学习和做。实时 
计算机图形学领域不断发展，不断发明和整合新的思想和特征。你 
可以参与其中。所采用的各种技术看起来令人生畏，但你不需要实 
施一系列流行语 -dujour以获得良好的效果。根据应用程序的约束 
和视觉风格巧妙地结合少量技术，可以产生独特的视觉效果。在 
GitHub上分享您的结果，GitHub也可用于托管博客。参与其中！ 
该领域最好的部分之一是它每隔几年就会重新发明一次。计算机架 
----------------------- Page 1151-----------------------
构改变和改进。几年前没有用的东西现在值得追求。每个新的GPU 
产品都有不同的功能，速度和内存组合。什么是有效的，什么是瓶 
颈变化和发展。即使是那些看似古老而成熟的地区也值得重新审视。 
创造被认为是一个弯曲，破碎和融合其他想法的问题，而不是从无 
到有。此版本发布于 1974年[1724]，由Sutherland，Sproull和 
Schumacker撰写的计算机图形学领域的一篇里程碑论文，即 “十 
种隐藏表面算法的特征化”之后的44年。他们的 55页纸是一个令 
人难以置信的彻底比较。这种算法被描述为 “非常昂贵”，这种蛮 
力技术甚至没有研究者的名字，并且只在附录中提到过，现在被称 
为z缓冲区。公平地说，Sutherland是z缓冲区 EdCatmull的发 
明者的顾问，他的论文讨论这个概念将在几个月后发表[237]。24.2。 
你这个第十一个隐藏表面技术赢了，因为它很容易在硬件中实现， 
因为内存密度上升，成本下降。Sutherland等人完成的 “十大算法” 
调查。完全有效的时间。随着条件的变化，使用的算法也会发生变 
化。看到未来几年会发生什么将是令人兴奋的。当我们回顾当前渲 
染技术的时代时，感觉如何？没有人知道，每个人都会对未来的发 
展方式产生重大影响。没有一个未来，没有必须发生的过程。你创 
造它。你想下一步该做什么？（CD PROJEKT R，The Witcher R 
是 CD PROJEKT Capital Group 的注册商标。巫师游戏 c CD 
PROJEKTSA 由CD PROJEKTSA开发。保留所有权利。巫师的游 
戏是基于AndrzejSapkowski的散文。所有其他版权和商标均为其 
各自所有者的财产。）参考书目[1]Aalto，Tatu， “Remedy的 
----------------------- Page 1152-----------------------
Northlight引擎中的DirectX光线跟踪实验”，游戏开发者大会， 
2018年3月19日。1044[2]Aaltonen，Sebastian， “现代无纹 
理延迟渲染技术”，Beyond3D论坛，2016年2月28 日。引用于 
p。906,907[3]Abbas，Wasim，“实用分析2D签名距离场生成”， 
在ACMSIGGRAPH2016会谈中，文章编号。2016年7月68 日。 
引用于p。677,678 [4]Abrash，Michael，MichaelAbrash的图 
形编程黑皮书，特别版，科里奥利集团公司，1997年。引用于p。 
823[5]Abrash，迈克尔， “延迟 -AR和VR的必要条件， “阀门 
时间博客中的Ramblings，2012年12月29日。引用于p。920,939 
[6]Abrash，迈克尔， “光栅扫描显示：不仅仅是满足眼睛”， “阀 
门时间”中的Ramblings博客，2013年 1月28 日。引用于第9 
页。922,1012[7]Abrash，迈克尔， “击倒VR兔子洞：修复审判 
者”， “阀门时间”中的Ramblings博客，2013年7月26 日。 
被引用于第9页。935,1011 [8]Abrash，迈克尔， “Oculus首席 
科学家预测未来5年的VR技术，”VR网站之路，2016年 11月4 
日。引用于p。931,932[9]Adams，Ansel，TheCamera，Little， 
BrownandCompany，1980。引用于p。291[10]Adams，Ansel， 
The Negative，Little，BrownandCompany，1981。引用于p。 
289,291 [11]Adams，Ansel，The Print，Little，Brown and 
Company，1983。引用于 p。291 [12]Adorjan，Matthias， 
OpenSfM：一个从动作系统的协作结构，视觉计算的文凭论文，维 
也纳科技大学，2016年。引用于p。574,575[13]Aila，Timo和 
----------------------- Page 1153-----------------------
Ville Miettinen， “dPVS：用于大规模动态环境的遮挡剔除系统”， 
IEEE计算机图形和应用，第一卷。24，不。2，pp.86-97，2004 
年3月。引用于p。666,821,839,850,879[14]Aila，Timo和Samuli 
Laine ， “Alias-Free Shadow Maps ” ，在 Eurographics 
Symposium on Rendering ， Eurographics Association ， 
pp.161-166，June2004.引用于p。260[15]Aila，Timo和Samuli 
Laine， “了解GPU上光线遍历的效率”，高性能图形，2009年6 
月。511[16]Aila，Timo，Samuli Laine和Tero Karras， “了解 
GPU 对射线穿越的效率 - 开普勒和费米附录”，技术报告 
NVR-2012-02，NVIDIA，2012年。511,961[17]Airey，John M.， 
John H.Rohlf和 FrederickP.小布鲁克斯， “在复杂虚拟建筑环境 
中以互动更新速率迈向图像现实主义”，ACM SIGGRAPH计算机 
图形学 （交互式3D图形研讨会），第一卷。24，不。2，pp.41-50， 
1990年3月。引用于p。687,83710511052参考书目[18]Airey， 
John M.，通过自动模型空间细分和潜在可见集计算提高建筑物漫 
游系统的更新率，博士论文，技术报告TR90-027，大学计算机科 
学系北卡罗来纳州教堂山分校，1990年7月。引用于p。837[19] 
Akeley，K.，P。Haeberli和 D.Burns，tomesh.c，一个关于SGI 
Developer'sToolboxCD的C程序，1990年。692 [20]Akeley， 
Kurt和 PatHanrahan， “实时图形架构”，课程CS448A笔记， 
斯坦福大学，2001年秋季。引用于p。1040[21]Akenine-M'oller， 
Tomas， “Fast3DTriangle-BoxOverlapTesting”，图形工具杂 
----------------------- Page 1154-----------------------
志，第一卷。6，不。1，pp.29-33,2001。引用于p。974,975[22] 
Akenine-M'oller，Tomas和JacobStr¨om， “面向大众的图形： 
用于移动电话的硬件光栅化架构”，ACM Transactions on 
Graphics，vol。22，不。3，pp.801-808,2003。引用于 p。 
146,1015,1027[23]Akenine-M'oller，Tomas和 UlfAssarsson， 
 “关于阴影体积轮廓中的顶点度”，图形工具杂志，第一卷。8，不。 
4，pp.21-24,2003。引用于p。667 [24]Akenine-M'oller，T。 
和T.Aila， “使用改进的三角形设置的保守和平铺光栅化”，图形 
工具杂志，第一卷。10，不。3，pp.1-8,2005。引用于p。996,1001 
[25]Akenine-Moller，Tomas和 Bj¨ornJohnsson， “每个人的表 
现如何？”计算机图形技术杂志，第一卷。1，不。18，pp.37-41,2012。 
引用于p。790 [26]Akenine-M'oller，Tomas， “关于图形硬件 
的一些注释”，TomasAkenine-M'oller 网页，2012年 11月27 
日。引用于p。999,1000 [27]Akin，Atilla， “推动材料现实主义 
的极限”，MaxwellRender博客，2014年 11月26 日。引用于p。 
362,363 [28]Alexa，Marc， “MeshMorphing的最新进展”， 
计算机图形学论坛，第一卷。21，不。2，pp.173-197,2002。引 
用于p。87,88,102[29]Alexa，M。和T.Boubekeur，“Subdivision 
Shading”，ACMTransactions onGraphics，vol。27，不。5， 
pp.142：1-142：3,2008。引用于p。767[30]Aliaga，DanielG. 
和Anselmo Lastra， “提供有保证的帧速率的自动图像放置”，在 
SIGGRAPH'99中：第26届计算机图形学与交互技术年会论文集， 
----------------------- Page 1155-----------------------
ACM 出版社/ Addison-Wesley PublishingCo.，pp.307-316， 
1999年8月。引用于p。561[31]AMD， “AMD PowerTune技 
术”，AMD 网站，2011年。引用p。789[32]AMD， “AMD图 
形核心下一代 （GCN）架构”，AMD 网站，2012年。引用p。1036 
[33]AMD， “异步着色器：释放GPU的全部潜力”，AMD网站， 
2015年。引用p。1036[34]AMD， “Radeon：剖析Polaris架 
构”，AMD 网站，2016年。引用于p。1038[35]AMD，“Radeon 
的下一代 Vega 架构”，AMD 网站，2017 年。引用 p。 
1035,1036,1037[36]AMD，GPUOpen， “TressFX”，GitHub 
存储库，2017年。引用于p。642,644,647[37]美国摄影测量与遥 
感学会， “LAS规范，版本 1.4-R13”，asprs.org，2013年7月 
15日。引用于p。573[38]Anagnostou，Kostas， “虚幻如何渲 
染框架”，Light博客的相互作用，2017年 10月24 日。引用于p。 
899,905,913[39]Anderson，EricA.， “构建Obduction：Cyan 
的自定义UE4艺术工具”，游戏开发者大会，2016年3月。引用 
于p。366参考书目 1053[40]Andersson，Johan，“在 Frostbite 
中使用程序着色器Splatting渲染地形”，SIGGRAPH高级实时渲 
染 3D 图形和游戏课程， 2007 年 8 月。引用于 p 。 
43,175,218,877,878 [41] Andersson ， Johan 和 Daniel 
Johansson， “Shadows＆Decals：Frodbite的D3D10技术”， 
游戏开发者大会，2009年 3月。引用于 p。245,246,247 [42] 
Andersson，Johan，“Frostbite-Current＆Future中的并行图形”， 
----------------------- Page 1156-----------------------
SIGGRAPHBeyondProgrammableShading课程，2009年8月。 
引用于p。893[43]安德森，约翰，“战地3中的DirectX11渲染”， 
游戏开发者大会， 2011 年 3 月。引用于第 4 页。 
147,888,890,893,896[44]Andersson，Johan， “战地3中的闪 
亮PC图形”，GeForceLAN，2011年10月。引用于p。569,570,604 
[45]Andersson，Johan， “游戏引擎的并行期货”，英特尔动态 
执行环境研讨会，2012 年 5 月。引用于 p。811,812 [46] 
Andersson，Johan，“渲染管道 - 挑战和后续步骤”，SIGGRAPH 
在实时渲染课程中公开问题，2015年8月。引用于p。156,514,1014 
[47]Andersson，Johan和Colin Barr'e-Brisebois， “闪亮的像 
素和超越：SEED的实时光线追踪”，游戏开发者大会，2018年3 
月。1044 [48]Andersson，M.，J。Hasselgren，R。Toth和T. 
Akenine-M'oller，“用于随机渲染的自适应纹理空间着色，“计算 
机图形学论坛，第一卷。33，不。2，pp.341-350,2014。引用于p。 
910,911 [49]Andersson，Magnus，随机光栅化和深度缓冲的算 
法改进，博士论文，隆德大学，2015年 10月。引用于p。1015[50] 
Andersson，M.，J。Hasselgren和T.Akenine-M'oller，“Masked 
DepthCullingforGraphicsHardware”，ACMTransactionson 
Graphics，vol。34，不。6，pp.188：1-188：9,2015。引用于p。 
849，1015,1016[51]Andreev，Dmitry， “视频游戏的实时帧率 
上转换”，ACMSIGGRAPH2010会谈，ACM，文章编号。2010 
年7月16日。引用于p。537,542[52]Andreev，德米特里， “从 
----------------------- Page 1157-----------------------
另一个角度反抗锯齿”，游戏开发者大会，2011年3月。引用于p。 
147[53]Anguelov，Bobby， “DirectX10教程 10：影子映射第 
2部分”，2011年5月25 日采取倡议博客。引用于p。249 [54] 
Annen，Thomas，Jan Kautz，Fr'edo Durand和 Hans-Peter 
Seidel， “中等照明的球形谐波梯度”，第 15届 Eurographics协 
会会议论文集，EurographicsAssociation，pp.331-336，2004 
年6月。引用于p。488 [55]Annen，Thomas，Tom Mertens， 
PhilippeBekaert，Hans-PeterSeidel和Jan Kautz， “卷积阴影 
地图”，第18届 Eurographics协会会议论文集，Eurographics 
Association，pp.51-60，June2007年。引用p。255[56]Annen， 
Thomas，Tom Mertens，Hans-PeterSeidel，Eddy Flerackers 
和Jan Kautz， “指数阴影地图”，图形界面2008，加拿大人机通 
信学会，第 155-161页，2008年5月。引用p。256[57]Annen， 
Thomas ，Zhao Dong，Tom Mertens，Philippe Bekaert， 
Hans-PeterSeidel，和Jan Kautz， “动态场景中的实时，全频率 
阴影”，ACM Transactions on Graphics，vol。27，不。3，文 
章编号。2008年8月34 日。引用于p。257[58]Ansari，Marwan 
Y.， “使用 DirectX9像素着色器的图像效果”，Wolfgang Engel 
编辑，ShaderX2：使用DirectX9的着色器编程技巧和诀窍，第 
481-518页，Wordware，2004。引用页。521,6651054参考书 
目[59]答案，詹姆斯， “快速灵活：技术艺术与渲染未知”，游戏 
开 发 者 大 会 ， 2016 年 3 月 。 引 用 于 第 4 页 。 
----------------------- Page 1158-----------------------
710,787,805,931,934,936,938 [60] Antoine，Fran.cois，Ryan 
Brucks，BrianKaris和GavinMoran， “The Boy，the Kiteand 
the 100 Square Mile Real-Time Digital Backlot” ， ACM 
SIGGRAPH2015会谈，ACM，文章编号。2015年8月20 日。引 
用于 p。493 [61]安东尼奥，富兰克林， “更快的线段交叉点”， 
David Kirk编辑，Graphics Gems III，pp.199-202，Academic 
Press，1992。引用于 p。988,989 [62]安东诺夫，迈克尔， 
 “AsynchronousTimewarp Examined”，Oculus开发者博客， 
2015年3月3 日。引用于p。936,937[63]Apodaca，AnthonyA. 
和 LarryGritz，Advanced RenderMan：为动画创作CGI，Morgan 
Kaufmann，1999年。引用p。37,909[64]Apodaca，Anthony 
A.，“PhotoRealisticRenderMan如何工作”，高级 RenderMan： 
为动画创作CGI，Morgan Kaufmann，第6章，1999。同样在 
SIGGRAPHAdvanced RenderMan2：RIINFINITY及其他课程， 
2000年7月。引用于p。51[65]Apple， “ARKit”，Apple开发 
者网站。引用 p。918 [66]Apple， “适用于 iOS的OpenGL ES 
编程指南”，Apple开发人员网站。引用p。177,702,713[67]de 
Ara'ujo，BR，DSLopes，P。Jepp，JAJorge和 B.Wyvill， “关 
于隐式表面多边形化的调查，”ACM计算调查，第一卷。47，不。 
4，pp.60：1-60：39,2015。引用于p。586,683,751,753,781,944 
[68]Arge，L.，GS Brodal和 R.Fagerberg， “Cache-Oblivious 
DataStructures”，数据结构手册，CRC出版社，第34章，2005 
----------------------- Page 1159-----------------------
年。在第 827 [69]ARM Limited， “ARMR MaliTMApplication 
DeveloperBestPractices，Version 1.0，”ARM文档，2017年 
2月27日。引用于p。48,798,1029 [70]Arvo，James，Box-Sphere“ 
IntersectionTesting的简单方法”，Andrew S.Glassner编辑， 
GraphicsGems，Academic Press，pp.335-339,1990。引用于p 。 
977,984 [71] Arvo ， James ， “Ray Tracing with 
Meta-Hierarchies”，SIGGRAPH高级主题，在 RayTracing课程， 
1990年8月。引用于p。953[72]Arvo，James，ed。，Graphics 
GemsII，Academic Press，1991。引用于p。102,991[73]Arvo， 
詹姆斯， “部分封闭的多面体来源的辐照雅可比”，在SIGGRAPH 
'94：第21届计算机图形和交互技术年会论文集，ACM，第343-350 
页，1994年7月。引用于第4页。379 [74]Arvo，James， “辐 
照张量在模拟非朗伯现象中的应用”，SIGGRAPH'95：第22届计 
算机图形学与交互技术年会论文集，ACM，pp.335-342，Aug 。 
引自p。389,390[75]Asanovic，Krste，etal。，“The Landscape 
of Parallel Computing Research：A View from Berkeley”， 
Technical Report No. UCB / EECS-2006-183 ， EECS 
Department，UniversityofCalifornia，Berkeley，2006 。引用 
p。806,815 [76]Ashdown，Ian，Radiosity：A Programmer's 
Perspective，JohnWiley＆Sons，Inc.，1994。引用于p。271,442 
[77]Ashikhmin，Michael，和 PeterShirley，“各向异性的 Phong 
光反射模型”，技术报告 UUCS-00-014，犹他大学计算机科学系， 
----------------------- Page 1160-----------------------
2000年6月。引用于p。352[78]Ashikhmin，Michael，Simon 
Premoze和 PeterShirley， “基于 Microfacet的BRDF发生器”， 
SIGGRAPH '00：第27届计算机图形学与交互技术年会论文集， 
ACMPress / Addison-Wesley Publishing Co. ，第67-74页， 
2000年7月。引用第2页。参考文献328,335,357参考书目 1055 
[79]Ashikhmin，迈克尔，基于“ Microfacet的BRDF”，SIGGRAPH 
表面反射建模和测量课程的最新技术，2001年8月。引用于p。329 
[80]Ashikhmin，Michael，AbhijeetGhosh， “环境地图的简单 
模糊思考”，图形工具杂志，第一卷。7，不。4，pp.3-8,2002。 
引用于p。417,418 [81]Ashikhmin，Michael，和西蒙 Premoze， 
 “基于分布的 BRDF，”技术报告，2007年。引用 p。357 [82] 
Asirvatham，Arul和 HuguesHoppe， “使用基于GPU的几何剪 
贴图进行地形渲染”，载于Matt Pharr，编辑，GPU Gems 2， 
Addison-Wesley，第27-45页，2005年。872,873[83]Assarsson， 
Ulf和TomasM'oller，“用于边界框的优化视图Frustum剔除算法”， 
图形工具杂志，第一卷。5，不。1，pp.9-22,2000。引用于p。 
836,982,986 [84]Atanasov，Asen和Vladimir Koylazov， “用 
于渲染类镜片的实用随机算法”，在ACM SIGGRAPH2016会谈 
中，文章编号。67，2016年7月。引用于p。372[85]奥斯汀，迈 
克尔， “体素冲浪”，游戏开发者大会，2016年3月。引用于p。 
586[86]B.rentzen，J。Andreas，SteenLundNielsen，Mikkel 
Gj.l和 BentD.Larsen， “SCCG'08第24届春季计算机图形学会 
----------------------- Page 1161-----------------------
议论文集，ACM，第 171-177页，2008年4月，”隐藏线删除的 
两种方法。 “673,675 [87]Baert，J.，A。Lagae和 Ph.Dutr'e， 
 “稀疏体素八分之一的核外构造”，计算机图形学论坛，第一卷。 
33，不。6，pp.220-227,2014。引用于p。579,582[88]Bagnell， 
Dan， “Cesium-VertexCompression中的图形技术”，Cesium 
博客，2015年 5月 18日。引用于p。715 [89]Bahar，E。和S. 
Chakrabarti，“全波理论应用于3D对象的计算机辅助图形”，IEEE 
计算机图形和应用，第一卷。7，不。7，pp.46-60，1987年7月。 
引用于p。361 [90]Bahnassi，Homam和Wessam Bahnassi， 
 “容积云和巨型粒子”，载于Wolfgang Engel，编辑，ShaderX5， 
CharlesRiverMedia，第295-302页，2006年。引用p。521,556 
[91]Baker，Dan，“Advanced LightingTechniques，”Meltdown 
2005，July 2005.引用于 p。369 [92] Baker，Dan和 Yannis 
Minadakis， “Firaxis'文明V：可扩展游戏性能的案例研究”，游 
戏开发者大会，2010年3月。引用于p。812 [93]Baker，Dan， 
 “ Spectacular Specular-LEAN and CLEAN Specular 
Highlights”，游戏开发者大会，2011年3月。引用于p。370[94] 
Baker，Dan，“对象空间照明”，游戏开发者大会，2016年3月。 
引用于p。911[95]Bako，Steve，ThijsVogels，BrianMcWilliams， 
Mark Meyer，Jan Nov'ak，Alex Harvill，PradeepSen，Tony 
DeRose和FabriceRousselle，Kernel-Predicting“ Convolutional 
Networks for Deoising Monte Carlo Renderings” ，ACM 
----------------------- Page 1162-----------------------
Transactions在图形，卷。36，不。4，文章编号。97,2017。引用 
于 p。511,1043 [96]鲍德温，道格，和 MichaelWeber， “通过 
坐标转换的快速雷三角交叉点”，计算机图形技术杂志，第一卷。5， 
不。3，pp.39-49,2016。引用于p。962[97]Balestra，C。和 P.-K.恩 
斯塔德， “未知的技术：德雷克的财富”，游戏开发者大会，2008 
年3月。引用于p。893 [98]班克斯，大卫， “多样化的照明”， 
SIGGRAPH '94：第21届计算机图形学与互动技术年会论文集， 
ACM，第327-334页，1994年7月。引用于第4页。359 1056 
参考书目[99]Barb，C。， “纹理流媒体在Titanfall 2”，游戏开 
发者大会，2月 -3月。2017年。引用p。869[100]Barber，CB， 
DPDobkin和 H.Huhdanpaa， “凸壳的Quickhull算法”，技术 
报告 GCG53，几何中心，1993年 7月。引用于 p。950 [101] 
Barequet，G。和G. Elber， “三维矢量的最佳边界锥”， “信息 
处理快报”，第一卷。93，不。2，pp.83-89,2005。引用于p。834 
[102]Barkans，AnthonyC.，“ColorRecovery：True-Color8-Bit 
Interactive Graphics ， ” IEEE Computer Graphics and 
Applications，vol。17，不。1，pp.67-77，1月/2月。1997年。 
引用p。1010[103]Barkans，AnthonyC.， “使用护身符建筑的 
高质量渲染”，参见ACM SIGGRAPH/ EUROGRAPHICS图形硬 
件研讨会，ACM，第79-88页，1997年8月。引用于p。189[104] 
Barla，Pascal，JoelelleThollot和 Lee Markosian， “X-Toon： 
An ExtendedToonShader”，第四届非真实动画和渲染国际研讨 
----------------------- Page 1163-----------------------
会论文集，ACM，第127-132页，2006年。引用 p。654 [105] 
Barr'e-Brisebois，Colin和 MarcBouchard， “快速，廉价和令 
人信服的次表面散射外观的近似半透明”，游戏开发者大会，2月 
至3月。2011年。引用p。639,640[106]Barr'e-Brisebois，Colin 
和StephenHill， “混合细节”，自我影子博客，2012年7月10 
日。引用于p。366,371,890 [107] Barr'e-Brisebois，Colin， 
 “Hexagonal Bokeh Blur Revisited” ，ZigguratVertigo 的 
Hideout博客，2017年4月17日。引用于p。531[108]巴雷特， 
肖恩，“混合不会超过 Lerp，”游戏开发者，第一卷。11，不。10， 
pp.39-41，2004年 11月。引用于p。160[109]Barrett，Sean， 
 “稀疏虚拟纹理”，游戏开发者大会，2008年3月。引用于p。867 
[110]Barringer，R.，M。Andersson和T.Akenine-M'oller，“Ray 
Accelerator：在异构架构上进行高效灵活的光线跟踪”，计算机图 
形论坛，第一卷。36，不。8，pp.166-177，2017年。引用 p。 
1006 [111] Bartels，Richard H.，John C. Beatty和 Brian A. 
Barsky， “用于计算机图形学和几何建模的样条简介”，Morgan 
Kaufmann，1987年。引用于p。732,734,749,754,756,781[112] 
Barzel，Ronen，ed。，GraphicsTools-thejgt Editors'Choice， 
AK  Peters ， Ltd. ， 2005 。 引 用 于 p 。 
1058,1064,1065,1084,1091,1111,1115,1133,1138,1143 [113] 
Batov，Vladimir， “快速简单的记忆分配器”，Dobbs博士的门 
户，1998年 1月1日。引用于p。793 [114]Baum，DanielR.， 
----------------------- Page 1164-----------------------
StephenMann，KevinP.Smith和James M.Winget， “使光能 
传递可用：自动预处理和网格化技术，用于生成精确的光能传递解 
决方案”，计算机图形学（SIGGRAPH'91会议录），第一卷 25， 
不。4，pp.51-60，1991年7月。引用于p。689 [115]Bavoil， 
Louis，StevenP.Callahan，Aaron Lefohn，Jo.ao LDComba和 
Cl'audioT.Silva，“使用k-Buffer对GPU进行多片段效应”，2007 
年 “交互式3D图形和游戏研讨会论文集”，ACM，第97页 -2007 
年4月 -5月 -10月。引用于p。156,624,626[116]Bavoil，Louis， 
StevenP.Callahan和Cl'audioT.Silva， “使用反投影和深度剥离 
的鲁棒软阴影映射”，图形工具杂志，第一卷。13，不。1， 
pp.16-30,2008。引用于p。238,252参考书目 1057[117]Bavoil， 
Louis，“高级软阴影映射技术”，游戏开发者大会，2008年2月。 
引用于p。256[118]Bavoil，Louis和 KevinMyers， “具有双深 
度剥离的顺序独立透明度”，NVIDIA白皮书，2008年2月。引用 
于p。155,157[119]Bavoil，Louis和 MiguelSainz，以及Rouslan 
Dimitrov， “基于图像空间地平线的 Aambient 遮挡”，ACM 
SIGGRAPH2008会谈，ACM，文章编号。2008年8月22 日。引 
用于p。460 [120]Bavoil，Louis和JonJansen， “粒子阴影和缓 
存高效后处理”，游戏开发者大会，2013年3月。引用于p。570 
[121]Bavoil，Louis和 IainCantlay，“SetStablePowerState.exe： 
在Windows 10上禁用GPU Boost，以便在NVIDIAGPU上进行 
更确定的时间戳查询”，NVIDIAGameWorks博客，2016年9月 
----------------------- Page 1165-----------------------
14日。789 [122]Beacco，A.，N。Pelechano和C.And'ujar， 
 “实时人群渲染调查”，计算机图形学论坛，第一卷。35，不。8， 
pp.32-50,2016。引用于 p。563,566,567,587,798 [123] Bec， 
Xavier， “更快的折射公式和透射颜色过滤”，RayTracing News， 
vol。10，不。1997年 1月1日。引用于p。627[124]Beckmann， 
Petr，和Andr'eSpizzichino，粗糙表面的电磁波散射“     ”，Pergamon 
出版社，1963年。331,338[125]Beeler，Dean和AnujGosalia， 
 “OculusRift的异步时间扭曲”，Oculus开发者博客，2016年3 
月25 日。引用于p。935,937[126]Beeler，Dean，EdHutchins 
和 PaulPedriana， “AsynchronousSpacewarp”，Oculus开发 
者博客，2016年 11月10日。引用于p。937[127]Beers，Andrew 
C.，ManeeshAgrawala和 NavinChaddha，“从压缩纹理渲染”， 
SIGGRAPH '96：第23届计算机图形学和交互技术年会论文集， 
ACM，第373-378页， 1996年 8 月。引用于 p。192 [128] 
Behrendt，S.，C。Colditz，O。Franzke，J。Kopf和O.Deussen， 
 “使用 BillboardClouds进行风景的逼真实时渲染”，计算机图形 
论坛，第一卷。24，不。3，pp.507-516,2005。引用p。563[129] 
Belcour，Laurent和 PascalBarla， “用于改变彩虹模型的微小理 
论的实用扩展”，ACM图形交易（SIGGRAPH2017），第一卷。 
36，不。4，pp.65：1-65：14，2017年7月。引用于p。363[130] 
B'enard，Pierre，Adrien Bousseau和JéoelleThollot， “关于程 
式化动画的时间连贯性的最新报告”，计算机图形学论坛，第一卷。 
----------------------- Page 1166-----------------------
30，不。8，pp.2367-2386,2011。引用于p。669,678[131]B'enard， 
Pierre，Lu Jingwan ，Forrester Cole，Adam Finkelstein 和 
JéoelleTollot， “活动笔画：动画 3D模型的连贯线条程式化”， 
在非真实照片国际研讨会论文集中动画与渲染，Eurographics 
Association，pp.37-46,2012。引用于p。669 [132] B'enard， 
Pierre，Aaron Hertzmann和 MichaelKass， “使用精确拓扑计 
算光滑表面轮廓”，ACMTransactions onGraphics，vol。33， 
不。2，pp.19：1-19：21,2014。引用于p。656,667[133]Benson， 
David和Joel Davis，“OctreeTextures”，ACMTransactionson 
Graphics （SIGGRAPH2002），vol。21，不。3，pp.785-790， 
2002年7月。引用于p。190[134]Bentley，Adrian，“inFAMOUS 
SecondSon EnginePostmortem”，游戏开发者大会，2014年 
3月。引用于p。54,490,871,884,9041058参考书目[135]deBerg， 
M.，M。van Kreveld，M。Overmars，和O. Schwarzkopf， 
ComputationalGeometry-AlgorithmsandApplications，Third 
Edition，Springer-Verlag，2008。引用p。685,699,967[136]van 
denBergen，G。， “使用AABB树的复杂可变形模型的高效碰撞 
检测”，图形工具杂志，第一卷。2，没有。4，pp.1-13,1997。也 
在[112]中收集。引用p。821 [137]Berger，Matthew，Andrea 
Tagliasacchi ， Lee M. Seversky ， Pierre Alliez ， Ga ¨ 
elGuennebaud，JoshuaA. Levine，Andrei Sharf和ClaudioT. 
Silva，“点云表面重建概述”，计算机图形论坛，第一卷。36，不。 
----------------------- Page 1167-----------------------
1，pp.301-329,2017。引用于p。573,683[138]Beyer，Johanna， 
Markus Hadwiger和 HanspeterPfister， “基于GPU的大规模 
卷可视化技术的先进技术”，计算机图形论坛，第一卷。34，不。 
8，pp.13-37,2015。引用于p。586[139]Bezrati，Abdul， “实 
时照明通过光链接列表”，SIGGRAPH在游戏中实时渲染的进展， 
2014年8月。引用于p。893,903[140]Bezrati，Abdul，Real-Time“ 
Lightingvia Light Linked List”，Wolfgang Engel编辑，GPU 
Pro6，CRC出版社，第 183-193页，2015年。引用于p。893,903 
[141]Bier，EricA.和 KennethR.Sloan，Jr。，“Two-PartTexture 
Mapping”，IEEEComputerGraphicsandApplications，vol。 
6，不。9，pp.40-53，1986年9月。引用于p。170[142]Biermann， 
Henning，Adi Levin和 DenisZorin， “具有正常控制的分段平滑 
细分曲面”，SIGGRAPH'00：第27届计算机图形学和交互技术年 
会论文集，ACM出版社/Addison-Wesley出版社公司，第113-120 
页，2000年7月。引用于p。764 [143]Billeter，Markus，Erik 
Sintorn和UlfAssarsson， “使用光传播体积进行实时多重散射”， 
参见ACMSIGGRAPH交互式3D图形和游戏研讨会论文集，ACM， 
第 119-126页，2012 。引用p。611 [144]Billeter，Markus， 
Ola Olsson和 UlfAssarsson， “Tiled ForwardShading”，沃 
尔夫冈·恩格尔编辑，GPUPro4，CRC出版社，第99-114页，2013 
年。引用于第6页。895,896，914[145]Billeter，Markus， “移 
动硬件上的多光渲染”，SIGGRAPH实时多光管理和阴影与集群着 
----------------------- Page 1168-----------------------
色课程，2015年8月。引用于p。893,900,903,914[146]Bilodeau， 
Bill， “顶点着色器技巧：利用顶点着色器提高性能的新方法”，游 
戏开发者大会，2014年3月。引用于p。51,87,514,568,571,798 
[147]Binstock，Atman， “使用延迟锁存优化VR图形”，Oculus 
开发者博客，2015年3月2 日。引用于p。938[148]Bishop，L.， 
D。Eberly，T。Whitted，M。Finch和 M.Shantz， “Designing 
a PC Game Engine ， ” IEEE Computer Graphics and 
Applications，vol。18，不。1，pp.46-53，1月/2月。1998年。 
引用p。836[149]Bitterli，Benedikt，BenediktBitterliRendering 
Resources，https：//benedikt-bitterli.me/ resources，CCBY3.0 
许可，https：//creativecommons.org/licenses/by/3.0。引用p。 
441,445,447,449,450 [150]Bittner，Jir'和Jan Prikryl， “使用线 
空间划分的精确区域可见性”，技术报告TR-186-2-01-06，计算 
机图形学和算法研究所，维也纳科技大学，2001年3月。引用于p。 
843 [151]Bittner，Jir'。，PeterWonka和 MichaelWimmer， 
 “使用线空间细分的城市场景的可见性预处理”，载于Pacific 
Graphics 2001，IEEE Computer Society，pp.276-284，2001 
年 10月。引用页。843参考书目 1059[152]Bittner，Jir'。，Oliver 
Mattausch，AriSilvennoinen和 MichaelWimmer， “影子施法 
者剔除高效阴影贴图”，交互式3D图形和游戏研讨会，ACM，第 
81-88页，2011 。引用p。247[153]Bj.rge，Marius，SamMartin， 
Sandeep Kakarlapudi，和Jan-Harald Fredriksen， “高效渲染 
----------------------- Page 1169-----------------------
瓷砖本地存储”，ACMSIGGRAPH2014会谈，ACM，文章编号。 
2014年7月51日。引用于p。156[154]Bj.rge，Marius， “移 
动移动图形”，SIGGRAPH高级实时着色课程，2016年7月。引 
用于p。247,265[155]Bjorke，Kevin， “基于图像的照明”，在 
Randima Fernando 编辑，GPU Gems ，Addison-Wesley ， 
pp.308-321,2004。引用于p。500[156]Bjorke，Kevin， “高质 
量过滤 ” ， Randima Fernando ，编辑，GPU Gems ， 
Addison-Wesley，第391-424页，2004年。515,521[157]Blasi， 
Philippe，BertrandLeSa​ ​ ec和ChristopheSchlick， “离散 
体积密度对象的渲染算法”，计算机图形论坛，第一卷。12，不。 
3，pp.201-210,1993。引用于p。598[158]Blinn，JF和MENewell， 
 “计算机生成图像中的纹理和反射， “ACM的通讯，第一卷。19， 
没有。10，pp.542-547，1976年 10月。引用于p。405,406 [159] 
Blinn，James F.， “计算机合成图像的光反射模型”，ACM计算 
机图形学（SIGGRAPH'77Proceedings），第一卷。11，不。2， 
pp.192-198，1977年7月。引用于p。331,340,416[160]Blinn， 
James， “皱纹表面的模拟”，计算机图形学（SIGGRAPH '78 
Proceedings），第一卷。12，不。3，pp.286-292，1978年8 
月。引用于p。209,765 [161]Blinn，James F.， “代数表面绘图 
的概括”，ACM Transactions on Graphics，vol。1，不。3， 
pp.235-256,1982。引用于p。751 [162] Blinn，Jim， “我和我 
的（假）影子，”IEEE计算机图形和应用，第一卷。8，不。1，pp.82-86， 
----------------------- Page 1170-----------------------
1988年 1月。也收集在[165]。引用p。225,227[163]Blinn，Jim， 
 “双曲线插值， “IEEE计算机图形和应用，第一卷。12，不。4， 
pp.89-94，1992年7月。也在[165]中收集。引用p。999 [164] 
Blinn，Jim，“图像合成理论”，IEEE计算机图形和应用，第一卷。 
14，没有。5，pp.83-87，1994年9月。也在[166]中收集。引用 
p。160[165]Blinn，Jim，Jim Blinn的角落：图形管道之旅，Morgan 
Kaufmann，1996年。引用p。27,832,1059 [166]Blinn，Jim， 
Jim Blinn'sCorner：DirtyPixels，MorganKaufmann，1998。 
引用于p。165,1059[167]Blinn，Jim， “暴风雪中的幽灵”，IEEE 
计算机图形和应用，第一卷。18，不。1，pp.79-84，1月/ 2月。 
同样收集于[168]，第9章。165 [168] Blinn，Jim，Jim Blinn's 
Corner：Notation，Notation，Notation，MorganKaufmann， 
2002。引用于p。165,1059[169]Blinn，Jim， “什么是像素？” 
IEEE计算机图形和应用，第一卷。25，不。5，pp.82-87，9月/ 10 
月。2005年。引用p。165,280[170]Bloomenthal，Jules， “边 
缘推断应用于抗锯齿”，计算机图形学（SIGGRAPH '83 
Proceedings），第一卷。17，不。3，pp.157-162，1983年7 
月。引用于 p。146 [171] Bloomenthal，Jules， “An Implicit 
SurfacePolygonizer”，PaulS.Heckbert编辑，GraphicsGems 
IV，Academic Press，pp.324-349,1994。引用于p。753 [172] 
Blow，Jonathan， “Mipmapping，Part1，”GameDeveloper， 
vol。8，不。12，pp.13-17，2001年 12月。引用于p。1841060 
----------------------- Page 1171-----------------------
参考书目[173]Blow，Jonathan，“Mipmapping，Part2，”Game 
Developer，vol。9，不。1，pp.16-19，2002年 1月。引用于p。 
184[174]Blow，Jonathan， “Happycake发展笔记：阴影”， 
HappycakeDevelopment Notes网站，2004年8月25 日。引 
用p。242[175]Blythe，David， “The Direct3D10System”， 
ACMTransactionsonGraphics，vol。25，不。3，pp.724-734， 
2006年7月。引用于p。29,39,42,47,48,50,249[176]Bookout， 
David， “可编程混合与像素着色器排序”，英特尔开发者专区博 
客，2015年 10月 13日。引用于p。52 [177]出生，马克斯和埃 
米尔沃尔夫，光学原理：电磁传播理论，光干涉和衍射，第七版， 
剑桥大学出版社，1999年。引用于p。373[178]Borshukov，乔 
治和JP刘易斯， “重新加载矩阵的现实人脸渲染”，2003年7月 
ACM SIGGRAPH 2003草图和应用，ACM，引自p。635 [179] 
Borshukov，George和JP Lewis，“FastSubsurfaceScattering”， 
SIGGRAPH数字面部克隆课程，2005年8月。引用于p。635[180] 
Botsch，Mario，Alexander Hornung，MatthiasZwicker和 Leif 
Kobbelt， “今日 GPU 上的高质量表面喷涂”，参见第二届 
Eurographics/ IEEEVGTC基于点图形的研讨会，Eurographics 
Association，第17-24页，2005年6月。引用于 p。574 [181] 
Boubekeur，Tamy，PatrickReuter和ChristopheSchlick，Scalar“ 
Tagged PN Triangles ” ， 在 Eurographics 2005 Short 
Presentations，EurographicsAssociation，pp.17-20，2005年 
----------------------- Page 1172-----------------------
9月。引用于p。747[182]Boubekeur，T。和 MarcAlexa，“Phong 
Tessellation”，ACMTransactions onGraphics，vol。27，不。 
5，pp.141：1-141：5,2008。引用于p。748[183]​ ​  Boulton， 
Mike， “Halo4中的静态照明技巧”，游戏开发者大会，2013年 
3月。引用于p。486 [184]Bouth，Antoine，FabriceNeyret， 
NelsonMax，EricBruneton和CyrilCrassin， “云中的交互式多 
重各向异性散射，“在2008年交互式3D图形和游戏研讨会论文集， 
ACM，第 173-182页，2008年。引用于第4页。618,619,620[185] 
Bowles，H.，K。Mitchell，B。Sumner，J。Moore，andM.Gross， 
 “IterativeImageWarping，”ComputerGraphicsForum，vol。 
31，不。2，pp.237-246,2012。引用于p。523[186]Bowles，H。， 
 “鞋带上的海洋：形状表示，网格化和阴影”，SIGGRAPH在2013 
年7月的游戏过程中实时渲染的进展。引用于p。878[187]Bowles， 
Huw和 BeibeiWang， “闪闪发光但不太闪耀！一个稳定而强大的 
程序闪光效果，“SIGGRAPH在游戏中实时渲染的进展，2015年8 
月。引用于p。372[188]Box，Harry，SetLightingTechnician's 
Handbook：FilmLightingEquipment，Practiceandelectrical 
Distribution，Fourth Edition，Focal Press，2010。435 [189] 
博伊德， Stephen ，和 Lieven Vandenberghe ， Convex 
Optimization，剑桥大学出版社，2004年。可自由下载。引用p。 
946[190]Brainerd，W.，T。Foley，M。Kraemer，H。Moreton 
和 M.Nie.ner，“使用自适应四叉树的细分曲面的高效GPU渲染”， 
----------------------- Page 1173-----------------------
ACMTransactionsonGraphics，vol。35，不。4，pp.113：1-113： 
12,2016。引用于p。779,780[191]Bratt，I。， “ARM MaliT880 
移动GPU”，HotChips网站，2015年。引用于p。1027参考书 
目1061[192]Brawley，Zoe和 NatalyaTatarchuk， “视差遮挡 
映射：使用反向高度图跟踪的自阴影，透视 - 正确凹凸映射”， 
Wolfgang Engel编辑，ShaderX3，Charles RiverMedia，pp。 
2004年 11月，135-154。引用于p。217 [193]Bredow，Rob， 
 “Stuart Little的毛皮”，SIGGRAPHAdvanced RenderMan2： 
到 RI INFINITY及其后，2000年 7月。引用 p。382,633 [194] 
Brennan，Chris，“通过调整物体距离精确环境映射反射和折射”， 
Wolfgang Engel编辑，Direct3DShaderX：Vertex＆PixelShader 
技巧和技巧，Wordware，第290-294页， 2002年5月。引用于 
p。500[195]Brennan，Chris，“漫反射立方体映射”，Wolfgang 
Engel编辑，Direct3DShaderX：Vertex＆PixelShader技巧和技 
巧，Wordware，第287-289页，2002年5月。引用于p。427 [196] 
Breslav，Simon，KarolSzerszen，LeeMarkosian，PascalBarla 
和Jo¨elleThollot， “用于着色3D场景的动态2D模式”，ACM 
TransactionsonGraphics，vol。27，不。3，pp.20：1-20：5,2007。 
引用于 p。670 [197] Bridson，Robert，Fluid Simulation for 
ComputerGraphics，SecondEdition，CRCPress，2015。引用 
于 p。571,649 [198] Brinck，Waylon 和 Andrew Maximov， 
 “Uncharted4的技术艺术”，SIGGRAPH制作会议，2016年7 
----------------------- Page 1174-----------------------
月。引用于p。290[199]Brinkmann，Ron，数字合成的艺术与科 
学，MorganKaufmann，1999年。引用于p。149,151,159,160 
[200] Brisebois，Vincent和Ankit Patel， “在 OptiX 5中分析 
AI性能提升”，NVIDIA新闻中心，2017年7月31 日。引用于p。 
511,1043,1044 [201]Brown，Alistair， “StarCitizen中的视觉 
效果”，游戏开发者大会，2015年3月。引用于p。366[202]Brown， 
GaryS.，“非高斯随机表面阴影”，IEEE天线和传播学报，第一卷。 
28，不。6，pp.788-790,1980。引用于p。334[203]Bruneton， 
Eric和 FabriceNeyret， “预先计算的大气散射”，计算机图形论 
坛，第一卷。27，不。4，pp.1079-1086,2008。引用于p。614,615,616 
[204]Bruneton，Eric，FabriceNeyret和 NicolasHolzschuch， 
 “使用从几何到 BRDF的无缝过渡的实时逼真海洋照明”，计算机 
图形论坛，第一卷。29，不。2，pp.487-496,2010。引用于p。 
372[205]Bruneton，Eric和 FabriceNeyret， “用于高效和精确 
表面着色的非线性预过滤方法综述”，IEEE可视化与计算机图形学， 
第一卷。18，不。2，pp.242-260,2012。引用于 p。372 [206] 
Buades，Jose Mar'.a，Jes'usGumbau和 MiguelChover， “可 
分离的软阴影映射”，视觉计算机，第一卷。32，不。2，pp.167-178， 
2016年2月。引用于p。252[207]Buchanan，JW和 MCSousa， 
 “边缘缓冲：简单轮廓渲染的数据结构”，第1届非真实动画和渲 
染国际研讨会论文集，ACM，第39-42页，6月2000。引用p。 
666 [208]Bukowski，Mike，PadraicHennessy，BrianOsman 
----------------------- Page 1175-----------------------
和 MorganMcGuire， “可扩展的高质量运动模糊和环境遮挡”， 
SIGGRAPH在3D图形和游戏的实时渲染方面取得进展，2012年8 
月。引用于 p 。540,542,543 [209] Bukowski，Mike，Padraic 
Hennessy，Brian Osman和 Morgan McGuire， “Skylanders 
SWAPForceDepth-of-FieldShader”，作者：Wolfgang Engel， 
编辑，GPUPro4，CRC出版社，第 175页 -184,2013。引用于p。 
529,530,532,533[210]Bunnell，Michael， “DynamicAmbient 
OcclusionandIndirectLighting，”，MattPharr，ed。，GPU 
Gems2，Addison-Wesley，pp.223-233,2005。引自p。454,497 
1062参考书目[211]vanderBurg，John， “建立一个先进的粒子 
系统”，Gamasutra，2000年6月。引用于p。571[212]伯利， 
布伦特， “阴影地图偏向锥和改进的软阴影：迪士尼奖金部分， 
 “SIGGRAPH RenderManfor Everyone课程，2006年8月。引 
用于第4页。249,250 [213]Burley，Brent和 DylanLacewell， 
 “Ptex：生产渲染的每面纹理映射”，第 19届 Eurographics会议 
论文集，EurographicsAssociation，pp.1155-1164,2008。引用 
页。191 [214] Burley，Brent， “迪士尼基于物理的阴影”， 
SIGGRAPH电影和游戏制作中的实用基于物理的阴影，2012年8 
月。引用于 p。325,336,340,342,345,353,354,357,364 [215] 
Burley，Brent， “将迪斯尼 BRDF扩展到具有集成次表面散射的 
BSDF”，SIGGRAPH理论和实践中的基于物理的阴影过程，8月。 
2015.引用于 p。354 [216] Burns，Christopher A.，Kayvon 
----------------------- Page 1176-----------------------
Fatahalian和William R.Mark， “具有解耦采样的懒惰对象空间 
着色体系结构”， “高性能图形会议论文集，Eurographics 
Association”，第 19-28页，2010年6月。引用于p。910[217] 
Burns，CA和WA Hunt， “可见性缓冲：缓存阴影的缓存友好方 
法”，计算机图形技术期刊，第一卷。2，没有。2，pp.55-69,2013。 
引用于p。905,906 [218]Cabello，Ricardo，et al。，Three.js 
源代码，发布 r89 ， 2017 年 12 月。引用于 p 。 
41,50,115,189,201,407,485,552,628 [219]Cabral，Brian和Leith 
 （凯西）Leedom，“使用线积分卷积的成像矢量场”，SIGGRAPH 
'93：第20期会议录计算机图形学和交互技术年会，ACM，第 
263-270页，1993年8月。引用于p。538[220]Caillaud，Florian， 
VincentVidal，FlorentDupont，和GuillaumeLavou'e， “任意 
纹理网格的渐进式压缩”，计算机图形学论坛，第一卷。35，不。 
7，pp.475-484,2016。引用于p。709[221]Calver，Dean， “着 
色器中的顶点减压”，Wolfgang Engel编辑，Direct3DShaderX： 
Vertex＆PixelShader技巧和技巧，Wordware，第172-187页， 
2002年5月。引用于p。713[222]Calver，Dean，Photo-Realistic“ 
DeferredLighting”，Beyond3D.com网站，2003年7月30 日。 
引用于p。883,884,886 [223]Calver，Dean， “在GPU上访问 
和修改拓扑”，载于Wolfgang Engel，编辑，ShaderX3，Charles 
RiverMedia，第5-19页，2004年。703 [224]Calver，Dean， 
 “具有高动态范围的 PS3.0上的延迟照明”，Wolfgang Engel编 
----------------------- Page 1177-----------------------
辑，ShaderX3，Charles RiverMedia，第97-105页，2004年。 
288 [225] Cantlay，Iain和 Andrei Tatarinov， “从 Terrain 到 
Godrays：更好地利用DX11”，游戏开发者大会，2014年3月。 
引用于p。44,569 [226]Card，Drew和Jason L.Mitchell， “使 
用像素和顶点着色器进行非照片级真实渲染”，Wolfgang Engel 
编辑，Direct3DShaderX：Vertex＆PixelShader技巧和技巧， 
Wordware，pp。2002年5月319-333。引用于p。662,668[227] 
Carling，Richard， “Matrix Inversion”，Andrew S.Glassner 
编辑，Graphics Gems，Academic Press，pp.470-471,1990。 
68[228]Carmack，John，“延迟缓解策略”，AltDevBlog，2013 
年2月22 日。引用于p。920,936,937[229]做Carmo，Manfred 
P.，微分几何曲线和曲面，Prentice-Hall，Inc.，1976。引用于p。 
81 参考书目 1063 [230] Carpenter，Loren， “A-Buffer ， 
Antialiased Hidden Surface Method ， “计算机图形学 
 （SIGGRAPH'84Proceedings），第一卷。18，不。3，pp.103-108， 
1984年7月。引用于 p。155,626 [231]Carpentier，Giliam和 
KoheiIshiyama， “Decima，Advances in LightingandAA，” 
SIGGRAPH在游戏中实时渲染的进展，2017年8月。引用于p。 
146,148,386,805[232]Carucci，Francesco，“InsideGeometry 
Instancing” ，载于 Matt Pharr 编辑， GPU Gems 2 ， 
Addison-Wesley ，pp.47-67,2005。引用于 p。797 [233] 
Casta.no，Ignacio，“LightmapParameterization，'TheWitness 
----------------------- Page 1178-----------------------
Blog，2010年3月30 日。引用于p。486 [234]Casta.no，Ignacio， 
 “计算Alpha Mipmaps”，The Witness Blog，2010年9月9 
日。引用于p。204,206 [235]Casta.no，Ignacio， “Shadow 
MappingSummary-Part 1，'TheWitness Blog，2013年 9月 
23 日。引用于p。249,250,265 [236]Catmull，E。和R.Rom， 
 “一类局部插值样条”，在R.Barnhill＆R。Riesenfeld，eds。， 
Computer Aided Geometric Design ，Academic Press ， 
pp.317-326,1974。引用于p。731 [237]Catmull，E。，一种用 
于曲面计算机显示的细分算法，博士论文，犹他大学，1974年 12 
月。引用于p。1048[238]Catmull，Edwin， “曲面的计算机显 
示”，参见 IEEE计算机图形学，模式识别和数据结构会议论文，IEEE 
出版社，第 11-17页，1975年5月。引用于p。24[239]Catmull， 
E。和J.Clark， “在任意拓扑网格上递归生成 B样条曲面”，计算 
机辅助设计，第一卷。10，不。6，pp.350-355，1978年9月。 
引用于p。761,762[240]Cebenoyan，Cem， “图形管道性能”， 
在 RandimaFernando编辑，GPUGems，Addison-Wesley，第 
473-486 页，2004 年。引用于 p。787,802,815,853 [241] 
Cebenoyan，Cem， “真正的虚拟纹理 - 利用 DirectX11.2平铺 
资源”，游戏开发者大会，2014年3月。引用于p。246,263,867 
[242] Celes，Waldemar 和 Frederico Abraham， “Fast and 
Versatile Texture-Based Wireframe Rendering，”The Visual 
Computer，vol。27，不。10，pp.939-948,2011。引用于p。674 
----------------------- Page 1179-----------------------
[243]Cerezo，Eva，FredericP'erez，Xavier Pueyo，Francisco 
J.Seron和 Fran.coisX.Sillion，“关于参与媒体渲染技术的调查”， 
 “视觉计算机”，第一卷。21，不。5，pp.303-328，2005年6 
月。引用于 p 。 590 [244] The Cesium Blog ， http ： 
//cesiumjs.org/blog/,2017。引用于 p。879 [245] Chabert， 
Charles-F'elix，马万春，Tim Hawkins，Pieter Peers和 Paul 
Debevec， “使用波长依赖的 NormalMaps快速渲染真实面孔”， 
ACM SIGGRAPH2007海报，ACM，文章编号。183，2007年8 
月。引用p。634 [246]Chaikin，G。， “高速曲线生成算法”， 
计算机图形和图像处理，第一卷。4，不。3，pp.346-349,1974。 
引用于p。754[247]Chaitanya，ChakravartyR.Alla，AntonS. 
Kaplanyan，Christoph Schied，MarcoSalvi，Aaron Lefohn， 
Derek Nowrouzezahrai 和 Timo Aila ， “使用 Recurrent 
DenoisingAutoencoder进行蒙特卡罗图像序列的交互式重建”， 
ACMTransactions on图形，第一卷36，不。4，文章编号。98， 
pp.2017。引用于p。511,1043[248]Chajdas，Matth¨ausG。， 
Christian Eisenacher，MarcStamminger和Sylvain Lefebvre， 
 “VirtualTextureMapping101”，Wolfgang Engel编辑，GPU 
Pro，AK Peters，Ltd.，pp.185-195,2010。引用于p。8671064 
参考书目[249]Chajdas，Matth¨ausG。， “D3D12和Vulkan： 
经验教训”，游戏开发者大会，2016年3月。引用p。40,806,814 
[250]陈，丹尼和布莱恩约翰斯顿， “渲染风格：非洲武士的背后的 
----------------------- Page 1180-----------------------
历史和技术”，游戏开发者大会，2009年3月。引用p。652,658,664 
[251]Chan，Danny， “使命召唤：高级战争的真实世界测量”， 
在SIGGRAPH理论和实践中基于物理的阴影课程，2015年8月。 
引用于p。349,355 [252]Chan，Eric和 Fr'edoDurand， “Fast 
Prefiltered Lines”，在 Matt Pharr 编辑，GPU Gems 2， 
Addison-Wesley ， pp.345-359,2005 。引用于 p 。 [253] 
Chandrasekhar，Subrahmanyan，RadiativeTransfer，Oxford 
UniversityPress，1950。引用于p。352[254]Chang，Chia-Tche， 
BastienGorissen和SamuelMelchior， “旋转组SO （3，R）上 
的快速定向边界框优化”，ACMTransactionsonGraphics，vol。 
30，不。5，pp.122：1-122：16，2011年 10月。引用p。951[255] 
Chang，Chun-Fa，Gary Bishop和Anselmo Lastra， “LDI树： 
基于图像的渲染的层次表示”，SIGGRAPH'99：第26届计算机图 
形学与交互技术年会论文集，ACM Press / Addison-Wesley 
PublishingCo.，pp.291-298，1999年8月。引用于p。565[256] 
Chen ，GP Sander ，D。 Nehab ，L。Yang 和 L. Hu ， 
 “Depth-Presorted Triangle Lists，”ACM Transactions on 
Graphics，vol。31，不。6，pp.160：1-160：9,2016。引用于p。 
831[257]Chen，Hao， “Halo3的照明与材料”，游戏开发者大 
会，2008年3月。引用于p。475 [258]Chen，Hao和 Natalya 
Tatarchuk， “Bungie的照明研究”，SIGGRAPH在3D图形和游 
戏的实时渲染方面取得进展，2009年8月。引用p。256,257,475 
----------------------- Page 1181-----------------------
[259]Chen，K.， “孤岛惊魂4 中的自适应虚拟纹理渲染”，游戏 
开发者大会，2015年3月。引用于p。869 [260]Chen，Pei-Ju， 
HirokoAwata，Atsuko Matsushita，En-ChengYang和 Kentaro 
Arikawa，“普通青鸟蝴蝶的极度光谱丰富，Graphiumsarpedon，” 
生态与进化的前沿，第一卷。4，pp.18，2016年3月8 日。引用 
于 p。272 [261]Chi，Yung-feng， “今日GPU上浅水的真实动 
画”，Wolfgang Engel编辑，ShaderX4，CharlesRiverMedia， 
第 467-480 页，2005年。在第 602,626 [262] Chiang，Matt 
Jen-Yuan，BenediktBitterli，ChuckTappan和 BrentBurley， 
 “用于生产路径追踪的实用可控毛发和毛皮模型”，计算机图形论 
坛 （Eurographics2016），第一卷。35，不。2，pp.275-283,2016。 
引用于p。643[263]Chlumsk'y，Viktor，多通道距离场的形状分 
解，硕士论文，布拉格捷克技术大学理论计算机科学系，2015年5 
月。引用于 p。677,890 [264]Choi，H。， “Bifrost-TheGPU 
Architecturefor NextFiveBillion”，ARMTech Forum，2016 
年 6 月。引用于 p。1026,1027 [265] Christensen，Per H.， 
 “Point-Based Approximate Color Bleeding ，”Technical 
memo，PixarAnimation Studios，2008。引用于p。454 [266] 
Cichocki，Adam， “针对平面反射器的优化像素投射反射”， 
SIGGRAPH在游戏中实时渲染的进展，2017年8月。引用于p。 
509 [267] Cignoni ，P. ，C 。 Montani 和 R. Scopigno ， 
 “Triangulating Convex PolygonsHavingTVertices”，图形工 
----------------------- Page 1182-----------------------
具杂志，第一卷。1，不。2，pp.1-4,1996。也在[112]中收集。引 
用p。690参考书目 1065[268]Cignoni，Paolo， “关于顶点法 
线的计算”，MeshlabStuff博客，2009年4月10日。也在[112] 
中收集。引用p。695[269]Cigolle，Zina H.，SamDonow，Daniel 
Evangelakos ，Michael Mara ，Morgan McGuire 和 Quirin 
Meyer， “关于独立单位向量的有效表示的调查”，计算机图形技 
术杂志，第一卷。3，不。1，pp.1-30，2014。引用于p。222,714,715 
[270]Clarberg，Petrik和TomasAkenine-M'oller， “用于直接 
照明的实用产品重要性采样”，计算机图形学论坛，第一卷。27， 
不。2，pp.681-690,2008。引用于p。419 [271]Clarberg，P.， 
R。Toth，J。Hasselgren，J。Nilsson和T.Akenine-M'oller，AMFS“  ： 
用于未来图形处理器的自适应多频着色”，ACMTransactions on 
Graphics，vol 。33，不。4，pp.141：1-141：12,2014。引用于 
p。910,1013[272]Clark，James H.， “可见表面算法的分层几何 
模型”，ACM的通讯，第一卷。19，没有。10，pp.547-554，1976 
年 10月。引用于 p。835 [273]Coffin，Christina， “基于 SPU 
的战场3中的延迟阴影，用于Playstation3，”游戏开发者大会， 
2011年3月。引用于p。898,904 [274]Cohen，Jonathan D.， 
MarcOlano和 DineshManocha，“外观保留简化”，SIGGRAPH 
'98：第25届计算机图形学和交互技术年会论文集，ACM，第 115 
页 -1998年7月122日。引用于p。212[275]Cohen，Michael 
F.和John R.Wallace，RadiosityandRealisticImageSynthesis， 
----------------------- Page 1183-----------------------
Academic PressProfessional，1993。引用于p。442,483 [276] 
Cohen-Or，Daniel，Yiorgos Chrysanthou，Fr'edo Durand， 
NedGreene，Vladlen Kulton和 Cl'audio T. Silva，SIGGRAPH 
可见性，问题，技术与应用课程，2001年8月。引用于p。[277] 
Cohen-Or，Daniel，YiorgosChrysanthou，Cl'audioT.Silva和 
Fr'edoDurand， “演练应用可见性调查”，IEEE可视化和计算机 
图形学交易，第一卷。9，不。3月，第412-431页，7月至9月。 
2003年。引用p。830,831,879[278]Cok，Keith，RogerCorron， 
Bob Kuehne和ThomasTrue，SIGGRAPH开发高效图形软件： 
图形学的阴阳，2000年7月。引用于p。801[279]Colbert，Mark 
和Jaroslav Kriv'anek， “GPU-Based ImportanceSampling”， 
Hubert Nguyen 编辑，GPU Gems 3，Addison-Wesley，第 
459-475 页，2007 年。419,423,503 [280] Colbert，Mark和 
Jaroslav Kriv'anek， “带有过滤重要性的实时着色”，ACM 
SIGGRAPH2007技术草图，ACM，文章编号。71，2007年8月。 
引用p。419,423 [281]Cole，Forrester，Aleksey Golovinskiy， 
Alex Limpaecher，HeatherStoddartBarros，Adam Finkelstein， 
Thomas Funkhouser和SzymonRusinkiewicz， “人们在哪里划 
线？”ACM图形交易 （SIGGRAPH2008），第一卷。27，不。3， 
pp.88：1-88：11,2008。引用于p。656 [282]Cole，Forrester 
和Adam Finkelstein， “高质量线可见性的两种快速方法”，IEEE 
可视化和计算机图形学交易，第一卷。16，不。5，pp.707-717， 
----------------------- Page 1184-----------------------
9月/ 10月。2010年。引用p。668,675[283]Collin，D。， “剔 
除战场”，游戏开发者大会，2011年3月。引用于p。837,840,849 
[284]Conran，Patrick，“SpecVarMaps：BumpBumpMapsinto 
Specular Response”，ACM SIGGRAPH2005草图，ACM，文 
章编号。2005年8月22 日。引用于p。369[285]Cook，Robert 
L.和 KennethE.Torrance， “计算机图形学的反射模型”，计算机 
图形学（SIGGRAPH '81 Proceedings），第一卷。15，不。3， 
pp.307-316，1981年7月。引用于p。314,326,331,338,343,446 
1066参考书目[286]Cook，Robert L.和 KennethE.Torrance， 
 “A Reflectance Model for Computer Graphics ，”ACM 
TransactionsonGraphics，vol。1，不。1，pp.7-24，1982年 1 
月。引用于p。326,338,343,446[287]Cook，RobertL.，“Shade 
Trees”，ComputerGraphics （SIGGRAPH'84Proceedings）， 
vol。18，不。3，pp.223-231，1984年7月。引用于p。37,765 
[288]Cook，RobertL.， “计算机图形学中的随机抽样”，ACM 
TransactionsonGraphics，vol。5，不。1，pp.51-72，1986年 
1月。引用于p。249 [289]Cook，RobertL.，LorenCarpenter 
和 Edwin Catmull， “雷耶斯图像渲染架构”，计算机图形学 
 （SIGGRAPH'87Proceedings），第一卷。21，不。4，pp。1987 
年 7月95-102。引用于p。26,774,908 [290]Cook，Robert L. 
和 Tony DeRose， “Wavelet Noise”，ACM Transactions on 
Graphics （SIGGRAPH2005），vol。24，不。3，pp.803-811,2005。 
----------------------- Page 1185-----------------------
引用于p。199 [291]Coombes，David， “DX12做和不做，更 
新！”NVIDIAGameWorks博客，2015年 11月12日。引用于p。 
814 [292]Cormen，TH，CE Leiserson，R。Rivest和C.Stein， 
 “算法导论”，麻省理工学院出版社，2009年。引用于 p。 
820,829,835 [293] Courr`eges，Adrian ， “GTA V-Graphics 
Study”，Adrian Courr`eges博客，2015年 11月2 日。引用于 
p。525,535,901,913[294]Courr`eges，Adrian，“DOOM （2016） 
-GraphicsStudy”，AdrianCourr`eges博客，2016年9月9 日。 
引用于p。246,535,540,629,901,913[295]Courr`eges，Adrian， 
 “谨防透明像素”，Adrian Courr`eges博客，2017年5月9 日。 
引用于p。160,208[296]考克斯，迈克尔，和 PatHanrahan，“用 
于对象并行渲染的像素合并：分布式侦听算法”，参见 1993年 “平 
行渲染研讨会论文集”，ACM，第49-56页，1993年 11月。802 
[297]Cox，Michael，DavidSprague，John Danskin，RichEhlers， 
BrianHook，BillLorensen和GaryTarolli，SIGGRAPH为PC平 
台课程开发高性能图形应用程序，1998年7月。1023[298]Cozzi， 
Patrick， “采用深度缓冲”，AGI博客，2008年3月5日。引用 
于p。943[299]Cozzi，Patrick和 KevinRing，虚拟地球仪的3D 
引擎设计，AK Peters / CRC 出版社，2011 年。引用 p。 
668,715,872,879[300]Cozzi，P。和 D.Bagnell，“WebGLGlobe 
RenderingPipeline”，Wolfgang Engel编辑，GPUPro4，CRC 
出版社，第39-48页，2013年。被引用在第 872,876[301]Cozzi， 
----------------------- Page 1186-----------------------
Patrick，ed。，WebGL Insights，CRC出版社，2015年。引用于 
p。129,1048[302]Cozzi，Patrick，“Cesium3DTiles”，GitHub 
存储库，2017年。引用于p。827[303]Crane，Keenan，Ignacio 
Llamas和SarahTariq， “3D流体的实时模拟和渲染”，Hubert 
Nguyen编辑，GPUGems3，Addison-Wesley，第633-675页， 
2007年。引用p。608,609,649[304]Crassin，Cyril，Giga体素： 
基于体素的渲染管道，用于有效探索大型和详细场景，博士论文， 
格勒诺布尔大学，2011年 7月。引用于 p。494,579,584 [305] 
Crassin，Cyril，Fabrice Neyret，MiguelSainz，Simon Green 
和 ElmarEisemann，使“用VoxelConeTracing的交互间接照明”， 
计算机图形论坛，第一卷。30，不。7，pp.1921-1930,2011。引 
用于 p。455,467 [306]Crassin，Cyril和 SimonGreen， “使用 
GPU硬件光栅化器进行基于八叉树的稀疏体素化”，PatrickCozzi 
和 Christophe Riccio编辑，OpenGL Insights，CRC Press，第 
303-319页，2012年。582参考书目 1067[307]Crassin，Cyril， 
 “用于实时全局照明的基于八叉树的稀疏体素化”，NVIDIAGPU 
技术大会，2012年2月。引用于p。504,582[308]Crassin，Cyril， 
 “用于下一代实时渲染的动态稀疏体素八分之一”，SIGGRAPH 
BeyondProgrammableShading课程，2012年8月。引用于p。 
579,584 [309] Crassin ，Cyril ，Morgan McGuire，Kayvon 
Fatahalian 和 Aaron Lefohn ， “Aggregate G-Buffer 
Anti-Aliasing ， ” IEEE Transactions on Visualization and 
----------------------- Page 1187-----------------------
ComputerGraphics，vol。22，不。10，pp.2215-2228，2016 
年 10月。引用于p。888[310]Cripe，Brian和ThomasGaskins， 
 “DirectModel 工具包：满足技术应用的 3D 图形需求， 
 “Hewlett-PackardJournal，pp.19-27，1998年5月。引用于p。 
818 [311]Crow，FranklinC.， “计算机图形的阴影算法”，计算 
机图形学（SIGGRAPH'77Proceedings），第一卷。11，不。2， 
pp.242-248，1977年7月。引用于p。230[312]Crow，Franklin 
C.， “Summed-AreaTablesforTextureMapping，”Computer 
Graphics （SIGGRAPH '84 Proceedings），vol。18，不。3， 
pp.207-212，1984年7月。引用于p。186[313]Culler，David 
E.和Jaswinder PalSingh，AnoopGupta，并行计算机体系结构： 
硬件/软件方法，MorganKaufmann，1998年。引用p。810[314] 
Cunningham，Steve， “使用正交基底进行 3D观察和旋转”， 
AndrewS.Glassner编辑，GraphicsGe FranklinC.， “计算机图 
形的阴影算法”，计算机图形学 （SIGGRAPH'77Proceedings）， 
第一卷。11，不。2，pp.242-248，1977年7月。引用于p。230 
[312]Crow，FranklinC.， “Summed-AreaTables for Texture 
Mapping，”ComputerGraphics （SIGGRAPH'84Proceedings）， 
vol。18，不。3，pp.207-212，1984年7月。引用于p。186[313] 
Culler，DavidE.和Jaswinder PalSingh，AnoopGupta，并行计 
算机体系结构：硬件/软件方法，MorganKaufmann，1998年。 
引用p。810 [314]Cunningham，Steve， “使用正交基底进行 
----------------------- Page 1188-----------------------
3D观察和旋转”，AndrewS.Glassner编辑，GraphicsGe Franklin 
C.， “计算机图形的阴影算法”，计算机图形学（SIGGRAPH '77 
Proceedings），第一卷。11，不。2，pp.242-248，1977年7 
月。引用于p。230 [312]Crow，FranklinC.， “Summed-Area 
TablesforTexture Mapping，”ComputerGraphics （SIGGRAPH 
'84 Proceedings），vol。18，不。3，pp.207-212，1984年7 
月。引用于p。186[313]Culler，DavidE.和Jaswinder PalSingh， 
Anoop Gupta，并行计算机体系结构：硬件/软件方法，Morgan 
Kaufmann，1998年。引用p。810[314]Cunningham，Steve， 
 “使用正交基底进行3D观察和旋转”，AndrewS.Glassner编辑， 
GraphicsGe “计算机图形学（SIGGRAPH '84Proceedings）， 
第一卷。18，不。3，pp.207-212，1984年7月。引用于p。186 
[313]Culler，DavidE.和Jaswinder PalSingh，Anoop Gupta， 
并行计算机体系结构：硬件/软件方法，MorganKaufmann，1998 
年。引用p。810[314]Cunningham，Steve， “使用正交基底进 
行3D观察和旋转”，AndrewS.Glassner编辑，GraphicsGe “计 
算机图形学（SIGGRAPH'84Proceedings），第一卷。18，不。 
3，pp.207-212，1984年7月。引用于p。186[313]Culler，David 
E.和Jaswinder PalSingh，AnoopGupta，并行计算机体系结构： 
硬件/软件方法，MorganKaufmann，1998年。引用p。810[314] 
Cunningham，Steve， “使用正交基底进行 3D观察和旋转”， 
Andrew S.Glassner编辑，GraphicsGems，Academic Press， 
----------------------- Page 1189-----------------------
pp.516-521,1990。引用于p。74[315]Cupisz，Kuba和 Kasper 
Engelstoft， “统一照明”，游戏开发者大会，2015年3月。引用 
于p。476,482,509 [316]Cupisz，Robert， “使用四面体镶嵌的 
光探针插值”，游戏开发者大会，2012年3月。引用于p。489,490 
[317]柯蒂斯，卡西迪，“松散和粗略的动画”，在ACMSIGGRAPH 
'98电子艺术和动画目录，ACM，p。145，1998年7月。引用于 
p。672 [318]Cychosz，JM和WN Waggenspack，Jr。， “将 
雷与圆柱相交”，PaulS. Heckbert编辑，Graphics Gems IV， 
Academic Press，pp.356-365,1994。引用次数页。959 [319] 
Cyrus，M。和J. Beck， “广义二维和三维剪辑”，计算机与图形 
学，第一卷。3，pp.23-28,1978。引用于p。959[320]Dachsbacher， 
Carsten，和MarcStamminger， “半透明阴影地图”，在第14 
届 Eurographics渲染研讨会论文集，EurographicsAssociation， 
pp.197-201 ，2003 年 6 月。引用于 p 。 638,639 [321] 
Dachsbacher，Carsten和 MarcStamminger，“反射阴影地图”， 
载于 2005年交互式 3D 图形与游戏研讨会论文集，ACM，第 
203-231页，2005年。引用于p。491 [322]Dachsbacher，Carsten 
和 MarcStamminger， “间接照明的飞溅”，载于2006年交互式 
3D图形和游戏研讨会论文集，ACM，第93-100页，2006年。引 
用于第4页。492 [323]Dachsbacher，C。和 N.Tatarchuk，“Prism 
Parallax Occlusion Mapping with Accurate Silhouette 
Generation”，交互式3D图形与游戏研讨会海报，2007年4月 
----------------------- Page 1190-----------------------
至 5月。引用于p。220 [324]Dallaire，Chris， “用于地形瓦片 
索引缓冲区生成的二元三角树，”Gamasutra，2006年 12月21 
日。引用于p。876[325]Dam，Eri​ ​ kB.，MartinKoch和 Martin 
Lillholm， “Quaternions，InterpolationandAnimation，”技 
术报告 DIKU-TR-98/5，哥本哈根大学计算机科学系，1998年7 
月。引用于 p 。81 [326] Davies，Jem， “BifrostGPU架构和 
ARM Mali-G71GPU”，HotChips，2016年8月。引用于 p。 
10251068参考书目[327]Davies，Leigh， “OITtoVolumetric 
Shadow Mapping，101 Use for Raster-OrderedViews Using 
DirectX12，”IntelDeveloperZone博客，2015年3月5 日。 
引用于p。52,139,156[328]Davies，Leigh， “RasterizerOrder 
Views 101：A Primer”，IntelDeveloperZone博客，2015年8 
月5 日。引用于p。52,156 [329]Day，Mike， “CSM滚动：一 
种用于渲染级联阴影贴图的加速技术， “由MikeActon提出， 
SIGGRAPH在游戏中实时渲染的进展，2012年8月。引用于p。 
245[330]Day，Mike，“一个高效且用户友好的色调映射运算符”， 
Insomniac研发博客，2012年9月18日。引用于p。286[331]De 
Smedt，Matthijs， “PCGPU性能热点”，NVIDIAGameWorks 
博客，2016年 8 月 10 日。引用于p。790,792,795,814 [332] 
Debevec，PaulE.， “将合成物体渲染成真实场景：用全局照明和 
高动态范围摄影桥接传统和基于图像的图形”，SIGGRAPH '98： 
第25期会议录计算机图形学和交互技术年会，ACM，第189-198 
----------------------- Page 1191-----------------------
页，1998年 7月。引用于 p。406 [333] Debevec，Paul，Rod 
Bogart，FrankVitz和GregWard，SIGGRAPHHDRI和基于图像 
的照明课程，2003年7月。引用于p。435 [334]DeBry，David 
 （grue），Jonathan Gibbs，Devorah DeLeon Petty和 Nate 
Robins， “在非参数模型上绘制和渲染纹理”，ACM 图形交易 
 （SIGGRAPH2002），第一卷。21，不。3，pp.763-768，2002 
年7月。引用于p。190[335]DeCarlo，Doug，Adam Finkelstein 
和SzymonRusinkiewicz， “具有时间连贯性的暗示轮廓的交互式 
渲染”，第3届非真实动画和渲染国际研讨会论文集，ACM，第 
15-24页，6月2004年。引用p。655[336]Decaudin，Philippe， 
 “卡通3D渲染的渲染”，技术报告INRIA2919，法国科技大学， 
1996年6月。引用于p。661,664 [337]Decaudin，Philippe和 
FabriceNeyret， “容积广告牌， “计算机图形学论坛，第一卷。 
28，不。8，pp.2079-2089,2009。引用于p。564[338]D'ecoret， 
Xavier，Fr'edo Durand，Fran.cois Sillion 和 Julie Dorsey， 
 “BillboardCloudsfor ExtremeModelSimplification”，ACM 
Transactions onGraphics （SIGGRAPH2003），vol。22，不。 
3，pp.689-696,2003。引用于p。563 [339]Deering，M.，S。 
Winnder，B。Schediwy，C。Duff和 N.Hunt， “三角形处理器 
和标准矢量着色器：用于高性能图形的VLSI系统”，计算机图形学 
 （SIGGRAPH'88）会议录），第一卷。22，不。4，pp.21-30， 
1988年8月。引用于p。883[340]Deering，Michael，Geometry“ 
----------------------- Page 1192-----------------------
Compression”，SIGGRAPH '95：第22届计算机图形学和交互 
技术年会论文集，ACM，第13-20页，1995年8月。引用于p。 
700 [341] Delalandre，Cyril，Pascal Gautron，Jean-Eudes 
Marvie和GuillaumeFran。cois， “透射函数映射”，交互式3D 
图形和游戏研讨会，2011年。引用于p。570,612,620[342]Delva， 
Michael，Julien Hamaide和 Ramses Ladlani， “使用 Shader 
Shaker生成基于语义的着色器”，Wolfgang Engel编辑，GPU 
Pro6，CRCPress，pp.505-520,2015。引用p。128[343]Demers， 
Joe，“景深：技术概述”，RandimaFernando编辑，GPUGems， 
Addison-Wesley ，第 375-390 页， 2004 年。 531 [344] 
Demoreuille，Pete， “为VR优化虚幻引擎4渲染器”，Oculus 
开发者博客，2016年5月25日。引用于p。900,934参考书目1069 
[345]d'Eon，Eugene和 David Luebke， “现实实时皮肤渲染的 
先进技术”，作者：Hubert Nguyen，编辑，GPU Gems 3， 
Addison-Wesley，第293-347页，2007年。引用p。635,636,639 
[346]d'Eon，Eugene，Guillaume Fran.cois，Martin Hill，Joe 
Letteri和Jean-Mary Aubry， “节能头发反射模型”，计算机图 
形学论坛，第一卷。30，不。4，pp.1467-8659,2011。引用于p。 
641,643 [347]DeRose，T.，M。Kass和T.Truong， “角色动画 
中的细分曲面”，SIGGRAPH'98：第25届计算机图形学和交互技 
术年会论文集，ACM，pp。 1998年 7月85-94。引用于 p。 
761,764,767,777[348]Deshmukh，Priyamvad，FengXie和 Eric 
----------------------- Page 1193-----------------------
Tabellion，“梦工厂织物遮阳模型：从艺术家友好到物理上合理”， 
在ACMSIGGRAPH2017会谈中，文章编号。2017年7月38 日。 
引用于p。359 [349]Deshpande，Adit， “你需要知道的9篇深 
度学习论文”，Adit Deshpande博客，2016年8月24 日。引用 
于 p。1043 [350]Didyk，P.，T。Ritschel，E。Eisemann，K。 
Myszkowski，和 H.-P.Seidel，“自适应图像 - 空间立体视图合成”， 
见 “视觉，建模和可视化研讨会论文集 2010”，Eurographics 
Association，第299-306页，2010年。523[351]Didyk，P.，E。 
Eisemann，T。Ritschel，K。Myszkowski和 H.-P.Seidel， “用 
于高刷新率显示的3D内容的感知实时时间上采样”，计算机图形 
论坛，第一卷。29，不。2，pp.713-722,2011。引用于p。523[352] 
Dietrich，Andreas，EnricoGobbetti和Sung-EuiYoon， “大规 
模模拟渲染技术”，IEEE计算机图形和应用，第一卷。27，不。6， 
pp.20-34，Nov。/ Dec。2007年。引用p。587,879[353]Dietrich， 
Sim， “AttenuationMaps”，Mark DeLoura 编辑，Game 
ProgrammingGems，CharlesRiverMedia，pp.543-548,2000。 
引用于p。221[354]Dimitrijevi'c，Aleksandar，“绩效状态跟踪”， 
载于PatrickCozzi和ChristopheRiccio，编辑，OpenGLInsights， 
CRC出版社，第 527-534页，2012年。789[355]Dimov，Rossen， 
 “为GTR BRDF推导史密斯阴影函数”，ChaosGroup白皮书， 
2015年6月。引用第7页。343 [356]Ding，Vivian， “我们最 
后的游戏和电影照明”，游戏开发者大会，2014年3月。引用于p。 
----------------------- Page 1194-----------------------
229[357]Dmitriev，Kirill和Yury Uralsky， “使用分层最小 - 最 
大阴影贴图的软阴影”，游戏开发者大会，2007年3月。引用于p。 
252 [358] Dobashi，Yoshinori ，Kazufumi Kaneda，Hideo 
Yamashita，Tsuyoshi Okita和Tomoyuki Nishita， “一种简单， 
高效的云彩逼真动画方法”，SIGGRAPH'00：第27届计算机图形 
学与互动年会论文集技术，ACM Press / Addison-Wesley 
Publishing Co.，pp.19-28，July 2000.引用于 p。556 [359] 
Dobashi，Yoshinori，TsuyoshiYamamoto和Tomoyuki Nishita， 
 “使用图形硬件的大气散射效果的交互式渲染”，图形硬件2002， 
EurographicsAssociation，pp.99-107，2002年9月。引用于p。 
604 [360] Dobbie，Will， “GPU文本渲染与矢量纹理，”Will 
Dobbie博客，2016年 1月21 日。引用于p。677[361]Dobbyn， 
Simon，John Hamill，Keith O'Conor 和 Carol O'Sullivan， 
 “Geopostors：实时几何/冒名顶替人群渲染系统”，载于2005 
年交互式3D图形和游戏研讨会论文集，ACM，pp.95-102，2005 
年4月。引用于p。551[362]Doggett，M。，“TextureCaches，” 
IEEEMicro，vol。32，不。3，pp.136-141,2005。引用于p。1017 
1070参考书目[363]Doghramachi，Hawar，和Jean-Normand 
Bucci， “Deferred +：Next-Gen剔除和渲染黎明引擎”，载于 
Wolfgang Engel，编辑，GPUZen，BlackCat Publishing，第 
77-103页，2017年。715,849,908[364]杜比实验室公司，“ICtCp 
杜比白皮书”，杜比网站。引用p。276,287 [365] Domin'e， 
----------------------- Page 1195-----------------------
S'ebastien， “OpenGLMultisample，”游戏开发者大会，2002 
年3月。引用于p。145[366]Dong，Zhao，BruceWalter，Steve 
Marschner和 DonaldP.Greenberg， “预测金属表面测量微观几 
何学的外观”，ACMTransactions onGraphics，vol。35，不。 
1，文章号2015年9月9 日。引用于p。361 [367]Donnelly， 
William ， “Per-Pixel Displacement Mapping with Distance 
Functions，”，MattPharr编辑，GPUGems2，Addison-Wesley， 
pp.123-136,2005。218 [368] Donnelly，William 和 Andrew 
Lauritzen， “方差阴影地图”，载于2006年交互式3D图形研讨 
会论文集，ACM，第 161-165页，2006年。引用于第4页。252 
[369]Donner，Craig和 HenrikWannJensen， “多层半透明材 
料中的光扩散”，ACM图形交易（SIGGRAPH2005），第一卷。 
24，不。3，pp.1032-1039,2005。引用于p。635[370]Doo，D。 
和 M.Sabin， “特殊点附近的递归分割表面的行为”，计算机辅助 
设计，第一卷。10，不。6，pp.356-360，1978年9月。引用于p。 
761[371]Dorn，Jonathan，ConnellyBarnes，Jason Lawrence 
和WestleyWeimer， “迈向自动限制程序着色器”，计算机图形 
论坛 （PacificGraphics2015），第一卷。34，不。7，pp.77-87,2015。 
引用于p。200[372]Doss，JoshuaA.， “基于艺术的渲染与嫁接 
冒名”，在MarkDeLoura编辑，GameProgrammingGems7， 
Charles RiverMedia，pp.447-454,2008。引用于p。672 [373] 
Dou，Hang，Yajie Yan，Ethan Kerzner，Zeng Dai和 Chris 
----------------------- Page 1196-----------------------
Wyman， “阴影贴图的自适应深度偏差”，计算机图形技术期刊， 
第一卷。3，不。4，pp.146-162,2014。引用于p。250[374]Dougan， 
Carl， “The ParallelTransport Frame”，MarkDeLoura编辑， 
Game Programming Gems 2 ， Charles River Media ， 
pp.215-219,2001。引用于 p。102 [375] Drago，F.，K。 
Myszkowski，T。Annen和 N.Chiba， “用于显示高对比度场景 
的自适应对数映射”，计算机图形论坛，第一卷。22，不。3， 
pp.419-426,2003。引用于 p。286 [376] Driscoll，Rory， 
 “CubemapTexel SolidAngle”，CODEITNOW博客，2012年 
1月15日。引用于p。419 [377]Drobot，Michal， “Quadtree 
Displacement Mapping with Height Blending” ，作者： 
Wolfgang Engel 编辑， GPU Pro ，AK Peters ， Ltd. ， 
pp.117-148,2010。引用于p。220[378]Drobot，Michal， “实 
时图形的空间和时间一致性框架”，Eric Lengyel编辑，Game 
EngineGems 2，AK Peters，Ltd.，pp.97-118,2011。被引用在 
第 518[379]Drobot，Michal， “杀戮地带的照明：影子堕落”， 
数字龙会议，2013年4月。引用于p。116[380]Drobot，Michal， 
 “PhysicallyBasedArea Lights”，Wolfgang Engel编辑，GPU 
Pro5，CRC出版社，第67-100页，2014年。引用于p。116,388 
[381]Drobot，Michal，全屏通行证中的“     GCN执行模式”，Michal 
Drobot博客，2014年4月 1日。引用于p。514[382]Drobot， 
Michal， “混合重建抗锯齿”，SIGGRAPH在游戏中实时渲染的 
----------------------- Page 1197-----------------------
进展，2014年8月。引用于p。141,142,146,165参考书目 1071 
[383]Drobot，Michal， “混合重建抗锯齿”，载于Wolfgang 
Engel，编辑，GPUPro6，CRC出版社，第 101-139页，2015年。 
引用于第4页。141,146,165[384]Drobot，Michal， “使命召唤 
无限战争的渲染”，数字龙会议，2017年 5月。引用于 p。 
262,325,371,420,502,503,509,569[385]Drobot，Michal， “用 
于平铺和集群渲染的改进剔除”，SIGGRAPH在游戏中实时渲染的 
进展，2017年8月。引用于p 。902,905[386]Drobot，Michal， 
 “实用多层材料在使命召唤无限战争中”，SIGGRAPH基于物理学 
的理论和实践中的阴影， 2017 年 8 月。引用于 p。 
151,363,364,623,625,629 [387]Duff，Tom， “合成三维渲染图 
像”，计算机图形学（SIGGRAPH '85Proceedings），第一卷。 
19，没有。3，pp.41-44，1985年7月。引用于p。[388]达夫， 
汤姆，詹姆斯伯吉斯，PerChristensen，ChristopheHery，Andrew 
Kensler，MaxLiani和 RyusukeVillemin， “建立正交基础，重新 
审视”，计算机图形技术期刊，第一卷。6，不。1，pp.1-8,2017。 
引用于p。75 [389] Duffy，Joe， “CLR InsideOut”，MSDN 
杂志，第一卷。21，不。2006年9月10日。引用于p。791[390] 
Dufresne，MarcFauconneau， “ForwardClusteredShading”， 
英特尔软件开发人员专区，2014年8月5日。引用于p。900,914 
[391]Duiker，Haarm-Pieter和GeorgeBorshukov，Filmic“  Tone 
Mapping”，2006年 10月27 日电子艺界的演讲。引用于p。286 
----------------------- Page 1198-----------------------
[392] Duiker ，Haarm-Pieter ， “用于实时渲染的 Filmic 
Tonemapping”，2010 年 7 月的电影和游戏制作课程中的 
SIGGRAPH色彩增强和渲染。引用于 p。286,288,289,290 [393] 
Dummer，Jonathan ， “Cone Step Mapping ：一种迭代 
Ray-Heightfield交叉算法，“lonesock网站，2006年。引用于p。 
219 [394]Dunn，Alex， “透明度（或透明度）渲染”，NVIDIA 
GameWorks 博客， 2014 年 10 月 20 日。引用于 p 。 
155,157,159,204,569 [395] Dupuy，Jonathan ，Eric Heitz， 
Jean-Claude Iehl，Pierre Poulin，Fabrice Neyret 和 Victor 
Ostromoukhov， “Linear Efficient Antialiased Displacement 
and ReflectanceMapping，”ACMTransactions onGraphics， 
vol 。32，不。6，pp.211：1-211：11，2013年 11月。引用于 
p。370[396]Dupuy，Jonathan， “使用LEADR映射对基于物理 
的阴影进行抗锯齿化”，SIGGRAPH理论与实践中基于物理的阴影， 
2014年8月。引用于p。370[397]Dupuy，Jonathan，EricHeitz 
和 Eugened'Eon， “微观和微观理论统一的进一步发展， “关于 
渲染的 Eurographics 研讨会论文集：实验理念与实施， 
EurographicsAssociation，pp.55-63,2016。引用于p。352,648 
[398]Durand，Fr'edo，3D可见性：分析研究与应用，博士论文， 
Universit'eJoseph Fourier，格勒诺布尔，1999年7月。引用于 
p。879[399]Dutr'e，Philip，GlobalIlluminationCompendium， 
网页，2003年9月29 日。引用于p。372,443,512[400]Dutr'e， 
----------------------- Page 1199-----------------------
Philip，Kavita Bala 和 Philippe Bekaert，Advanced Global 
Illumination，SecondEdition，AK Peters，Ltd.，2006。Citedon 
p。269,442,512,684[401]Dyken，C.，M。Reimers和J.Seland， 
 “Real-Time GPU Silhouette Refinement Using Adaptively 
BlendedB'ezierPatches”，ComputerGraphics Forum，vol。 
27，不。1，pp.1-12,2008。引用于p。7471072参考书目[402]Dyn， 
Nira，DavidLevin和JohnA. Gregory， “用于曲线设计的4点 
插值细分方案”，计算机辅助几何设计，第一卷。4，不。4， 
pp.257-268,1987。引用于p。755[403]Eberly，David， “三角 
测量通过耳朵剪辑”，几何工具网站，2003年。引用于p。686[404] 
Eberly，David，3D游戏引擎设计：实时计算机图形学的实用方法， 
第二版， Morgan Kaufmann ， 2006 年。引用于 p 。 
82,772,829,950,951,959,976,990 [405] Eberly，David， “从法 
线贴图重建高度场”， “几何工具博客”，2006年5月3 日。引 
用于 p。214 [406]Eberly，David， “快速准确的SLERP计算算 
法”，图形，GPU 和游戏工具杂志，第一卷。15，不。3， 
pp.161-176,2011。引用于p。[403]Ebert，DavidS.，John Hart， 
BillMark，F。KentonMusgrave，DarwynPeachey，KenPerlin 
和 StevenWorley，纹理与建模：程序方法，第三版，Morgan 
Kaufmann，2002年。引用于p。198,200,222,672[408]Eccles， 
Allen， “钻石怪物3DfxVoodoo 1”，GameSpy名人堂，2000 
年。引用于p。1[409]Eisemann，Martin和Xavier D'ecoret， 
----------------------- Page 1200-----------------------
 “快速场景体素和应用”，参见ACMSIGGRAPH2006草图，ACM， 
文章编号。2006年8月8 日。引用p。581,586[410]Eisemann， 
Martin，MarcusMagnor，ThorstenGrosch和StefanM¨uller， 
 “使用 RaySlopes的快速射线/轴对齐边界框重叠测试”，图形工 
具杂志，第一卷。12，不。4，pp.35-46,2007。引用于p。961[411] 
Eisemann，Martin和Xavier D'ecoret，合理软阴影的遮挡纹理“        ”， 
计算机图形学论坛，第一卷。27，不。1，pp.13-23,2008。引用于 
p。230 [412] Eisemann，Martin，Michael Schwarz ，Ulf 
Assarsson和 MichaelWimmer，Real-TimeShadows，AK Peters 
/ CRC Press，2011。引用于 p。223,244,249,253,265 [413] 
Eisemann，Martin，MichaelSchwarz，UlfAssarsson和 Michael 
Wimmer，SIGGRAPHEfficientReal-TimeShadows课程，2012 
年8月。265[414]ElGarawany，Ramy， “Uncharted4 中的延 
迟照明”，SIGGRAPH在2016年7月的游戏实时渲染方面取得进 
展。引用于p。472,886,887,898,904 [415]ElMansouri，Jalal， 
 “RenderingTomClancy'sRainbowSixSiege”，游戏开发者大 
会，2016年 3月。引用于 p。146,246,252,805,850,887 [416] 
Elcott，Sharif，KayChang，MasayoshiMiyamoto和 Napaporn 
Metaaphanon，最终幻想“     XV渲染技术”，ACMSIGGRAPH2016 
会谈，ACM，文章编号。2016年7月48 日。引用于p。620[417] 
Eldridge，Matthew，HomanIgehy和 PatHanrahan， “石榴： 
完全可扩展的图形架构， “在SIGGRAPH '00：第27届计算机图 
----------------------- Page 1201-----------------------
形和交互技术年会论文集，ACM 出版社/Addison-Wesley出版公 
司，第443-454页，2000年7月。引用于p。1020,1021,1022[418] 
Eldridge，Matthew，围绕可扩展性和通信设计图形架构，博士论 
文，斯坦福大学，2001年6月。引用p。1020,1022,1023[419]Elek， 
Oskar， “实时渲染具有多重散射的可参数化行星大气”， “中欧 
计算机图形学研讨会”，2009年。615 [420]Elek，Oskar， “实 
时渲染中的分层材料”，载于第 14届中欧计算机图形学研讨会论文 
集，维也纳科技大学，第27-34页，2010年5月。364参考书目 
1073[421]Elinas，Pantelis，和Wolfgang Stuerzlinger， “3D 
云的实时渲染”，图形工具杂志，第一卷。5，不。4，pp.33-45,2000。 
引用于p。556[422]van EmdeBoas，P.，R。Kaas和 E.Zijlstra， 
 “高效优先队列的设计和实施”，数学系统理论，第一卷。10，不。 
1，pp.99-127,1977。引用于p。827[423]Enderton，Eric，Erik 
Sintorn ， Peter Shirley 和 David Luebke ， “Stochastic 
Transparency ， ” IEEE Transactions on Visualization and 
ComputerGraphics，vol。17，不。8，pp.1036-1047,2011。引 
用于p。149,206[424]Endres，Michael和 FrankKitson， “完 
善像素：改进视觉造型的艺术”，游戏开发者大会，2010年3月。 
引用于p。289[425]Eng，奥斯汀， “更严厉的挫折剔除以及你为 
什么要忽视它”，Cesium博客，2017年2月2 日。引用于p。986 
[426]恩格尔，沃尔夫冈，ed。，Direct3DShaderX：Vertex和 
PixelShader技巧和技巧，Wordware，2002。引用于p。xvii [427] 
----------------------- Page 1202-----------------------
Engel，Wolfgang，ed。，ShaderX2：DirectX9，Wordware， 
2004的简介和教程。引用于p。xvi [428]Engel，Wolfgang，ed。， 
ShaderX2：使用 DirectX9，Wordware，2004的着色器编程技巧 
和诀窍。引用于p。xvi [429]Engel，Wolfgang，ed。，ShaderX3， 
Charles River Media，2004。引用于 p。1148 [430] Engel， 
Wolfgang， “Cascaded Shadow Maps”，Wolfgang Engel， 
编辑，ShaderX5，Charles RiverMedia，第197-206页，2006 
年。引用第 11页。242,243 [431]恩格尔，沃尔夫冈， “为多个灯 
光设计渲染器：轻型预透镜渲染器”，载于Wolfgang Engel，编 
辑，ShaderX7，CharlesRiverMedia，第655-666页，2009年。 
引用于p 。892 [432] Engel，Wolfgang， “Light Pre-Pass;延 
期照明：最新发展，“SIGGRAPH在游戏中实时渲染的进展，2009 
年8月。引用于第4页。892,901[433]Engel，Wolfgang， “过 
滤和剔除的可见性缓冲区”，游戏开发者大会欧洲，2016年8月。 
引用于p。833,851,907 [434] Engelhardt，Thomas和 Carsten 
Dachsbacher， “八面体环境地图”，载于2008年视觉，建模和 
可视化会议论文集，AkaGmbH，第383-388页，2008年 10月。 
引用于 p 。413 [435] Ericson，Christer，Real-TimeCollision 
Detection ， Morgan Kaufmann ， 2005 。引用于 p 。 
827,879,946,948,950,955,977,978,979,990 [436] Ericson ， 
Christer， “碰撞使用分离轴测试”，游戏开发者大会，2007年3 
月。引用于 p。980 [437] Ericson，Christer， “更多Capcom/ 
----------------------- Page 1203-----------------------
CEDEC Bean-Spilling，”realtimecollisiondetection.net-博客， 
2007年 10月 1日。引用于p。537 [438]埃里克森，克里斯特， 
 “命令你的图形绘制呼叫！”realtimecollisiondetection.net-博 
客，2008年 10月3 日。引用p。803 [439]Ericson，Christer， 
 “优化粒子系统的渲染”，realtimecollisiondetection.net-博客， 
2009年 1月2 日。引用于p。556,568[440]Ericson，Christer， 
 “优化球 - 三角交叉测试”，realtimecollisiondetection.net-博 
客，2010年 12月30 日。引用于p。974 [441]Eriksson，Carl， 
DineshManocha和WilliamV.BaxterIII， “用于更快地展示大型 
静态和动态环境的 HLOD”，载于2001年交互式 3D图形研讨会 
论文集，ACM，第 111-120页， 2001年。引用p。8661074参 
考书目[442] Estevez，Alejandro Conty和 Christopher Kulla， 
 “Production Friendly MicrofacetSheen BRDF”，技术报告， 
SonyImageworks，2017年。358[443]Etuaho，Olli，“Bug-Free 
andFastMobileWebGL”，PatrickCozzi，ed。，WebGL Insights， 
CRCPress，pp.123-137,2015。引用于p。702,796,802,805,814 
[444]Evans，Alex， “动态场景的全局照明的快速近似”，3D图 
形和游戏中的SIGGRAPH高级实时渲染课程，2006年8月。引用 
于 p。454,488 [445] Evans ，Alex 和 Anton Kirczenow ， 
 “LittleBigPlanet2中的体素”，SIGGRAPH在2011年8月的游 
戏实时渲染方面取得进展。571[446]埃文斯，亚历克斯， “从失败 
中学习：对'梦想 PS4'，一个几何密集，绘画UGC游戏的有希望， 
----------------------- Page 1204-----------------------
非常规和被遗弃的渲染器的调查，”SIGGRAPH在游戏中实时渲染 
的进展，8月。引用于。577,679[447]埃文斯，马丁， “使用延迟 
的屏幕空间贴花在其他东西上绘制东西，”博客3。0，2015年2 
月27 日。引用于p。889 [448]Everitt，Cass， “使用GeForce 
和GeForce2进行单通道轮廓渲染”，NVIDIA白皮书，2000年6 
月。656[449]Everitt，Cass， “互动订单独立透明度”，NVIDIA 
白皮书，2001年5月。引用于p。154[450]Everitt，Cass和 Mark 
Kilgard，“用于硬件加速渲染的实用且强大的模板阴影卷”，NVIDIA 
白皮书，2002年3月。引用于p。232[451]Everitt，Cass和John 
McDonald， “BeyondPorting”，SteamDevDays，2014年2 
月。引用p。795,805[452]Everitt，Cass，GrahamSellers，John 
McDonald和Tim Foley， “接近零驾驶员开销”，游戏开发者大 
会，2014年 3月。引用于 p。191,192 [453] Everitt，Cass， 
 “MultiviewRendering， “SIGGRAPH移动图形课程，2016年7 
月。引用于第4页。927,928[454]Ewins，Jon P.，MarcusD.Waller， 
MartinWhite和 PaulF.Lister， “MIP-MapLevelSelectionfor 
Texture Mapping，”IEEE Transactions on Visualization and 
ComputerGraphics，vol。4，不。4月，第317-329页，10月 
至 12月 1998年。引用 p。185[455]Eyles，J.，S.Molnar，J。 
Poulton，T。Greer，A。Lastra，N。England和 L.Westover， 
 “PixelFlow ：The Realization ” ，在 ACM SIGGRAPH / 
EUROGRAPHICS研讨会论文集中图形硬件，ACM，pp.57-68， 
----------------------- Page 1205-----------------------
1997年8月。引用于p。1022[456]Fairchild，MarkD.，Color 
Appearance Models，Third Edition，JohnWiley＆Sons，Inc.， 
2013。引用于p。276,278,291[457]Farin，Gerald，“Triangular 
Bernstein-B'ezier Patches ，” Computer Aided Geometric 
Design，vol。3，不。2，pp.83-127,1986。引用于p。745,781[458] 
法林，杰拉德，计算机辅助几何设计的曲线和曲面 - 实用指南，第 
四 版 ， Academic Press Inc. ， 1996 。 引 用 于 p 。 
718,720,721,724,725,728,732,734,738,742,745,749,754,756,78 
1[459]Farin，GeraldE.，NURBS：从射影几何到实际应用，第二 
版，AK Peters，Ltd.，1999。引用于p。781[460]Farin，Gerald 
和 DianneHansford，CAGD的要点，AK Peters，Ltd.，2000。 
引用于 p。781 [461] Farin，Gerald E.和 Dianne Hansford， 
PracticalLinearAlgebra：AGeometryToolbox，AK Peters，Ltd.， 
2004。Citedon p。102,991参考书目 1075 [462]Fatahalian， 
Kayvon和 RandyBryant，并行计算机体系结构和编程课程，卡内 
基梅隆大学，2017年春季。30,55[463]Fauconneau，M。， “用 
ISPC进行高质量，快速 DX11纹理压缩，“游戏开发者大会，2015 
年3月。引用于p。198[464]Fedkiw，Ronald，JosStam和 Henrik 
WannJensen， “烟雾的视觉模拟”，SIGGRAPH '01：第27届 
计算机图形学和交互技术年会论文集，ACM，第15-22页，8月。 
引用于。649 [465]Fenney，Simon， “使用低频信号调制的纹理 
压缩”，在GraphicsHardware2003，EurographicsAssociation， 
----------------------- Page 1206-----------------------
pp.84-91，July2003.引用于p。196[466]费尔南德斯，安东尼奥 
拉米雷斯和布鲁诺奥利维拉， “GPUTessellation：我们仍然有地 
形掩盖，”Patrick Cozzi和 Christophe Riccio编辑，OpenGL 
Insights，CRCPress，pp.145-161,2012。引用于p。46,879 [467] 
Fernando，Randima， “Percentage-CloserSoftShadows”， 
ACM SIGGRAPH2005草图，ACM，文章编号。2005年8月35 
日。引用于p。250 [468]Ferwerda，James， “计算机图形学的 
早期愿景元素”，IEEE计算机图形和应用，第一卷。21，不。5， 
pp.22-33，9月/ 10月。2001年。引用p。278[469]Feynman， 
Richard，Robert B. Leighton和 MatthewSands，Feynman物 
理学讲座，1963年。可在 FeynmanLectures网站上获得，2006 
年。298,373[470]deFigueiredo，LH， “AdaptiveSamplingof 
Parametric Curves”，Alan Paeth编辑，Graphics Gems V， 
Academic Press，pp.173-178,1995。771[471]Filion，Dominic 
和 RobMcNaughton， “星际争霸 II：效果和技术”，SIGGRAPH 
在3D图形和游戏的实时渲染方面取得进展，2008年8月。引用于 
p。[472]Fisher，F。和A.Woo，“REvs. NHSpecularHighlights”， 
PaulS. Heckbert编辑，Graphics Gems IV，Academic Press， 
pp.388-400,1994。引用p。421 [473]Flavell，Andrew， “Run 
Time Mip-MapFiltering”，GameDeveloper，vol。5，不。11， 
pp.34-43，1998年 11月。引用于 p。185,186 [474] Floater， 
Michael，KaiHormann和G'ezaK'os， “凸多边形上重心坐标的 
----------------------- Page 1207-----------------------
一般构造”，计算数学进展，第一卷。24，不。1-4，pp.311-331， 
2006年 1月。引用于p。970[475]Floater，M。， “Triangular 
B'ezierSurfaces”，技术报告，奥斯陆大学，2011年8月。引用 
于p。741 [476]Fog，Agner， “用C ++优化软件”，软件优化 
资源，2007年。引用于p。815[477]Fogal，Thomas，Alexander 
Schiewe和JensKr¨uger，“基于可扩展GPU的射线引导体绘制的 
分析”，IEEE大型数据分析和可视化研讨会论文集（LDAV13）， 
IEEE计算机学会，第43-51页，2013年。引用p。586[478]Foley， 
Tim，“并行编程模型简介”，SIGGRAPHBeyondProgrammable 
Shading课程，2009年8月。引用于p。815[479]Fong，Julian， 
MagnusWrenninge ， Christopher Kulla 和 Ralf Habel ， 
SIGGRAPH ProductionVolume Renderingcourse，2017年 8 
月。引用于p。589,590,591,592,594,649[480]Forest，Vincent， 
Loic Barthe 和 Mathias Paulin ， “Real-Time Hierarchical 
Binary-SceneVoxelization”，图形，GPU和游戏工具杂志，第一 
卷。14，没有。3，pp.21-34,2011。引用于p。581[481]Forsyth， 
Tom， “比较VIPM方法”，载于Mark DeLoura编辑，Game 
Programming Gems 2 ， Charles River Media ， 
pp.363-376,2001。引用于p。707,711,859 1076参考书目[482] 
Forsyth，Tom， “Impostors：AddingClutter”，MarkDeLoura 
编辑，Game Programming Gems 2，Charles River Media， 
pp.488-496,2001。引用p。561,562[483]Forsyth，Tom， “使 
----------------------- Page 1208-----------------------
阴影缓冲使用多种动态挫折”，在Wolfgang Engel 编辑， 
ShaderX4，Charles RiverMedia，第331-346页，2005年。引 
用p。242 [484]Forsyth，Tom， “极其实用的阴影”，游戏开发 
者大会，2006年3月。引用于p。234,241,242 [485]Forsyth， 
Tom， “线性速度顶点缓存优化”，TomF的技术博客，2006年9 
月28日。引用p。701,705[486]Forsyth，Tom，Shadowbuffers“ ”， 
游戏开发者大会，2007年3月。引用于p。234,242[487]Forsyth， 
汤姆， “暮光之城：一个简单的游戏通用照明模型，”TomF的技 
术博客，2007年3月22 日。引用于p。382,432 [488]Forsyth， 
Tom， “RenderstateChangeCosts”，TomF的技术博客，2008 
年 1月27 日。引用p。795,796,802,803 [489]Forsyth，Tom， 
 “VR，AR和其他现实”，TomF的技术博客，2012年9月16日。 
引用于p。917[490]Forsyth，Tom，“预乘Alpha Part2”，TomF 
的技术博客，2015年3月18日。引用于p。208 [491]Forsyth， 
Tom， “sRGB学习曲线”，TomF的技术博客，2015年 11月30 
日。引用于p。161,162,163[492]Fowles，GrantR.，Introduction 
to Modern Optics，Second Edition，Holt，Reinhart，and 
Winston，1975。引用于p。373 [493]Franklin，Dustin， “基 
于硬件的环境遮挡”，载于Wolfgang Engel，编辑，ShaderX4， 
Charles RiverMedia，第91-100页，2005年。引用于第37页。 
452 [494]Frey，IvoZoltan， “具有双四元数和QTangents的球 
形剥皮”，在ACMSIGGRAPH2011会谈中，文章编号。2011年 
----------------------- Page 1209-----------------------
8月11日。引用于p。209,210,715[495]Frisken，Sarah，Ronald 
N.Perry，Alyn P.Rockwood和Thouis R.Jones， “自适应采样 
距离场：计算机图形形状的一般表示， “在SIGGRAPH'00：第27 
届计算机图形学和交互技术年会论文集，ACM 出版社/ 
Addison-Wesley 出版公司，第249-254页，2000年7月。引用 
于 p。677,751 [496]Frisvad，Jeppe Revall， “从没有标准化的 
3D单位矢量建立正交基础”，图形工具杂志，第一卷。16，不。3， 
pp.151-159,2012。引用于p。75 [497]Fry，Alex， “Frostbite 
中的高动态范围颜色分级和显示”，游戏开发者大会，2月至3月。 
2017年。引用 p。283,287,288,290 [498] Frykholm，Niklas， 
 “BitSquid低级动画系统”，Autodesk Stingray博客，2009年 
11月20 日。引用于p。715,905 [499]弗里克霍尔姆，尼克拉斯， 
 “什么是万向节锁，我们为什么还要担心呢？”AutodeskStingray 
博客，2013年3月15日。引用于p。73[500]Fuchs，H.，ZM Kedem 
和 BFNaylor， “关于先验树结构的可见表面生成”，计算机图形 
学（SIGGRAPH '80 Proceedings），第一卷。14，没有。3， 
pp.124-133，1980年7月。引用于 p。823 [501] Fuchs，H.， 
GDAbram和 EDGrant， “近实时阴影显示刚性物体”，计算机 
图形学（SIGGRAPH '83 Proceedings），第一卷。17，不。3， 
pp.65-72，1983年 7月。引用于 p。823参考书目 1077 [502] 
Fuchs，H.，J。Poulton，J。Eyles，T。Greer，J。Goldfeather， 
D。Ellsworth，S。Molnar，G。Turk，B。Tebbs，andL.Israel， 
----------------------- Page 1210-----------------------
 “Pixel-Planes5：使用处理器增强存储器的异构多处理器图形系 
统， “计算机图形学（SIGGRAPH'89Proceedings），vol。23， 
不。3，pp.79-88，1989年7月。引用于p。8,1026[503]Fuhrmann， 
Anton L.，EikeUmlauf和Stephan Mantler， “森林渲染的极端 
模型简化， “在第一届 Eurographics 自然现象会议论文集， 
EurographicsAssociation，pp.57-66,2005。引用于p。563[504] 
Fujii，Yasuhiro， “Oren-Nayar反射模型的微小改进”，http： 
// mimosa-pudica.net，2013年 10月9 日。引用于p。354[505] 
F？unfzig，C.，K.Müuller，D。Hansford和G.Farin， “GPU上 
切线平面连续曲面的 PNG1三角形”，图形界面2008，加拿大信 
息处理学会，pp 。引用次数：219-226,2008。747 [506]Fung， 
James，GP“U上的计算机视觉”，载于MattPharr编辑，GPUGems 
2，Addison-Wesley，pp.649-666,2005。引用于p。521 [507] 
Funkhouser，ThomasA.，建筑模型交互式可视化的数据库和显示 
算法，博士论文，加州大学伯克利分校，1993年。引用于p。866 
[508]Funkhouser，ThomasA.，和Carlo H.S'equin， “复杂虚 
拟环境可视化期间交互式帧速率的自适应显示算法”，SIGGRAPH 
'93：第20届计算机图形和交互技术年会论文集，ACM，第247-254 
页，1993年8月。引用于p。710,864,865,866[509]F¨urst，Ren'e， 
Oliver Mattausch 和 Daniel Scherzer ， “Real-Time Deep 
ShadowMaps”，Wolfgang Engel编辑，GPUPro4，CRC出版 
社，第 253 页-264,2013。引用于 p。258 [510] Gaitatzes， 
----------------------- Page 1211-----------------------
Athanasios 和 Georgios Papaioannou ， “Progressive 
Screen-SpaceMultichannelSurfaceVoxelization”，Wolfgang 
Engel编辑，GPUPro4，CRC出版社，第137-154页，2013年。 
引用于p。582[511]Galeano，David， “在Turbulenz引擎中渲 
染优化”，PatrickCozzi编辑，WebGL Insights，CRC出版社， 
第 157-171页，2015年。795,796,802，803 [512]Gallagher， 
Benn和 MartinMittring， “在 UE4中构建Paragon”，游戏开 
发者大会，2016年3月。引用于p。527,556,637[513]Garcia， 
Ismael，MateuSbert和 L'azl'oSzirmay-Kalos，“使用 Billboard 
Clouds进行树木渲染”，第三届匈牙利计算机图形和几何会议， 
2005年 1月。563[514]Garland，Michael和 PaulS.Heckbert， 
 “地形和高度场的快速多边形逼近”，技术报告CMU-CS-95-181， 
卡内基梅隆大学，1995年。引用于p。708,877 [515]Garland， 
Michael和 PaulS.Heckbert， “使用二次误差测量的表面简化”， 
SIGGRAPH '97：第24届计算机图形学与交互技术年会论文集， 
ACM 出版社/Addison-Wesley 出版社公司，第209-216页，1997 
年8月。引用于p。708[516]加兰，迈克尔，和 PaulS.Heckbert， 
 “使用二次误差度量标准用颜色和纹理简化表面”，参见IEEE 
Visualization 98，IEEEComputerSociety，pp.263-269，1998 
年 7 月。引用于 p。706,707,708 [517] Garland，Michael， 
Quadric-Based PolygonalSurfaceSimplification，PhDthesis， 
Technical Report CMU-CS-99-105 ， Carnegie Mellon 
----------------------- Page 1212-----------------------
University，1999。引用于p。709[518]Gautron，Pascal，Jaroslav 
Kriv'anek，SumantaPattanaik和 KadiBouatouch， “用于精确 
和高效渲染的新颖半球基础”，关于第 15届 Eurographics协会会 
议论文集，EurographicsAssociation，pp.321-330，2004年6 
月。引用于p。404 1078参考书目[519]Geczy，George， “3D 
世界中的2D编程：使用 DirectX8Direct3D开发2D游戏引擎”， 
Gamasutra，2001年6月。引用于p。550[520]Gehling，Michael， 
 “DynamicSkyscapes”，Game Developer，vol。13，不。3， 
pp.23-33，2006年3月。引用于p。549[521]Geiss，Ryan，“使 
用GPU生成复杂的程序性地形”，在 HubertNguyen编辑，GPU 
Gems3，Addison-Wesley，pp.7-37,2007。引用于p。171[522] 
Geiss ，Ryan 和 Michael Thompson ， “NVIDIA 演示团队 
Secrets-Cascades”，游戏开发者大会，2007年3月。引用于p。 
171,571[523]Geldreich，Rich，“crunch/crnlibv1.04，”GitHub 
repository，2012。引用于p。870[524]总务管理局， “政府采购 
中使用的颜色”，文件编号FED-STD-595C，2008年 1月16日。 
引用于第4页。349[525]Gerasimov，Philipp， “全方位阴影映 
射”，在 RandimaFernando编辑，GPUGems，Addison-Wesley， 
第 193-203页，2004年。引用于p。234[526]Gershun，Arun， 
 “光场”，莫斯科，1936年，由P.Moon和G.Timoshenko翻译， 
数学和物理学杂志，第一卷。18，不。2，pp.51-151,1939。引用 
于p。379[527]吉布森，史蒂夫， “亚像素字体渲染的遥远起源”， 
----------------------- Page 1213-----------------------
亚像素字体渲染技术，2006年8月4日。引用于p。675[528]Giegl， 
Markus和 MichaelWimmer，“Unpopping：解决平滑离散 LOD 
过渡的图像 - 空间混合问题”，计算机图形论坛，第一卷。26，不。 
1，pp.46-49,2007。引用于p。856[529]Giesen，Fabian， “查 
看 FrustumCulling”，ryg博客，2010年 10月17日。引用于p。 
983,986[530]Giesen，Fabian， “2011年图形管道之旅”，ryg 
博 客 ， 2011 年 7 月 9 日 。 引 用 于 p 。 
32,42,46,47,48,49,52,53,54,55,141,247,684,701,784,1040 [531] 
Giesen，Fabian， “FastBlurs1”，ryg博客，7月30 日，2012。 
引用于p。518 [532]Gigus，Z.，J。Canny和 R.Seidel， “高效 
计算和表示多面体对象的方面图”，IEEETransactionsonPattern 
Analysis and Machine Intelligence ，vol 。 13 ，不。6 ， 
pp.542-551,1991。引用于 p。831 [533]Gilabert，Mickael和 
NikolayStefanov， “DeferredRadianceTransferVolumes”， 
游戏开发者大会，2012年 3月。引用于 p。478,481 [534]van 
Ginneken，B.，M。Stavridi和JJ Koenderink， “粗糙表面的漫 
反射和镜面反射”，AppliedOptics，vol。37，不。1998年 1月 
1日。引用于p。335 [535]Ginsburg，Dan和 DaveGosselin， 
 “Dynamic Per-Pixel LightingTechniques”，Mark De-Loura 
编辑，Game Programming Gems 2，Charles River Media， 
pp.452-462,2001。引用于p 。211,221 [536]Ginsburg，Dan， 
 “将源2移植到Vulkan”，SIGGRAPH下一代API课程概述，2015 
----------------------- Page 1214-----------------------
年8月。引用p。814 [537]Giorgianni，EdwardJ.和Thomas E. 
Madden，DigitalColor Management：EncodingSolutions， 
Second Edition，John Wiley＆Sons，Inc.，2008。引用于p。 
286,291[538]Girshick，Ahna，Victoria Interrante，SteveHaker 
和Todd Lemoine， “线条方向问题：在3D线条图中使用主要方 
向的争论”，在第一届非真实感国际研讨会论文集中动画与渲染， 
ACM，第43-52页，2000年6月。引用于 p。672 [539]Gj.l， 
Mikkel和 MikkelSvendsen， “内心的渲染”，游戏开发者大会， 
2016年3月。引用于p。521,524,527,572,587,604,609,892,1010 
[540]Glassner，AndrewS.，ed。，GraphicsGems，Academic 
Press，1990。Citedonp。102,991参考书目1079[541]Glassner， 
AndrewS.， “计算3D模型的表面法线，“在AndrewS.Glassner 
编辑，GraphicsGems，Academic Press，pp.562-566,1990。引 
用于p。695[542]Glassner，Andrew， “从非结构化多边形列表 
构建顶点法线”，在PaulS.Heckbert编辑，GraphicsGems IV， 
Academic Press，pp.60-73,1994。引用于p。691,692,695[543] 
Glassner，Andrew S.，Principlesof DigitalImageSynthesis， 
vol。1，MorganKaufmann，1995年。引用于p。372,512,1010 
[544] Glassner ，Andrew S. ，Principles of Digital Image 
Synthesis，vol。2，MorganKaufmann，1995年。引用于 p。 
268,271,280,372,512 [545]Gneiting，A。， “实时几何缓存”， 
ACM SIGGRAPH2014会谈，ACM，文章编号。2014年8月49 
----------------------- Page 1215-----------------------
日。引用于p。92[546]Gobbetti，Enrico和 FabioMarton，“分 
层点云”，基于点的图形研讨会，2004年6月。引用于p。573[547] 
Gobbetti，E.，D。Kasik和S.-E.尹 “大规模模型可视化的技术策 
略”， “固体与物理建模ACM研讨会”，2008年6月。879[548] 
高盛，罗纳德，“三维空间的两条线的交叉”，AndrewS.Glassner 
编辑，图形宝石，学术出版社，p。304,1990。引用于p。990[549] 
Goldman，Ronald， “三架飞机的交叉点”，AndrewS.Glassner 
编辑，GraphicsGems，Academic Press，p。305,1990。引用于 
p 。 990 [550] Goldman ， Ronald ， “Matrices and 
Transformations”，AndrewS.Glassner，ed。，GraphicsGems， 
Academic Press，pp.472-475,1990。引用于 p。75 [551] 
Goldman，Ronald，“B'ezierCurves的某些属性”，载于Andrew 
S.Glassner 编 辑 ， Graphics Gems ， Academic Press ， 
pp.587-593,1990。722[552]Goldman，Ronald， “从转型矩阵 
中恢复数据”，JamesArvo编辑，GraphicsGemsII，Academic 
Press，pp.324-331,1991。引用于p。74[553]Goldman，Ronald， 
 “分解线性和仿射变换”，DavidKirk编辑，GraphicsGems III， 
Academic Press，pp.108-116,1992。74 [554] Goldman ， 
Ronald，单变量和双变“     量Bernstein基函数的恒等式”，Alan Paeth 
编辑，GraphicsGemsV，Academic Press，pp.149-162,1995。 
引用于p。781[555]Gollent，M。，景观创造和渲染在“          REDengine 
3”，游戏开发者大会，2014年3月。引用于p。262,263,873[556] 
----------------------- Page 1216-----------------------
Golub，Gene 和 Charles Van Loan，Matrix Computations， 
FourthEdition，Johns HopkinsUniversityPress，2012.Citonp。 
102[557]Golus，Ben，“抗锯齿阿尔法测试：深奥的阿尔法覆盖”， 
Medium.com网站，2017年8月12日。引用于p。204,205,206,207 
[558]Gomes，Abel，IrinaVoiculescu，JoaquimJorge，Brian 
Wyvill 和 Callum Galbraith，Implicit Curves and Surfaces： 
Mathematics，Data Structures and Algorithms，Springer， 
2009。引用于 p。583,683,751,753,781,944 [559]Gonzalez， 
RafaelC.和 RichardE.Woods，DigitalImageProcessing，Third 
Edition ， Addison-Wesley ， 2007 。 130,543,661 [560] 
Gonzalez-Ochoa，C。和 D.Holder， “未知的水技术”，游戏开 
发者大会，2012年 3月。引用于 p。879 [561]Gooch，Amy， 
BruceGooch，PeterShirley和 ElaineCohen， “自动技术插图 
的非照片级真实照明模型”，SIGGRAPH'98：第25届计算机图形 
学和交互技术年会论文集，ACM ，pp.447-452，1998年7月。 
引用于p。1031080参考书目[562]Gooch，Bruce，Peter-PikeJ. 
Sloan，AmyGooch，PeterShirley，和 RichardRiesenfeld，“交 
互式技术插图”，1999年 “交互式3D图形研讨会论文集”，ACM， 
第31-38页，1999年。656,667 [563]Gooch，Bruce或Amy， 
和Amy或 BruceGooch，非真实感渲染，AK Peters，Ltd.，2001。 
引用于p。652,678[564]Good，Otavio和ZacharyTaylor， “使 
用球面谐波光图优化光子追踪”，参见ACM SIGGRAPH2005草 
----------------------- Page 1217-----------------------
图，文章编号。2005年8月53日。引用于p。475 [565]Goodwin， 
Todd，IanVollick和Aaron Hertzmann， “Isophote距离：艺术 
中风厚度的阴影方法”，第五届非真实感动画和渲染国际研讨会论 
文集，ACM，第 53-62页，2007年8月。引用于p。657,667[566] 
Goral，Cindy M.，KennethE.Torrance，DonaldP.Greenberg 
和 BennettBattaile， “模拟漫反射光之间光的相互作用，”计算 
机图形学（SIGGRAPH'84Proceedings），第一卷。18，不。3， 
pp.112-222，1984年7月。引用于p。442 [567]Gortler，Steven 
J.，RadekGrzeszczuk，RichardSzeliski和 MichaelF.Cohen， 
 “The Lumigraph”，SIGGRAPH '96：第23届计算机图形学和 
交互技术年会论文集，ACM，第43页-54，1996年8月。引用于 
p。549 [568]Gosselin，DavidR.，PedroV. Sander和Jason L. 
Mitchell， “Real-TimeTexture-SpaceSkinRendering”，作者： 
Wolfgang Engel，编辑，ShaderX3，Charles River Media，第 
171-183页， 2004年。引用p。635[569]Gosselin，DavidR.， 
 “实时皮肤渲染”，游戏开发者大会，2004年3月。引用于 p。 
634,635 [570] Goswami，Prashant，Yanci Zhang ，Renato 
Pajarola和 EnricoGobbetti， “使用多路 kd树的高质量交互式渲 
染海量模型，”PacificGraphics2010，2010年9月。引用于p。 
574[571]Gotanda，Yoshiharu，“StarOcean4：FlexibleShader 
Management and Post-Processing ” ，Game Developers 
Conference，Mar。2009.引用于 p。286 [572] Gotanda， 
----------------------- Page 1218-----------------------
Yoshiharu， “视频游戏的电影模拟”，2010年7月的电影和游戏 
制作课程中的SIGGRAPH色彩增强和渲染。引用于 p。286 [573] 
Gotanda，Yoshiharu， “超越简单的基于物理的 Blinn-Phong模 
型的实时，”SIGGRAPH基于物理的阴影在理论和实践课程，2012 
年8月。引用于p。354,364,421[574]Gotanda，Yoshiharu，“为 
新游戏机设计反射模型”，SIGGRAPH基于物理学的理论和实践中 
的阴影，2014年8月。引用于p。331,354,355 [575]Gotanda， 
Yoshiharu，MasakiKawase和 MasanoriKakimoto，SIGGRAPH 
实时渲染基于物理的光学效应理论与实践课程，2015年8月。引用 
于 p。543 [576] Gottschalk，S.，MC Lin和 D. Manocha， 
 “OBBTree：快速干扰检测的分层结构”，SIGGRAPH'96：第23 
届计算机图形学和交互技术年会论文集，ACM，pp1996年8月第 
171-180号。引用第 11页。946,980 [577]Gottschalk，Stefan， 
碰撞查询使用定向边界框，博士论文，计算机科学系，北卡罗来纳 
大学教堂山分校，2000年。引用p。947,951,980[578]Gouraud， 
H。， “曲面的连续着色”，IEEETransactions onComputers， 
vol。C-20，pp.623-629，1971年6月。引用于p。118[579]格 
林，克里斯， “高效的自阴影光能传递法线贴图， “SIGGRAPH高 
级实时渲染3D图形和游戏课程，2007年8月。引用于p。403参 
考书目 1081[580]Green，Chris， “用于矢量纹理和特殊效果的 
改进的Alpha测试放大率”，SIGGRAPH高级实时渲染3D图形和 
游戏课程，2007年8月。引用于p。206,677,678,890[581]Green， 
----------------------- Page 1219-----------------------
D.，andD.Hatch，“FastPolygon-CubeIntersectionTesting，”， 
Alan Paeth，ed。，Graphics Gems V ，Academic Press， 
pp.375-379,1995 。引用p。974[582]Green，Paul，Jan Kautz 
和 Fr'edoDurand， “环境地图渲染的高效反射和可见性近似”， 
计算机图形学论坛，第一卷。26，不。3，pp.495-502,2007。引 
用于p。398,417,424,466,471[583]格林，罗宾，“球形谐波照明： 
坚韧不拔的细节”，游戏开发者大会，2003年3月。引用于 p。 
401,430 [584]格林，西蒙， “愚蠢的OpenGL着色器技巧”，游 
戏开发者大会，2003年3月。引用于p。537,539,540[585]Green， 
Simon， “使用图形硬件的总面积表”，游戏开发者大会，2003 
年3月。引用于p。188[586]格林，西蒙， “次表面散射的实时近 
似”，RandimaFernando编辑，GPUGems，Addison-Wesley， 
第263-278页，2004年。引用于p。633,635,638,639[587]Green， 
Simon， “实施改进的 Perlin噪声”，载于Matt Pharr，编辑， 
GPUGems2，Addison-Wesley，pp.409-416,2005。引用于p.6。 
199[588]格林，西蒙， “DirectX10/11视觉效果”，游戏开发者 
大会，2009年3月。引用于p。518[589]格林，西蒙， “屏幕空 
间流体渲染游戏”，游戏开发者大会，2010年3月。引用于 p。 
520,569[590]Greene，Ned，“环境映射和世界预测的其他应用”， 
IEEE计算机图形和应用，第一卷。6，不。11，pp.21-29，1986 
年 11月。引用于p。410,414,424 [591]Greene，Ned，Michael 
Kass和GavinMiller， “层次Z缓冲区可见性”，SIGGRAPH'93： 
----------------------- Page 1220-----------------------
第 20届计算机图形学和交互技术年会论文集，ACM，第231页 
-238，1993年8月。引用于 p。846,847,1015 [592]Greene， 
Ned， “检测矩形实体和凸多面体的交点”，PaulS. Heckbert编 
辑，Graphics Gems IV，Academic Press，pp.74-82,1994。在 
第 946[593]Greene，Ned，复杂环境的分级渲染，博士论文，技 
术报告UCSC-CRL-95-27，加州大学圣克鲁兹分校，1995年6月。 
引用于p.6。846,847[594]Greger，Gene，PeterShirley，Philip 
M. Hubbard，和 Donald P. Greenberg ， “The Irradiance 
Volume”，IEEE计算机图形和应用，第一卷。18，不。2，pp.32-43， 
Mar。/Apr。1998年。引用p。487 [595]Gregorius，Dirk， “凸 
多面体之间的分离轴测试”，游戏开发者大会，2013年3月。引用 
于p。987 [596]Gregorius，Dirk， “实施QuickHull”，游戏开 
发者大会，2014年3月。引用于p。950,951 [597]Gregorius， 
Dirk， “物理模拟的强大接触创造”，游戏开发者大会，2015年3 
月。引用于p。947[598]Grenier，Jean-Philippe， “基于物理的 
镜头光晕”，Autodesk Stingray博客，2017年7月3 日。引用 
于 p。524,526 [599]Grenier，Jean-Philippe， “关于屏幕空间 
HIZ追踪的注释，”AutodeskStingray博客，2017年8月14日。 
引用于 p。508 1082 参考书目 [600] Gribb ，Gil 和 Klaus 
Hartmann， “从世界观投影矩阵中快速提取观看平面飞机，” 
gamedevs.org，2001年6月。引用于p。984[601]Griffin，Wesley 
和 MarcOlano， “纹理压缩的客观图像质量评估”，参见ACM 
----------------------- Page 1221-----------------------
SIGGRAPH交互式3D图形和游戏研讨会第18次会议记录，ACM， 
第 119-126页，3月。 1999年。引用 p。198[602]Griffiths， 
Andrew，“Real-TimeCellularTexturing，”inWolfgangEngel， 
ed。，ShaderX5，CharlesRiverMedia，pp.519-532,2006。引 
用于p。199[603]Grimes，Bronwen，“ShadingaBigger，Better 
Sequel：Techniques in Left 4 Dead 2”，Game Developers 
Conference，2010 年 3 月。引用于 p。366 [604] Grimes， 
Bronwen， “构建推动反恐精英的内容：全球进攻性经济”，游戏 
开发者大会，2014年3月。引用于p。366 [605]格里茨，拉里， 
 “ShaderAntialiasing”，高级RenderMan：为动画创作CGI， 
MorganKaufmann，第11章，1999年。另外（作为 “着色语言 
中的基本抗锯齿”）在SIGGRAPH高级 RenderMan：超越伴奏课 
程，1999年8月。引用页。200 [606]Gritz，Larry， “光与表面 
的秘密生活”，SIGGRAPH高级 RenderMan2：到 RI无限及超越 
当然，2000年7月。同样在“照明模型和光”中，在高级 RenderMan 
中：创建CGIfor Motion图片，MorganKaufmann，1999年。 
引用于p。382[607]Gritz，Larry和 Eugened'Eon， “线性的重 
要性”，HubertNguyen编辑，GPUGems3，Addison-Wesley， 
pp.529-542,2007。引用于p。161,166,184[608]Gritz，Larry， 
ed。，“OpenShadingLanguage1.9：LanguageSpecification，” 
Sony Pictures Imageworks Inc.，2017。引用于 p。37 [609] 
Gronsky，Stefan， “照明食品”，SIGGRAPH任何人都可以烹饪 
----------------------- Page 1222-----------------------
- 里面 Ratatouille的厨房课程，2007年8月。引用p。638[610] 
Gruen，Holger， “Hybrid Min/ Max Plane-Based Shadow 
Maps”，Wolfgang Engel编辑，GPU Pro，AK Peters，Ltd。， 
第447-454页，2010年。252 [611]Gruen，Holger和 Nicolas 
Thibieroz，“使用Dx11链接列表的OIT和间接照明”，游戏开发 
者大会，2010年3月。引用于p。[612]Gruen，Holger， “优化 
的扩散景深解算器（DDOF），”游戏开发者大会，2011年3月。 
引用于p。535[613]Gruen，Holger，“ConstantBufferswithout 
Constant Pain”，NVIDIAGameWorks博客，2015年 1月 14 
日。引用于p。795[614]Gr¨un，Holger， “平滑的N-Patches”， 
载于Wolfgang Engel，编辑，ShaderX5，CharlesRiverMedia， 
第 5-22页，2006年。引用于第7页。747[615]Gr¨un，Holger， 
 “实施快速 DDOF求解器”，Eric Lengyel编辑，Game Engine 
Gems2，AK Peters，Ltd.，pp.119-133,2011。引用于p。535[616] 
Gu，Xianfeng，StevenJ.Gortler和 HuguesHoppe，“Geometry 
Images”，ACMTransactionsonGraphics （SIGGRAPH2002）， 
vol。21，不。3，pp.355-361,2002。引用于 p。566 [617] 
Guennebaud，Ga¨el，Lo¨.cBarthe和 Mathias Paulin， “高质 
量自适应软阴影映射”，计算机图形论坛，第一卷。26，不。3， 
pp.525-533,2007。引用于p。252[618]Guenter，B.，J。Rapp 
和 M. Finch， “GPU 着色器中的符号分化”，技术报告 
MSR-TR-2011-31，Microsoft，2011年3月。引用于p。1017[619] 
----------------------- Page 1223-----------------------
Guenter，Brian，MarkFinch，StevenDrucker，DesneyTan和 
JohnSnyder，“Foveated3DGraphics”，ACMTransactionson 
Graphics，vol。31，不。6，文章编号。164,2012。引用于p。924， 
931参考书目 1083[620]Guerrette，Keith， “移动天堂”，游戏 
开发者大会，2014年 3 月。引用于 p。617 [621] Guertin， 
Jean-Philippe，Morgan McGuire和 Derek Nowrouzezahrai， 
 “快速稳定的特征感知运动模糊滤波器”，技术报告，NVIDIA，2013 
年11月。引用于p。537,542,543[622]Guigue，Philippe和Olivier 
Devillers，“使用方向谓词的快速和稳健的三角形 - 三角形重叠测 
试”，图形工具的期刊，第一卷。8，不。1，pp.25-42,2003。引 
用于 p。972,974 [623] Gulbrandsen，Ole， “Artist Friendly 
MetallicFresnel”，计算机图形技术杂志，第一卷。3，不。4， 
pp.64-72,2014。引用于p。320 [624]盖蒙，梅尔， “火焰技术： 
玩火，”游戏开发者，第一卷。7，不。2，pp.23-27，2000年2 
月。引用于p。554[625]Haar，Ulrich和SebastianAaltonen， 
 “GPU驱动的渲染管道”，SIGGRAPH在游戏中实时渲染的进展， 
2015年8月。引用于p。246,247,263,833,848,849,850,851,905 
[626]Habel，Ralf，BogdanMustata和 MichaelWimmer， “高 
效球形谐波照明与 PreethamSkylight模型”，在Eurographics 
2008-Short Papers 中 ，  Eurographics Association ， 
pp.119-122,2008。引用于 p。[627] Habel，Ralf和 Michael 
Wimmer， “高效辐照度法线图”，2010年ACM SIGGRAPH交 
----------------------- Page 1224-----------------------
互式3D图形和游戏研讨会论文集，ACM，第189-195页，2010 
年2月。引用于p。404,475 [628]Hable，John，“Uncharted2： 
HDRLighting”，游戏开发者大会，2010年3月。引用于p。286,288 
[629]Hable，John， “为什么Reinhard去饱和你的黑人”，电影 
世界博客，2010年5月17日。引用p。288[630]Hable，John， 
 “为什么胶片曲线会使你的黑人饱和，”电影世界博客，2010年5 
月24 日。引用于p。288 [631]Hable，John， “Uncharted2： 
CharacterLightingandShading，”SIGGRAPH在2010年7月 
的游戏过程中实时渲染方面取得了进展。357,635 [632]Hable， 
John，“下一代人物：从面部扫描到面部动画”，游戏开发者大会， 
2014年3月。引用于p。466 [633]Hable，John， “简单快速的 
球形谐波旋转”，电影世界博客，2014年7月2 日。引用于p。 
401 [634]Hable，John， “FilmicTonemappingwith Piecewise 
PowerCurves”，FilmicWorlds Blog，2017年 3月26 日。引 
用于p。286[635]Hable，John，Minimal“ ColorGradingTools”， 
FilmicWorlds Blog，2017年 3月28 日。引用于p。290 [636] 
Hadwiger，Markus，Christian Sigg，Henning Scharsach， 
KhatjaB¨uhler和 MarkusGross， “离散等值面的实时光线投射和 
高级阴影”，计算机图形学论坛，第一卷。20，不。3， 
pp.303-312,2005。引用于p。583[637]Haeberli，P。和K.Akeley， 
 “累积缓冲器：高质量渲染的硬件支持”，计算机图形学（SIGGRAPH 
'90Proceedings），第一卷。24，不。4，pp.309-318，1990年 
----------------------- Page 1225-----------------------
8月。引用于p。139,529,537,547[638]Haeberli，Paul和 Mark 
Segal， “纹理映射作为基本绘图原始”，第4届 Eurographics渲 
染研讨会，EurographicsAssociation，pp.259-266，1993年6 
月。引用于p 。200 1084参考书目[639]Hagen，MargaretA.， 
 “如何制作视觉逼真的3D显示器”，计算机图形学，第一卷。25， 
不。2，pp.76-81，1991年4月。引用于p。554[640]Haines， 
Eric， “EssentialRayTracingAlgorithms”，Andrew Glassner 
编辑，“RayTracing简介”，Academic PressInc.，第2章，1989 
年。引用于 p。955,959,961,969 [641] Haines，Eric， “Fast 
Ray-ConvexPolyhedronIntersection，”，JamesArvo，ed。， 
GraphicsGemsII，Academic Press，pp.247-250,1991。961[642] 
Haines，Eric，“PointinPolygonStrategies”，PaulS.Heckbert 
编辑，Graphics Gems IV，Academic Press，pp.24-46,1994。 
962,966,968,969,970[643]Haines，Eric和StevenWorley，“执 
行中等质量渲染时的快速，低内存Z缓冲”，图形工具杂志，第一 
卷。1，不。3，pp.1-6,1996。引用于p。803[644]Haines，Eric， 
 “Soft PlanarShadows UsingPlateaus”，图形工具杂志，第一 
卷。6，不。1，pp.19-27,2001。也在[112]中收集。引用p。229[645] 
Haines，Eric，“交互式3D图形”，UdacityCourse291，于2013 
年5月推出。引用p。1048[646]Haines，Eric，“60Hz，120Hz， 
240Hz......”，实时渲染博客，2014年 11月5日。引用于p。1011 
[647]海恩斯，埃里克， “三角形的限制”，实时渲染博客，2014 
----------------------- Page 1226-----------------------
年 11月10日。引用于p。688,695 [648]Haines，Eric， “GPU 
喜欢预乘，”实时渲染博客，2016年 1月10日。引用于p。160,208 
[649]Haines，Eric， “PNGPuzzle”，实时渲染博客，2016年2 
月19日。引用于p。160[650]Haines，Eric， “Minecon2016 
报告”，实时渲染博客，2016年9月30 日。引用于p。920[651] 
Hakura，Ziyad S.和Anoop Gupta， “纹理映射缓存架构的设计 
与分析”，载于 “第24届国际计算机体系结构研讨会论文集”， 
ACM，第 108-120页，1997年6月。引用p。997,1007,1017[652] 
Hall，Chris，RobHall和 DaveEdwards， “在汽车2中渲染”， 
SIGGRAPH在3D图形和游戏课程中实时渲染方面取得进展，2011 
年8月。245,246,937[653]Hall，Roy，IlluminationandColorin 
ComputerGeneratedImagery，Springer-Verlag，1989。1010 
[654] Hall ，Tim ， “如何使用 OpenGL 渲染镜子 ” ， 
comp.graphics.api.opengl新闻组，1996年8月。引用于p。505 
[655] Halstead，Mark，Michal Kass和Tony DeRose， “使用 
Catmull-Clark曲面的高效，公平插值”，SIGGRAPH'93：第20 
届计算机图形学和交互技术年会论文集，ACM，第35页-44，1993 
年 8月。引用于 p。762,763,778 [656] Hamilton，Andrew 和 
KennethBrown， “摄影测量和星球大战前线”，游戏开发者大会， 
2016年3月。引用于p。366[657]Hammon，Earl，Jr。， “用 
于GGX +Smith微表面的 PBR漫反射照明”，游戏开发者大会， 
2月至3月。2017年。引用p。331,334,337,342,355[658]Han， 
----------------------- Page 1227-----------------------
Charles，BoSun，RaviRamamoorthi和 EitanGrinspun， “频 
域法线贴图过滤”，ACM图形交易 （SIGGRAPH2007），第一卷。 
26，不。3，pp.28：1-28::11，2007年7月。引用于p。369,370 
[659]Han，S。和P.Sander， “动画场景中减少过度绘制的三角 
重新排序”，第20届ACM SIGGRAPH交互式3D图形和游戏研 
讨会论文集，ACM，第23-27页，2016.引用于p。831参考书目 
1085[660]Hanika，Johannes， “Manuka：Weta Digital的光 
谱渲染器”，SIGGRAPH路径追踪生产课程，2017年8月。引用 
于p。278,280,311,591[661]Hanrahan，P。和P.Haeberli，Direct“ 
WYSIWYG 3DandShapeuringon3DShapes， “计算机图形学 
 （SIGGRAPH'90Proceedings），第一卷。24，不。4，pp.215-223， 
1990年8月。引用于p。942[662]Hanrahan，Pat和Wolfgang 
Krueger， “地表散射引起的分层表面反射”，SIGGRAPH'93：第 
20届计算机图形学和交互技术年会论文集，ACM，第 165-174页， 
8月。1993年。引用 p。353,354 [663] Hanson，Andrew J.， 
VisualizingQuaternions，MorganKaufmann，2006。引用于p。 
102[664]Hapke，B。， “月球表面的理论光度学函数”，地球物 
理研究期刊，第一卷。68，不。15，pp.4551-4586，1963年8 
月1日。引用于p。314[665]Harada，T.，J。McKee和J.Yang， 
 “转发+：将延迟照明提升到新的水平”，在 Eurographics 
2012-Short Papers，EurographicsAssociation，pp.5-8，May 
2012.Cited在第 895[666]Harada，T。， “转发+的2.5D剔除”， 
----------------------- Page 1228-----------------------
参见 SIGGRAPHAsia 2012技术简报，ACM，第18页，第 1至 
18页，第4页，2012年 12月。897 [667]Harada，Takahiro， 
Jay McKee和JasonC.Yang， “前进+：迈向实时电影式阴影的一 
步”，Wolfgang Engel编辑，GPUPro4，CRC出版社，第 115-135 
页，2013年。引用于p。887,895,896,897,904[668]Hargreaves， 
Shawn， “DeferredShading”，游戏开发者大会，2004年3月。 
引用于 p。882,884,886 [669] Hargreaves，Shawn 和 Mark 
Harris， “DeferredShading”，NVIDIA开发者大会，2004年6 
月29 日。引用于p。882,884 [670]Harris，MarkJ.和Anselmo 
Lastra， “Real-TimeCloud Rendering，”ComputerGraphics 
Forum，vol。20，不。3，pp.76-84,2001。引用于p。556,617[671] 
Hart，Evan，DaveGosselin和John Isidoro， “使用 Direct3D 
和OpenGL进行顶点着色”，游戏开发者大会，3月 2001年。引 
用p。659[672]Hart，Evan，“UHDColorforGames”，NVIDIA 
白皮书，2016年6月。引用于p。161,165,278,281,283,287,290 
[673] Hart，JC，DJ Sandin和 LH Kauffman， “Ray Tracing 
Deterministic3-DFractals，”ComputerGraphics （SIGGRAPH 
'89 Proceedings），vol。23，不。3，pp.289-296,1989。引用 
于 p。752 [674]Hart，John C.，George K.Francis和 LouisH. 
Kauffman， “可视化四元数轮换”，ACM Transactions on 
Graphics，vol。13，不。3，pp.156-276,1994。引用于p。102[675] 
Hasenfratz，Jean-Marc，Marc Lapierre，Nicolas Holzschuch 
----------------------- Page 1229-----------------------
和 Fran.coisSillion，“实时软阴影算法综述”，计算机图形学论坛， 
第一卷。22，不。4，pp.753-774,2003。引用于 p。265 [676] 
Hasselgren，J.，T。Akenine-M'oller和 L.Ohlsson， “保守光栅 
化”，载于 MattPharr，编辑，GPUGems2，Addison-Wesley， 
pp.677-690,2005。引用于p。1001 [677] Hasselgren，J.，T。 
Akenine-M'oller，and S. Laine， “A Family of Inexpensive 
SamplingSchemes，”ComputerGraphics Forum，vol。24， 
不。4，pp.843-848,2005。引用于p。146[678]Hasselgren，J。 
和 T. Akenine-M'oller， “高效多视图光栅化结构”，第17届 
Eurographics 协会会议论文集，Eurographics Association， 
pp.61-72，2006年6月。引用p。928[679]Hasselgren，J。和 
T.Akenine-M'oller， “高效深度缓冲压缩”，图形硬件2006， 
EurographicsAssociation，pp.103-110，2006年9月。引用于 
p。997,1009,1016 1086参考书目[680] Hasselgren，J。和T. 
Akenine-M'oller， “PCU：The ProgrammableCulling Unit，” 
ACM Transactions on Graphics ，vol 。 26 ，不。 3 ， 
pp.92.1-91.20,2007。引用于p。252 [681]Hasselgren，J.，M。 
Andersson，J。Nilsson和T.Akenine-M'oller，“ACompressed 
DepthCache，”Journal ofComputerGraphicsTechniques， 
vol。1，不。1，pp.101-118,2012。引用于 p。1009 [682] 
Hasselgren，Jon，Jacob Munkberg和 KarthikVaidyanathan， 
 “离散和运动模糊的实用分层重建”，计算机图形技术杂志，第一 
----------------------- Page 1230-----------------------
卷。4，不。2，pp.45-58,2012。引用于p。542[683]Hasselgren， 
J.，M。Andersson和T.Akenine-M'oller， “MaskedSoftware 
OcclusionCulling，”High-PerformanceGraphics，2016年6 
月。引用于p。849,850 [684]Hast，Anders， “3D立体渲染： 
实施问题概述”，EricLengyel编辑，GameEngineGems，Jones 
＆Bartlett ，第 123-138 页， 2010 年。927,932,934 [685] 
Hathaway，Benjamin， “Alpha BlendingasaPost-Process”， 
Wolfgang Engel编辑，GPUPro，AK Peters，Ltd.，第 167-184 
页，2010年。引用于第9页。208[686]He，Xiao D.，KennethE. 
Torrance，Fran.coisX. Sillion和 Donald P.Greenberg， “光反 
射的综合物理模型 ” ，计算机图形学（SIGGRAPH '91 
Proceedings），第一卷。25，不。4，pp.175-186，1991年7 
月。引用于p。361,424 [687]He，Y.，Y。Gu和 K.Fatahalian， 
 “使用自适应，多速率着色扩展图形管道”，ACMTransactionson 
Graphics，vol。33，不。4，pp.142：1-142：12,2014。引用于 
p。1013[688]他，Y。，T。Foley，N。Tatarchuk和 K.Fatahalian， 
 “快速，自动着色器细节级别的系统”，ACM Transactions on 
Graphics，vol。34，不。6，pp.187：1-187：12,2015。引用于 
p。853 [689]Hearn，Donald和 M.PaulineBaker，计算机图形 
学与OpenGL，第四版，Prentice-Hall，Inc.，2010年。引用于p。 
102[690]Heckbert，Paul， “纹理映射调查”，IEEE计算机图形 
和应用，第一卷。6，不。11，pp.56-67，1986年 11月。引用于 
----------------------- Page 1231-----------------------
p。222 [691] Heckbert ，Paul S. ， “纹理映射基础和 
ImageWarping”，技术报告516，计算机科学部，加州大学伯克 
利分校，1989年6月。引用于p。187,189,222，[692]Heckbert， 
PaulS.， “像素的坐标是什么？”，AndrewS.Glassner编辑，图 
形宝石，学术出版社，第246-248页，1990年。[693]Heckbert， 
PaulS.， “用于双向光线跟踪的自适应光能传递纹理”，计算机图 
形学（SIGGRAPH '90 Proceedings），第一卷。24，不。4， 
pp.145-154，1990年8月。引用于p。439 [694]Heckbert，Paul 
S.和 HenryP.Moreton， “多边形纹理映射和着色的插值”，计算 
机图形学中的最新技术：可视化和建模，Springer-Verlag， 
pp.101-111,1991。引用p。22,999 [695] Heckbert，PaulS.， 
ed。，GraphicsGems IV，Academic Press，1994。引用于p。 
102,991[696]Heckbert，PaulS.， “A MinimalRayTracer”， 
PaulS. Heckbert编辑，Graphics Gems IV，Academic Press， 
pp.375-381,1994。引用于p。444 [697]Heckbert，PaulS.，和 
Michael Herf， “用图形硬件模拟软阴影” ，技术报告 
CMU-CS-97-104，卡内基梅隆大学，1997年 1月。引用于p。228 
[698]Hecker，Chris， “更多编译器结果，以及如何处理它”，游 
戏开发者，第 14-21页，8月/ 9月。1996年。引用p。793参考 
书目 1087 [699] Hector，Tobias， “Vulkan：移动高效率”， 
Imagination博客，2015年11月5日。引用于p。40,794,814 [700] 
Hegeman，Kyle，NathanA.Carr和GavinSPMiller， “基于粒 
----------------------- Page 1232-----------------------
子的流体模拟在 GPU上”，计算科学-ICCS 2006，Springer， 
pp.228-235,2006。引用p。571[701]Heidmann，Tim， “真实 
阴影，实时”，IrisUniverse，没有。18，pp.23-31，1991年 11 
月。引用于p。230,231[702]Heidrich，Wolfgang和 Hans-Peter 
Seidel， “独立于视图的环境地图， “在 ACM SIGGRAPH / 
EUROGRAPHICS图形硬件研讨会论文集，ACM，pp.39-45，1998 
年 8 月。引用于 p。413 [703] Heidrich，Wolfgang ，R¨ 
udiferWestermann，Hans-PeterSeidel和Thomas Ertl， “像素 
纹理在可视化和逼真图像合成中的应用”，1999年 “交互式3D图 
形研讨会论文集”，ACM，pp。 1999年4月，127-134，引自 
p。538 [704]Heidrich，Wolfgang和 Hans-PeterSeidel， “现 
实，硬件加速着色和照明”，SIGGRAPH'99：第26届计算机图形 
学与交互技术年会论文集，ACM 出版社/Addison-Wesley出版社 
Co.，pp.171-178，1999年8月。引用于p。413,417,426 [705] 
Heidrich，Wolfgang，KatjaDaubert，Jan Kautz和 Hans-Peter 
Seidel，“基于预计算可见性的照明微观几何， “在SIGGRAPH'00： 
第 27届计算机图形学与互动技术年会论文集，ACM 出版社/ 
Addison-Wesley PublishingCo.，pp.455-464，2000年7月。 
引用于p。466 [706]Heitz，Eric和 FabriceNeyret， “在稀疏体 
素八分之一中代表外观和预过滤子像素数据”，在第四届ACM 
SIGGRAPH/ Eurographics会议上的高性能图形会议论文集， 
EurographicsAssociation，pp.125-134，2012年6月。引用于 
----------------------- Page 1233-----------------------
p。579,585,586[707]Heitz，Eric，ChristopheBourlier和 Nicolas 
Pinel， “发射器和接收器方位角方向对随机粗糙表面照明功能的相 
关效应”， “随机和复杂媒体中的波”，第一卷。23，不。3， 
pp.318-335,2013。引用于p。336 [708]Heitz，Eric， “了解基 
于 Microfacet的BRDF中的掩蔽 - 阴影功能，”计算机图形技术 
杂志，第一卷。3，不。4 ，pp.48-107,2014。引用于 p。 
332,333,334,335,336,337,339,344[709]Heitz，Eric和Jonathan 
Dupuy， “用随机评估实现简单的各向异性粗糙漫射材料”，技术 
报告，2015年。引用于p。331[710]Heitz，Eric，Jonathan Dupuy， 
Cyril Crassin 和 Carsten Dachsbacher， “SGGX Microflake 
Distribution”，ACM Transactions on Graphics （SIGGRAPH 
2015），vol。34，不。4，pp.48：1-48：11，2015年8月。引 
用于p。648,649[711]Heitz，Eric，Jonathan Dupuy，Stephen 
Hill和 DavidNeubelt，“具有线性转换余弦的实时多边形光着色”， 
ACMTransactionsonGraphics （SIGGRAPH2016），vol。35， 
不。4，pp.41：1-41：8，2016年7月。引用于p。390[712]Heitz， 
Eric，Johannes Hanika，Eugened'Eon和CarstenDachsbacher， 
 “使用 Smith模型的多重散射微型 BSDF”，ACM 图形交易 
 （SIGGRAPH2016），第一卷。35，不。4，pp.58：1-58：8， 
2016年7月。引用于p。346[713]Held，Martin， “ERIT-高效 
可靠的交叉口测试集”，图形工具杂志，第一卷。2，没有。4， 
pp.25-44,1997。引用于p。959,974[714]Held，Martin，“FIST： 
----------------------- Page 1234-----------------------
多边形的快速工业强度三角剖分”，Algorithmica，vol。30，不。 
4，pp.563-596,2001。引用于 p。685 1088 参考书目[715] 
Hennessy ， John L. 和 David A. Patterson ， Computer 
Architecture：AQuantitativeApproach，FifthEdition，Morgan 
Kaufmann，2011。引用于p。12,30,783,789,867,1007,1040[716] 
Hennessy，Padraic， “实施注释：基于物理的镜头光晕”，占位 
符艺术博客，2015年 1月19日。引用p。526[717]Hennessy， 
Padraic， “Skylanders中的混合分辨率渲染：SuperChargers”， 
游戏开发者大会，2016年3月。引用于p。520[718]Hensley， 
Justin和ThorstenScheuermann，“使用Summed-AreaTables 
的动态光泽环境反射”，Wolfgang Engel编辑，ShaderX4，Charles 
RiverMedia，第 187-200页，2005年。188,419[719]Hensley， 
Justin，ThorstenScheuermann，GregCoombe，MontekSingh 
和Anselmo Lastra，“FastSummed-AreaTableGenerationand 
ItsApplications，”ComputerGraphics Forum，vol。24，不。 
3，pp.547-555,2005。引用于p。188,419[720]Hensley，Justin， 
 “闪亮，模糊的事物”，SIGGRAPH Beyond Programmable 
Shading课程，2009年8月。引用于p。419 [721]Henyey，LG 
和JLGreenstein，“星系中的漫射辐射”，载于 “天体物理学杂志”， 
第一卷。93，pp.70-83,1941。引用p。598 [722]Herf，M。和 
PSHeckbert， “快速软阴影”，在ACM SIGGRAPH '96Visual 
Proceedings，ACM，p。145，1996年8月。引用于 p。[723] 
----------------------- Page 1235-----------------------
Hermosilla，Pedro和 Pere-PauV'azquez， “使用几何着色器的 
NPR效果”，Wolfgang Engel编辑，GPUPro，AK Peters，Ltd.， 
pp.149-165,2010。被引用在第 668 [724] Herrell，Russ，Joe 
Baldwin和ChrisWilcox， “高质量多边形边缘”，IEEE计算机图 
形和应用，第一卷。15，不。4，pp.68-74，1995年7月。引用 
于p。673 [725]Hertzmann，Aaron， “3D非真实感渲染介绍： 
轮廓和轮廓”，SIGGRAPH非真实感渲染课程，1999年8月。引 
用于第6页。663，667[726]Hertzmann，Aaron和 DenisZorin， 
 “IllustratingSmoothSurfaces”，在SIGGRAPH'00中：第27 
届计算机图形学与交互技术年会论文集，ACM 出版社/ 
Addison-Wesley PublishingCo.，pp.517-526，2000年7月。 
引用于p。667,672 [727]Hertzmann，Aaron， “基于笔画的渲 
染概述”，IEEE计算机图形和应用，第一卷。23，不。4月，第70-81 
页，7月/8月。2003年。引用p。678[728]Hertzmann，Aaron， 
 “非照片写实渲染和艺术科学”，载于第8届非真实感动画和渲染 
国际研讨会论文集，ACM，第 147-157页，2010年。引用于第6 
页。678[729]Hery，Christophe，“OnShadowBuffers”，Stupid 
RenderMan/ RATTricks，SIGGRAPH 2002 RenderMan Users 
Group meeting，2002年7月。638 [730]Hery，Christophe， 
 “实施皮肤 BSSRDF （或几个），”SIGGRAPH RenderMan，理 
论与实践课程，2003 年 7 月。引用于 p。638 [731] Hery， 
Christophe，MichaelKass和Junyi Ling， “几何入阴影”，技术 
----------------------- Page 1236-----------------------
备忘录，皮克斯动画工作室，2014年。引用于p。370[732]Hery， 
Christophe和Junyi Ling， “皮克斯的材料基础：PxrSurface和 
Pxr-MarschnerHair，”SIGGRAPH理论和实践中的基于物理的着 
色课程，2017年8月。引用于p。321,343,359,363,364,370[733] 
Herzog，Robert，Elmar Eisemann，Karol Myszkowski 和 
H.-P.Seidel，“GPU上的时空上采样”，2010年ACMSIGGRAPH 
交互式3D图形和游戏研讨会论文集，ACM，第91-98页，2010 
年。引用于 p。520 [734]Hicks，Odell， “模拟热成像”，载于 
Wolfgang Engel，编辑，ShaderX3，Charles River Media，第 
169-170页，2004年。521参考书目 1089[735]Hill，FS，Jr。， 
 “'PerpDot'产品的乐趣，“在 PaulS.Heckbert，ed。，Graphics 
GemsIV，Academic Press，pp.138-148,1994。引用于p。6,987 
[736]Hill，Steve， “ASimpleFastMemoryAllocator”，David 
Kirk编辑，GraphicsGemsIII，Academic Press，pp.49-50,1992。 
793[737]希尔，斯蒂芬， “渲染与信念，”游戏开发者大会，2010 
年3月。引用于p。452,457 [738]Hill，Stephen和 DanielCollin， 
 “实用，动态的游戏可见性”，载于Wolfgang Engel，编辑，GPU 
Pro2，AK Peters/ CRC出版社，第329-348页，2011年。引用 
于p 。848 [739]希尔，斯蒂芬， “狂野西部的镜面摊牌”，自我 
影子博客，2011年7月22 日。引用于p。370 [740]希尔，斯蒂 
芬和丹贝克， “坚如磐石的阴影：图像稳定而不牺牲细节”， 
SIGGRAPH在游戏中实时渲染的进展，2012年8月。371 [741] 
----------------------- Page 1237-----------------------
Hillaire，S'ebastien，“通过减少对驱动程序的调用来提高性能”， 
PatrickCozzi和ChristopheRiccio编辑，OpenGLInsights，CRC 
Press，第353-363页，2012年。795,796,797 [742] Hillaire， 
S'ebastien， “Frostbite 中基于物理和统一的体积渲染”， 
SIGGRAPH在实时渲染课程中的进展，2015年8月。引用于p。 
570,610,611,612,613[743]Hillaire，S'ebastien， “Frostbite中 
基于物理的天空，大气和云渲染”，SIGGRAPH理论和实践中基于 
物 理 的 阴 影 ， 2016 年 7 月 。 引 用 于 p 。 
589,596,599,602,610,614,615,616,617,620,621,622,623,649 
[744] Hillaire，S'ebastien， “Volumetric Stanford Bunny，” 
Shadertoy，2017年 3月 25 日。引用p。594 [745] Hillaire， 
S'ebastien，“Frostbite中交互式全局照明工作流的实时光线跟踪， 
 “游戏开发者大会，2018年3月。引用p。1044[746]Hillesland， 
Karl， “Real-TimePtexandVector Displacement”，Wolfgang 
Engel编辑，GPUPro4，CRC出版社，第69-80页，2013年。引 
用于p。191[747]Hillesland，KE和JCYang，“TexelShading”， 
Eurographics2016-Short Papers，EurographicsAssociation， 
pp.73-76，May2016.引用于p。911[748]Hillesland，Karl，Texel“ 
Shading”，GPUOpen网站，2016年7月21 日。引用于p。911 
[749]Hinsinger，D.，F。Neyret和 M.-P.Cani，“海浪互动动画”， 
载于2002年ACMSIGGRAPH/ Eurographics计算机动画研讨会 
论文集，ACM，第161-166页，2002年。878 [750] Hirche， 
----------------------- Page 1238-----------------------
Johannes，Alexander Ehlert，StefanGuthe和MichaelDoggett， 
 “硬件加速的每像素位移映射”，图形界面2004，加拿大人类计算 
机通信学会，第 153-158页，2004年。220[751]Hoberock，Jared 
和YuntaoJia， “高质量环境遮挡”，在HubertNguyen编辑， 
GPUGems3，Addison-Wesley，pp.257-274,2007。引用于p。 
454 [752]Hoetzlein，Rama， “GVDB：RaytracingGPU上的稀 
疏体素数据库结构”，高性能图形，2016年 6月。引用于 p。 
578,582,586[753]Hoetzlein，Rama，“NVIDIARGVDBVoxels： 
ProgrammingGuide，”NVIDIA网站，2017年5月。引用于p。 
578,580,582[754]Hoffman，DonaldD.，Visual Intelligence， 
WW Norton＆Company，2000。引用于p。150[755]Hoffman， 
Naty和 Kenny Mitchell， “实时照片级真实地形照明”，Game 
Developer，vol。8，不。7，pp.32-41，2001年7月。 “实时照 
片级真实地形照明”游戏开发者大会的更详细版本，2001年3月。 
也收集于[1786]。引用p。451 1090参考书目[756] Hoffman， 
Naty， “视频游戏的色彩增强”，2010年7月的电影和游戏制作 
课程中的 SIGGRAPH色彩增强和渲染。引用于第4页。289,290 
[757]Hoffman，Naty， “回声室之外：学习其他学科，行业和艺 
术形式”，2013年3月开放交互式3D图形和游戏研讨会主题演讲。 
引用于第28页。284,289 [758]Hoffman，Naty， “背景：阴影 
的物理和数学”，SIGGRAPH基于物理学的理论和实践中的阴影， 
2013年7月。引用于p。315[759]Holbert，Daniel， “Normal 
----------------------- Page 1239-----------------------
OffsetShadows”，DissidentLogic博客，2010年8月27 日。 
引用于p。238[760]霍尔伯特，丹尼尔， “对影子痤疮说'再见'，” 
游戏开发者会议海报，2011 年 3 月。引用于 p。238 [761] 
Hollemeersch，C。-F。，B.Pieters，P。Lambert和R.VandeWalle， 
 “使用CUDA加速虚拟纹理”，Wolfgang Engel编辑，GPUPro， 
AK Peters，Ltd.，pp.623-642,2010 。引用 p。868 [762] 
Holzschuch，Nicolas和 RomainPacanowski， “识别测量反射 
中的衍射效应”，Eurographics材料外观建模研讨会，2015年6 
月。引用于 p.6。361 [763] Holzschuch，Nicolas和 Romain 
Pacanowski， “结合反射和衍射的双尺度微小反射模型”，ACM 
Transactions onGraphics （SIGGRAPH2017），vol。36，不。 
4，pp.66：1-66：12，2017年7月。引用于p。331,343,361[764] 
Hoobler，Nathan， “高性能后处理”，游戏开发者大会，2011 
年3月。引用于p。54,536[765]Hoobler，Nathan， “快速，灵 
活，基于物理的体积光散射，“游戏开发者大会，2016年3月。引 
用于p。608 [766]Hooker，JT， “Treyarch的体积全局照明”， 
SIGGRAPH在游戏中实时渲染的进展，2016年7月。引用于p。 
395,478,488,489[767]Hoppe，H.，T。DeRose，T。Duchamp， 
M。Halstead，H。Jin，J。McDonald，J。Schweitzer，和W.Stuetzle， 
 “PiecewiseSmoothSurfaceReconstruction， “在SIGGRAPH 
'94：第21届计算机图形和交互技术年会论文集，ACM，第295-302 
页，1994年7月。引用于第4页。758,760,763 [768]Hoppe， 
----------------------- Page 1240-----------------------
Hugues， “ProgressiveMeshes”，SIGGRAPH'96：第23届计 
算机图形学和交互技术年会论文集，ACM，第99-108页，1996 
年8月。引用于p 。706,707,710,859 [769]Hoppe，Hugues， 
 “视图依赖的渐进网格细化”，在SIGGRAPH'97中：第24届计 
算机图形学与交互技术年会论文集， ACM 出版社/ 
Addison-Wesley PublishingCo.，pp.189-198，1997年8月。 
引用于p。772 [770]Hoppe，Hugues， “高效实现渐进网格”， 
计算机和图形学，第一卷。22，不。1，pp.27-36,1998。引用于p。 
707,710[771]Hoppe，Hugues，透明顶点缓存的网格局部优化“        ”， 
SIGGRAPH '99：第26届计算机图形学与交互技术年会论文集， 
ACM 出版社/Addison-Wesley PublishingCo.，pp1999年8月 
269-276。引用于p。700[772]Hoppe，Hugues， “用于简化具 
有外观属性的网格的新二次指标”， “可视化论文集”，IEEE计算 
机学会，第59-66页，1999年 10月。709 [773]Hormann，K。 
和 M.Floater，'任意平面多边形的均值坐标，“ACMTransactions 
onGraphics，vol。25，不。4，pp.1424-1441，2006年 10月。 
引用于p。970参考书目 1091[774]Hormann，Kai，BrunoL'evy 
和AllaSheffer，SIGGRAPHMesh参数化：理论与实践课程，2007 
年8月。引用于p。[775]Hornus，Samuel，Jared Hoberock， 
Sylvain Lefebvre和John Hart， “ZP +：正确的Z-Pass模板阴 
影”，载于2005年交互式3D图形与游戏研讨会论文集，ACM， 
第195-202页，2005年4月。引用于p。[776]Horvath，Helmuth， 
----------------------- Page 1241-----------------------
 “GustavMie和粒子对光的散射和吸收：历史发展和基础，”定量 
光谱学和辐射传递杂志，第一卷。110，没有。11，pp.787-799,2009。 
引用于p。597 [777]Hoschek，Josef和 DieterLasser，计算机 
辅助几何设计基础，AK Peters，Ltd.，1993。引用于 p。 
778,721,725,732,734,738,742,749,754,781[778]Hosek，Lukas 
和Alexander Wilkie， “An SpectralSky-Dome Radiance的分 
析模型”，ACMTransactiononGraphics，vol。31，不。4，pp.1-9， 
2012年7月。引用于p。614[779]Hu，Jinhui，SuyaYou和 Ulrich 
Neumann， “大规模城市建模的方法”，IEEE计算机图形和应用， 
第一卷。23，不。6，pp.62-69，Nov。/ Dec。2003年。引用p。 
[780]Hu，L.，P。Sander，和H.Hoppe，Parallel“ View-Dependent 
Level-of-DetailControl”，IEEETransactions onVisualization 
andComputerGraphics，vol。16，不。5，pp.718-728,2010。 
引用于p。475,859 [781]Hu，Liwen，MaChongyangMa，Linlin 
Luo和 Hao Li， “使用发型数据库的单视图头发建模， “ACM 
TransactiononGraphics，vol。34，不。4，pp.1-9，2015年7 
月。引用于p。645 [782]Hubbard，PhilipM.， “使用球体近似 
多面体进行时间 - 临界碰撞检测”，ACM Transactions on 
Graphics，vol。15，不。3，pp.179-210,1996。引用于p。976[783] 
Hughes，James，RezaNourai和 EdHutchins， “理解，测量和 
分析VR图形性能”，参见Wolfgang Engel编辑，GPUZen，Black 
Cat Publishing ，第 253-274 页， 2017 年。引用页。 
----------------------- Page 1242-----------------------
785,815,937,938,940 [784]Hughes，John F.和TomasMoller， 
 “从单位矢量建立正交基础”，图形工具杂志，第一卷。4，不。4， 
pp.33-35,1999。也在[112]中收集。引用p。75,552[785]Hughes， 
John F.，Andriesvan Dam，MorganMcGuire，DavidF.Sklar， 
James D.Foley，StevenK.Feiner和 KurtAkeley，计算机图形学： 
原则与实践，第三版，Addison-Wesley，2013年。引用于 p。 
102,278[786]Hullin，Matthias，ElmarEisemann，Hans-Peter 
Seidel和Sungkil Lee， “基于物理的实时镜头光晕渲染”，ACM 
Transactions onGraphics （SIGGRAPH2011），vol。30，不。 
4，pp.108：1-108：10，2011年7月。引用于p。524,526[787] 
Humphreys，Greg，MikeHouston，RenNg，RandallFrank， 
Sean Ahern ，Peter D. Kirchner 和 James t。Klosowski ， 
 “Chromium：用于集群上交互式渲染的流处理框架”，ACM 
TransactionsonGraphics，vol。21，不。3，pp.693-702，2002 
年7月。引用于p。1020[788]Hunt，RWG，The Reproduction 
ofColour，Sixth Edition，JohnWiley＆Sons，Inc.，2004。引 
用于p。291[789]Hunt，RWG和 MRPointer，MeasuringColor， 
FourthEdition，JohnWiley＆Sons，Inc.，2011。引用于p。276， 
291 [790]Hunt，Warren， “虚拟现实的实时射线投射”，热门 
3D会话，高性能图形，2017年7月。引用于p。939[791]Hunter， 
Biver和 PaulFuqua，光科学与魔术：摄影照明导论，第四版，焦 
点出版社，2011年。引用于第 9页。435 1092参考书目[792] 
----------------------- Page 1243-----------------------
Hurlburt，Stephanie， “改善游戏中的纹理压缩”，游戏开发者 
会议AMDCapsaicin＆Cream开发人员会议，2017年2月。引用 
p。870[793]Hwu，Wen-Mei和 DavidKirk， “编程大规模并行 
处理器”，课程ECE498AL1注释，伊利诺伊大学电子与计算机工 
程系，2007 年秋季。1040 [794] Igehy，Homan，Matthew 
Eldridge和 KekoaProudfoot， “在纹理缓存架构中预取， “在 
ACM SIGGRAPH / EUROGRAPHICS图形硬件研讨会论文集， 
ACM，第 133-142页，1998年8月。引用于p。1017[795]Igehy， 
Homan，MatthewEldridge和 PatHanrahan，“并行纹理缓存”， 
参 见 ACM SIGGRAPH / EUROGRAPHICS Workshop on 
Graphics Hardware，ACM，pp.95-106，1999年8月。引用于 
p。1017 [796] Iglesias-Guitian，Jose A.，Bochang Moon， 
Charalampos Koniaris，EricSmolikowski和 Kenny Mitchell， 
 “用于实时时间过滤的像素历史线性模型”，计算机图形论坛 
 （PacificGraphics2016），第一卷。35，不。7，pp.363-372,2016。 
引用于p。143[797]Ikits，Milan，Joe Kniss，Aaron Lefohn和 
Charles Hansen， “体积渲染技术”，RandimaFernando编辑， 
GPUGems，Addison-Wesley，第667-692页，2004年。605,607 
[798]Iourcha，Konstantine和Jason C.Yang， “方向自适应边 
缘抗混叠滤波器”，见 “高性能图形会议论文集2009”，ACM， 
第 127-133页，2009年8月。引用于第4页。[799]Isenberg， 
Tobias，BertFreudenberg，NickHalper，StefanSchlechtweg 
----------------------- Page 1244-----------------------
和Thomas Strothotte， “开发人员多边形模型轮廓算法指南”， 
IEEE计算机图形和应用，第一卷。23，不。4月，第28-37页，7 
月/8月。2003年。引用p。678[800]Isenberg，M。和 P.Alliez， 
 “压缩多边形网格几何与平行四边形预测”，见 “可视化会议论文 
集”，IEEE计算机学会，第 141-146页，2002年。92[801]Isensee， 
Pete， “C ++优化策略与技术”，PeteIsensee网站，2007年。 
引用于 p。815 [802] Isidoro，John，Alex Vlachos 和 Chris 
Brennan， “渲染海水， “在Wolfgang Engel，ed。，Direct3D 
ShaderX ：Vertex ＆Pixel Shader Tips and Techniques ， 
Wordware，pp.347- 356，2002年 5月。引用于 p。43 [803] 
Isidoro，约翰， “下一代皮肤渲染”，游戏科技大会，2004年。 
引用于第4页。635[804]Isidoro，John， “阴影映射：基于GPU 
的技巧和技巧”，游戏开发者大会，2006年3月。引用于p。250 
[805] Iwanicki，Micha l， “低频预计算可见性的正常映射”， 
SIGGRAPH2009会谈，ACM，文章编号。52，2009年8月。引 
用于p。466,471 [806]Iwanicki，Michal， “我们最后的照明技 
术”，ACMSIGGRAPH2013会谈，ACM，文章编号。2013年7 
月20 日。引用于p。229,289,467,476,486,498 [807]Iwanicki， 
Michal和Angelo Pesce，基于物理渲染的近似模型“       ，“SIGGRAPH 
理论和实践课程中基于物理的阴影，2015年 8月。引用于 p。 
386,387,422,424,502 [808] Iwanicki，Micha l 和 Peter-Pike 
Sloan， “环境骰子”，关于渲染 - 实验性思想与实现的 
----------------------- Page 1245-----------------------
Eurographics研讨会，2017年6月。引用于p。395,478,488[809] 
Iwanicki，Michal和 Peter-PikeSloan， “使命召唤中的预计算照 
明：无限战争”，SIGGRAPH在2017年8月游戏课程中实时渲染 
的进展。402,471,476,490,491 参考书目 1093 [810] Jakob， 
Wenzel，Milos Hasan，Ling-QiYan，Jason Lawrence，Ravi 
Ramamoorthi 和 Steve Marschner ， “Discrete Stochastic 
Microfacet Models ， ” ACM Transactions on Graphics 
 （SIGGRAPH2014 ），第一卷 33，不。4，pp.115：1-115：9， 
2014年7月。引用于p。372[811]Jakob，Wenzel，Eugened'Eon， 
OttoJakob和SteveMarschner， “渲染分层材料的综合框架”， 
ACM图形交易 （SIGGRAPH2014），第一卷。33，不。4，pp.118： 
1-118：14，2014年7月。引用于p。346,364[812]Jakob，Wenzel， 
 “layerlab：用于分层材料的计算工具箱”，SIGGRAPH基于物理 
学的理论与实践着色课程，2015年8月。引用于 p。364 [813] 
James，Doug L.和 Christopher D. Twigg， “Skinning Mesh 
Animations”，ACMTransactions onGraphics，vol。23，不。 
3，pp.399-407，2004年8月。引用于p。85[814]James，Greg， 
 “硬件加速程序纹理动画操作”，Mark DeLoura编辑，Game 
Programming Gems 2 ， Charles River Media ， 
pp.497-509,2001。引用于p。521 [815]James，Greg和John 
O'Rorke，“Real-TimeGlow”，RandimaFernando，编辑，GPU 
Gems，Addison-Wesley，第343-362页，2004年。引用于p。 
----------------------- Page 1246-----------------------
517,518，527[816]Jansen，Jon和 LouisBavoil，“使用 DirectX 
11曲面细分和混合分辨率快速渲染不透明度的粒子”，NVIDIA白 
皮书，2011年2月。引用于p。520,569,570,571,609,612 [817] 
Jarosz，Wojciech， “FastImageConvolutions”，伊利诺伊大 
学厄巴纳 - 香槟分校 SIGGRAPH研讨会，2001年。518 [818] 
Jarosz，Wojciech，高效蒙特卡罗散射光传输方法，博士论文，加 
州大学圣地亚哥分校，2008年9月。引用于p。589[819]Jarosz， 
Wojciech，NathanA.Carr和 HenrikWannJensen， “重要性采 
样球谐波”，计算机图形学论坛，第一卷。28，不。2， 
pp.577-586,2009。引用于p。419 [820]Jendersie，Johannes， 
DavidKuri和ThorstenGrosch， “用于实时全局照明的预计算照 
度组合， “在第20届ACM SIGGRAPH交互式3D图形与游戏研 
讨会论文集，ACM，第 129-137页，2016年。引用于第4页。483 
[821]Jensen，HenrikWann，Justin Legakis和Julie Dorsey， 
 “渲染湿材料”，渲染技术'99，Springer，第273-282页，1999 
年6月。引用于p。[822]Jensen，HenrikWann，使用Photon 
Mapping的逼真图像合成，AK Peters，Ltd.，2001。引用于p。 
630[823]Jensen，HenrikWann，StephenR.Marschner，Marc 
Levoy和 PatHanrahan， “地下光传输的实用模型”，SIGGRAPH 
'01第 28届计算机图形学和交互技术年会论文集，ACM，第 
511-518页，2001年8月。引用于p。634,638 [824]Jeschke， 
Stefan，StephanMantler和 MichaelWimmer， “交互式光滑和 
----------------------- Page 1247-----------------------
弯曲壳体映射”，在渲染技术中，EurographicsAssociation， 
pp.351-360，2007年6月。引用于p。220[825]Jiang，Yibing， 
 “在 Uncharted4 中创建基于体积的材料的过程”，SIGGRAPH 
在游戏中实时渲染的进展，2016年7月。引用p。356,357,358,359 
[826]Jim'enez，JJ，FRFeito和 RJSegura， “用于多点内包络测 
试的鲁棒和优化算法，无需预处理”，计算机图形论坛，第一卷。 
28，不。8，pp.2264-2274,2009。引用于p。970[827]Jim'enez， 
JJ，DavidWhelan，Veronica Sundstedt和 DiegoGutierrez， 
 “Real-TimeRealisticSkinTranslucency，”ComputerGraphics 
andApplications，vol。30，不。4，pp.32-41,2010。引用于p。 
6371094参考书目[828]Jimenez，Jorge，BelenMasia，Jose I. 
Echevarria，FernandoNavarro和 DiegoGutierrez， “Practical 
MorphologicalAntialiasing， “在Wolfgang Engel编辑，GPU 
Pro2，AK Peters/CRCPress，pp.95-113,2011。引用于p。[829] 
Jimenez，Jorge，DiegoGutierrez，etal。，SIGGRAPHFiltering 
Approach for Real-TimeAnti-Aliasing course，Aug。2011.引 
用于p。147,165[830]Jimenez，Jorge，Jose I.Echevarria，Tiago 
Sousa和 DiegoGutierrez，“SMAA：增强的亚像素形态抗锯齿”， 
计算机图形学论坛，第一卷。31，不。2，pp.355-364,2012。引 
用于p。146,148[831]Jimenez，Jorge， “下一代角色渲染”， 
游戏开发者大会，2013年3月。引用于p。636,637[832]Jimenez， 
Jorge， “使命召唤高级战争中的下一代后处理”，SIGGRAPH在 
----------------------- Page 1248-----------------------
游戏中实时渲染的进展， 2014 年 8 月。引用于 p.6。 
251,527,534,535,537,540,542,543[833]Jimenez，Jorge，Karoly 
Zsolnai，AdrianJarabo，ChristianFreude，ThomasAuzinger， 
Xian-Chun Wu，Javier von der Pahlen，MichaelWimmer 和 
DiegoGutierrez， “可分离的次表面散射”，计算机图形学论坛， 
第一卷。34，不。6，pp.188-197,2015。引用于 p。637 [834] 
Jimenez，Jorge， “FilmicSMAA：Sharp Morphologicaland 
TemporalAntialiasing，”SIGGRAPH在游戏中实时渲染的进展， 
2016年7月。引用于p。[835]Jimenez，Jorge，XianchunWu， 
Angelo Pesce和AdrianJarabo，准确间接遮挡的实用实时策略“           ”， 
SIGGRAPH理论与实践中的基于物理的阴影课程，2016年7月。 
引用p。451,461,462,468,472 [836]Jimenez，Jorge， “使命召 
唤中的动态时间抗锯齿：无限战争”，SIGGRAPH在游戏中实时渲 
染的进展，2017年8月。引用于p。142,143,145,146,148,166， 
805[837]Jin，Shuangshuang，RobertR.Lewis和 DavidWest， 
 “顶点正常计算算法的比较”， “视觉计算机”，第一卷。21， 
pp.71-82,2005。引用于p。695[838]Johansson，Mikael， “建 
筑信息模型的高效立体渲染（BIM）”，计算机图形技术杂志，第 
一卷。5，不。3，pp.1-17,2016。引用于p。927[839]Johnson， 
GS，J。Lee，CABurns和WR Mark， “The IrregularZ-Buffer： 
HardwareAcceleration for Irregular DataStructures，”ACM 
Transactions on Graphics，vol。24，不。4，pp.1462-1482， 
----------------------- Page 1249-----------------------
2005年 10月。引用于 p。260 [840]Johnsson，Bj¨orn，Per 
Ganestam，MichaelDoggett和TomasAkenine-M'oller， “在 
图形处理器上运行的软件算法的功效， “参见第四届 ACM 
SIGGRAPH/ Eurographics高性能图形会议论文集，Eurographics 
Association，pp.67-75，2012年6月。引用于第4页。790[841] 
Jones，James L.， “使用OpenGLES3.0的高效变形目标动画”， 
载于Wolfgang Engel，编辑，GPUPro5，CRC出版社，第289-295 
页，2014年。90[842]Jéonsson，Daniel，ErikSund'en，Anders 
Ynnerman和Timo Ropinski， “交互式体绘制的体积照明技术概 
述”，计算机图形学论坛，第一卷。33，不。1，pp.27-51,2014。 
引用于 p。605 [843] Joy，Kenneth I.，On-Line Geometric 
ModelingNotes，http：//graphics.idav.ucdavis.edu/ education 
/ CAGDNotes/ homepage.html，1996。引用于p。756 [844] 
Junkins，S。， “英特尔处理器图形Gen9的计算架构”，英特尔 
白皮书v1.0，2015年8月。引用于p。1006，1007[845]Kajiya， 
JamesT.， “各向异性反射模型”，计算机图形学 （SIGGRAPH'85 
Proceedings），第一卷。19，没有。3，pp.15-21，1985年7月。 
引用于p。853参考书目 1095[846]Kajiya，JamesT.， “渲染方 
程”，计算机图形学（SIGGRAPH '86Proceedings），第一卷。 
20，不。4，pp.143-150，1986年8月。引用于p。315,437,444 
[847]Kajiya，JamesT.和Timothy L.Kay，用三维纹理渲染毛皮“     ”， 
计算机图形学 （SIGGRAPH'89Proceedings），第一卷。17，不。 
----------------------- Page 1250-----------------------
3，pp.271-280，1989年7月。引用于p。359,642[848]Kalnins， 
Robert D. ，Philip L. Davidson ，Lee Markosian 和 Adam 
Finkelstein ， “Coherent Stylized Silhouettes ” ， ACM 
Transactions onGraphics （SIGGRAPH2003），vol。22，不。 
3，pp.856-861,2003。引用于p。667[849]K¨ampe，Viktor，快 
速，记忆效率高的体素化阴影构建，博士论文，查尔姆斯理工大学， 
2016年。引用于p。586[850]K¨ampe，Viktor，ErikSintorn， 
OlaOlsson和 UlfAssarsson， “快速，记忆效率高的体素化阴影 
构造”，IEEE可视化与计算机图形学，第一卷。22，不。10， 
pp.2239-2248，2016年 10月。引用于p。264,586[851]Kaneko， 
Tomomichi ，Toshiyuki Takahei ，Masahiko Inami ，Naoki 
Kawakami，YasuyukiYanagida，Taro Maeda和SusumuTachi， 
 “具有视差映射的详细形状表示”，2001年 12月人工现实与电传 
的国际会议。引用p。215[852]Kang，H.，H。Jang，C.-S。Cho 
和J.Han，“使用GPUTessellation进行多分辨率地形渲染”， “视 
觉计算机”，第一卷。31，不。4，pp.455-469,2015。引用于p。 
567,876[853]Kaplan，Matthew，BruceGooch和ElaineCohen， 
 “交互式艺术渲染”，载于第一届非真实动画和渲染国际研讨会论 
文集，ACM，第67-74页，2000年6月。670,672[854]Kaplanyan， 
Anton， “CryEngine3中的光传播量”，SIGGRAPH在游戏中实 
时渲染的进展，2009年8月。引用于p。493 [855]Kaplanyan， 
Anton和CarstenDachsbacher， “用于实时间接照明的级联光传 
----------------------- Page 1251-----------------------
播量”，2010年ACMSIGGRAPH交互式3D图形和游戏研讨会论 
文集，ACM，第99-107页，2月。2010年。引用p。494,496 [856] 
Kaplanyan，Anton， “CryENGINE3：达到光速”，SIGGRAPH 
在 2010 年 7 月的游戏过程中实时渲染方面取得进展。 
196,289,290,848,849,887,892 [857] Kaplanyan ， Anton ， 
Stephen Hill，Anjul Patney和Aaron Lefohn， “过滤分布抗锯 
齿的法线分布”，载于 “高性能图形学报”，Eurographics 
Association，pp.151-162，2016年6月。引用于 p。371 [858] 
Kapoulkine，Arseny， “最佳网格渲染不是最佳”，比特，像素， 
周期和更多博客，2017年7月31 日。引用于p。700,701 [859] 
Karabassi ，Evaggelia-Aggeliki ，Georgios Papaioannou 和 
TheoharisTheoharis， “基于快速深度缓冲的体素化算法”，图形 
工具杂志，第一卷。4，不。4，pp.5-10,1999。引用于p。580[860] 
Karis，Brian，“Tiled LightCulling”，GraphicRants博客，2012 
年4月9 日。引用于p。113,882[861]Karis，Brian， “虚幻引擎 
4中的真实阴影”，SIGGRAPH理论与实践课程中基于物理的阴影， 
2013  年  7  月  。  引  用  第  11  页  。 
111,113,116,325,336,340,342,352,355,383,385,388,421,423 
[862]Karis，Brian， “高质量的时间超级采样”，SIGGRAPH在 
2014 年 8 月的游戏过程中实时渲染方面取得了进展。 
142,143,144,620[863]Karis，Brian， “虚幻中基于物理的头发阴 
影”，SIGGRAPH理论与实践中的基于物理的阴影，2016年7月。 
----------------------- Page 1252-----------------------
引用于p。641,644,6461096参考书目[864]Kass，Michael，Aaron 
Lefohn和JohnOwens，在“GPU上使用模拟扩散的交互式景深”， 
技术备忘录，皮克斯动画工作室，2006年。引用 p。535 [865] 
Kasyan，Nikolas，“玩实时阴影”，SIGGRAPHEfficientReal-Time 
Shadows课程，2013年7月。引用p。54,234,245,251,264,585 
[866]Kautz，Jan，Wolfgang Heidrich和 KatjaDaubert， “用 
于OpenGL渲染的凹凸贴图阴影”，技术报告 MPI-I-2000-4-001， 
Max-Planck-Institutf¨urInformatik，Saarbrüucken，德国，2000 
年2月。引用于p。466 [867]Kautz，Jan和 MDMcCool， “用 
预滤波环境地图逼近光泽反射”，图形接口2000，加拿大人机通信 
学会，第 119-126页，2000年5月。423 [868]Kautz，Jan，P.-P。 
V'azquez，W。Heidrich和 H.-P.Seidel， “预过滤环境地图的统 
一方法”，渲染技术2000，Springer，第 185-196页，2000年6 
月。引用于p。420 [869]Kautz，Jan，Peter-PikeSloan和John 
Snyder， “使用球谐函数的低频照明的快速，任意 BRDF阴影”， 
在第 13届 Eurographics渲染研讨会论文集中，Eurographics 
Association，pp.291-2002年6月29 日。引用第2页。401,431 
[870] Kautz，Jan ，Jaakko Lehtinen 和 Peter-Pike Sloan ， 
SIGGRAPH PrecomputedRadianceTransfer：理论与实践课程， 
2005年 8月。引用于 p。481 [871] Kautz，Jan， “SH Light 
Representations”，SIGGRAPH预计算辐射传递：理论与实践课 
程，2005年8月。引用于p。430 [872]Kavan，Ladislav，Steven 
----------------------- Page 1253-----------------------
Collins，Jir'。Z'ara和CarolO'Sullivan， “在双重四元数中剥皮”， 
2007年 “交互式3D图形与游戏研讨会论文集”，ACM，第39-46 
页，2007年4月至5月。引用于第4页。87[873]Kavan，Ladislav， 
StevenCollins，Jir'。Z'ara和CarolO'Sullivan， “几何蒙皮与近 
似双四元数混合”，ACMTransactions onGraphics，vol。27， 
不。4，pp.105：1-105：23,2008。引用于p。87 [874]Kavan， 
Ladislav，Simon Dobbyn，StevenCollins，Jir'。Z'ara和Carol 
O'Sullivan， “Polypostors：用于3D人群的2D多边形冒充者， 
 “参见 2008年交互式 3D图形和游戏研讨会论文集，ACM，第 
149-156页，2008年。引用于第4页。562[875]Kavan，Ladislav， 
AdamW. Bargteil和 Peter-PikeSloan， “LeastSquaresVertex 
Baking” ，计算机图形学论坛，第一卷。30 ，不。4 ， 
pp.1319-1326,2011。引用于p。452 [876]Kay，L。，“SceneJS： 
基于WebGL的场景图形引擎”，作者 PatrickCozzi和Christophe 
Riccio，编辑，OpenGL Insights，CRC出版社，第571-582页， 
2012年。引用于p。829[877]Kay，TL和JT Kajiya，“RayTracing 
ComplexScenes”，计算机图形学 SIGGRAPH（      '86Proceedings）， 
第一卷。20，不。4，pp.269-278，1986年8月。引用于p。959,961 
[878]Kelemen，Csaba和 L'azl'oSzirmay-Kalos， “具有重要性 
采样的基于 Microfacet的耦合镜面 - 哑光 BRDF模型”，在 
Eurographics 2001-Short Presentations ， Eurographics 
Association，pp.25-34 ，9月2001年。引用p。346,352,419[879] 
----------------------- Page 1254-----------------------
凯勒，亚历山大， “即时光能传递”，SIGGRAPH'97：第24届计 
算机图形学和互动技术年会论文集， ACM 出版社/ 
Addison-Wesley 出版公司，第49-56页，1997年8月。引用于 
p。491 [880] Keller ，Alexander 和 Wolfgang Heidrich ， 
 “InterleavedSampling”，渲染技术2001，Springer，第266-273 
页，2001年6月。引用于p。145[881]Kemen，B。， “对数深 
度缓冲优化和修复”，Outerra博客，2013年7月18日。引用于 
p。101参考书目 1097[882]Kensler，Andrew和 PeterShirley， 
 “通过自动搜索优化 Ray-Triangle交叉点”，2006年 IEEE交互式 
光线跟踪研讨会，IEEE计算机学会，第33-38页，2006年。962[883] 
Kent，James R.，Wayne E.Carlson和 RichardE.Parent， “多 
面体对象的形状转换”，计算机图形学（SIGGRAPH '92 
Proceedings），第一卷。26，不。2，pp.47-54,1992。引用于p。 
87[884]Kershaw，Kathleen，一种广义纹理映射管道，硕士论文， 
计算机图形学程序，康奈尔大学，伊萨卡，纽约，1992年。引用于 
p。169,170 [885] Kessenich，John，Graham Sellers和 Dave 
Shreiner，OpenGL编程指南：学习OpenGL的官方指南，版本 
4.5与SPIR-V，第9版，Addison-Wesley，2016年。引用于p。 
27,39,41,55,96,173,174 [886] Kettlewell，Richard， “渲染 
Codemasters的GRID2及其后，”游戏开发者大会，2014年 3 
月。引用于p。258 [887]Kharlamov，Alexander，IainCantlay 
和YuryStepanenko，下一代“   SpeedTree渲染”，HubertNguyen 
----------------------- Page 1255-----------------------
编辑，GPUGems3，Addison-Wesley，pp.69-92,2007。引用p。 
207,560,564,646,856 [888]Kihl，Robert， “使用体积距离场在 
霜冻2中消灭掩蔽”，SIGGRAPH在2010年7月的游戏过程中实 
时渲染方面取得进展。889,890 [889] Kilgard，MarkJ.， “实现 
OpenGL：一种架构的两种实现”，参见ACM SIGGRAPH / 
EUROGRAPHICS图形硬件研讨会，ACM，第45-55页，1997年 
8月。引用次数页。1007[890]Kilgard，MarkJ.， “使用模板缓 
冲器创造反射和阴影”，游戏开发者大会，1999年3月。引用于p。 
805 [891]Kilgard，MarkJ.， “今日GPU的实用和强大的凹凸映 
射技术”，游戏开发者大会，2000年3月。引用于p。212,214[892] 
Kim，Pope和 DanielBarrero， “渲染太空船的技术”，韩国游戏 
会议，2011年 11月。引用于p。892,900，905[893]Kim，教皇， 
 “战锤40,000 中的屏幕空间贴花：太空船”，在ACMSIGGRAPH 
2012会谈中，文章编号。2012年8月6 日。引用于p。889[894] 
Kim，Tae-Yong和 UlrichNeumann，“OpacityShadowMaps”， 
RenderingTechniques2001，Springer，pp.177-182,2001。引 
用于p。257,570,571,612[895]King，Gary和William Newhall， 
 “高效的全方位阴影地图”，载于Wolfgang Engel，编辑， 
ShaderX3，CharlesRiverMedia，第435-448页，2004年。[896] 
King，Gary， “阴影映射算法”，GPUJackpot演示，2004年 10 
月。引用于p。235,240 [897]King，Gary， “动态辐照度环境地 
图的实时计算”，载于 Matt Pharr，编辑，GPU Gems 2， 
----------------------- Page 1256-----------------------
Addison-Wesley，第 167-176页，2005年。426,428,430 [898] 
King，Yossarian， “永远不要让'看到你流行 - 几何级别的细节选 
择问题， “在 MarkDeLoura编辑，GameProgrammingGems， 
CharlesRiverMedia，pp.432-438,2000。引用于p。861,864[899] 
King，Yossarian，“2DLensFlare”，MarkDeLoura编辑，Game 
ProgrammingGems，CharlesRiverMedia，pp.515-518,2000。 
引用于p。524[900]Kircher，Scott，“照明和简化圣徒行：第三，” 
游戏开发者大会，2012年3月。引用于p。889,892 1098参考书 
目[901]Kirk，DavidB.和 DouglasVoorhies， “DN-10000VS的 
渲染架构”，计算机图形学（SIGGRAPH '90Proceedings），第 
一卷。24，不。4，pp.299-307，1990年8月。引用于p。185[902] 
Kirk，David，ed。，GraphicsGemsIII，Academic Press，1992。 
引用于p。102,991[903]Kirk，DavidB.和Wen-meiW. Hwu， 
Programming Massively Parallel Processors ：A Handson 
Approach，Third Edition，MorganKaufmann，2016。引用于 
p。55，1040 [904] Klehm，Oliver，Tobias Ritschel，Elmar 
Eisemann和 Hans-PeterSeidel， “屏幕空间中的 BentNormals 
andCones”，视觉，建模和可视化，EurographicsAssociation， 
pp.177-182,2011。被引用在第467,471 [905]Klein，AllisonW.， 
Wilmot Li，Michael M. Kazhdan，Wagner T. Corr.ea，Adam 
Finkelstein和Thomas A. Funkhouser， “非真实虚拟环境”， 
SIGGRAPH'00：Proceedings第27届计算机图形学与交互技术年 
----------------------- Page 1257-----------------------
会，ACM 出版社/Addison-Wesley PublishingCo.，pp.527-534， 
2000年7月。引用于 p。670,671 [906]Klein，R.，G。Liebich 
和W. Strasser， “Mesh Reductionwith ErrorControl”，第7 
届可视化会议论文集'96，IEEE计算机学会，第311-318页，1996 
年。引用 p。875 [907] Kleinhuis，Christian， “MorphTarget 
Animation 使用 DirectX”，载于Wolfgang Engel，编辑， 
ShaderX4，CharlesRiverMedia，第39-45页，2005年。89[908] 
Klint，Josh，“植被管理在 Leadwerks游戏引擎4”，EricLengyel 
编辑，Game EngineGems 3，CRC Press，pp.53-71,2016。引 
用于p。560[909]Kloetzli，J。， “D3D11软件Tessellation”， 
游戏开发者大会，2013年3月。引用于p。879[910]Klosowski， 
JT，M。Held，JSB Mitchell，H。Sowizral和 K.Zikan， “使用 
k-DOP的边界体积层次进行高效碰撞检测”，IEEE可视化和计算机 
图形学，第一卷。4，不。1，pp.21-36,1998。引用于p。979IEEE 
可视化与计算机图形学报，第一卷。6，不。2，pp.108-123，2000 
年 4 月/ 2000年。[911] Knight，Balor，Matthew Ritchie和 
GeorgeParrish， “高效延迟着色的屏幕空间分类”，EricLengyel 
编辑，Game EngineGems2，AK Peters，Ltd。，第55-73页， 
2011年。引用于第4页。898 [912] Kniss，Joe，G.Kindlmann 
和C.Hansen， “用于交互式体绘制的多维传递函数”，IEEE可视 
化与计算机图形学，第一卷。8，不。3，pp.270-285,2002。引用 
于 p。[913] Kniss，Joe，S.Premoze，C.Hansen，P.Shirley和 
----------------------- Page 1258-----------------------
A.McPherson ， “A Volume for Volume Lighting and 
Modeling，”IEEETransactionsonVisualizationandComputer 
Graphics，vol。9，不。2，pp.150-162,2003。引用于p。607[914] 
Knowles，Pyarelal，GeoffLeach和 FabioZambetta， “高效分 
层片段缓冲技术”，PatrickCozzi和Christophe Riccio，编辑， 
OpenGL Insights，CRC出版社，第279-292页，2012年。引用 
于 p 。155 [915] Kobbelt，Leif，SIGGRAPH '00 中的 “√ 
3-Subdivision”：第27届计算机图形学和交互技术年会论文集， 
ACM 出版社/Addison-Wesley 出版公司，第103-112页，2000 
年7月。引用于p。756,761[916]Kobbelt，Leif和 MarioBotsch， 
 “计算机图形学中基于点的技术概述”，计算机与图形学，第一卷。 
28，不。6，pp.801-814，2004年 12月。引用于 p。578 [917] 
Kochanek，DorisHU和 RichardH.Bartels， “插入具有局部张 
力，连续性和偏差控制的样条”，计算机图形学（SIGGRAPH'84 
Proceedings），第一卷。18，不。3，pp.33-41，1984年7月。 
引用于p。730,731参考书目 1099 [918] Koenderink，Jan J.， 
AndreaJ.van Doorn和 MarigoStavridi， “根据表面散射模式表 
达的双向反射分布函数”，ECCV2001年会议录，第一卷。2，pp。 
1996年第28-39页。引用第2页。404 [919]Koenderink，JanJ. 
和SylviaPont， “天鹅绒皮肤的秘密”，机器视觉和应用杂志，第 
一卷。14，没有。4，pp.260-268,2002。引用于p。356[920]K¨ 
ohler，Johan，“实际秩序独立透明度”，技术报告ATVI-TR-16-02， 
----------------------- Page 1259-----------------------
Activision Research，2016年。引用于 p。569 [921] Kojima， 
Hideo，HidekiSasaki，MasayukiSuzuki和JunjiTago， “通过 
福克斯眼中的照片写实：金属齿轮固体地面零点的核心”，游戏开 
发者大会，2013年3月。引用于p。[922]Kolchin，Konstantin， 
 “Curvature-Based Shading of Translucent Materials，例如 
Human Skin”，在 Proceedings of the 5th Conference on 
Computer Graphics and Interactive Techniques in Australia 
and SoutheastAsia，ACM，pp.239-242， 2007年 12月。引 
用于 p。634 [923] Koltun，Vladlen，Yiorgos Chrysanthou和 
DanielCohen-Or， “使用双射线空间从硬件加速的区域可见性”， 
在渲染技术2001，Springer，第204-214页，2001年6月。引 
用于p。843[924]Kontkanen，Janne和SamuliLaine，Ambient“ 
OcclusionFields”，Wolfgang Engel，编辑，ShaderX4，Charles 
RiverMedia，第101-108页，2005年。452 [925]Kontkanen， 
Janne和Samuli Laine， “环境遮挡领域”，载于2005年交互式 
3D图形与游戏研讨会论文集，ACM，第41-48页，2005年4月。 
引用于第4页。452 [926]Kontkanen，Janne和Samuli Laine， 
 “采样预计算体积照明”，图形工具杂志，第一卷。11，不。3， 
pp.1-16,2006。引用于p。489,491 [927]Koonce，Rusty，Tabula“ 
Rasa中的延迟阴影”，作者：HubertNguyen，编辑，GPUGems 
3，Addison-Wesley，第429-457页，2007年。239,886,887[928] 
Kopta，D.，T。Ize，J。Spjut，E。Brunvand，A。Davis和A. Kensler， 
----------------------- Page 1260-----------------------
 “快速，有效的动画场景BVH更新”，在ACM会议录中SIGGRAPH 
交互式3D图形和游戏研讨会，ACM，第197-204页，2012年。 
引用于p。821[929]Kopta，D.，K。Shkurko，J。Spjut，E。Brunvand 
和A. Davis， “能量和带宽高效光线跟踪架构”，第5届高性能图 
形会议论文集，ACM，pp 。引用次数：121-128，2013年7月。 
1039 [930] Kotfis，Dave和 Patrick Cozzi， “来自深度相机的 
OctreeMapping”，Wolfgang Engel编辑，GPUPro7，CRC出 
版社，第 257-273页，2016年。引用于 p。573,580,919 [931] 
Kovacs，D.，J。Mitchell，S。Drone和 D.Zorin， “Real-Time 
Creased  Approximate  Subdivision  Surfaces  with 
Displacements” ，IEEE Transactions on Visualization and 
ComputerGraphics，第一卷。16，不。5，pp.742-751,2010。 
引用于p。777 [932]Koval`e'.k，V'.t和Jir'。Sochor， “使用统 
计优化的遮挡查询进行遮挡剔除”，中欧计算机图形学，可视化和 
计算机视觉国际会议（WSCG），1月至2月。2005年。引用p。 
845[933]Krajcevski，P.，Adam Lake和 D.Manocha， “FasTC： 
加速固定速率纹理编码”，参见ACM SIGGRAPH交互式3D图形 
和游戏研讨会，ACM，第 137-144页， 2013年3月。引用于p。 
870 [934] Krajcevski，P。和 D. Manocha， “Fast PVRTC 
CompressionUsingIntensityDilation，”JournalofComputer 
GraphicsTechniques，vol。3，不。4，pp.132-145,2014。引用 
于 p。870 [935]Krajcevski，P。和D.Manocha， “SegTC：使 
----------------------- Page 1261-----------------------
用图像分割的快速纹理压缩， “高性能图形学会论文集， 
EurographicsAssociation，pp.71-77，2014年6月。引用于p。 
8701100参考书目[936]Krassnigg，Jan， “延迟贴花渲染技术”， 
EricLengyel编辑，Game EngineGems，Jones和 Bartlett，第 
271-280 页，2010年。889 [937] Kraus，Martin和 Magnus 
Strengert， “基于双线性插值的金字塔滤波器”，GRAPP2007， 
第二届国际计算机图形理论与应用会议论文集，INSTICC，第21-28 
页，2007年。引用次数页。518[938]Krishnamurthy，V。和M. 
Levoy，“将光滑曲面拟合到密集的多边形网格”，SIGGRAPH'96： 
第23届计算机图形学和交互技术年会论文集，ACM，第313-324 
页，1996年8月。引用于p。765[939]Krishnan，S.，M。Gopi， 
M。Lin，D。Manocha和A. Pattekar， “使用ShellTree在样条 
模型之间快速准确地进行接触确定”，计算机图形论坛，第一卷。 
17，不。3，pp.315-326,1998。引用于p。718 [940]Krishnan， 
S.，A。Pattekar，MCLin和 D.Manocha， “球壳：快速接近查 
询的高阶边界体积”，“第三届国际机器人算法基础研讨会论文集”， 
AK Peters，Ltd，pp.122-136,1998。引用于 p。718 [941] 
Kristensen，Anders Wang，Tomas Akenine-Mller 和 Henrik 
WannJensen，“用于实时照明设计的预计算局部辐射传输”，ACM 
Transactions onGraphics （SIGGRAPH2005），vol。24，不。 
3，pp.1208-1215，2005年8月。引用于p。481 [942]Kronander， 
Joel，Francesco Banterle，Andrew Gardner，Ehsan Miandji 
----------------------- Page 1262-----------------------
和Jonas Unger， “混合现实场景的真实感渲染， “计算机图形学 
论坛，第一卷。34，不。2，pp.643-665,2015。引用于p。935[943] 
Kryachko，Yuri， “使用顶点纹理位移进行逼真的水渲染”，载于 
MattPharr编辑，GPUGems2，Addison-Wesley，第283-294 
页，2005年。43 [944]Kubisch，Christoph和 MarkusTavenrath， 
 “OpenGL4.4场景渲染技术”，NVIDIAGPU技术大会，2014 
年3月。引用于p。795,849,851[945]Kubisch，Christoph，“生 
命的三角形 -NVIDIA的逻辑管道”，NVIDIAGameWorks博客， 
2015年3月 16日。引用于p。32 [946]Kubisch，Christoph， 
 “从OpenGL过渡到Vulkan”，NVIDIAGameWorks博客，2016 
年2月11日。引用于p。40,41,796,814 [947]Kulla，Christopher 
和AlejandroConty，重新审“  视Imageworks的基于物理的阴影”， 
SIGGRAPH理论和实践中基于物理的阴影课程，2017年8月。引 
用 p 。 321,336,343,346,347,352,353,358,363,364 [948] 
Kyprianidis，Jan Eric，HenryKang和J¨urgenD'ollner， “GPU 
上的各向异性Kuwahara过滤”，Wolfgang Engel ，ed。，GPU 
Pro，AK Peters，Ltd.，pp.247-264,2010。引用于p。665[949] 
Kyprianidis，Jan Eric，John Collomosse，Tinghuai Wang 和 
Tobias Isenberg， “'艺术'的状态：图像和视频艺术程式化技术的 
分类，”IEEE可视化和计算机图形学交易，第一卷。19，没有。5， 
pp.866-885，2013年5月。引用于p。665,678[950]Lacewell， 
Dylan，DaveEdwards，PeterShirley和William B.Thompson， 
----------------------- Page 1263-----------------------
 “用于交互式植物渲染的随机广告牌云”，图形工具杂志，第一卷。 
11，不。1，pp.1-12,2006。引用于p。563,564[951]Lacewell， 
Dylan，“BakingWithOptiX”，NVIDIAGameWorks博客，2016 
年6月7日。引用p。452 [952]Lachambre，S'ebastian，S'ebastian 
Lagarde 和 Cyril Jover ，Unity 摄影测量工作流程，Unity 
Technologies，2017年。引用于p。349 [953]Lacroix，Jason， 
 “在熟悉的面孔上投射新光：在古墓丽影中基于光的渲染”，游戏 
开发者大会，2013年3月。引用于p。114,116参考书目1101[954] 
Lafortune，Eric PF，Sing-Choong Foo，Kenneth E.Torrance 
和 DonaldP.Greenberg，“反射函数的非线性逼近”，SIGGRAPH 
'97：第24届年会论文集 “计算机图形学与交互技术”，ACM 出版 
社/ Addison-Wesley Publishing Co.，pp.117-126，1997年 8 
月。引用于p。424 [955]Lagae，Ares和 PhilipDutr'e， “高效 
射线 - 四边形交叉测试”，图形工具杂志，第一卷。10，不。4， 
pp.23-32,2005。引用于p。967[956]Lagae，A.，S。Lefebvre， 
R。Cook，T。DeRose，G。Drettakis，DSEbert，JP Lewis，K。 
Perlin，and M.Zwicker， “程序噪声函数的最新技术， “在 
Eurographics 2010-State of the Art Reports，Eurographics 
Association，pp.1-19,2010。引用于 p。199 [957] Lagarde， 
S'ebastian，“Phong和 Blinn照明模型之间的关系”，S'ebastian 
Lagarde博客，2012年3月29 日。引用于p。421 [958]Lagarde， 
S'ebastian和Antoine Zanuttini， “基于局部图像的照明与视差 
----------------------- Page 1264-----------------------
校正立方体图”，在ACM SIGGRAPH2012会谈，ACM，文章编 
号。2012年8月36 日。引用于p。500[959]Lagarde，S'ebastian， 
 “关于菲涅耳方程的备忘录”，S'ebastian Lagarde博客，2013 
年4月29日。引用于p。321[960]Lagarde，S'ebastian和Charles 
deRousiers，“将 Frostbite移动到基于物理的渲染， “SIGGRAPH 
理论与实践课程中基于物理的阴影，2014年8月。引用于第4页。 
111,113,115,116,312,325,336,340,341,354,371,422,426,435,50 
3,890 [961] Lagarde ，S'ebastian ， “IES Light Format ： 
Specificationand Reader，” S'ebastian Lagarde博客，2014 
年 11月5日。引用于p。116,435[962]Laine，Samuli，Hannu 
Saransaari，Janne Kontkanen，Jaakko Lehtinen和TimoAila， 
 “实时间接照明的增量即时光能传递”，第 18届 Eurographics移 
植技术研讨会论文集，EurographicsAssociation，pp2007年6 
月277-286。引用于p。492 [963]Laine，Samuli和TeroKarras， 
 “'高效的稀疏体素八分之一 - 分析，扩展和实施”，技术报告， 
NVIDIA，2010年。引用p。579,580,586[964]Laine，Samuli， 
 “体素化的拓扑方法， “计算机图形学论坛，第一卷。32，不。4， 
pp.77-86,2013。引用于 p。581 [965] Laine，Samuli和 Tero 
Karras， “Apex PointMapforConstant-TimeBoundingPlane 
Approximation ” ， 在 Eurographics Symposium on 
Rendering-Experimental  Ideas ＆ Implementations ， 
EurographicsAssociation，pp.51-55,2015。引用于p 。980[966] 
----------------------- Page 1265-----------------------
Lake，Adam，Carl Marshall，MarkHarris和 MarcBlackstein， 
 “可扩展实时动画的风格化渲染技术”，在非真实动画和渲染国际 
研讨会上，ACM，第 13-20页，6月2000年。引用第2页。670[967] 
Lambert，JH，Photometria，1760。翻译：DLDiLaura，北美照 
明工程学会，2001年。引自p。109,389,390,469[968]Lander， 
Jeff， “Skin Them Bones：Web Programming for the Web 
Generation，”GameDeveloper，vol。5，不。5，1998年5月 
第 11-16页。引用第9页。86[969]兰德，杰夫， “在渲染树的阴 
影下”，游戏开发者，第一卷。7，不。2，pp.17-21，2000年2 
月。引用于p。657,670[970]兰德，杰夫， “那是一个包裹：纹理 
映射方法，”游戏开发者，第一卷。7，不。10，pp.21-26，2000 
年 10月。引用于p。170,173[971]兰德，杰夫， “万圣节闹鬼的 
树”，游戏开发者，第一卷。7，不。11，pp.17-21，2000年 11 
月。引用于p。942[972]兰德，杰夫， “程序员洞穴深处的图像”， 
游戏开发者，第一卷。8，不。5，pp.23-28，2001年5月。引用 
于p。654,666,672 1102参考书目[973]兰德，杰夫， “后照片写 
实主义的时代”，游戏开发者，第一卷。8，不。6，pp.18-22，2001 
年6月。引用于p。670[974]Landis，Hayden， “生产就绪全球 
照明”，SIGGRAPHRenderManinProduction课程，2002年7 
月。引用于p。446，448,465 [975]Langlands，Anders， “渲染 
色彩空间”，alShaders博客，2016年6月23 日。引用于p。278 
[976]Lanman，Douglas和 DavidLuebke， “近眼光场显示器”， 
----------------------- Page 1266-----------------------
ACMTransactionsonGraphics，vol。32，不。6，pp.220：1-220： 
10，2013年 11月。引用于p。549,923[977]Lanza，Stefano， 
 “水下神射线的动画与渲染”，载于Wolfgang Engel，编辑， 
ShaderX5，Charles River Media，第315-327页，2006年。 
626,631[978]Lapidous，Eugene和GuofangJiao， “低成本图 
形硬件的最佳深度缓冲 ” ，参见 ACM SIGGRAPH / 
EUROGRAPHICS图形硬件研讨会，ACM，第67-73页，1999年 
8月。引用 p。100 [979] Larsen，E.，S。Gottschalk，M。Lin 
和 D. Manocha， “快速接近查询与扫掠球体积”，技术报告 
TR99-018，计算机科学系，北卡罗来纳大学，1999年。引用于p。 
976[980]Larsson，Thomas和TomasAkenine-M'oller， “连续 
变形身体的碰撞检测 ” ，在 Eurographics 2001-Short 
Presentations，EurographicsAssociation，pp.325-333，2001 
年 9 月。引用于 p。821 [981] Larsson，Thomas 和 Tomas 
Akenine-M'oller，“用于广义碰撞检测的动态边界体积层次”，计 
算机与图形学，第一卷。30，不。3，pp.451-460,2006。引用于p。 
821 [982] Larsson，Thomas，Tomas Akenine-M'oller 和 Eric 
Lengyel， “更快的球体盒重叠测试”，图形工具杂志，第一卷。 
12，不。1，pp.3-8,2007。引用于p。977[983]Larsson，Thomas， 
 “高效的椭圆体 -OBB交叉测试”，图形工具杂志，第一卷。13， 
不。1，pp.31-43,2008。引用于p。978[984]Larsson，Thomas 
和 LinusK¨allberg， “快速计算紧密定向的边界框，”EricLengyel 
----------------------- Page 1267-----------------------
编辑，GameEngineGems2，AK Peters，Ltd.，pp.3-19,2011。 
引用于 p。951,952 [985] Lathrop，Olin，David Kirk和 Doug 
Voorhies，“通过亚像素寻址精确渲染”，IEEE计算机图形和应用， 
第一卷。10，不。5，pp.45-53，1990年9月。引用于p。689[986] 
Latta，Lutz，“GPU上的大规模并行粒子系统”，载于Wolfgang 
Engel，编辑，ShaderX3，CharlesRiverMedia，第 119-133页， 
2004年。同时在GDC2004上发表并发表为 “建立一个百万粒子 
系统，“Gamasutra，2004年7月28 日。引用于p。568,571[987] 
Latta，Lutz， “粒子效应的一切”，游戏开发者大会，2007年3 
月。引用于 p。568,569,571 [988] Lauritzen ，Andrew ， 
 “Summed-Area Variance Shadow Maps”，作者：Hubert 
Nguyen ， 编 辑 ， GPU Gems 3 ， Addison-Wesley ， 
pp.157-182,2007。引用于p。188,252,253,255[989]Lauritzen， 
Andrew 和 Michael McCool ， “Layered Variance Shadow 
Maps”，图形界面2008，加拿大人类计算机通信学会，第 139-146 
页，2008年5月。引用于p。257[990]Lauritzen，Andrew，“延 
迟渲染当前和未来的渲染管道”，SIGGRAPH超越可编程着色课程， 
2010年7月。引用于p。888,893,895,896,914 [991]Lauritzen， 
Andrew，MarcoSalvi和Aaron Lefohn， “样本分布阴影地图”， 
交互式3D图形和游戏研讨会，ACM，第97-102页，2011年2 
月。引用 p。54,101,244,245参考书目 1103 [992] Lauritzen， 
Andrew， “将光与像素相交：关于前向和延迟渲染的推理”， 
----------------------- Page 1268-----------------------
SIGGRAPH超越可编程着色过程，2012年8月。引用于p。882,887， 
896 [993] Lauritzen，Andrew， “图形计算的未来方向”， 
SIGGRAPH实时渲染课程中的问题，2017年 8月。引用于 p。 
32,812,908[994]LaValle，Steve， “预测的潜力”，Oculus开发 
者博客，2013年7月 12 日。引用于p。915,920,936,939 [995] 
LaValle，Steven M.，Anna Yershova，Max Katsev和 Michael 
Antonov， “Oculus Rift的头部跟踪”，IEEE国际会议机器人与 
自动化（ICRA），IEEE计算机学会，第 187-194页，2014年 5 
月至6月。引用于p。915,916,936[996]Laven，Philip，MiePlot 
网站和软件，2015年。引用于p。597,599[997]Lax，PeterD.， 
Linear Algebra and Its Applications，Second Edition，John 
Wiley＆Sons，Inc.，2007。Citedonp。[998]Lazarov，Dimitar， 
 “使命召唤中的基于物理的照明：黑色行动， “SIGGRAPH在游戏 
中实时渲染的进展，2011 年 8 月。引用于第 4 页。 
340,370,371,421,476 [999]Lazarov，Dimitar， “在使命召唤中 
获得更多身体：黑色行动 II”，SIGGRAPH理论和实践课程中基于 
物理的阴影，2013年 7月。引用第4 页。352,421,502 [1000] 
Lazarus，F。和A.Verroust， “三维变形：一项调查”， “视觉计 
算机”，第一卷。14，没有。8，pp.373-389,1998。引用于p。 
87,102[1001]Le，BinhHuy和Jessica K.Hodgins， “具有优化 
旋转中心的实时骨骼皮肤”，ACMTransactionsonGraphics，vol。 
35，不。4，pp.37：1-37：10,2016。引用于p。87 [1002]利百 
----------------------- Page 1269-----------------------
特，理查德， “ForzaHorizo​ ​ n2的制作”，Eurogamer.net， 
2014年 10月11日。引用于p。141,900[1003]Lecocq，Pascal， 
PascalGautron，Jean-Eudes Marvie和Gael Sourimant， “亚 
像素阴影映射”，参见ACM SIGGRAPH交互式3D图形和游戏研 
讨会第18次会议论文集，ACM，第103-110页，2014年。259[1004] 
Lecocq，Pascal，Arthur Dufay，GaelSourimant和Jean-Eude 
Marvie， “实时区域光着色的分析近似”，IEEE可视化和计算机图 
形学，第一卷。23，不。5，pp.1428-1441,2017。引用于p。389 
[1005] Lee，Aaron WF，David Dobkin，Wim Sweldens 和 
PeterSchr¨oder， “多分辨率网格变形”，SIGGRAPH'99：第26 
届计算机图形学与交互技术年会论文集，ACM Press/ Addison- 
Wesley PublishingCo.，pp.343-350,1999。引用于p。87[1006] 
Lee，Aaron，HenryMoreton和 HuguesHoppe， “移位的细分 
曲面”，在SIGGRAPH'00中：第27届计算机图形学与互动技术 
年会论文集，ACM 出版社/Addison-Wesley出版公司，第85-94 
页，2000年7月。引用于p。706,765,766 [1007]Lee，Aaron， 
 “建立你自己的细分曲面”，Gamasutra，2000年9月8 日。引 
用于p。[1008]Lee，Hyunho和 Min-HoKyung， “使用嵌入式 
树折叠的并行网格简化”， “视觉计算机”，第一卷。32，不。6， 
pp.967-976,2016。引用于p。709[1009]Lee，Hyunjun，Sungtae 
Kwon和SeungyongLee， “实时铅笔渲染”，在第四届非真实动 
画和渲染国际研讨会论文集，ACM，第37-45页，2006年。引用 
----------------------- Page 1270-----------------------
页。672 1104参考书目[1010] Lee，Jongseok，SungyulChoe 
和SeungyongLee， “用于移动图形的网格几何压缩， “2010年 
第7届 IEEE消费者通信与网络会议，IEEE计算机学会，第 1-5页， 
2010年。引用于第4页。714[1011]Lee，Mark， “Pre-lighting 
in Resistance2”，游戏开发者大会，2009年 3月。引用于p。 
892[1012]Lee，Sungkil和 ElmarEisemann， “实时实时镜头 - 
耀斑渲染”，计算机图形学论坛，第一卷。32，不。4，pp.1-6,2013。 
引用于p。526[1013]Lee，W.-J.，Y。Youngsam，J。Lee，J.-W。 
金，J.-H。Nah，S。Jung，S。Lee，H.-S。Park和T.-D. Han， 
 “SGRT：用于实时光线跟踪的移动GPU架构”，在第五届高性能 
图形会议论文集中 “实用的实时镜头 - 耀斑渲染”，计算机图形 
学论坛，第一卷。32，不。4，pp.1-6,2013。引用于p。526[1013] 
Lee，W.-J.，Y。Youngsam，J。Lee，J.-W。金，J.-H。Nah，S。 
Jung，S。Lee，H.-S。Park和T.-D. Han， “SGRT：用于实时光 
线跟踪的移动GPU架构”，在第五届高性能图形会议论文集中 “实 
用的实时镜头 - 耀斑渲染”，计算机图形学论坛，第一卷。32，不。 
4，pp.1-6,2013。引用于p。526[1013]Lee，W.-J.，Y。Youngsam， 
J。Lee，J.-W。金，J.-H。Nah，S。Jung，S。Lee，H.-S。Park 
和T.-D. Han，“SGRT：用于实时光线跟踪的移动GPU架构”，在 
第五届高性能图形会议论文集中rence，ACM，pp.109-119，2013 
年7月。引用于p。1039[1014]Lee，Yunjin，LeeMarkosian， 
SeungyongLee和John F.Hughes，“通过抽象阴影划线”，ACM 
----------------------- Page 1271-----------------------
图形交易 （SIGGRAPH2007），第一卷。26，不。3，pp.18：1-18： 
6，2007年 7月。引用于 p。656 [1015] Lee-Steere，J。和J. 
Harmon， “足球在60FPS：渲染 MaddenNFL10的挑战”，游 
戏开发者大会，2010年3月。引用于p。[1016]Lefebvre，Sylvain 
和 FabriceNeyret， “基于模式的程序纹理”，2003年交互式3D 
图形研讨会论文集，ACM，第203-212页，2003年。引自p。[1017] 
Lefebvre，Sylvain，SamuelHornus和 FabriceNeyret，“Octree 
TexturesontheGPU”，载于 MattPharr，编辑，GPUGems2， 
Addison-Wesley，第 595-613页，2005年。引用于p。190[1018] 
Lefebvre ，Sylvain 和 Hugues Hoppe ， “Perfect Spatial 
Hashing”，ACMTransactions onGraphics，vol。25，不。3， 
pp.579-588，2006年 7月。引用于 p。190 [1019] Lehtinen， 
Jaakko，“预先计算和捕获光传输的框架”，ACMTransactionson 
Graphics，vol。26，不。4，pp.13：1-13：22,2007。引用于p。 
481 [1020]Lehtinen，Jaakko，高效物理照明的理论和算法，博士 
论文，赫尔辛基理工大学，埃斯波，芬兰，2007年。引用于p。481 
[1021] Lehtinen ，Jaakko ，Matthias Zwicker ，Emmanuel 
Turquin，Janne Kontkanen，Fr'edoDurand，Fran.coisSillion 
和 Timo Aila， “AMeshless Hierarchical Representation for 
LightTransport，”ACMTransactions onGraphics，vol。27， 
不。3，pp.37：1-37：9,2008。引用p。484 [1022]Lengyel，Eric， 
 “调整顶点的预测深度值”，MarkDeLoura，编辑，游戏编程宝 
----------------------- Page 1272-----------------------
石，CharlesRiverMedia，pp.361-365,2000。引用于p。236,657 
[1023] Lengyel ， Eric ， “T-Junction Elimination and 
Retriangulation”，DanteTreglia编辑，Game Programming 
Gems 3，Charles RiverMedia，pp.338-343,2002。引用于p。 
690 [1024] Lengyel，Eric，ed。，Game EngineGems 2，AK 
Peters，Ltd.，2011。引用于p。815[1025]Lengyel，Eric，3DGame 
Programming and Computer Graphics，T​ ​ hird Edition， 
Charles River Media，2011。引用于 p。102,209,210 [1026] 
Lengyel，Eric， “游戏数学案例研究”，游戏开发者大会，2015 
年3月。引用于p。863[1027]Lengyel，Eric， “SmoothHorizo 
​ ​ nMapping”，EricLengyel编辑，Game EngineGems 3， 
CRC Press，pp.73-83,2016。引用于p。[1028]Lengyel，Eric， 
 “直接从Glyph轮廓渲染的GPU友好字体”，计算机图形技术杂 
志，第一卷。6，不。2，pp。2017年3月31 日至47 日。引用于 
p。677,970 [1029]Lengyel，Jerome， “图形和视觉的融合”， 
计算机，第一卷。31，不。7，pp.46-53，1998年7月。引用于p。 
546[1030]Lengyel，Jerome， “Real-TimeFur”，Rendering 
Techniques 2000，Springer，pp.243-256，2000年6月。引用 
于p。853参考书目 1105[1031]Lengyel，Jerome，EmilPraun， 
Adam Finkelstein和 HuguesHoppe，“任意曲面上的实时毛皮”， 
2001年交互式 3D图形研讨会论文集，ACM，第227-232页， 
Mar 。引用于。646，853[1032]Lensch，HendrikPA，Michael 
----------------------- Page 1273-----------------------
Goesele，PhilippeBekaert，Jan Kautz，MarcusA. Magnor， 
Jochen Lang和 Hans-PeterSeidel， “半透明物体的互动渲染”， 
太平洋计算机图形和应用会议 2002年，IEEE计算机学会，第 
214-224页，2002年 10月。引用于p。635[1033]Levoy，Marc 
和TurnerWhitted，“使用积分作为显示原语”，技术报告85-022， 
计算机科学系，北卡罗来纳大学教堂山分校，1985年 1月。572 
[1034]Levoy，Marc和 PatHanrahan，“光场渲染”，SIGGRAPH 
'96：第23届计算机图形和交互技术年会论文集，ACM，第31-42 
页，1996年8月。引用页。549[1035]Levoy，Marc，KariPulli， 
Brian Curless，Szymon Rusinkiewicz，David Koller，Lucas 
Pereira，MattGinzton，SeanAnderson，James Davis，Jeremy 
Ginsberg和JonathanShade， “数字米开朗基罗项目：大型雕像 
的3D扫描， “在SIGGRAPH'00：第27届计算机图形学与交互技 
术年会论文集，ACM 出版社/ Addison-Wesley PublishingCo.， 
pp.131-144，2000年7月。引用p。573[1036]L'evy，Bruno， 
Sylvain Petitjean，NicolasRay和J'erome Maillot， “自动纹理 
图集生成的最小二乘保形贴图”，ACMTransactiononGraphics， 
vol。21，不。3，pp.362-371，2002年7月。引用于p。485,486 
[1037]Lewis，JP，MattCordner和 NicksonFong， “姿势空间 
变形：形状插值和骨架驱动变形的统一方法”，SIGGRAPH '00： 
第27届计算机图形学年会论文集 InteractiveTechniques，ACM 
Press/Addison-Wesley PublishingCo.，pp.165-172，July2000. 
----------------------- Page 1274-----------------------
引用于p。84,87,90,102[1038]Leyendecker，Felix， “Crafting 
theWorldofCrysis3”，游戏开发者大会欧洲，2013年8月。引 
用于p。366[1039]Li，Xin， “Slerp，或者不是Slerp，”游戏开 
发者，第一卷。13，不。7，pp.17-23，2006年8月。引用于p。 
[1040]Li，Xin， “iSlerp：Slerp的增量方法”，图形工具杂志， 
第一卷。12，不。1，pp.1-6,2007。引用于p。82[1041]Licea-Kane， 
Bill，“GLSL：中心还是质心？ （或当Shaders攻击时！）“OpenGL 
管道通讯，第一卷。3，2007年。引用于p。141[1042]Liktor， 
G'abor和Carsten Dachsbacher， “用于硬件光栅化的延迟阴影 
去耦”，参见ACM SIGGRAPH交互式3D图形和游戏研讨会论文 
集，ACM，第 143-150页，2012年。引用于p 。910[1043]Liktor， 
G'abor和Carsten Dachsbacher， “在GPU上解耦延迟着色”， 
Wolfgang Engel编辑，GPU Pro4，CRC出版社，第81-98页， 
2013年。910 [1044]Liktor，G.，M。Pan和C. Dachsbacher， 
 “FractionalReyes-StyleAdaptiveTessellationfor Continuous 
LevelofDetail”，ComputerGraphicsForum，vol。33，不。7， 
pp。191-198,2014。引用于p。774,775[1045]Liktor，G。和 K. 
Vaidyanathan，“用于增量硬件遍历的带宽高效 BVH布局”，“高 
性能图形学会议论”，EurographicsAssociation，pp.51-61，2016 
年6月。引用次数页。1039[1046]Lilley，Sean， “阴影和铯实 
施”，Cesium网站，2016年 11月。引用于p。265 [1047]Lin， 
Gang和Thomas P.-Y.Yu，“改进的三维网格渲染顶点缓存方案”， 
----------------------- Page 1275-----------------------
IEEETrans。关于可视化和计算机图形学，第一卷。12，不。4， 
pp.640-648,2006。引用于 p。701 1106 参考书目 [1048] 
Lindbloom，Bruce，“RGB/XYZ Matrices”，BruceLindbloom 
网站，2017年4月7 日。引用于p。278 [1049]Lindholm，Eri 
​ ​ k，MarkKilgard和 HenryMoreton， “一个用户可编程的顶 
点引擎， “在SIGGRAPH '01第28届计算机图形学与交互技术年 
会论文集，ACM，pp.149-158，2001年8月。引用于p。15,38[1050] 
Lindholm，E.，J.Nickolls，S.Oberman和J.Montrym，“NVIDIA 
Tesla：A UnifiedGraphicsandComputingArchitecture，”IEEE 
Micro，vol。28，不。2，pp.39-55,2008。引用于p。1004,1029,1031 
[1051] Lindstrom ， P 。和 JD Cohen ， “Onres-the-Fly 
Decompressionand Renderingof MultiresolutionTerrain，” 
in Proceedings of the 2010 ACM SIGGRAPH Symposium on 
Interactive3DGraphicsandGames，ACM，pp。 65-73,2010。 
引用于p。879 [1052] Ling-Qi，Yan，Chi-WeiTseng，Henrik 
WannJensen和 RaviRamamoorthi， “物理准确的毛皮反射：建 
模，测量和渲染”，ACM图形交易 （SIGGRAPHAsia2015），第 
一卷。34，不。6，文章编号。185,2015。引用于p。640,641,647 
[1053]Lira，Felipe，FelipeChaves，Fl'avioVillalva，JesusSosa， 
Kl'eversonPai.ao和Te'ofilo Dutra， “MobileToonShading”， 
作者：Wolfgang Engel，编辑，GPUZen ，BlackCatPublishing， 
pp.115-122,2017。引用于p。[1054]Liu，Albert Julius，Zhao 
----------------------- Page 1276-----------------------
Dong，MilosHasan和Steve Marschner， “模拟实木的结构和 
纹理”，ACM Transactions on Graphics，vol。35，不。6，文 
章编号。170,2016。引用于p。199[1055]Liu，Edward， “Lens 
MatchedShadingand UnrealEngine4 IntegrationPart3”， 
NVIDIAGameWorks博客，2017年1月18 日。引用于p。930,940 
[1056]Liu，Fang，Meng-ChengHuang，Xue-Hui Liu，和 En-Hua 
Wu， “高效深度剥离通过桶分类”，在高性能图形会议论文集， 
ACM，pp。 2009年8月51-57。引用于p。[1057]刘立刚，张 
磊，尹旭，Craig Gotsman和 StevenJ. Gortler， “地球/全球网 
格参数化方法”， “几何处理研讨会论文集”，Eurographics 
Association，pp.1495-1504,2008。引用于p。485 [1058]Liu， 
Songrun，Zachary Ferguson，AlecJacobson和YotamGingold， 
 “无缝：缝合擦除和缝合意识将形状与网格分辨率解耦”，ACM 
Transactions onGraphics，vol。36，不。6，pp.216：1-216： 
15,2017。引用于p。486 [1059]Liu，Xinguo，Peter-PikeSloan， 
Heung-YeungShum和John Snyder， “光学对象的全频预计算 
辐射传递”，“第 15届 Eurographics会议渲染技术会议论文集”， 
EurographicsAssociation，pp。 2004年6月，337-344。引用 
于p。432 [1060]Llopis，Noel， “面向数据设计的高性能编程”， 
Eric Lengyel编辑，Game EngineGems 2，AK Peters，Ltd.， 
pp.251-261,2011。引用于p。791,812[1061]Lloyd，Brandon， 
JeremyWendt，NagaGovindaraju和 DineshManocha， “CC 
----------------------- Page 1277-----------------------
ShadowVolumes”，在第 15届 Eurographics渲染技术研讨会论 
文集，EurographicsAssociation，pp.197-206，2004年6月。 
被引用在第 233[1062]Lloyd，Brandon，DavidTuft，Sung-Eui 
Yoon和 DineshManocha，“WarpingandPartitioningfor Low 
Error Shadow Maps ” ， Eurographics Symposium on 
Rendering，EurographicsAssociation，pp.215-226，June2006. 
Cited在第 241,242,244 [1063] Lloyd，Brandon，Logarithmic 
PerspectiveShadowMaps，博士论文，计算机科学系，北卡罗来 
纳大学教堂山分校， 2007 年 8 月。 101,241,242 [1064] 
Lobanchikov，IgorA.和 HolgerGruen， “GSC GameWorld's 
STALKER：清晰的Sky-A展示 Direct3D 10.0/ 1， “游戏开发者 
大会，2009年 3月。引用于 p。252，887,888参考书目 1107 
[1065]L ¨ ofstedt ， Marta 和 Tomas Akenine-M'oller ， 
 “Ray-Triangle IntersectionAlgorithms 的评估框架”，图形工 
具杂志，第一卷。10，不。2，pp.13-26,2005。引用于p。962[1066] 
Lokovic，Tom和 EricVeach， “深影地图”，SIGGRAPH '00： 
第 27届计算机图形学和交互技术年会论文集，ACM 出版社/ 
Addison-Wesley 出版公司，第385页 -2000年7月第392号。 
引用第9页。[1067]循环，C。，基于三角形的平滑细分，硕士论 
文，犹他大学数学系，1987年8月。引用于p.307,258,570,638。 
758,759,760,761 [1068]Loop，Charles和Jim Blinn， “使用可 
编程图形硬件进行分辨率独立曲线渲染”，ACMTransactions on 
----------------------- Page 1278-----------------------
Graphics，vol。24，不。3，pp.1000-1009,2005。引用于p。677,725 
[1069]Loop，Charles和Jim Blinn， “在GPU上渲染矢量艺术”， 
在 Hubert Nguyen编辑，GPU Gems 3，Addison-Wesley， 
pp.543-561,2007。引用于p。677,725[1070]Loop，Charles和 
ScottSchaefer， “用双立方补丁逼近Catmull-Clark细分曲面”， 
ACMTransactions onGraphics，vol。27，不。1，pp.8：1-8： 
11,2008。引用p。767,775,776,777,779[1071]Loop，Charles， 
ChaZhang和ZhengnyouZhang， “应用于基于图像的建模的实 
时高分辨率稀疏体素化”，第5期高性能图形学报会议，ACM，第 
73-79页，2013年7月。引用于p。580[1072]Loos，Bradford 
和 Peter-PikeSloan，“容量障碍”，载于2010年ACMSIGGRAPH 
交互式3D图形研讨会论文集，ACM，第151-156页，2010年2 
月。引用于p。459 [1073]Loos，BradfordJ.，LakulishAntani， 
Kenny Mitchell，Derek Nowrouzezahrai，Wojciech Jarosz和 
Peter-Pike Sloan ， “Modular Radiance Transfer ” ，ACM 
Transactions onGraphics，vol。30，不。6，pp.178：1-178： 
10,2011。引用于p。484 [1074]Lorach，Tristan， “DirectX10 
BlendShapes：Breakingthe Limits”，HubertNguyen编辑， 
GPUGems3，Addison-Wesley，pp.53-67,2007。引用于p。90 
[1075] Lorach，Tristan， “Soft Particles”，NVIDIA白皮书， 
2007年 1月。引用于p。558[1076]Lord，Kieren和 RossBrown， 
 “使用遗传算法优化三角带， “在第三届澳大拉西亚和东南亚计算 
----------------------- Page 1279-----------------------
机图形学和互动技术国际会议论文集 （GRAPHITE2005），ACM， 
pp.169-176,2005。引用于p。699[1077]Lorensen，William E. 
和 HarveyE.Cline， “MarchingCubes：一种高分辨率3D表面 
构造算法”，计算机图形学（SIGGRAPH '87Proceedings），第 
一卷。21，不。4，pp.163-169，1987年7月。引用于p。583[1078] 
Losasso，F。和 H. Hoppe， “Geometry Clipmaps：Terrain 
RenderingUsingNestedRegularGrids，”ACMTransactionson 
Graphics，vol。23，不。3，pp.769-776,2004。引用于p。872,873 
[1079]Lottes，Timothy， “FXAA”，NVIDIA白皮书，2009年 
2月。引用于p。148[1080]Lottes，Timothy， “15幻灯片中的 
FXAA3.11”，SIGGRAPH过滤方法，用于实时抗锯齿课程，2011 
年8月。148[1081]乐天，Timothy，“高级技术和优化-HDR-VDR 
彩色管道”，游戏开发者大会，2016年3月。引用于p。281,286,1010 
[1082] Lottes，Timothy， “VDR 跟进 - 用于 HDR 信号的 
Tonemapping”，GPUOpen网站，2016年 10月5日。引用于p。 
281 [1083]Lottes，Timothy， “传统与新'HDR'编码的技术评估 
与显示能力交叉，”Timothy Lottes博客，2016年 10月12日。 
引用于p。2831108参考书目[1084]Lottes，Timothy， “FXAA 
PixelWidthContrastReduction，”Timothy Lottes博客，2016 
年 10月27 日。引用于p。[1085]Loviscach，J¨orn，“Silhouette 
GeometryShaders”，Wolfgang Engel编辑，ShaderX3，Charles 
RiverMedia，第49-56页，2004年。853[1086]Loviscach，J¨ 
----------------------- Page 1280-----------------------
orn，“CareandFeedingofNormalVectors”，Wolfgang Engel 
编辑，ShaderX6，Charles RiverMedia，pp.45-56,2008。引用 
p。366 [1087]Loviscach，J¨orn， “照顾和喂养正常载体”，游 
戏开发者大会，2008年3月。引用于p。366[1088]Low，Kok-Lim 
和Tiow-Seng Tan， “使用顶点聚类进行模型简化”，1997年 
Symposiumon Interactive3DGraphics，ACM，第75-81页， 
1997年4月。引用次数页。709 [1089]Ludwig，Joe， “将课程 
堡垒2移植到虚拟现实的经验教训”，游戏开发者大会，2013年3 
月。引用 p。920,932,940 [1090] Luebke，David P.和 Chris 
Georges， “门户与镜子：潜在可见集的简单，快速评估”，载于 
1995年交互式3D图形研讨会论文集，ACM，第105页 - 106， 
1995年4 月。引用于 p。838 [1091] Luebke，David P.， “A 
Developer'sSurveyof PolygonalSimplificationAlgorithms，” 
IEEEComputer Graphics＆Applications，vol。21，没有。3， 
pp.24-35，2001年5月至6月。引用于p。706，716[1092]Luebke， 
David，3DGraphics的详细程度，MorganKaufmann，2003年。 
引用于 p。706,708,709,716,854,879 [1093] Luksch，C.，RF 
Tobler，T.Mühlbacher，M.Schw¨arzler和 M.Wimmer， “具有 
规则取样的光泽材料的实时渲染” ， “视觉计算机，第一卷。30， 
不。6-8，pp.717-727,2014。引用于p。423 [1094] Lysenko， 
Mikola， “在 Minecraft游戏中迷失”，0 FPS博客，2012年6 
月 30 日。引用于p。582,583 [1095] Ma，Wan-Chun，Tim 
----------------------- Page 1281-----------------------
Hawkins，Pieter Peers，Charles-F'elix Chabert，MalteWeiss 
和 PaulDebevec，“从偏振球面梯度照明中快速采集镜面和漫反射 
法线贴图”，在会议录中第18届 Eurographics技术研讨会， 
EurographicsAssociation，pp.183-194，2007年6月。引用于 
p。634，635[1096]MacDonald，JD和 KSBooth， “使用空间 
细分进行光线追踪的启发式”，VisualComputer，vol。6，不。6， 
pp.153-165,1990。引用于p。953[1097]Maciel，P。和 P.Shirley， 
 “使用纹理簇的大环境的视觉导航”，1995年 Symposium on 
Interactive 3D Graphics，ACM，pp.96-102,1995的论文集。 
561,853,866 [1098] Macklin，Miles， “Faster Fog”，Miles 
Macklin博客，2010年6月10日。引用于p。603[1099]Maglo， 
Adrien ，Guillaume Lavou'e ， Florent Dupont 和 C'eline 
Hudelot， “3D 网格压缩：调查，比较和新兴趋势”，ACM 
ComputingSurveys，vol。47，不。3，pp.44：1-44：41，2015 
年4月。引用于p。712,714[1100]Magnenat-Thalmann，Nadia， 
RichardLaperri`ere和 DanielThalmann， “用于手动画和物体抓 
取的联合依赖局部变形”，图形界面'88，加拿大人机通信学会，第 
26-33页，1988年6月。引用于p。85[1101]Magnusson，Kenny， 
 “用战地3照亮你”，游戏开发者大会，2011年3月。引用于p。 
482 [1102]Mah，Layla和StephanHodes，“DirectComputefor 
Gaming：使用计算着色器为您的引擎增压”，游戏开发者大会， 
2013年3月。引用于p。54,518,535参考书目 1109[1103]Mah， 
----------------------- Page 1282-----------------------
Layla， “为下一代图形提供动力：AMDGCN架构”，游戏开发者 
大会，2013年3月。引用于p。1035[1104]Mah，Layla， “VR 
和图形应用中的低延迟和无间断渲染”，游戏开发者大会，2015年 
3月。引用于p。922,928,938,939[1105]Maillot，Patrick-Giles， 
 “使用四元数进行编码3D转换”，载于AndrewS.Glassner编辑， 
图形宝石，学术出版社，第498-515页，1990年。77[1106]Maillot， 
J'er.ome和JosStam， “多边形建模的统一细分方案”，计算机图 
形论坛，第一卷。20，不。3，pp.471-479,2001。引用于p。761 
[1107]Ma¨.m，Jonathan和 DanielThalmann， “改进了几何实 
例化的外观变化”，Wolfgang Engel编辑，ShaderX6，Charles 
River Media，第17-28页，2008年。引用第 7页。798,800 
[1108]Ma¨.m，Jonathan，BarbaraYersin和 DanielThalmann， 
 “人群的独特实例”，IEEE计算机图形和应用，第一卷。29，不。 
6，pp.82-90,2009。引用于p。798,800 [1109]Malan，Hugh， 
 “Crackdown 中的图形技术”，载于Wolfgang Engel，编辑， 
ShaderX7，CharlesRiverMedia，第 189-215页，2009年。561 
[1110]Malan，Hugh， “实时全局照明和尘埃中的反思 514”， 
SIGGRAPH在游戏中实时渲染的进展，2012年8月。引用于p。 
142,143,493 [1111] Malmer，Mattias，Fredrik Malmer，Ulf 
Assarsson和 NicolasHolzschuch， “接近阴影的快速预先计算的 
环境遮挡”，图形工具杂志，第一卷。12，不。2，pp.59-71,2007。 
引用于p。452 [1112]Malvar，HenriqueS.，GaryJ.Sullivan和 
----------------------- Page 1283-----------------------
SridharSrinivasan，“用于图像压缩的基于提升的可逆颜色变换”， 
数字图像处理应用XXXI，SPIE，2008年。引用于p。197[1113] 
Malvar，R。， “Fast Progressive Image Coding Without 
Wavelets，”DataCompressionConference，2000年3月。引 
用于p。870[1114]Malyshau，Dzmitry， “基于四元数的渲染管 
道”，Wolfgang Engel，编辑，GPU Pro3，CRC Press， 
pp.265-273,2012。引用于 p。82,210,715 [1115] Mammen， 
Abraham， “使用虚拟 PixelMaps技术实现的透明度和抗锯齿算 
法”，IEEE计算机图形和应用，第一卷。9，不。4，pp.43-55， 
1989年7月。引用于p。139,154[1116]Mamou，Khaled，Titus 
Zaharia和 Fran.coisePr.eteux， “TFAN：低复杂度3D网格压缩 
算法”，计算机动画和虚拟世界，第一卷。20，pp.1-12,2009。引 
用于 p。712 [1117] Mansencal，Thomas， “关于渲染引擎 
ColourspacesAgnosticism”，Color Science博客，2014年9 
月 17日。引用于p。278 [1118]Mansencal，Thomas， “关于 
RGBColourspace模型性能”，ColorScience博客，2014年 10 
月9 日。引用于p。278[1119]Manson，Josiah和ScottSchaefer， 
 “参数化意识 MIP映射”，计算机图形论坛，第一卷。31，不。4， 
pp.1455-1463,2012。引用于 p。[1120] Manson，Josiah 和 
Peter-PikeSloan， “快速过滤反射探测器”，计算机图形学论坛， 
第一卷。35，不。4，pp.119-127,2016。引用于p。420,503,518 
[1121]Mantor，M。和 M.Houston， “AMD图形核心低功耗高 
----------------------- Page 1284-----------------------
性能图形和并行计算”，AMD融合开发者峰会，2011年6月。引 
用于p。1036[1122]Mara，M。和M.McGuire， “截面，透视 
投影3D球体的二维多面体边界”，计算机图形技术杂志，第一卷。 
2，没有。2，pp.70-83,2013。引用于p。863,886,8941110参考 
书目[1123]Mara，M.，M。McGuire，D。Nowrouzezahrai和 D. 
Luebke， “Deep G-Buffers for Stable Global Illumination 
Approximation ，” in Proceedings of High Performance 
Graphics，EurographicsAssociation， pp.87-98，2016年 6 
月。引用于p。509[1124]Mara，Michael，MorganMcGuire， 
BenediktBitterli和WojciechJarosz，“一种高效的全局照明去噪 
算法”，高性能图形，2017年6月。511[1125]Markosian，Lee， 
MichaelA. Kowalski，SamuelJ.Trychin，LubomirD.Bourdev， 
DanielGoldstein和John F.Hughes， “实时非照片写实渲染”， 
SIGGRAPH'97：第24届年度会议录计算机图形学与交互技术会议， 
ACM 出版社/ Addison-Wesley PublishingCo.，pp.415-420， 
1997年8月。引用于p。667 [1126]Markosian，Lee，Barbara 
J. Meier，MichaelA. Kowalski，LoringS.Holden，JD Northrup 
和John F.Hughes， “基于艺术的连续细节渲染”，载于第 1届国 
际会议论文集非真实感动画和渲染研讨会，ACM，第59-66页， 
2000年6月。引用p。670,672[1127]Marques，R.，C。Bouville， 
M。Ribardi`ere，LPSantos和 K.Bouatouch， “球形斐波纳契点 
集合照明积分”，计算机图形论坛，第一卷。32，不。8， 
----------------------- Page 1285-----------------------
pp.134-143,2013。引用于p。[1128]Marschner，Stephen R.， 
HenrikWannJensen，MikeCammarano，SteveWorley和 Pat 
Hanrahan， “人发纤维的光散射”，ACM图形交易 （SIGGRAPH 
2003），第一卷。22，不。3，pp.780-791,2000。引用于p。 
359,640,641,642,643,644 [1129] Marschner，Steve 和 Peter 
Shirley，计算机图形学基础，第四版，CRC出版社，2015年。引 
用于p。102[1130]Marshall，CarlS.， “卡通渲染：实时轮廓边 
缘检测和渲染”，MarkDeLoura编辑，GameProgrammingGems 
2，Charles RiverMedia，pp.436-443,2001。引用次数页。666 
[1131]马丁，Sam和 PerEinarsson， “用于视频游戏的实时光能 
传递架构”，SIGGRAPH在2010年7月的3D图形和游戏课程中 
实时渲染方面取得了进展。482 [1132] Martin，Tobias 和 
Tiow-SengTan， “使用梯形阴影贴图进行抗锯齿和连续性”，在 
第15届Eurographics协会研讨会上，EurographicsAssociation， 
pp.153-160，2004年6月。引用p。[1133]马丁内斯，亚当，“在 
仙境中更快的照片写实：在Sony PicturesImageworks中基于物 
理的阴影和照明”，2010年 7 月的电影和游戏制作课程中的 
SIGGRAPH基于物理的着色模型。引用于第 11页。340 [1134] 
Mason，Ashton EW和 EdwinH.Blake， “计算机动画中的自动 
分层细节优化水平”，计算机图形论坛，第一卷。16，不。3， 
pp.191-199,1997。引用于p。866[1135]Masserann，Arnaud， 
 “索引多个顶点阵列”，PatrickCozzi和Christophe Riccio，编 
----------------------- Page 1286-----------------------
辑，OpenGL Insights，CRC出版社，第365-374页，2012年。 
引用于p。691,699,703[1136]Mattausch，Oliver，Jir'。Bittner 
和 MichaelWimmer，“CHC ++：CoherentHierarchicalCulling 
Revisited”，计算机图形论坛，第一卷。27，不。2，pp.221-230,2008。 
引用于 p。845 [1137] Mattausch，Oliver，Jir'。Bittner，Ari 
Silvennoinen，DanielScherzer和 MichaelWimmer， “影子地 
图的高效在线可见性”，载于Wolfgang Engel，编辑，GPUPro3， 
CRC出版社，第233-242页，2012年。247[1138]Mattes，Ben 
和Jean-FrancoisSt-Amour， “波斯王子的说明性渲染”，游戏开 
发者大会，2009年3月。引用于p。658,662参考书目 1111[1139] 
Matusik，W.，C。Buehler，R。Raskar，SJGortler和 L.McMillan， 
SIGGRAPH '00中的 “基于图像的视觉外壳”：第27届计算机图 
形和交互技术年会论文集，ACM 出版社/ Addison-Wesley 
PublishingCo.，第369-374页，2000年。580[1140]Maughan， 
Chris， “Texture Masking for Faster Lens Flare”，在 Mark 
DeLoura编辑，Game Programming Gems 2，Charles River 
Media，pp.474-480,2001。引用于 p。524 [1141] Maule， 
Marilena，Jo.ao LDComba，RafaelTorchelsen和 RuiBastos， 
 “基于光栅的透明度技术概述”，计算机和图形学，第一卷。35， 
不。6，pp.1023-1034,2011。引用于p。[1142]Maule，Marilena， 
Jo.aoComba，RafaelTorchelsen和 RuiBastos，“混合透明度”， 
参见ACMSIGGRAPH交互式3D图形和游戏研讨会论文集，ACM， 
----------------------- Page 1287-----------------------
第 103-118页，2013年。在第 156 [1143]Mavridis，Pavlos， 
和Georgios Papaioannou， “GPU上的高质量椭圆纹理过滤”， 
交互式3D图形和游戏研讨会，ACM，第23-30页，2011年2月。 
引用于p。[1144] Mavridis，P。和G. Papaioannou， “紧凑型 
YCoCg帧缓冲器”，计算机图形技术期刊，第一卷。1，不。1， 
pp.19-35,2012。引用于p。804,805 [1145] Max，Nelson L.， 
 “Horizo​ ​ nMapping：Bump-MappedSurfaces的阴影”， 
TheVisualComputer，vol。4，不。2，pp.109-117,1988。引用 
于 p。460,466 [1146] Max，Nelson L.， “FacetNormals计算 
顶点法线的权重”，图形工具杂志，第一卷。4，不。2，pp.1-6,1999。 
也在[112]中收集。引用p。695 [1147]Max，Nelson， “在建立 
正交基础时提高精度”，计算机图形技术杂志，第一卷。6，不。1， 
pp.9-16,2017。引用于p。75[1148]Maxima，计算机代数系统， 
http：//maxima.sourceforge.net/,2017。引用于p。991[1149] 
Mayaux，Benoit， “实时体积渲染”，修订版演示方，3月至4 
月。2013.引用于p。620[1150]McAllister，DavidK.，Anselmo 
A. Lastra和Wolfgang Heidrich， “高效渲染空间双向反射分布函 
数”，图形硬件2002，EurographicsAssociation，pp.79-88， 
2002年9月。引用p。417,424 [1151]McAllister，David，Spatial“ 
BRDFs”，RandimaFernando编，GPUGems，Addison-Wesley， 
第293-306页，2004年。[1152]McAnlis，Colt，A“Multithreaded 
3DRenderer”，EricLengyel编辑，GameEngineGems，Jones 
----------------------- Page 1288-----------------------
and Bartlett，pp.149-165,2010。引用于第41页。814 [1153] 
McAuley，Stephen， “在孤岛惊魂中校准照明和材料 3， 
 “SIGGRAPH理论与实践课程中基于物理的阴影，2012年8月。 
引用于p。349[1154]麦克劳利，斯蒂芬， “渲染孤岛惊魂世界4”， 
游 戏 开 发 者 大 会 ， 2015 年 3 月 。 引 用 于 p 。 
143,146,210,420,424,453,481,503,715,864 [1155] McCabe ， 
Dan和John Brothers，“DirectX6TextureMapCompression，” 
GameDeveloper，vol。5，不。8，pp.42-46，1998年8月。引 
用于p。1013[1156]McCaffrey，Jon，“探索移动与桌面OpenGL 
性能”，Patrick Cozzi 和 Christophe Riccio 编辑，OpenGL 
Insights，CRC出版社，第337-352页，2012年。814 [1157]麦 
克劳德，斯科特，理解漫画：隐形艺术，哈珀多年生，1994年。引 
用于 p 。 652,678 [1158] McCombe ，JA ， “PowerVR 
Graphics-Latest Developmentsand Future Plans”，游戏开发 
者大会，2015年3月。引用于p。511,1039，10441112参考书 
目[1159]McCool，MichaelD.，ChrisWales和 KevinMoule， 
 “增量和分层希尔伯特阶边方程多边形光栅化”，图形硬件2001， 
EurographicsAssociation，pp.65-72，2001年 8 月。引用在 
第 996,1001[1160]McCormack，J.，R。McNamara，C。Gianos， 
L。Seiler，NPJouppi和 KenCorell，“Neon：ASingle-Chip3D 
Workstation Graphics Accelerator ，”in ACe SIGGRAPH / 
Proceedings EUROGRAPHICS 图形硬件研讨会，ACM ，第 
----------------------- Page 1289-----------------------
123-123页，1998年 8 月。引用于 p。185,1010,1034 [1161] 
McCormack，Joel，RonaldPerry，KeithI.Farkas和 NormanP. 
Jouppi，“猫：各向异性纹理映射的快速椭圆线”，SIGGRAPH'99： 
第 26届年会论文集计算机图形学与交互技术，ACM 出版社/ 
Addison-Wesley PublishingCo.，第243-250页，1999年8月。 
引用于p。[1162]McCormack，Joel和 RobertMcNamara，“使 
用半平面边缘函数的平铺多边形遍历”，图形硬件2000， 
EurographicsAssociation，pp.15-22，2000年8月。引用于p。 
22,996,997[1163]McDermott，Wes，Allegorithmic的综合PBR 
指南，第一卷。2，Allegorithmic，2016。引用于p。325,349[1164] 
McDonald，J。和 M.Kilgard， “使用相邻边缘法线的无裂纹点 - 
正常三角形”，技术报告，NVIDIA，2010年 12月。引用于p。 
747[1165]McDonald，J。， “不要全力以赴：高效的缓冲管理”， 
游戏开发者大会，2012年3月。引用于p。[1166]麦当劳，约翰， 
 “阿尔法混合：预先或不预先”，NVIDIAGameWorks博客，2013 
年 1月31 日。引用于第11页。208[1167]麦当劳，约翰， “避免 
灾难性绩效损失：检测CPU-GPU同步点，“游戏开发者大会，2014 
年 3月。引用于 p。790,794,805 [1168] McEwan，Ian，David 
Sheets，MarkRichardson和StefanGustavson， “GLSL中的高 
效计算噪声”，图形工具杂志，第一卷。16，不。2，pp.85-94,2012。 
引用于p。199 [1169]McGuire，Morgan和John F.Hughes， 
 “硬件确定的特征边缘”，载于第三届非真实动画和渲染国际研讨 
----------------------- Page 1290-----------------------
会论文集，ACM，第35-47页，2004年6月。引用次数页。668[1170] 
McGuire，Morgan， “The SuperShader”，Wolfgang Engel， 
编辑，ShaderX4，Charles RiverMedia，第485-498页，2005 
年。128 [1171] McGuire，Morgan和 Max McGuire， “Steep 
ParallaxMapping”，交互式3D图形与游戏研讨会海报，2005 
年 4 月。引用于 p。215,216,217,218,933 [1172] McGuire， 
Morgan ， 计 算 机 图 形 学 档 案 ， http ： 
//graphics.cs.williams.edu/data，2011年8月。引用于p。105,118 
[1173] McGuire ，Morgan ， Padraic Hennessy ，Michael 
Bukowski和 BrianOsman， “可塑性运动模糊的重建滤波器”， 
交互式3D图形和游戏研讨会，2012年2月。537,540,541,542,543 
[1174] McGuire，Morgan，Michael Mara和 David Luebke， 
 “Scalable Ambient Obscurance ” ， High Performance 
Graphics，2012 年 6 月。459 [1175] McGuire，M.，D。 
Evangelakos，J。Wilcox，S。Donow和 M.Mara， “Plausible 
Blinn-Phong反射标准立方体 MIP图”，技术报告CSTR201301， 
计算机科学系，威廉姆斯学院，2013年。引用于 p。419 [1176] 
McGuire，Morgan和 LouisBavoil，“加权混合顺序独立透明度”， 
计算机图形技术期刊，第一卷。2，没有。2，pp。122-141,2013。 
引用于 p。158参考书目 1113 [1177] McGuire，Morgan， 
 “Z-Prepass认为不相关”，休闲效果博客，2013年8月14日。 
引用于p。803,882[1178]McGuire，Morgan，Skylanders“    SWAP 
----------------------- Page 1291-----------------------
ForceDepth-of-FieldShader”，Casual Effects博客，2013年 
9月 13 日。引用于p。529,530,532,533,536 [1179] McGuire， 
Morgan和 Michael Mara， “EfficientGPU Screen-Space Ray 
Tracing，”JournalofComputerGraphicsTechniques，vol。3， 
不。4，pp.73-85,2014。引用于p。[1180]McGuire，Morgan， 
 “实施加权，混合顺序无关的透明度”，休闲效果博客，2015年3 
月26 日。引用于第4页。158,569[1181]McGuire，Morgan， 
 “FastColoredTransparency”，CasualEffects博客，2015年3 
月27 日。引用于p。158[1182]McGuire，Morgan， “透过玻 
璃看，对实时透明度的未来黑暗， “SIGGRAPH实时渲染课程中的 
开放式问题，2016年7月。引用于第4页。159,165,623,649[1183] 
McGuire，摩根， “避免运动疾病在VR发展中的策略”，休闲效 
果博客，2016年8月 12 日。引用于p。920 [1184]McGuire， 
Morgan，MikeMara，DerekNowrouzezahrai和 DavidLuebke， 
 “使用预计算光场探测器的实时全局照明”，在第21届 ACM 
SIGGRAPH交互式3D图形和游戏研讨会论文集中，ACM，pp。 
2017年2月2：1-2：11。引用第2页。490,502 [1185]McGuire， 
Morgan和 MichaelMara，Phenomenological“   Transparency，” 
IEEE Transactions of Visualization and Computer Graphics， 
vol。23，no.5，pp.1465-1478，2017 年 5 月。引用于 p。 
158,623,624,629,632,649[1186]McGuire，Morgan， “虚拟前 
沿：计算机图形学在虚拟现实中的挑战＆增强现实， “SIGGRAPH 
----------------------- Page 1292-----------------------
NVIDIA会谈，2017年7月31 日。引用于p。923,939,940[1187] 
McGuire，摩根， “NVIDIA研究如何为VR的未来重塑显示管道， 
第2部分，”VR网站之路，2017年 11月30 日。引用于第9页。 
919,940,1046[1188]McGuire，Morgan，TheGraphicsCodex， 
Edition2.14，Casual EffectsPublishing，2018。372,512,1047 
[1189]McGuire，Morgan，“RayMarching”，在TheGraphics 
Codex，Edition2.14，Casual EffectsPublishing，2018中。引 
用于p。752 [1190]麦克拉伦，詹姆斯， “明日儿童的技术”，游 
戏开发者大会，2015年 3月。引用于 p。496,504,569 [1191] 
McNabb，Doug， “Sparse ProceduralVolume Rendering”， 
Wolfgang Engel编辑，GPUPro6，CRC出版社，第 167-180页， 
2015年。引用于p。611,934[1192]McReynolds，Tom和 David 
Blythe，高级图形编程使用OpenGL，MorganKaufmann，2005 
年       。       引        用       于        p      。 
152,153,199,200,221,222,229,538,551,674,675,678 [1193] 
McTaggart，Gary， “Half-Life2/ValveSourceShading”，游 
戏开发者大会，2004年3月。被引在第 127,394,402,478,488,499 
[1194]McVoy，Larry和Carl Staelin， “lmbench：用于性能分 
析的便携式工具”，载于USENIX年度技术会议论文集，USENIX， 
第 120-133页，Jan 。引自 p。792 [1195] Mehra，Ravish和 
Subodh Kumar， “使用定向距离图精确有效地绘制细节”，在第 
八届印度视觉，图形和图像处理会议论文集中，ACM，第34页： 
----------------------- Page 1293-----------------------
1-34：2012年 12月8 日。引用于p。[1196]Melax，Stan，“一 
种简单，快速，有效的多边形缩减算法”，GameDeveloper，vol。 
5，不。11，pp。1998年 11月44-49。引用于p。707,8601114 
参考书目[1197]Melax，Stan，“TheShortestArcQuaternion”， 
MarkDeLoura编辑，GameProgrammingGems，CharlesRiver 
Media，第214-218页，2000年。83[1198]Meneveaux，Daniel， 
Benjamin Bringier，EmmanuelleTauzia，Micka¨elRibardi`ere 
和 LionelSimonot， “使用 InterfacedLambertianMicrofacets 
渲染粗糙的不透明材料”，IEEE可视化与计算机图形学，第一卷。 
24，不。3，pp.1368-1380,2018。引用于p。331[1199]Meng， 
Johannes ， Florian Simon ，Johannes Hanika 和 Carsten 
Dachsbacher， “使用三刺激色彩进行物理上有意义的渲染”，计 
算机图形学论坛，第一卷。34，不。4，pp.31-40,2015。引用于p。 
349[1200]Merry，Bruce，“基于平铺架构的性能调优”，Patrick 
Cozzi和ChristopheRiccio编辑，OpenGLInsights，CRCPress， 
pp.323-335,2012。引用于p。790,814 [1201]Mertens，Tom， 
Jan Kautz，PhilippeBekaert，Hans-PeterSeidel和 FrankVan 
Reeth， “高效渲染局部次表面散射”，第 11届太平洋计算机图形 
和应用会议论文集，IEEE计算机社会，第 51-58页，2003年 10 
月。引用于p。639[1202]Meshkin，Houman，“排序独立Alpha 
混合”，游戏开发者大会，2007年3月。引用于p。156[1203] 
Meyer，Alexandre和 FabriceNeyret，“交互式体积纹理”，“渲 
----------------------- Page 1294-----------------------
染技术”98，Springer，第157-168页，1998年7月。565,646[1204] 
Meyer，Alexandre，FabriceNeyret和 PierrePoulin， “带有阴 
影和阴影的树的交互式渲染”， “渲染技术2001”，Springer，第 
183-196页，2001年6月。引用于p。202[1205]Meyer，Quirin， 
JochenS ¨ u.ner ，Gerd Su.ner ，Marc Stamminger 和 G ¨ 
untherGreiner ， “On Floating-Point Normal Vectors ，” 
ComputerGraphicsForum，vol。29，不。4，pp.1405-1409,2010。 
引用于p。222[1206]Meyers，Scott，“CPUCaches和Whyyou 
care”，代码::潜水会议，2014年 11月5日。引用于p。791,792 
[1207]Microsoft， “CoordinateSystems”，Windows混合现 
实网站，2017年。引用于p。918,932[1208]Microsoft，“Direct3D 
11Graphics”，Windows开发人员中心。引用p。42,233,525 [1209] 
Mikkelsen，Morten S.， “Bump Mapping Unparametrized 
SurfacesontheGPU”，Technical Report，NaughtyDog，2010。 
引用于p。210[1210]Mikkelsen，MortenS.，“FinePrunedTiled 
LightLists”，Wolfgang Engel编辑，GPU Pro7，CRC出版社， 
第69-81页，2016年。引用于 p。897,914 [1211]米勒，加文， 
 “用于本地和全球可访问性着色的有效算法”，SIGGRAPH '94： 
第21届计算机图形和交互技术年会论文集，ACM，第319-326 
页，1994年 7月。引用于第4页。449 [1212] Miller，Gene S. 
和C. RobertHoffman， “照明和反射图：模拟和真实环境中的模 
拟物体”，SIGGRAPH高级计算机图形动画课程，1984年7月。 
----------------------- Page 1295-----------------------
408,424 [1213] Miller，Scott， “用于扩展动态范围图像的感知 
EOTF”，SMPTE标准更新演示，2014年5月6 日。引用于p。[1214] 
Mitchell，D。和A. Netravali， “计算机图形学中的重建过滤器”， 
计算机图形学 （SIGGRAPH'88Proceedings），第一卷。22，不。 
4，pp.239-246，1988年8月。引用于p。[1215]Mitchell，Jason 
L.，MichaelTatro和 IanBullard， “DirectX6中的多重纹理，” 
游戏开发者，第一卷。5，不。9，pp.33-37，1998年9月。引用 
于 p。200 Bibliography 1115 [1216]Mitchell，Jason L.， “高 
级顶点和像素着色器技术”，欧洲游戏开发者大会，2001年9月。 
引用于p。521[1217]Mitchell，Jason L.， “在 Direct3D中使用 
1.4像素着色器进行图像处理”，在Wolfgang Engel编辑，Direct3D 
ShaderX：Vertex＆Pixel Shader技巧和技巧，Wordware，第 
258-269页，2002年。引用页。521,662[1218]Mitchell，Jason 
L.，MarwanY.Ansari和 EvanHart， “使用 DirectX9像素着色 
器进行高级图像处理”，Wolfgang Engel编辑，ShaderX2：使用 
DirectX 9 进行着色器编程技巧和诀窍， Wordware ， 
pp.439-468,2004。引用于p。515,517,521[1219]Mitchell，Jason 
L.，“LightShaftRendering”，Wolfgang Engel编辑，ShaderX3， 
CharlesRiverMedia，pp。573-588,2004。引用于p。604[1220] 
Mitchell，Jason L.和 PedroV.Sander， “显式早期剔除的应用”， 
SIGGRAPH实时着色课程，2004年8月。引用于p。53,1016[1221] 
Mitchell，Jason， “运动模糊环境地图”，载于Wolfgang Engel， 
----------------------- Page 1296-----------------------
编辑，ShaderX4，Charles RiverMedia，第263-268页，2005 
年。538[1222]Mitchell，Jason，GaryMcTaggart和ChrisGreen， 
 “Valve的源引擎中的阴影”，SIGGRAPH高级实时渲染3D图形 
和游戏课程，2006年 8 月。引用 p。289,382,402,499 [1223] 
Mitchell，Jason L.，Moby Francke和 Dhabih Eng， “Team 
Fortress2中的说明性渲染”，第五届非真实动画和渲染国际研讨 
会论文集，ACM，pp。 2007年8月71-76。收集于[1746]。引 
用p。678 [1224]米切尔，杰森， “有目的的程式化：团队要塞2 
的说明性世界”，游戏开发者大会，2008年3月。引用于p。652,254 
[1225]Mitchell，Kenny， “体积光散射作为后处理”，在 Hubert 
Nguyen编辑，GPUGems3，Addison-Wesley，第275-285页， 
2007年。引用于p。604[1226]Mittring，Martin，Triangle“ Mesh 
TangentSpaceCalculation”，Wolfgang Engel编辑，ShaderX4， 
CharlesRiverMedia，第77-89页，2005年。210[1227]Mittring， 
Martin， “寻找下一代Gen-CryEngine 2”，SIGGRAPH高级实 
时渲染 3D 图形和游戏课程，2007 年 8 月。引用于 p。 
43,195,239,242,255,457,476,559,856,860,861 [1228] Mittring， 
Martin和 Byran Dudash， “DirectX 11虚幻引擎背后的技术 
'Samaritan'Demo，”游戏开发者大会，2011年3月。引用于p。 
389,502,531,641，[1229]Mittring，Martin， “虚幻引擎4元素 
演示背后的技术”，“游戏开发者大会”，2012年3月。引用于p。 
288,371,383,495,526,536,571 [1230] Mohr，Alex 和 Michael 
----------------------- Page 1297-----------------------
Gleicher， “从例子中建立高效，准确的角色皮肤”，ACM图形交 
易 （SIGGRAPH2003），第一卷。22，不。3，pp.562-568,2003。 
引用于p。85[1231]Müoller，Tomas和 BenTrumbore， “快速， 
最小存储雷三角交叉点”，图形工具杂志，第一卷。2，没有。1， 
pp.21-28,1997。也在[112]中收集。引用 p。962,965 [1232] 
Mololler，Tomas， “快速三角形 - 三角形交叉测试”，图形工具 
杂志，第一卷。2，没有。2，pp.25-30,1997。引用于p。972[1233] 
Mololler，Tomas和John F.Hughes， “有效地构建矩阵以将一 
个向量旋转到另一个向量， “图形工具杂志，第一卷。4，不。4， 
pp.1-4,1999。也在[112]中收集。引用p。83,84 [1234]Molnar， 
Steven， “用于高性能架构的高效超级采样抗锯齿”，技术报告 
TR91-023，北卡罗来纳大学教堂山分校计算机科学系，1991年。 
145,5471116参考书目[1235]Molnar，S.，J。Eyles和J. Poulton， 
 “PixelFlow：使用图像合成的高速渲染”，计算机图形学 
 （SIGGRAPH'92Proceedings），第一卷。26，不。2，pp.231-240， 
1992年7月。引用于p。832,1022[1236]Molnar，S.，M.Cox， 
D.Ellsworth，和 H.Fuchs， “ASortingClassificationofParallel 
Rendering，”IEEEComputerGraphicsandApplications，vol。 
14，没有。4，pp.23-32，1994年7月。引用于p。1020,1023[1237] 
Montesdeoca，SE，HSSeah和 H.-M.拉尔， “艺术导演的水彩 
渲染动画”，表达2016年，Eurographics协会，第 51-58页，2016 
年 5月。引用于p。665 [1238]Morein，Steve， “ATI Radeon 
----------------------- Page 1298-----------------------
HyperZTechnology”，图形硬件Hot3D会议，2000年8月。引 
用于p。1009,1015,1016,1038[1239]Moreton，HenryP.和Carlo 
H.S'equin，“FairSurfaceforFairSurfaceDesign，”Computer 
Graphics （SIGGRAPH '92 Proceedings），vol。26，不。2， 
pp.167-176，1992年 7月。引用于 p。761 [1240] Moreton， 
Henry， “使用前向差分的水密曲面细分”，图形硬件2001， 
EurographicsAssociation，pp.25-132，2001年8月。引用于p。 
768,769 [1241]Morovic，J'an，ColorGamut Mapping，John 
Wiley＆Sons，2008。引用于p。[1242]Mortenson，MichaelE.， 
GeometricModeling，Third Edition，JohnWiley＆Sons，2006。 
Citedonp。718，781[1243]Morton，GM， “面向计算机的大 
地测量数据库和文件排序的新技术”，技术报告，IBM，渥太华， 
安大略省，1966年3月1日。引用于p。1018[1244]Mueller， 
Carl，“飞行模拟器图像生成器的体系结构”，技术报告TR95-015， 
北卡罗来纳大学教堂山分校计算机科学系，1995年。[1245] 
Mulde，Jurriaan D.，Frans CA Groen 和 Jarke J. van Wijk， 
 “Screen-DoorTransparency的PixelMasks”，在Visualization 
'98，IEEEComputerSociety，pp.351-358，1998年 10月。引 
用p。[1246]Munkberg，Jacob和TomasAkenine-M'oller，“背 
景剔除运动模糊和景深，”图形，GPU和游戏工具杂志，第一卷。 
15，不。2，pp.123-139,2011。引用于p。835[1247]Munkberg， 
Jacob，KarthikVaidyanathan，Jon Hasselgren，PetrikClarberg 
----------------------- Page 1299-----------------------
和TomasAkenine-M'oller， “DefocusandMotionBlur的分层 
重建”，计算机图形学论坛，第一卷。33，不。4，pp.81-92,2014。 
引用于p。542[1248]Munkberg，J.，J。Hasselgren，P。Clarberg， 
M。Andersson和T.Akenine-M'oller， “纹理空间缓存和重建射 
线追踪”，ACM Transactions on Graphics，vol。35，不。6， 
pp.249：1-249：13,2016。引用于p。934[1249]Museth，Ken 
​ ​ ， “VDB：具有动态拓扑的高分辨率稀疏体积”，ACM 
Transactions on Graphics，vol。32，不。2，文章编号。2013 
年 6 月 27 日。引用于 p。578,584 [1250] Myers，Kevin， 
 “Alpha-to-Coverage in Depth”，Wolfgang Engel 编辑， 
ShaderX5，Charles RiverMedia，pp.69-74,2006。引用于p。 
207 [1251] Myers，Kevin， “Variance Shadow Mapping”， 
NVIDIA白皮书，2007年。引用于p。253 [1252]迈尔斯，凯文， 
Randima （Randy）Fernando和 LouisBavoil， “将逼真的软阴 
影融入你的游戏引擎”，NVIDIA白皮书，2008年2月。引用p。 
250[1253]迈尔斯，凯文，“稀疏影子树”，ACMSIGGRAPH2016 
会谈，ACM，文章编号。2016年7月14日。引用于p。239,246,263 
[1254] Nagy，Gabor ， “Real-Time Shadows on Complex 
Objects”，MarkDeLoura编辑，Game ProgrammingGems， 
Charles River Media，pp.567-580,2000。229参考书目 1117 
[1255]Nagy，Gabor，“Convincing-LookingGlassforGames”， 
MarkDeLoura编辑，GameProgrammingGems，CharlesRiver 
----------------------- Page 1300-----------------------
Media，pp.586-593,2000。[1256]Nah，J.-H.，H.-J。Kwon， 
D.-S。金，C.-H。Jeong，J。Park，T.-D。Han，D。Manocha 
和W.-C. Park，“RayCore：用于移动设备的光线跟踪硬件架构”， 
ACMTransactions onGraphics，vol。33，不。5，第162页： 
1-162：15,2014。引用于p。1039[1257]Naiman，AviC.，Jagged“ 
Edges：When IsFilteringNeeded？”，ACM Transactions on 
Graphics，vol。14，没有。4，pp.238-258,1998。引用于p。143 
[1258]Narasimhan，SrinivasaG.，MohitGupta，CraigDonner， 
RaviRamamoorthi，Shree K.Nayar和 HenrikWannJensen， 
 “通过稀释获取参与媒体的散射特性”，ACM图形交易（SIGGRAPH 
2006），vol 。25，不。3，pp.1003-1012，2006年8月。引用 
于p。591,592[1259]Narkowicz，Krzysztof，GPU上的实时BC6H 
压缩，在Wolfgang Engel编辑，GPU Pro5，CRC 出版社，第 
219-230页，2014年。引用于 p。503,870 [1260]Narkowicz， 
Krzysztof， “ACES FilmicTone MappingCurve”，Krzysztof 
Narkowicz博客，2016 年 1月 6 日。引用于 p。287 [1261] 
Narkowicz，Krzysztof， “HDRDisplay-FirstSteps”，Krzysztof 
Narkowicz博客，2016年8月31 日。引用p。287[1262]Nassau， 
Kurt，The Physics of Color：The Fifteen Causes of Color， 
SecondEdition，JohnWiley＆Sons，Inc.，2001。引用于p。373 
[1263] Navarro ，Fernando ，Francisco J. Ser'on 和 Diego 
Gutierrez，“运动模糊渲染：最先进的技术”，计算机图形学论坛， 
----------------------- Page 1301-----------------------
第一卷。30，不。1，pp.3-26,2011。引用于p。543[1264]Nehab， 
D.，P。Sander，J。Lawrence，N。Tatarchuk和J.Isidoro， “利 
用反向重投影加速实时着色”，图形硬件2007，Eurographics 
Association，pp.25-2007年8月35日。引用于p。522,523[1265] 
Nelson，Scott R.， “正确抗锯齿线的十二个特征”，图形工具杂 
志，第一卷。1，不。4，pp.1-20,206。引用于p。[1266]Neubelt， 
D。和M.Pettineo， “为该命令制作下一代物质管道：1886年， 
 “SIGGRAPH理论与实践课程中基于物理的阴影，2013年7月。 
引用于第4页。357,365,370[1267]Neubelt，D。和 M.Pettineo， 
 “为该命令制作下一代材料管道：1886年”，游戏开发者大会，2014 
年3月。引用于p。365,370,466,896[1268]Neubelt，D。和 M. 
Pettineo，Ready“ atDawnStudios的高级照明研发”，SIGGRAPH 
基于物理学的理论和实践中的着色课程，2015年8月。引用于p。 
398,477,488,498 [1269] Ng，Ren，Ravi Ramamoorthi和 Pat 
Hanrahan， “使用非线性小波照明近似的全频阴影”，ACM 
Transactions onGraphics （SIGGRAPH2003），vol。22，不。 
3，pp.376-281,2003。引用于 p。433 [1270] Ng，Ren，Ravi 
Ramamoorthi和 PatHanrahan， “用于全频率重载的三重产品小 
波积分， “ACM图形交易 （SIGGRAPH2004），第一卷。23，不。 
3，pp.477-487，2004年8月。引用于p。402，433,470 [1271] 
Ngan，Addy，Fr'edo Durand和Wojciech Matusik， “BRDF 
模型的实验分析”，在第16届 Eurographics协会研讨会上， 
----------------------- Page 1302-----------------------
EurographicsAssociation，pp.117-126，2005年6月至7月。 
引用p。338,343[1272]Nguyen，Hubert，“在体积上投下阴影”， 
游戏开发者，第一卷。6，不。3，pp.44-53，1999年3月。引用 
于p。229[1273]Nguyen，Hubert，“Fireinthe'Vulcan'Demo”， 
 “Randima Fernando编辑，GPU Gems，Addison-Wesley， 
pp.87-105,2004。引用于p。152,521,5541118参考书目[1274] 
Nguyen，Hubert和William Donnelly， “头发动画和'Nalu'演示 
中的渲染” ，载于 Matt Pharr ，编辑，GPU Gems 2 ， 
Addison-Wesley ，第 361 页 - 380,2005 。引用于 p 。 
257,644,719,730 [1275] Ni，T.，I。Casta.no，J。Peters，J。 
Mitchell，P。Schneider和V.Verma，SIGGRAPH细分表面高效 
替代课程，2009年8月。引用于 p。767,781 [1276] Nichols， 
Christopher， “关于无偏渲染的真相”，ChaosgroupLabs博客， 
2016年9月29 日。引用于p。1043[1277]Nicodemus，FE，JC 
Richmond，JJ Hsia，IWGinsberg和T.Limperis， “几何考虑和 
反射命名法”，国家标准局（美国），1977年 10月。引用于p。 
310,634[1278]Nienhuys，Han-Wen，JimArvo和 EricHaines， 
 “拳击比赛中的球体结果”，RayTracing News，vol。10，不。 
1997年 1月1日。引用于p。953[1279]Nie.ner，M.，C。Loop， 
M。Meyer和T. DeRose， “Catmull-Clark细分曲面的特征自适 
应GPU渲染”，ACMTransactions onGraphics，vol。31，不。 
1，pp.6：1：6：11，2012年 1月。引用于p。771,774,777,778,779 
----------------------- Page 1303-----------------------
[1280] Nie.ner，M.，C。Loop 和 G. Greiner， “高效评估 
Catmull-Clark 细分曲面中的半光滑折痕”，在 Eurographics 
2012-Short Papers中，EurographicsAssociation，pp.41-44， 
May 2012.引用于 p。777 [1281] Nie.ner，M。和 C. Loop， 
 “ Analytic Displacement Mapping Using Hardware 
Tessellation，”ACMTransactions onGraphics，vol。32，不。 
3，pp.26：1-26：9,2013。引用于p。766,773 [1282]Nie.ner， 
M. ， Rendering Subdivision Surfaces Using Hardware 
Tessellation ， PhD thesis ， Friedrich-Alexander-Universit ¨ 
atErlangen-N¨urnberg，2013。引用于p。777,779,781 [1283] 
Nie.ner，M.，B。Keinert，M。Fisher，M。Stamminger，C。 
Loop和 H.Sch¨afer， “Real-Time RenderingTechniques with 
HardwareTessellation，”Computer图形论坛，第一卷。35，不。 
1，pp.113-137,2016。引用于p。773,781，879[1284]Nishita， 
Tomoyuki，ThomasW.Sederberg和 MasanoriKakimoto，“Ray 
Tracing Trimmed Rational Surface Patches”，计算机图形学 
 （SIGGRAPH'90Proceedings），第一卷。24，不。4，pp.337-345， 
1990年8月。引用于p。967[1285]Nishita，Tomoyuki，Takao 
Sirai，KatsumiTadamura和 EihachiroNakamae， “考虑到大气 
散射的地球显示”，SIGGRAPH'93：第20届计算机图形学和交互 
技术年会，ACM会议录， 1993年8月，第 175-182页，引自第 
9页。614[1286]N'oll，Tobias和 DidierStricker， “用于自动纹 
----------------------- Page 1304-----------------------
理图集生成的任意形状图表的高效打包”，在第二十二届欧洲图表 
协 会 会 议 论 文 集 中 ， Eurographics Association ， 
pp.1309-1317,2011 。引用p。191[1287]Northrup，JD和 Lee 
Markosian， “艺术剪影：一种混合方法”，载于第一届非真实动 
画和渲染国际研讨会论文集，ACM，第31-37页，2000年6月。 
引用于第4页。[1288]Nov'ak，J。和C. Dachsbacher， “光栅 
化边界体积层次”，计算机图形学论坛，第一卷。31，不。2， 
pp.403-412,2012。引用于 p。565 [1289] Novosad，Justin， 
 “Advanced High-Quality Filtering”，Matt Pharr编辑，GPU 
Gems2，Addison-Wesley，第417-435页，2005年。引用于p。 
136,517,521 [1290] Nowrouzezahrai，Derek，Patricio Simari 
和 EugeneFiume， “SparseZonal HarmonicFactorizationfor 
EfficientSHRotation，”ACMTransactionsonGraphics，vol。 
31，不。3，文章编号。2012年第23期。引用第2页。401 [1291] 
Nuebel，Markus， “硬件加速木炭渲染”，Wolfgang Engel编 
辑，ShaderX3，CharlesRiverMedia，第 195-204页，2004年。 
引用p。671参考书目 1119[1292]Nummelin，Niklas，Frostbite“ 
onMobile”，SIGGRAPH移动图形课程，2015年8月。引用于p。 
903[1293]NVIDIA公司， “使用纹理图集改进批处理”，SDK白 
皮书，2004年。引用于 p。191[1294]NVIDIA公司， “暴露的 
GPU编程：NVIDIA演示背后的裸体真相”，SIGGRAPH参展商技 
术讲座，2005年8月。引用p。531[1295]NVIDIACorporation， 
----------------------- Page 1305-----------------------
 “SolidWireframe”，白皮书，WP-03014-001v01，2007年2 
月。引用于p。673,675[1296]NVIDIA公司， “NVIDIAGF100- 
世界上最快的GPU，以真正的几何现实主义提供出色的游戏性能”， 
白皮书，2010年。1031[1297]NVIDIA公司，“NVIDIAGeForce 
GTX 1080-GamingPerfected”，白皮书，2016年。引用于p。 
929,1029,1030,1032,1033 [1298] NVIDIA Corporation ， 
 “NVIDIATesla P100- 迄今为止最先进的数据中心加速器”，白 
皮书，2016年。引用于第4页。1029,1030,1034[1299]NVIDIA 
GameWorks       DirectX    样     本     ，     https    ： 
//developer.nvidia.com/gameworks-directx-samples。引用p。 
888,914  [1300]  NVIDIA  SDK  10  ， http  ： 
//developer.download.nvidia.com/SDK/10/direct3d/samples. 
html,2008。引用于p。48,255,558,647 [1301]NVIDIASDK 11， 
https ：//developer.nvidia.com/dx11-samples 。引用 p 。 
46,55,150 [1302]Nystad，J.，A。Lassen，A。Pomianowski，S。 
Ellis和T.Olson， “AdaptiveScalableTextureCompression”， 
在第四届ACMSIGGRAPH/ EurographicsConferenceonHigh- 
Proceedings  Performance  Graphics ， Eurographics 
Association，pp.105-114，June2012.引用于p。196[1303]Oat， 
Chris， “A Steerable Streak Filter”，Wolfgang Engel编辑， 
ShaderX3，Charles RiverMedia，第341-348页，2004年。引 
用p。520,524,525[1304]Oat，Chris，“IrradianceVolumesfor 
----------------------- Page 1306-----------------------
Games”，游戏开发者大会，2005年3月。引用于p。487 [1305] 
Oat，Chris， “IrradianceVolumesfor Real-TimeRendering”， 
inWolfgang Engel，ed。，ShaderX5，Charles River Media， 
pp.333-344,2006。引用于p。487 [1306]Oat，Christopher和 
PedroV.Sander， “AmbientAperture Lighting”，SIGGRAPH 
高级实时渲染3D图形和游戏课程，2006年8月。引用于p。466 
[1307] Oat ，Christopher 和 Pedro V. Sander ， “Ambient 
Aperture Lighting”，2007年 “交互式3D图形与游戏研讨会论 
文集”，ACM，第61-64页，2007年4月至5月。引用于p 。 
466,467,470 [1308] Oat ， Christopher 和 Thorsten 
Scheuermann， “计算单个渲染通道中的每像素物体厚度”， 
Wolfgang Engel编辑，ShaderX6，Charles RiverMedia，pp。 
57-62,2008。引用于p。[1309]Obert，Juraj，JMPvanWaveren 
和GrahamSellers，SIGGRAPH软件和硬件虚拟纹理课程，2012 
年8月。引用于p。867[1310]Ochiai，H.，K。Anjyo和A. Kimura， 
SIGGRAPH2016年7月对CG课程的矩阵指数的初步介绍。引用 
于p。102[1311]Oculus最佳实践，OculusVR，LLC，2017年。 
引用于p。920,923,924,925,928,932,933,935,936,937,939[1312] 
O'Donnell，Yuriy和 Matth¨ausG。Chajdas，“TiledLightTrees”， 
交互式3D图形研讨会和游戏，2017年2月。引用于p。9031120 
参考书目[1313]O'Donnell，Yuriy， “FrameGraph：Frostbite 
中的可扩展渲染架构”，游戏开发者大会，2月 -3月。2017年。 
----------------------- Page 1307-----------------------
引用p。514,520,812,814 [1314]Ofek，E。和A. Rappoport， 
 “关于弯曲物体的互动反思”，SIGGRAPH'98：第25届计算机图 
形学和互动技术年会论文集，ACM，第333-342页，1998年7月。 
引用于第4页。505[1315]Ohlarik，Deron，“BoundingSphere”， 
AGI博客，2008年2月4日。引用于p。950[1316]Ohlarik，Deron， 
 “Precisions，Precisions”，AGI博客，2008年9月3 日。引用 
于 p。715 [1317] Olano，M。和 T.Greer， “Triangle Scan 
ConversionUsing2DHomogeneousCoordinates”，摘自ACM 
SIGGRAPH / EUROGRAPHICS Workshop on Graphics 
Hardware，ACM，pp.89-95，1997年8月。被引用在第 832,999 
[1318]Olano，Marc，BobKuehne和 MaryannSimmons， “自 
动着色器详细程度”，图形硬件2003，Eurographics协会，第7-14 
页，2003年7月。引用于p。853 [1319]Olano，Marc， “用于 
评估图形硬件的改进噪声， “在图形硬件 2005，Eurographics 
Association，pp.105-110，2005年7月。引用于p。[1320]Olano， 
Marc和DanBaker，LEAN“  Mapping”，2010年ACMSIGGRAPH 
交互式3D图形和游戏研讨会论文集，ACM，第 181-188页，2010 
年。370 [1321]Olano，Marc，Dan Baker，Wesley Griffin和 
Joshua Barczak， “可变比特率GPU纹理解压缩”，参见第二十 
二届欧洲绘图研讨会论文集，Eurographics Association ， 
pp.1299-1308，June2011年。引用p。871[1322]Olick，Jon， 
 “Segment Buffering”，在Matt Pharr编辑，GPU Gems 2， 
----------------------- Page 1308-----------------------
Addison-Wesley，pp.69-73,2005。引用于p。797[1323]Olick， 
Jon， “当代游戏中的并行性”，SIGGRAPH超越可编程着色课程， 
2008年8月。引用于p。584[1324]Oliveira，ManuelM.，Gary 
Bishop，SIGGRAPH'00中的 救济纹理映射“      ”和DavidMcCllister， 
 “第27届计算机图形学与交互技术年会论文集”，ACM 出版社/ 
Addison-Wesley PublishingCo.，pp.359-368，2000年7月。 
引用于p 。565[1325]Oliveira，ManuelM.和 FabioPolicarpo， 
 “表面细节的有效表示”，技术报告 RP-351，UniversidadeFederal 
doRioGrandedoSul，2005年 1月26 日。引用于p。220[1326] 
Oliveira，ManuelM.和 MaiconBrauwers， “通过可变形物体进 
行实时折射”，2007年交互式3D图形和游戏研讨会论文集，ACM， 
第89-96页，2007年4月 -5月。引用p。630 [1327]Olsson， 
O。和U.Assarsson， “Tiled Shading”，图形，GPU和游戏工 
具杂志，第一卷。15，不。4，pp.235-251,2011。引用于 p。 
882,894,895[1328]Olsson，O.，M。Billeter，和 U.Assarsson， 
 “Clustered Deferredand ForwardShading”，2012年高性能 
图形，EurographicsAssociation，第87-96页，2012年6月。 
引用于p。899,900,901,903 [1329]Olsson，O.，M。Billeter和 
U.Assarsson， “TiledandClusteredForwardShading：支持透 
明度和MSAA”，ACMSIGGRAPH2012会谈，ACM，文章编号。 
2012年8月37 日。引用于p。899,900 [1330]Olsson，Ola， 
MarkusBilleter和 ErikSintorn， “用于多光的更高效的虚拟阴影 
----------------------- Page 1309-----------------------
贴图”，IEEE可视化和计算机图形学，第一卷。21，不。6， 
pp.701-713，2015年6月。引用于p。247,882,904[1331]Olsson， 
Ola， “来自许多灯光的高效阴影”，SIGGRAPH实时多光管理和 
阴影与集群着色课程，2015年8月。引用于p。904,914参考书目 
1121[1332]Olsson，Ola， “使用多个灯光进行实时着色简介”， 
SIGGRAPH实时多光管理和阴影与集群着色课程，2015年8月。 
引用第2页。886,892,893,900,904,905,914,1042[1333]O'Neil， 
Sean， “AccurateAtmospheric Sc​ ​ attering”，MattPharr 
编辑，GPUGems2，Addison-Wesley，pp.253-268 ，2005年。 
引用 p。614 [1334]van Oosten，Jeremiah， “Volume Tiled 
ForwardShading”，3D游戏引擎编程网站，2017年7月18日。 
引用于 p。900,914 [1335]Open 3D Graphics Compression， 
KhronosGroup，2013。引用于p。712[1336]OpenVDB，http： 
//openvdb.org，2017。引用于p。578 [1337]Oren，Michael 
和ShreeK.Nayar， “兰伯特反射模型的推广”，SIGGRAPH'94： 
第21届计算机图形学和交互技术年会论文集，ACM，第239-246 
页，1994年7月。引用p。331,354 [1338]O'Rourke，Joseph， 
 “寻找最小的封闭盒子”，国际计算机与信息科学期刊，第一卷。 
14，没有。3，pp.183-199,1985。引用于p。951[1339]O'Rourke， 
Joseph，Computational Geometry in C，Second Edition， 
Cambridge University Press，1998。引用于 p。685,686,967 
[1340]¨rtegren，Kevin和 EmilPersson， “集群着色：在 DirectX 
----------------------- Page 1310-----------------------
12中使用保守光栅分配灯”，Wolfgang Engel编辑，GPUPro7， 
CRC出版社，第43-68页，2016年。引用于p。901,914[1341]van 
Overveld，CVAM和 B.Wyvill， “一种基于顶点法线的多边形细 
分算法”，计算机图形国际'97，IEEE计算机学会，第3-12页，1997 
年 6月。引用次数页。744 [1342]van Overveld，CVAM和 B. 
Wyvill ， “Phong Normal Interpolation Revisited， “ACM 
TransactionsonGraphics，vol。16，不。4，pp.397-419，1997 
年 10月。引用于p。746[1343]Ownby，John-Paul，ChrisHall 
和 RobHall，“玩具总动员3：视频游戏 - 渲染技术”，SIGGRAPH 
在2010年7月3D图形和游戏实时渲染方面取得进展。引用于p 。 
230,249,519[1344]Paeth，AlanW.，ed。，GraphicsGemsV， 
Academic Press，1995。Citedon p。102,991[1345]Pag'an， 
Tito， “复杂模型的高效UV映射”，GameDeveloper，vol。8， 
不。8，pp.28-34，2001年8月。引用于p。171,173[1346]Palandri， 
R'emi和SimonGreen， “UE4和 Unity中的混合单声道渲染”， 
Oculus开发者博客，2016年9月30 日。引用于p。928 [1347] 
Pallister，Kim， “使用3D硬件生成程序云”，MarkDeLoura编 
辑，Game Programming Gems 2，Charles River Media， 
pp.463-473,2001。引用于 p。556 [1348] Pangerl，David， 
 “Quantized Ring Clipping”，在 Wolfgang Engel 编辑， 
ShaderX6，Charles RiverMedia，第133-140页，2008年。引 
用于p。873 [1349]Pangerl，David， “DirectX9的实用线程渲 
----------------------- Page 1311-----------------------
染”，Wolfgang Engel编辑，GPU Pro，AK Peters，Ltd。，第 
541-546 页，2010 年。814 [1350] Pantaleoni，Jacopo ， 
 “VoxelPipe ：用于 3D 体素化的可编程管道 ” ，在 
High-PerformanceGraphics2011，EurographicsAssociation， 
pp.99-106，2011年8月。引用于p。581[1351]Papathanasis， 
Andreas， “DragonAge IIDX11Technology”，游戏开发者大 
会，2011年3月。引用于p。252,892[1352]Papavasiliou，D。， 
 “Real-Time Grass （and Other Procedural Objects ）on 
Terrain”， “计算机图形技术杂志”，第二卷。4，不。1， 
pp.26-49,2015。引用于p。8641122参考书目[1353]Parberry， 
Ian， “摊销噪音， “计算机图形技术杂志，第一卷。3，不。2， 
pp.31-47,2014。引用于p。199 [1354]Parent，R.，Computer 
Animation：Algorithms＆Techniques，Third Edition，Morgan 
Kaufmann，2012。Citedonp。102[1355]Paris，Sylvain，Pierre 
Kornprobst，Jack Tumblin 和 Fr'edo Durand，SIGGRAPH A 
Gentle Introduction to Bilateral Filtering and Applications 
Applications课程，2007年8月。518,520,543[1356]Parker， 
Steven，William Martin，Peter-PikeJ. Sloan，PeterShirley， 
BrianSmits和Charles Hansen， “交互式光线追踪”，1999年 
交互式3D图形研讨会论文集，ACM ，pp.119-134,1999。引用 
于p。431 [1357]Patney，Anjul，MarcoSalvi，Joohwan Kim， 
Anton Kaplanyan，Chris Wyman，Nir Benty，David Luebke 
----------------------- Page 1312-----------------------
和Aaron Lefohn， “为凝视跟踪的虚拟现实实现最大限度的渲染， 
 “ACMTransactions onGraphics，vol。35，不。6，文章编号。 
179,2016。引用于p。143,924,931,932[1358]Patney，Anuj， 
SIGGRAPH视觉感知在虚拟现实课程中的应用，2017年8月。引 
用于p。931,940 [1359]帕特里，茉莉， “臭名昭着的第二个儿子 
和臭名昭着的第一光的 HDR显示支持 （第 1部分），”glowybits 
博客，2016年 12月21 日。引用于p。287[1360]帕特里，茉莉， 
 “在臭名昭着的第二个儿子和臭名昭着的第一光的 HDR显示支持 
 （第2部分），”glowybits博客，2017年 1月4 日。引用于p。 
283[1361]Patterson，JW，SGHoggar和JR Logie， “Inverse 
DisplacementMapping”，ComputerGraphics Forum，vol。 
10没有。2，pp.129-139,1991。引用于p。217[1362]Paul，Richard 
PC，RobotManipulators：Mathematics，Programming，and 
Control，MITPress，1981。引用于p。[1363]Peercy，MarkS.， 
MarcOlano，JohnAirey和 P.JeffreyUngar， “交互式多通道可 
编程着色”，SIGGRAPH'00：第27届计算机图形学与交互技术年 
会论文集，ACM Press / Addison-Wesley Publishing Co.， 
pp.425-432，2000年7月。引用于p。[1364]Pegoraro，Vincent， 
MathiasSchott和StevenG.Parker， “各向异性介质和光分布的 
单一散射的分析方法”，图形界面2009，加拿大信息处理协会， 
pp。71-77,2009。引用于p。[1365]Pellacini，Fabio， “用户可 
配置的自动着色器简化”，ACM图形交易（SIGGRAPH2005）， 
----------------------- Page 1313-----------------------
第一卷。24，不。3，pp.445-452，2005年8月。引用于p。853 
[1366]Pellacini，Fabio，MilosHasan和 KavitaBala，Interactive“ 
Cinematic Relighting with Global Illumination” ，Hubert 
Nguyen编辑，GPUGems3，Addison-Wesley，第 183-202页， 
2007年。引用于p 。547[1367]Pelzer，Kurt， “渲染无数的挥 
刀草 ” ，在 Randima Fernando 编辑， GPU Gems ， 
Addison-Wesley，pp.107-121,2004。引用于p。[1368]Penner， 
E。， “Shader Amortization Using Pixel Quad Message 
Passing”，Wolfgang Engel编辑，GPUPro2，AK Peters/CRC 
Press，第349-367页，2011年。1017,1018[1369]Penner，E。， 
 “Pre-IntegratedSkin Shading，”SIGGRAPH在游戏中实时渲 
染的进展，2011年8月。引用于p。634[1370]Perlin，Ken，“图 
像合成器”，计算机图形学（SIGGRAPH '85Proceedings），第 
一卷。19，没有。3，pp.287-296，1985年7月。引用于p。198,199 
[1371] Perlin，Ken和 Eric M. Hoffert， “Hypertexture，” 
ComputerGraphics （SIGGRAPH'89Proceedings），vol。23， 
不。3，pp.253-262，1989年 7 月。引用于 p。198,199,618 
Bibliography1123[1372]Perlin，Ken， “改善噪音”，ACM图 
形交易 （SIGGRAPH2002），第一卷。21，不。3，pp.681-682,2002。 
引用于p。181,198,199[1373]Perlin，Ken， “实施改进的 Perlin 
噪声 ” ，在 Randima Fernando 编辑， GPU Gems ， 
Addison-Wesley，pp.73-85,2004。引用于 p。199,620 [1374] 
----------------------- Page 1314-----------------------
Persson，Emil， “Alpha to Coverage”，Humus博客，2005 
年6月23 日。引用于p。204 [1375]Persson，Emil， “D3D10 
中用于高质量 HDR抗锯齿的后 Tonemapping解决方案， “在 
Wolfgang Engel，编辑，ShaderX6，Charles River Media， 
pp.161-164,2008。引用于p。[1376]Persson，Emil， “GPU纹 
理压缩”，Humus博客，2008年4月12日。引用于p。870[1377] 
佩尔森，埃米尔， “线性化深度”，腐殖质博客，2008年8月2 
日。引用于p。601 [1378]佩尔森，埃米尔， “表演”，腐殖质博 
客，2009年7月22 日。引用于p。790 [1379]佩尔森，埃米尔， 
 “让它变大，美丽，快速，一致：经验教训，开发正义2”，Wolfgang 
Engel编辑，GPUPro，AK Peters，Ltd。，第 571-596页，2010 
年。引用p。114,556,558,715,882[1380]Persson，Emil，Volume“ 
Decals”，Wolfgang Engel，ed。，GPUPro2，AK Peters/CRC 
Press，pp.115-120,2011。引用于p。889,890[1381]佩尔森，埃 
米尔， “创造巨大的游戏世界：雪崩工作室的经验”，在ACM 
SIGGRAPH2012会谈，ACM，文章编号。32，2012年8月。引 
用p。69,210,245,714,715,796,797[1382]Persson，Emil， “图 
形宝石游戏：Avalanche工作室的调查结果”，SIGGRAPH在游戏 
中实时渲染的进展，2012年8月。引用于p 。556,797,798[1383] 
Persson，Emil， “高级着色语言中的低级思维”，游戏开发者大 
会，2013年3月。引用于p。788[1384]Persson，Emil， “Wire 
Antialiasing”，Wolfgang Engel编辑，GPUPro5，CRC出版社， 
----------------------- Page 1315-----------------------
第211-218页，2014年。引用于p。[1385]Persson，Emil， “下 
一代和 DX11的低级着色器优化”，游戏开发者大会，2014年 3 
月。引用于p。788[1386]Persson，Emil，“ClusteredShading”， 
Humus博客，2015年 3月 24 日。引用于p。905,914 [1387] 
Persson，Emil， “实用集群着色”，SIGGRAPH实时多光管理和 
阴影与集群着色课程， 2015 年 8 月。引用 p 。 
883,886,888,896,897,899,900,901,914[1388]Persson，Tobias， 
 “PracticalParticleLighting，”GameDevelopersConference， 
2012年3月。569 [1389]Pesce，Angelo， “StableCascaded 
Shadow Maps-Ideas，”C0DE517E博客，2011年3月27 日。 
引用于p。[1390]Pesce，Angelo，当前“ 的DOF和MB，”C0DE517E 
博客，2012年 1月4 日。引用于p。532,534,542[1391]Pesce， 
Angelo， “太空船生活中的 33毫秒......”，SCRIBD演讲，2012 
年 10月8 日。引用于p。238,245,250,518,527,542,889 [1392] 
Pesce，Angelo， “SmoothenYour Functions，”C0DE517E博 
客，2014年4月26 日。引用于p。200 [1393]Pesce，Angelo， 
 “关于实时渲染器的注释”，C0DE517E博客，2014年9月3 日。 
引用于p。882,884,889,913[1394]Pesce，Angelo， “G-Buffer 
NormalEncodings的注释”，C0DE517E博客，2015年 1月24 
日。引用于p。715，887 [1395]Pesce，Angelo， “更错误：视 
差校正环境地图”，C0DE517E博客，2015年3月28 日。引用于 
p。5021124参考书目[1396]Pesce，Angelo， “深度意识上采样 
----------------------- Page 1316-----------------------
的低分辨率效应”，C0DE517E博客，2016年2月6 日。引用于p。 
520 [1397] Pesce，Angelo， “实时渲染连续体：分类法”， 
C0DE517E博客，2016年8月6 日。引用于p。913[1398]Peters， 
Christoph和 ReinhardKlein， “MomentShadowMapping”， 
第 19届交互式3D图形与游戏研讨会论文集，ACM，第7-14页， 
2月至 3月。2015.引用于 p。256 [1399] Peters，Christoph， 
CedrickMünstermann，NicoWetzstein和 ReinhardKlein，“用 
于半透明封堵器，软阴影和单散射的改进的力矩阴影贴图”，计算 
机图形技术杂志，第一卷。6，不。1，pp.17-67,2017。引用于p。 
257[1400]Pettineo，Matt， “如何假散景 （并让它看起来相当不 
错），”危险区博客，2011年2月28 日。引用于p。536[1401] 
Pettineo，Matt， “Light-IndexedDeferredRendering”，The 
DangerZone博客，2012年3月31 日。引用于p。896,905,914 
[1402]Pettineo，Matt， “试验 MSAAResolve的重建过滤器”， 
The DangerZone博客，2012年 10月28 日。136,142 [1403] 
Pettineo，Matt， “影子技术的采样”，危险区博客，2013年9 
月10日。引用于p。54,238,245,250,265[1404]Pettineo，Matt， 
 “影子样本更新”，危险区博客，2015年2月18日。引用于p。 
256,265 [1405]Pettineo，Matt， “渲染命令的替代历史：1886 
年”，SIGGRAPH在游戏中实时渲染的进展，2015年8月。引用 
于p。141,142,143,245,256,257,803，896[1406]Pettineo，Matt， 
 “Stairwayto （ProgrammableSamplePoint）Heaven”，The 
----------------------- Page 1317-----------------------
DangerZone博客，2015年9月13日。引用于p。142,906[1407] 
Pettineo，Matt， “BindlessTexturingfor DeferredRendering 
and Decals”，The DangerZone博客，2016年3月25 日。引 
用于p。192,888,900,901,907[1408]Pettineo，Matt，“SGSeries 
Part6：Stepintothe BakingLab”，The DangerZone博客， 
2016年 10月9 日。引用于p。398,477,536,540 [1409]Pfister， 
Hans-Peter，Matthias Zwicker，Jeroen van Barr 和 Markus 
Gross， “Surfels：SurfaceElementsasRenderingPrimitives”， 
SIGGRAPH'00：第27届计算机年会论文集图形和交互技术，ACM 
Press/Addison-Wesley PublishingCo.，pp.335-342，2000年 
7月。引用于p。573[1410]Phail-Liff，Nathan，ScotAndreason 
和Anthony Vitale， “CraftingVictorian London：订单的环境 
艺术和物质管道：1886年，“ACMSIGGRAPH2015会谈，ACM， 
文章编号。2015年8月59日。引用于p。365[1411]Pharr，Matt， 
 “Fast FilterWidth Estimateswith Texture Maps”，Randima 
Fernando编辑，GPUGems，Addison-Wesley，第417-424页， 
2004 年。[1412] Pharr，Matt和 Simon Green， “Ambient 
Occlusion ” ， Randima Fernando 编辑， GPU Gems ， 
Addison-Wesley，第279-292 页，2004 年。452,465 [1413] 
Pharr，Matt，WenzelJakob和Greg Humphreys，基于物理的 
渲染：从理论到实现，第三版，MorganKaufmann，2016年。引 
用于 p。136,144,145,165,271,442,445,512,589,623,630 [1414] 
----------------------- Page 1318-----------------------
Phong，BuiTuong， “计算机生成图像的照明”，ACM的通讯， 
第一卷。18，不。6，pp.311-317，1975年 6月。引用于 p。 
118,340,416[1415]Picott，KevinP.， “线性和区域照明模型的扩 
展”，计算机图形学，第一卷。18，不。2，pp.31-38，1992年3 
月。引用于 p。385,387参考书目 1125 [1416] Piegl，LesA.和 
Wayne Tiller ， The NURBS Book ， Second Edition ， 
Springer-Verlag，1997。引用于p。781 [1417]Pineda，Juan， 
 “用于多边形光栅化的并行算法”，计算机图形学 （SIGGRAPH'88 
Proceedings），第一卷。22，不。4，pp.17-20，1988年8月。 
引用于p。994[1418]Pines，Josh，“从场景到屏幕”，SIGGRAPH 
色彩增强和渲染电影和游戏制作课程，2010年7月。引用于 p。 
285,289[1419]Piponi，Dan和GeorgeBorshukov， “模型化和 
纹理混合的细分曲面的无缝纹理映射”，SIGGRAPH'00：第27届 
计算机图形学和交互技术年会论文集， ACM Press / 
Addison-Wesley PublishingCo.，pp.471-478，2000年7月。 
引用于p。767 [1420]Placeres，FrankPuig， “克服延迟着色缺 
点”，载于Wolfgang Engel，编辑，ShaderX5，Charles River 
Media，第115-130页，2006年。886,887 [1421] Pletinckx， 
Daniel ， “Quaternion Calculus as a Computer Tool in 
ComputerGraphics，”TheVisualComputer，vol。5，不。1， 
pp.2-13,1989。引用于p。102[1422]Pochanayon，Adisak，“捕 
捉和可视化真实 KombatX 中的实时GPU性能”，游戏开发者大 
----------------------- Page 1319-----------------------
会，2016年3月。引用于p。790[1423]Pohl，Daniel，Gregory 
S.Johnson和Timo Bolkart， “改进了广角，头戴式显示器的预 
翘曲”，在第19届ACM虚拟现实软件和技术研讨会论文集中， 
ACM，第259页-262，2013年10月。引用于p。628,925,926[1424] 
Policarpo，Fabio，ManuelM.Oliveira和Jo.ao LDComba，“任 
意多边形曲面上的实时浮雕图”，2005年 “交互式3D图形和游戏 
研讨会论文集”，ACM，第 155-162页，2005年4月。在第 217,218 
[1425]Policarpo，Fabio和 ManuelM.Oliveira， “非高度场表 
面细节的浮雕图”，2006年交互式3D图形和游戏研讨会论文集， 
ACM，第55-62页，2006年3月。引用于p。566[1426]Policarpo， 
Fabio和 Manuel M.Oliveira， “轻松的锥形步进缓冲图”，在 
Hubert Nguyen 编辑，GPU Gems 3 ，Addison-Wesley ， 
pp.409-428,2007。引用于p。219 [1427] Pool，J.，A。Lastra 
和 M.Singh，“GPU上可变精度浮点缓冲器的无损压缩”，在ACM 
SIGGRAPH 交互式 3D 图形和游戏研讨会论文集中，ACM， 
pp.47-54，2012年3月。引用于p。1009,1016[1428]Porcino， 
Nick， “失落的行星平行渲染”，Meshula.net网站，2007年 10 
月。引用于 p。538,647 [1429]Porter，Thomas和Tom Duff， 
 “合成数字图像”，计算机图形学 （SIGGRAPH'84Proceedings）， 
第一卷。18，不。3，pp.253-259，1984年 7月。引用于 p。 
149,151,153[1430]P¨otzsch，Christian， “加速移动虚拟现实中 
的GPUBarrelDistortionCorrection”，ImaginationBlog，2016 
----------------------- Page 1320-----------------------
年6月15日。引用p。926[1431]Poynton，Charles，DigitalVideo 
andHD：AlgorithmsandInterfaces，SecondEdition，Morgan 
Kaufmann ， 2012 。 Cited on p 。 161,163,166 [1432] 
Pranckevicius，Aras，“小型G缓冲器的紧凑型正常存储”，Aras 
的博客，2010年3月25 日。引用于p。715[1433]Pranckevicius， 
Aras和 RenaldasZioma， “FastMobileShaders”，SIGGRAPH 
Studio Talk，2011年 8 月。引用于 p。549,803，814 [1434] 
Pranckevicius，Aras， “RoughSortingbyDepth”，Aras的博 
客，2014年 1月 16日。引用于p。803 [1435]Pranckevicius， 
Aras，Jens Fursund和SamMartin， “团结中的先进照明技术”， 
UnityDevDay，游戏开发者大会，2014年3月。引用于p。482 1126 
参考书目[1436]Pranckevicius，Aras， “2014年跨平台着色器”， 
Aras的博客，2014年3月28 日。引用于p。[1437]Pranckevicius， 
Aras， “Unity4.5中的着色器编译”，Aras的博客，2014年5月 
5日。引用于p。[1438]Pranckevicius，Aras， “将团结移植到新 
的API”，SIGGRAPH下一代API课程概述，2015年8月。引用 
于p。40,806,814 [1439]Pranckevicius，Aras， “将达到每一种 
可能的可扩展性限制”，Aras的博客，2017年2月5日。引用p。 
128[1440]Pranckevicius，Aras，“字体渲染越来越有趣，“Aras' 
博客，2017年2月15日。引用于p。677,679[1441]Praun，Emil， 
Adam Finkelstein和 Hugues Hoppe， “LappedTextures”， 
SIGGRAPH '00：第27届计算机图形学和交互技术年会论文集， 
----------------------- Page 1321-----------------------
ACM 出版社/Addison-Wesley 出版公司，第465-470页，2000 
年7月。引用第2页。671[1442]Praun，Emil，HuguesHoppe， 
MatthewWebb和Adam Finkelstein，“实时孵化”，SIGGRAPH 
'01第28届计算机图形和交互技术年会论文集，ACM，第 581-586 
页， 2001年8月。引用于p。670 [1443]Preetham，ArcotJ.， 
PeterShirley和 BrianSmitsc， “用于日光的实用分析模型”， 
SIGGRAPH '99：第26届计算机图形学和交互技术年会论文集， 
ACM 出版社/ Addison-Wesley 出版公司，第91-100页，1999 
年8月。引用于 p。614 [1444]Preparata，FP和 MIShamos， 
ComputationalGeometry：An Introduction，Springer-Verlag， 
1985。引用于 p。686,967 [1445] Preshing，Jeff， “Ubisoft 
Montreal如何开发多核游戏 - 在C ++11之前和之后”，CppCon 
2014，2014年9月。引用p。812,815[1446]Press，William H.， 
SaulA. Teukolsky，William T.Vetterling和 Brian P.Flannery， 
NumericalRecipesinC，Cambridge UniversityPress，1992。 
引用于p。948,951,957 [1447] Proakis，John G.和 DimitrisG. 
Manolakis，DigitalSignalProcessing：Principles，Algorithms， 
andApplications，FourthEdition，Pearson，2006。Citedonp。 
130,133,135,136 [1448] Purnomo ，Budirijanto ，Jonathan 
Bilodeau，Jonathan D.Cohen和 Subodh Kumar， “使用量化 
和简化的硬件兼容顶点压缩”，在图形硬件2005中，Eurographics 
Association，pp.53-61，2005年 7月。引用于 p。713 [1449] 
----------------------- Page 1322-----------------------
Quidam ， Jade2 模 型 ， 由 wismo 出 版 ， http ： 
//www.3dvia.com/wismo,2017。引用于 p。[1450] Qu'.lez，' 
我.nigo，'在GPU上以4096字节渲染具有两个三角形和光线跟踪 
的世界，“NVScene，2008年8月。引用于p。454,594,752 [1451] 
Qu'.lez ，'I .nigo ， “Improved Texture Interpolation ，” 
iquilezles.org，2010。引用于p.45。180[1452]Qu'.lez，'I.nigo， 
'CorrectFrustumCulling， “iquilezles.org，2013。引用于p。 
986 [1453] Qu'.lez ，'I .nigo ， “Efficient Stereo and VR 
Rendering，”Wolfgang Engel编辑，GPU Zen，Black Cat 
Publishing，pp.241-251,2017。引用于 p。927,928 [1454] 
Ragan-Kelley，Jonathan，Charlie Kilpatrick，BrianW. Smith 
和 DougEpps， “Lightspeed自动交互式照明预览系统， “ACM 
图形交易（SIGGRAPH2007），第一卷。26，不。3,25：1-25： 
11，2007年7月。引用于p。547[1455]Ragan-Kelley，Jonathan， 
Jaakko Lehtinen，Jia Jia Chen，Michael Doggett 和 Fr'edo 
Durand，“解耦图形管道取样”，ACMTransactionsonGraphics， 
vol。30，不。3，pp.17：1-17：17，2011年 5月。引用于p。 
910参考书目 1127[1456]R'akos，Daniel， “分层渲染的大量阴 
影投射灯”，PatrickCozzi和Christophe Riccio编辑，OpenGL 
Insights，CRC出版社，第259-278页，2012年。在第 246[1457] 
R'akos，Daniel，“可编程顶点拉动”，PatrickCozzi和Christophe 
Riccio，编辑，OpenGL Insights，CRC出版社，第293-301页， 
----------------------- Page 1323-----------------------
2012年。703[1458]Ramamoorthi，Ravi和 PatHanrahan， “辐 
照环境地图的有效表示， “在SIGGRAPH'01第28届计算机图形 
和交互技术年会论文集，ACM，第497-500页，2001年8月。引 
用于第4页。425,427,428,429,430 [1459]Ramamoorthi，Ravi 
和 PatHanrahan，“频率空间环境地图渲染”，ACMTransactions 
onGraphics，vol。21，不。3，pp.517-526,2002。引用于p。[1460] 
Raskar ，Ramesh 和 Michael Cohen ， “Image Precision 
Silhouette Edges”，1999年 Symposium on Interactive 3D 
Graphics，ACM，第135-140页，1999年。引用于p。Raskar， 
Ramesh， “用于非真实感渲染的硬件支持”，图形硬件2001， 
EurographicsAssociation，pp.41-46，2001年8月。引用于p.65。 
658,660 [1462]Raskar，Ramesh和Jack Tumblin，计算摄影： 
掌握镜头，照明和传感器的新技术，AK Peters，Ltd。，2007年。 
引用 p。 549 [1463] Rasmusson ，J. ，J 。 Hasselgren 和 
T.Akenine-Molol， “Exact and Error-Bounded Approximate 
ColorBufferCompressionandDecompression，”在Graphics 
Hardware2007，EurographicsAssociation，pp.41-48， 2007 
年8月。引用于p。997,1009[1464]Rasmusson，J.，J.Str¨om， 
和T.Akenine-Molol， “使用四叉树分解的浮点颜色缓冲器的误差 
有界压缩压缩”，“视觉计算机”，第一卷。26，不。1，pp.17-30,2009。 
引用于p。1009[1465]Ratcliff，JohnW.，“SphereTreesforFast 
VisibilityCulling，RayTracing，andRangeSearching”，Mark 
----------------------- Page 1324-----------------------
DeLoura编辑，Game Programming Gems 2，Charles River 
Media，pp.384-387,2001。引用p。821 [1466]Rauwendaal， 
Randall和 MikeBailey， “使用图形管道的混合计算体素化”，计 
算机图形技术杂志，第一卷。2，没有。1，pp.15-37,2013。引用 
于 p。582 [1467] Ray，Nicolas，Vincent Nivoliers，Sylvain 
Lefebvre和 Bruno L'evy， “Invisible Seams”， “第 21 届 
Eurographics协会会议论文集”，EurographicsAssociation，第 
1489-1496页，2010年6月。引用于 p 。486 [1468]Reddy， 
Martin，虚拟环境的感知调制水平，博士论文，爱丁堡大学，1997 
年。引用 p。864 [1469] Reed，Nathan， “在 inFAMOUS2中 
的环境遮挡场和贴花”，游戏开发者大会，2012年3月。引用于p。 
452 [1470]Reed，Nathan， “QuadrilateralInterpolation，Part 
1”，NathanReed博客，2012年5月26 日。引用于p。688[1471] 
Reed，Nathan和 DeanBeeler， “VR Direct：NVIDIA技术如何 
改善 VR 体验”，游戏开发者大会，2015 年 3 月。引用 p。 
928,936,937,938 [1472]里德，Nathan， “深度精确可视化”， 
NathanReed博客，2015年7月3 日。引用于p。100,1014[1473] 
Reed，Nathan， “GameWorksVR”，SIGGRAPH，2015年8 
月。引用于p。927,928,929 [1474]Reeves，WilliamT.， “粒子 
系统 - 用于建模一类模糊物体的技术”，ACM Transactions on 
Graphics，vol。2，没有。2，pp.91-108，1983年4月。引用于 
p。567 1128参考书目[1475] Reeves，William T.，David H. 
----------------------- Page 1325-----------------------
Salesin和 RobertL.Cook， “用深度地图渲染抗锯齿阴影”，计 
算机图形学（SIGGRAPH'87Proceedings），第一卷。21，不。 
4，pp.283-291，1987年7月。引用于p。247[1476]Rege，Ashu， 
 “DX11在地铁2033中的影响：最后的避难所”，游戏开发者大会， 
2010年3月。引用于p。535[1477]Reimer，Jeremy，Valve“  Goes 
Multicore”，arstechnica网站，2006年 11月5日。引用于p。 
812[1478]Reinhard，Erik，MikeStark，PeterShirley和James 
Ferwerda， “数字图像的摄影色调再现”，ACM 图形交易 
 （SIGGRAPH2002），第一卷。21，不。3，pp.267-276，2002 
年7月。引用于p。286,288[1479]Reinhard，Erik，GregWard， 
Sumanta Pattanaik和 PaulDebevec，高动态范围成像：采集， 
显示和基于图像的照明，MorganKaufmann，2006年。引用p。 
406,435 [1480] Reinhard，Erik，Erum Arif Khan，Ahmet 
OguzAky ¨ uz 和 Garrett Johnson ， Color Imaging ： 
FundamentalsandApplications，AK Peters，Ltd.，2008。引用 
于p。291[1481]Reis，Aurelio，“Per-PixelLit，LightScattering 
Smoke”，Wolfgang Engel编辑，ShaderX5，Charles River 
Media，第287-294页，2006年。569[1482]Ren，Zhong Ren， 
RuiWang，JohnSnyder，KunZhou，LiuXinguo Liu，BoSun， 
Peter-PikeSloan，HujunBao，PengnshengPeng，BainingGuo， 
 “使用球面谐波指数的动态场景中的实时软阴影”，ACM图形交易 
 （SIGGRAPH2006），第一卷。25，不。3，pp.977-986，2006 
----------------------- Page 1326-----------------------
年7月。引用于p。456,458,467 [1483]Reshetov，Alexander， 
 “MorphologicalAntialiasing，”inHigh-PerformanceGraphics 
2009，EurographicsAssociation，pp.109-116，Aug。2009. 
引用于p。[1484]Reshetov，Alexander， “通过重新采样减少混 
叠伪像”，2012年高性能图形，EurographicsAssociation，第 
77-86 页，2012 年 6 月。引用于 p。148 [1485] Reshetov， 
Alexander和 DavidLuebke， “无限分辨率纹理”，2016年高性 
能图形，Eurographics协会，第 139-150页，2016年6月。引用 
于p。677[1486]Reshetov，Alexander和JorgeJimenez，“2009 
年至2017年的 MLAA”，高性能图形研究影响回顾，2017年7月。 
引用于p。143,146,148,165[1487]Reuter，Patrick，Johannes 
Behr和 MarcAlexa， “改进的快速三角剥离邻接数据结构”，图 
形工具杂志，第一卷。10，不。2，pp.41-50,2016。引用于p。692 
[1488]Revet，Burke和Jon Riva，“巨大的僵尸部落品种和切片”， 
游戏开发者大会，2014年 3月。引用于 p。366 [1489] Revie， 
Donald，“使用延迟着色实现毛发”，Wolfgang Engel编辑，GPU 
Pro2，AK Peters/CRC出版社，第 57-75页，2011年。424 [1490] 
Rhodes，Graham，“快速，稳健的3D线段交叉”，MarkDeLoura 
编辑，Game Programming Gems 2，Charles River Media， 
pp.191-204,2001。引用于p。990 [1491] Ribardi`ere，Micka¨ 
el，BenjaminBringier，DanielMeneveaux和 LionelSimonot， 
 “性病：学生用于基于 Microfacet的BSDF斜坡的t分布， “计算 
----------------------- Page 1327-----------------------
机图形学论坛，第一卷。36，不。2，pp.421-429,2017。引用于p。 
343[1492]Rideout，菲利普， “剪影提取”，小蚱蜢博客，2010 
年 10月24 日。引用于p。47,668 [1493]Rideout，Philip和 Dirk 
VanGelder，“曲面细分着色器简介”，PatrickCozzi和Christophe 
Riccio编辑，OpenGLInsights，CRC出版社，第87-104页，2012 
年。引用于p 。44,46 [1494]Riguer，Guennadi， “使用 DirectX 
9.0的ATI图形硬件的性能优化技术”，ATI 白皮书，2002年。引 
用于第4 页。702参考书目 1129 [1495] Riguer，Guennadi， 
 “LiquidVRTM Today and Tomorrow ，”Game Developers 
Conference，2016年3月。引用于p。928[1496]Ring，Kevin， 
 “在万维网上渲染整个世界”，AnalyticalGraphics，Inc。的讲座， 
2013年 12月。引用于p。708[1497]Risser，Eric，MusawirShah 
和Sumanta Pattanaik， “使用正割方法更快地进行浮雕测绘”， 
图形工具杂志，第一卷。12，不。3，pp.17-24,2007。引用于p。 
[1498]Ritschel，T.，T。Grosch，MHKim，H.-P。Seidel，C。 
Dachsbacher和J. Kautz，Imperfect“ ShadowMapsfor Efficient 
ComputationofIndirectIllumination，”ACMTransactionson 
Graphics，vol。27，不。5，pp.129：1-129：8,2008。引用于p。 
492,578 [1499] Ritschel ， Tobias ， Thorsten Grosch 和 
Hans-PeterSeidel， “在图像空间中逼近动态全局照明”，载于 
2009年交互式3D图形和游戏研讨会论文集，ACM，第75-82页， 
2009年。引用p。496 [1500]Ritter，Jack，An“ EfficientBounding 
----------------------- Page 1328-----------------------
Sphere”，AndrewS.Glassner编辑，GraphicsGems，Academic 
Press，pp.301-303,1990。引用于p。950[1501]Robbins，Steven 
和SueWhitesides， “关于3D中三角交点的可靠性”，在国际计 
算科学及其应用会议上，Springer，第923-930页，2003年。引 
用于 p。974 [1502]Robinson，Alfred C.， “关于使用四元数模 
拟刚体运动”，技术报告58-17，莱特航空发展中心，1958年 12 
月。引用于第9页。76[1503]Rockenbeck，Bill， “inFAMOUS： 
SecondSon ParticleSystemArchitecture”，游戏开发者大会， 
2014年3月。引用p。568,569,571[1504]Rockwood，Alyn和 
PeterChambers，交互式曲线和曲面：关于CAGD的多媒体教程， 
MorganKaufmann，1996年。引自p。718[1505]Rogers，David 
F.，Computerural Elementsfor Computer Graphics，Second 
Edition，McGraw-Hill，1998。685 [1506]Rogers，DavidF.， 
NURBS简介：历史视角，MorganKaufmann，2000年。引用p。 
781[1507]Rohleder，Pawel和 MaciejJamrozik， “阳光与体积 
光线”，Wolfgang Engel编辑，ShaderX6，CharlesRiverMedia， 
pp.325-330,2008。引用于p。604[1508]Rohlf，J。和J.Helman， 
 “IRIS表演者：用于实时 3D 图形的高性能多处理工具包”， 
SIGGRAPH '94：第21届计算机图形学与交互技术年会论文集， 
ACM ，第381-394页，1994年7月。引用于p。807,809,861[1509] 
Rosado，Gilberto， “运动模糊作为后处理效应”，在Hubert 
Nguyen 编 辑 ， GPU Gems 3 ， Addison-Wesley ， 
----------------------- Page 1329-----------------------
pp.575-581,2007。引用于p。538[1510]Rossignac，J。和 M.van 
Emmerik，M。， “框架缓冲器上的隐藏轮廓， “在第七届 
Eurographics图形硬件会议论文集，EurographicsAssociation， 
pp.188-204，1992年9月。引用于p。657 [1511]Rossignac， 
Jarek和 PaulBorrel， “渲染复杂场景的多分辨率3D近似”，在 
BiancaFalcidieno和Tosiyasu L.Kunii，编辑。计算机图形学中的 
建模：方法和应用，Springer-Verlag，第455-465页，1993年。 
引用于 p。709 [1512] Rost，RandiJ.，Bill Licea-Kane，Dan 
Ginsburg，John Kessenich，BartholdLichtenbelt，HughMalan 
和 MikeWeiblen，OpenGL着色语言，第三版，Addison-Wesley， 
2009年。引用p。55,200[1513]Roth，Marcus和 DirkReiners， 
 “排序管道图像合成”，在 EurographicsSymposiumonParallel 
Graphics and Visualization ， Eurographics Association ， 
pp.119-126,2006。引用于p。1020，10221130参考书目[1514]R¨ 
ottger，Stefan，Alexander Irion和 Thomas Ertl， “Shadow 
Volumes Revisited”，WSCG期刊（第 10届中欧计算机图形学， 
可视化和计算机视觉国际会议），第一卷。10，不。1-3，pp.373-379， 
2002年2月。引用于p。232[1515]Rougier，NicolasP.，“Higher 
Quality 2DText Rendering，”Journal of Computer Graphics 
Techniques，vol。1，不。4，pp.50-64,2013。引用于p。676,677 
[1516] Rougier，Nicolas P.， “Shader-Based Antialiased ， 
Dashed，Stroked Polylines，”Journal ofComputerGraphics 
----------------------- Page 1330-----------------------
Techniques，vol。2，没有。2，pp.105-121,2013。引用于p。 
669[1517]deRousiers，Charles和 MattPettineo， “景深与景 
观渲染”，PatrickCozzi和Christophe Riccio，编辑，OpenGL 
Insights，CRC出版社，第205-218页，2012年。531,536[1518] 
Ruijters，Daniel，Bart M.ter HaarRomeny和 PaulSuetens， 
 “使用统一 B样条的基于GPU的高效纹理插值”，图形，GPU和 
游戏工具杂志，第一卷。13，不。4，pp.61-69,2008。引用于p。 
180,733,734 [1519] Rusinkiewicz，Szymon 和 Marc Levoy， 
 “QSplat：用于大网格的多分辨率点渲染系统”，SIGGRAPH'00： 
第 27届计算机图形学与交互技术年会论文集，ACM 出版社/ 
Addison-Wesley PublishingCo.，pp.343-352，2000年7月。 
引用于p。573 [1520] Rusinkiewicz，Szymon，Michael Burns 
和 Doug DeCarlo， “用于描绘形状和细节的夸张阴影”，ACM 
Transactions onGraphics，vol。25，不。3，pp.11199-1205， 
2006年7月。引用于 p。654 [1521] Rusinkiewicz，Szymon， 
ForresterCole，DougDeCarlo和Adam Finkelstein，SIGGRAPH 
线条图来自3D模型课程，2008年8月。引用于p。656,678[1522] 
Ruskin，Elan， “StreamingSunsetOverdrive的开放世界”，游 
戏开发者大会，2015年3月。引用于p。871[1523]Ryu，David， 
 “5亿和计数：料理鼠王的头发渲染”，皮克斯技术备忘录07-09， 
2007年 5月。引用于 p。648 [1524] “S3TC DirectX6.0标准纹 
理压缩”，S3Inc.网站，1998年。引用于p。192[1525]Sadeghi， 
----------------------- Page 1331-----------------------
Iman，Heather Pritchett，Henrik Wann Jensen 和 Rasmus 
Tamstorf，“艺术家友好的头发遮阳系统”，参见ACMSIGGRAPH 
2010年论文，ACM，文章编号。56，2010年7月。引用于 p。 
359,644[1526]Sadeghi，Iman，OlegBisker，Joachim DeDeken 
和 Henrik Wann Jensen ， “A Practical Microcylinder 
Appearance ModelforCloth Rendering”，ACMTransactions 
on Graphics，vol。32，不。2，pp.14：1-14：12，2013年4 
月。引用p。359[1527]Safdar，Muhammad，GuihuaCui，Youn 
Jin Kim和 MingRonnierLuo， “包含高动态范围和宽色域的图像 
信号的感知统一色彩空间”，Optics Express，vol。25，不。13， 
pp.15131-15151，2017年6月。引用于p。276 [1528]Saito， 
Takafumi和TokiichiroTakahashi， “可理解的三维形状渲染”， 
计算机图形学 （SIGGRAPH'90Proceedings），第一卷。24，不。 
4，pp.197-206，1990年8月。引用于p。661,883,884[1529]Salvi， 
Marco，“使用指数阴影图渲染过滤阴影”，载于Wolfgang Engel， 
编辑，ShaderX6，Charles RiverMedia，第257-274页，2008 
年。256[1530]Salvi，Marco， “影子过滤的概率方法”，游戏开 
发者大会，2008年2月。引用于p。256 [1531]Salvi，Marco， 
KirilVidim.ce，Andrew Lauritzen和Aaron Lefohn， “自适应体 
积阴影贴图”，计算机图形论坛，第一卷。29，不。4， 
pp.1289-1296,2010。引用于p。258,570参考书目 1131[1532] 
Salvi，Marco和 KarthikVaidyanathan， “多层Alpha混合”， 
----------------------- Page 1332-----------------------
在第 18届ACMSIGGRAPH交互式3D图形和游戏研讨会论文集， 
ACM，第 151-158页，2014年。被引用在第 156,642[1533]Salvi， 
Marco， “时间超级采样的游览”，游戏开发者大会，2016年 3 
月。引用于p。143[1534]Salvi，Marco， “深度学习：实时渲染 
的未来？”，SIGGRAPH实时渲染课程中的开放问题，2017年8 
月。引用于p。1043[1535]Samet，Hanan，空间数据结构的应 
用：计算机图形学，图像处理和GIS，Addison-Wesley，1989年。 
引用于p。825[1536]Samet，Hanan，空间数据结构的设计和分 
析，Addison-Wesley，1989年。引用于p。825[1537]Samosky， 
Joseph，SectionView：通过三维医学图像数据交互式指定和可视 
化部分的系统，硕士论文，麻省理工学院电气工程和计算机科学系， 
1993年。969 [1538] Sanchez，Bonet，Jose Luis和 Tomasz 
Stachowiak，“解决现代延迟渲染引擎中的一些常见问题”，2012 
年7月的发展会议。引用于 p。570 [1539]Sander，PedroV.， 
Xianfeng Gu ，Steven J. Gortler ，Hugues Hoppe 和 John 
Snyder， “剪影剪辑”，SIGGRAPH '00：第27届计算机图形学 
和交互技术年会论文集，ACM 出版社/ Addison-Wesley 
PublishingCo.，pp.327-334，2000年7月。引用于p。667[1540] 
Sander，PedroV.，JohnSnyder，StevenJ.Gortler，和 Hugues 
Hoppe， “纹理映射渐进网格”，在SIGGRAPH'01第28届计算 
机图形和交互技术年会论文集，ACM，pp.409-416，2001年8月。 
引用于p。710[1541]Sander，PedroV.，DavidGosselin和Jason 
----------------------- Page 1333-----------------------
L.Mitchell，图形硬件上的实时皮肤渲染“        ”，ACMSIGGRAPH2004 
草图，ACM，p。148，2004年8月。引用于p。635[1542]Sander， 
PedroV.，NatalyaTatarchuk和Jason L.Mitchell， “明确的早期 
Z剔除高效流体流动模拟”，Wolfgang Engel编辑，ShaderX5， 
CharlesRiverMedia，第 553-564页，2006年。引用p。53,1016 
[1543]Sander，PedroV.和Jason L.Mitchell， “渐进缓冲器：视 
图相关几何和纹理LOD渲染”，SIGGRAPH高级实时渲染 3D图 
形和游戏课程，2006年8月。被引用在第 860 [1544]Sander， 
PedroV.，Diego Nehab和 Joshua Barczak， “Fast Triangle 
ReorderingforVertex LocalityandReducedOverdraw”，ACM 
TransactionsonGraphics，vol。26，不。3，pp.89：1-89：9,2007。 
引用于p。701[1545]Sathe，RahulP.， “用于提高功率效率的可 
变精度像素着色”，EricLengyel编辑，Game EngineGems3， 
CRCPress，pp.101-109,2016。引用于p。814[1546]Scandolo， 
Leonardo，PabloBauszat和 ElmarEisemann， “合并阴影地图 
压缩的多分辨率层次结构”，计算机图形论坛，第一卷。35，不。 
7，pp.383-390,2016。引用于p。[1547]Sch¨afer，H.，J。Raab， 
B。Keinert，M。Meyer，M。Stamminger和 M.Nie.ner， “动 
态特征 - 自适应细分”，在第19届 Symposiumon Interactive 
的论文集中3D图形与游戏，ACM，第31-38页，2014年。引用 
于第4页。779[1548]Schander，Thomas和ClemensMusterle， 
 “使用混合延迟方法的实时路径跟踪”，GPU技术会议，2017年 
----------------------- Page 1334-----------------------
10月 18 日。引用于p。510 [1549] Schaufler，G。和W.St¨ 
urzlinger， “用于虚拟现实的三维图像缓存”，计算机图形论坛， 
第一卷。15，不。3，pp.227-236,1996。引用于p。561,5621132 
参考书目[1550]Schaufler，Gernot， “Nailboards：动态场景中 
图像缓存的渲染图元”， “渲染技术”，1997年，Springer，第 
151-162页，1997年6月。564,565[1551]Schaufler，Gernot， 
 “Per-Object Image Warping with Layered Impostors” ， 
RenderingTechniques '98，Springer，pp.145-156，1998年6 
月至7月。引用于p。[1552]Scheib，Vincent， “与 DirectX命 
令缓冲器并行渲染”，美丽的像素博客，2008年7月22 日。引用 
于p。814[1553]Scheiblauer，Claus，与巨大点云的互动，博士 
论文，维也纳科技大学，2016 年。引用于 p。575 [1554] 
Schertenleib，Sebastien， “多线程3D渲染器”，EricLengyel 
编辑，Game EngineGems，Jones和 Bartlett，第139-147页， 
2010年。814 [1555]Scherzer，Daniel， “大型环境的强大阴影 
贴图”，中欧计算机图形学研讨会，2005年5月。[1556]Scherzer， 
D.，S。Jeschke和 M.Wimmer， “具有时间重投影和阴影测试置 
信度的像素正确阴影贴图”，在第 18届 Eurographics协会渲染技 
术研讨会论文集，EurographicsAssociation，pp.45-50,2007。 
引用于p。522,523 [1557]Scherzer，D。和M.Wimmer， “用 
于离散细节渲染的帧顺序插值”，计算机图形论坛，第一卷。27， 
不。4,1175-1181,2008。引用于p。856[1558]Scherzer，Daniel， 
----------------------- Page 1335-----------------------
MichaelWimmer和Werner Purgathofer， “实时硬阴影映射方 
法概述”，计算机图形学论坛，第一卷。30，不。1，pp.169-186,2011。 
引用于p。[1559]Scherzer，D.，L。Yang，O。Mattausch，D。 
Nehab，P。Sander，M。Wimmer和 E.Eisemann， “关于实时 
渲染中的时间相干方法的调查”，计算机图形学论坛，第一卷31， 
不。8，pp.2378-2408,2011。引用于p。523[1560]Scheuermann， 
Thorsten， “实时实时毛发渲染和阴影”，ACMSIGGRAPH2004 
草图，ACM，p。147，2004年8月。引用于p。641,644,645[1561] 
Schied，Christoph和CarstenDachsbacher， “用于记忆效率延 
迟着色的延迟属性插值”，在第7届高性能图形会议论文集，ACM， 
第43-49页，8月。2015.引用于p。907[1562]Schied，Christoph 
和 Carsten Dachsbacher， “DeferredAttribute Interpolation 
Shading”，Wolfgang Engel编辑，GPUPro7，CRC出版社，第 
83-96页，2016年。引用于p。907 [1563]Schied，Christoph， 
Anton Kaplanyan，ChrisWyman，Anjul Patney，ChakravartyR. 
AllaChaitanya，John Burgess，ShiqiuLiu，CarstenDachsbacher 
和Aaron Lefohn， “时空方差指导过滤：路径的实时重建 - 跟踪 
全球照明， “高性能图形，2017年7月。引用于p。511 [1564] 
Schilling，Andreas，G。Knittel和WolfgangStra.er，“Texram： 
一种用于纹理的智能存储器”，IEEE计算机图形和应用，第一卷。 
16，不。3，pp.32-41，1996年5月。引用于p。189[1565]Schilling， 
Andreas， “环境地图的抗锯齿”，计算机图形学论坛，第一卷。 
----------------------- Page 1336-----------------------
20，不。1，pp.5-11,2001。引用于p。[1566]Schlag，John，“使 
用几何结构插入方向与四元数”，在JamesArvo编辑，Graphics 
GemsII，Academic Press，pp.377-380,1991。引用于p。[1567] 
Schlag，John， “对光栅图像数据的快速压花效应”，Paul S. 
Heckbert 编辑， Graphics Gems IV ，Academic Press ， 
pp.433-437,1994。引用于p。211[1568]Schlick，Christophe， 
 “基于物理渲染的廉价 BRDF模型”，计算机图形论坛，第一卷。 
13，不。3，pp.149-162,1994。引用于p。320,351参考书目 1133 
[1569]Schmalstieg，Dieter和 RobertF.Tobler， “三维边界框 
的快速投影面积计算”，图形工具杂志，第一卷。4，不。2， 
pp.37-43,1999。也在 [112]中收集。引用 p。863 [1570] 
Schmalstieg，Dieter和TobiasHollerer，增强现实：原则与实践， 
Addison-Wesley，2016年。引用于p。917,940[1571]Schmittler， 
JIWald和 P.Slusallek， “SaarCOR：光线追踪的硬件架构”，图 
形硬件2002，EurographicsAssociation，pp.27-36，2002年9 
月。引用于p。1039[1572]Schneider，Andrew和 NathanVos， 
 “Nubis：使用Decima 引擎创作实时体积 Cloudscapes”， 
SIGGRAPH在 2017年 8 月的游戏实时渲染方面取得了进展。 
619,620 [1573] Schneider，Jens 和 R¨udigerWestermann， 
 “GPU-Friendly高质量地形渲染”，WSCG期刊，第一卷。14， 
没有。1-3，pp.49-56,2006。引用于p。879 [1574]Schneider， 
Philip和 David Eberly，计算机图形学的几何工具，Morgan 
----------------------- Page 1337-----------------------
Kaufmann  ， 2003  年  。  引  用  于  p  。 
685,686,716,950,966,981,987,991[1575]Schollmeyer，Andre， 
Andrey Babanin和 Bernd Fro， “可编程延迟着色管道的与顺序 
无关的透明度”，计算机图形论坛，第一卷。34，不。7， 
pp.67-76,2015。引用于p。887[1576]Schorn，Peter和 Frederick 
Fisher， “测试多边形的凸性”，PaulS. Heckbert编辑，图形宝 
石 IV，学术出版社，第7-15页，1994年。引用于p。686[1577] 
Schott，Mathias，Vincent Pegoraro，CharlesHansen，K'evin 
Boulanger和 KadiBouatouch， “用于交互式直接体绘制的定向 
遮挡着色模型”，在Euro-Vis'09，EurographicsAssociation， 
pp.855-862,2009。引用于p。607[1578]Schott，Mathias，AV 
Pascal Grosset，Tobias Martin，Vincent Pegoraro，Sean T. 
Smith和CharlesD.Hansen， “交互式直接体绘制的景深效应”， 
计算机图形学论坛，第一卷。30，不。3，pp.941-950,2011。引 
用于p。607[1579]Schr¨oder，Peter和WimSweldens， “球面 
小波：在球体上有效地表现函数”，SIGGRAPH'95：第22届计算 
机图形学和交互技术年会论文集，ACM，第161页 - 172，1995 
年8月。引用于p。[1580]Schr¨oder，Peter，“我们能测量什么？” 
SIGGRAPH离散微分几何课程，2006年8月。引用于p。954[1581] 
Schroders，MFA和 RVGulik， “Quadtree ReliefMapping”， 
图形硬件2006，EurographicsAssociation，pp.61-66，2006年 
9月。引用于p。[1582]施罗德，蒂姆， “使用射线铸造的碰撞检 
----------------------- Page 1338-----------------------
测”，游戏开发者，第一卷。8，不。8，pp.50-56，2001年8月。 
引用于p。976[1583]Schuetz，Markus，Potree：渲染Web浏 
览器中的大点云，视觉计算文凭论文，维也纳科技大学，2016。引 
用p。574,575,576[1584]Sch¨uler，Christian，Normal“ Mapping 
Without Precomputed Tangents”，Wolfgang Engel编辑， 
ShaderX5，CharlesRiverMedia，pp.131-140,2006。引用于p。 
210[1585]Sch¨uler，Christian， “MultdamplingExtensionfor 
GradientShadowMaps”，inWolfgangEngel，ed。，ShaderX5， 
Charles River Media ，pp.207-218,2006。引用于 p。250 
[1586]Sch¨uler，Christian， “一种高效且物理上合理的实时着色 
模型”，载于Wolfgang Engel，编辑，ShaderX7，CharlesRiver 
Media，第 175-187页，2009年。325[1587]Sch¨uler，Christian， 
 “近似于查普曼放牧 - 大气散射的入射函数”，Wolfgang Engel 
编辑，GPUPro3，CRC出版社，第 105-118页，2012年。6161134 
参考书目[1588]Sch¨uler，Christian，“无分支矩阵到四元数转换， 
 “TheTenth Planet博客，2012年8月7 日。引用于第4页。81 
[1589]Schulz，Nicolas， “迈向下一代 -Ryse的渲染技术”，游 
戏开发者大会，2014年 3月。引用于 p。371,506,892,893,904 
[1590]Schulz，Nicolas和Theodor Mader，“Ryse的渲染技术： 
罗马之子”，SIGGRAPH在游戏中实时渲染的进展，2014年8月。 
引用于p。234,245,246,251,252,569,864[1591]Schulz，Nicolas， 
CRYENGINE Manual，Crytek GmbH，2016。引用于 p.24。 
----------------------- Page 1339-----------------------
111,113,631[1592]Schumacher，DaleA.， “General Filtered 
Image Rescaling”，David Kirk 编辑，Graphics Gems III， 
Academic Press，pp.8-16,1992。[1593]Schwarz，Michael和 
MarcStamminger， “BitmaskSoftShadows”，计算机图形学 
论坛，第一卷。26，不。3，pp.515-524,2007。引用于p。252[1594] 
施瓦茨，迈克尔，和 Hans-PeterSeidel， “GPU上的快速平行表 
面和固体体素化”，ACMTransactions onGraphics，vol。29， 
不。6，pp.179：1-179：10，2010年 12月。引用于p。581[1595] 
Schwarz，Michael，实用二元曲面和固体体素化与“             Direct3D11”， 
Wolfgang Engel编辑，GPUPro3，CRC出版社，第337-352页， 
2012年。581,582[1596]Seetzen，Helge，Wolfgang Heidrich， 
Wolfgang Stuerzlinger ，Greg Ward ，Lorne Whitehead ， 
MatthewTrentacoste，Abhijeet Ghosh和AndrejsVorozcovs， 
 “高动态范围显示系统”，ACM图形交易（SIGGRAPH2004）， 
vol 。23，不。3，pp.760-768，2004年8月。引用于p。1011[1597] 
Segal，M.，C。Korobkin，R.vanWidenfelt，J.Foran和 P.Haeberli， 
 “FastShadowsandLightingEffectsUsingTextureMapping，” 
ComputerGraphics （SIGGRAPH'92Proceedings），vol。26， 
不。2，pp。1992年7月249-252。引用于p。173,221,229[1598] 
Segal，Mark和 KurtAkeley，OpenGL图形系统：规范 版本（ 4.5）， 
Khronos集团，2017年6月。编辑 （v1.1）：ChrisFrazier;编辑 
 （第1.2-4.5节）：Jon Leech;编辑（第2.0节）：帕特布朗。引 
----------------------- Page 1340-----------------------
用p。845,1033 [1599]Seiler，LDCarmean，E。Sprangle，T。 
Forsyth，M。Abrash，P。Dubey，S。Junkins，A。Lake，J。 
Sugerman，R。Cavin，R。Espasa，E。Grochowski ，T.Juan 
和 P.Hanrahan， “Larrabee：用于视觉计算的多核x86架构”， 
ACMTransactionsonGraphics，vol。27，不。3，pp.18：1-18： 
15,2008。引用于 p。230,996,1017 [1600] Sekulic，Dean， 
 “EfficientOcclusionCulling”，RandimaFernando编辑，GPU 
Gems，Addison-Wesley，pp.487-503,2004。引用于p。524,836 
[1601]Selan，Jeremy， “使用查找表来加速颜色转换， “在 Matt 
Pharr编辑，GPUGems2，Addison-Wesley，pp.381-408,2005。 
引用于p。289,290 [1602]Selan，Jeremy， “电影色彩：从你的 
显示器到大屏幕”，VES 白皮书，2012 年。引用于 p。 
166,283,289,290,291[1603]Selgrad，K.，C。Dachsbacher，Q。 
Meyer和 M.Stamminger， “过滤精确软阴影的多层阴影贴图”， 
计算机图形论坛，第一卷。34，不。1，pp.205-215,2015。引用 
于p。259 [1604]Selgrad，K。，J.M¨uller，C。Reintges和 M. 
Stamminger， “快速阴影地图渲染多光设置”，在 Eurographics 
研讨会上关于渲染 - 实验想法和实现， Eurographics 
Association， pp.41-47,2016。引用于 p。247 [1605]卖家， 
Graham，PatrickCozzi，KevinRing，EmilPersson，JoeldaVahl 
和JMPvanWaveren，SIGGRAPH渲染大规模虚拟世界课程，2013 
年7月。引用于p。102,868,874,875,876,879参考书目1135[1606] 
----------------------- Page 1341-----------------------
卖方，Graham，Richard S. Wright Jr.和 Nicholas Haemel， 
OpenGLSuperbible：综合教程和参考，第七版，Addison-Wesley， 
2015。引用页。55[1607]Sen，Pradeep，MikeCammarano和 
PatHanrahan，“ShadowSilhouetteMaps”，ACMTransactions 
on Graphics （SIGGRAPH 2003 ），vol 。22 ，不。3 ， 
pp.521-526,2003。引用于p。259 [1608]高级，安德鲁， “移动 
GPU的面部动画”，Wolfgang Engel编辑，ShaderX7，Charles 
RiverMedia，第 561-570页，2009年。90[1609]高级，安德鲁， 
 “iPhone 3GS图形开发和优化策略”，Wolfgang Engel编辑， 
GPU Pro，AK Peters，Ltd。，第385-395页，2010年。引用于 
p。702,795,804,805[1610]Seymour，Mike， “Manuka：Weta 
Digital的新渲染器”，fxguide，2014年8月6 日。引用p。280 
[1611]Shade，J.，StevenGortler，Li-WeiHe和 RichardSzeliski， 
 “分层深度图像”，SIGGRAPH'98：第25届计算机图形学和交互 
技术年会论文集，ACM，第231页-242，1998年7月。引用于p。 
565 [1612]Shamir，Ariel， “关于网格分割技术的调查”，计算 
机图形学论坛，第一卷。27，不。6，pp.1539-1556,2008。引用 
于p。683[1613]Shankel，Jason， “用Skyboxes渲染遥远的风 
景”，MarkDeLoura编辑，GameProgrammingGems2，Charles 
RiverMedia，pp.416-420,2001。引用p。548[1614]Shankel， 
Jason，“FastHeightfieldNormalCalculation，”，DanteTreglia 
编辑，Game Programming Gems 3，Charles River Media， 
----------------------- Page 1342-----------------------
pp.344-348,2002。引用于p。695[1615]Shanmugam，Perumaal 
和OkanArikan，“GPU上的硬件加速环境光遮挡技术， “在2007 
年交互式3D图形和游戏研讨会论文集，ACM，第73-80页，2007 
年。引用于p。458 [1616]Shastry，AnirudhS.，“HighDynamic 
RangeRendering，”GameDev.net，2004。引用于p。527[1617] 
Sheffer，Alla，BrunoL'evy，MaximMogilnitsky和Alexander 
Bogomyakov， “ABF ++：Fast and Robust Angle Based 
Flattening，”ACMTransactionsonGraphics，vol。24，不。2， 
pp.311-330,2005。引用于p。485 [1618]Shemanarev，Maxim， 
 “文本光栅化曝光”，AGG项目，2007年7月。引用于p。676[1619] 
Shen，Hao，PhengAnn Heng和TangZeshengTang， “使用 
有符号距离的快速三角形 - 三角形重叠测试”，图形工具的期刊， 
第一卷。8，不。1，pp.17-24,2003。引用于p。974 [1620]沉， 
李，冯洁青，杨宝光， “指数软阴影映射”，计算机图形学论坛， 
第一卷。32，不。4，pp。107-116,2013。引用于p。257[1621] 
Shene，Ching-Kuang，“计算线和圆柱的交点”，PaulS.Heckbert 
编辑，GraphicsGemsIV，Academic Press，pp.353-355,1994。 
引用于p。959[1622]Shene，Ching-Kuang， “计算线和锥的交 
点”，Alan Paeth编辑，GraphicsGemsV，Academic Press， 
pp.227-231,1995。引用于p。959[1623]Sherif，Tarek，“WebGL 
2示例”，GitHub存储库，2017年3月17日。引用于p。122,125 
[1624] Shewchuk，Jonathan Richard， “Adaptive Precision 
----------------------- Page 1343-----------------------
Floating-Point Arithmetic and Fast Robust Geometric 
Predicates，DiscreteandComputationalGeometry，vol。18， 
不。3，pp.305-363，1997年 10月。引用于p。974[1625]Shilov， 
Anton，Yaroslav Lyssenko和Alexey Stepin， “高度定义：ATI 
RadeonHD2000架构评论”，Xbit Laboratories网站，2007年 
8月。引用p。[1626]Shirley，Peter，计算机图形学的基于物理的 
照明计算，博士论文，伊利诺伊大学厄巴纳香槟分校，1990年 12 
月。143,3511136参考书目[1627]Shirley，Peter，HelenHu， 
BrianSmits和 EricLafortune， “从业者对光反射模型的评估”， 
载于 PacificGraphics '97，IEEEComputerSociety，pp.40-49， 
Oct1997年。引用p。351[1628]Shirley，Peter，RayTracingin 
OneWeekend，RayTracing MinibooksBook1，2016。引用于 
p。512,1047[1629]Shirley，Peter， “来自Andrew Kensler的 
新简单 Ray-Box测试”，PeteShirley的图形博客，2016年2月 
14 日。引用于p。961 [1630] Shirman，Leon A.和 Salim S. 
Abi-Ezzi， “弯曲补丁快速加工法线锥”，计算机图形学论坛，第 
一卷。12，不。3，pp.261-272,1993。引用 p。833 [1631] 
Shishkovtsov，Oles，STALKER“ 中的延迟阴影”，载于 MattPharr， 
编辑，GPU Gems 2，Addison-Wesley，第143-166页，2005 
年。引用于 p。216,888 [1632] Shodhan，Shalin和 Andrew 
Willmott， “Spore中的风格化渲染”，Wolfgang Engel编辑， 
GPUPro，AK Peters，Ltd。，第 549-560页，2010年。678[1633] 
----------------------- Page 1344-----------------------
Shoemake，Ken， “用四元数曲线动画旋转”，计算机图形学 
 （SIGGRAPH '85 Proceedings），第一卷。19，没有。3， 
pp.245-254，1985 年 7 月。引用于 p。73,76,80,82 [1634] 
Shoemake，Ken， “Quaternionsand4×4 Matrices”，James 
Arvo 编 辑 ， Graphics Gems II ， Academic Press ， 
pp.351-354,1991。引用于p。[1635]Shoemake，Ken， “Polar 
MatrixDecomposition”，PaulS.Heckbert编辑，GraphicsGems 
IV，Academic Press，pp.207-221,1994。引用于p。74 [1636] 
Shoemake，Ken，“EulerAngleConversion”，PaulS.Heckbert 
编辑，GraphicsGemsIV，Academic Press，pp.222-229,1994。 
引用于p。70,73 [1637]Shopf，J.，J。Barczak，C。Oat和 N. 
Tatarchuk， “Froblins的三月：在GPU上模拟和渲染智能和细节 
生物的大量人群”，SIGGRAPH在 Real-的进展时间渲染在3D图 
形和游戏课程，2008年8月。引用于p。475,848,851 [1638]Sigg， 
Christian 和 Markus Hadwiger， “Fast Third-Order Texture 
Filtering”，MattPharr编辑，GPUGems2，Addison-Wesley， 
pp.313-329,2005。引用次数页。189,517[1639]Sikachev，Peter， 
Vladimir Egorov和SergeyMakeev，“QuaternionsRevisited”， 
Wolfgang Engel编辑，GPUPro5，CRC出版社，第361-374页， 
2014年。87,210,715[1640]西卡切夫，彼得和尼古拉斯·朗尚，“小 
偷的反思系统，“SIGGRAPH在游戏中实时渲染的进展，2014年8 
月。引用于p。502[1641]Sikachev，Peter，SamuelDelmont， 
----------------------- Page 1345-----------------------
Uriel Doyon和Jean-Normand Bucci， “下一代盗贼渲染”， 
Wolfgang Engel编辑，GPU Pro6，CRC出版社，第65-90页， 
2015年。引用 p。251,252 [1642]Sillion，Fran.cois和Claude 
Puech，RadiosityandGlobalIllumination，MorganKaufmann， 
1994。引用于 p。442,483 [1643] Silvennoinen，Ari 和 Ville 
Timonen，“QuantumBreak中的多尺度全局照明”，SIGGRAPH 
在游戏中实时渲染的进展，2015年8月。引用于p。488,496 [1644] 
Silvennoinen，Ari和Jaakko Lehtinen， “通过稀疏辐射探测器进 
行预计算局部重建的实时全局照明”，ACM图形交易 （SIGGRAPH 
Asia 2017），第一卷。36，不。6，pp.230：1-230：13，2017 
年 11月。引用于p。484 [1645]Sintorn，Erik，ElmarEisemann 
和 UlfAssarsson， “基于样本的软阴影可见性，使用无Alias阴影 
贴图，”计算机图形学论坛，第一卷。27，不。4，pp.1285-1292,2008。 
引用于 p。261 参考书目 1137 [1646] Sintorn，Erik 和 Ulf 
Assarsson， “2009年交互式3D图形与游戏研讨会论文集”中的 
 “头发自我阴影和透明度深度订购使用占用图”，第67-74页，2 
月。-mar。2009年。引用p。645[1647]Sintorn，Erik，ViktorK¨ 
ampe，OlaOlsson和 UlfAssarsson，“CompactPrecomputed 
Voxelized Shadows，”ACMTransactions onGraphics，vol。 
33，不。4，文章编号。150，2014年3月。引用于p。264,686[1648] 
Sintorn，Erik，ViktorK¨ampe，OlaOlsson和 UlfAssarsson， 
 “使用视图 - 样本聚类层次结构的每三角形阴影体积，“参见ACM 
----------------------- Page 1346-----------------------
SIGGRAPH交互式 3D图形与游戏研讨会第 18次会议论文集， 
ACM，第 111-118页，2014年3月。引用于p。233,259[1649] 
Skiena，Steven，算法设计手册，Springer-Verlag，1997年。引 
自p。707[1650]Skillman，Drew和 PeteDemoreuille， “Rock 
ShowVFX：为生活带来生活，”游戏开发者大会，2010年3月。 
引用p。569,572 [1651]Sloan，Peter-Pike，Jan Kautz和John 
Snyder， “在动态，低频照明环境中进行实时渲染的预计算辐射传 
递”，ACM图形交易 （SIGGRAPH2002），第一卷。21，不。3， 
pp.527-536，2002年7月。引用于p。471,479,480 [1652]Sloan， 
Peter-Pike，Jesse Hall，John Hart和JohnSnyder， “用于预计 
算辐射传输的聚类主成分， “ACM图形交易 （SIGGRAPH2003）， 
第一卷。22，不。3，pp.382-391,2003。引用于p。480 [1653]Sloan， 
Peter-Pike，Ben Luna和John Snyder， “Local，Deformable 
Precomputed Radiance Transfer ，”ACM Transactions on 
Graphics （SIGGRAPH2005），vol。24，不。3，pp.1216-1224， 
2005年8月。引用于p。431,481 [1654]Sloan，Peter-Pike，“预 
先计算的辐射传递的法线图”，载于2006年交互式3D图形和游戏 
研讨会论文集，ACM，第23-26页，2006年。404 [1655]Sloan， 
Peter-Pike，Naga K.Govindaraju，Derek Nowrouzezahrai和 
John Snyder， “基于图像的实时软全局照明的代理累积”，载于 
PacificGraphics 2007，IEEEComputer Society，pp.97- 105， 
2007年 10月。引用于p。456,467 [1656]Sloan，Peter-Pike， 
----------------------- Page 1347-----------------------
 “StupidSphericalHarmonics （SH）Tricks， “游戏开发者大会， 
2008年2月。引用于p。395,400,401,428,429,430,431,470[1657] 
Sloan，Peter-Pike，“EfficientSphericalHarmonicEvaluation，” 
Journal ofComputerGraphicsTechniques，vol。2，没有。2， 
pp.84-90,2013。引用于p。400 [1658]Sloan，Peter-Pike，Jason 
Tranchida，HaoChen和 LadislavKavan， “围绕GPU上的环境 
骚扰”，参见ACMSIGGRAPHAsia2013技术简报，ACM，文章 
编号。2013 年 11月 32 日。引用于p。453 [1659] Sloan， 
Peter-Pike，“DeringingSphericalHarmonics”，参见SIGGRAPH 
Asia 2017技术简报，ACM，文章编号。2017年 11月 11日。引 
用于p。401,429 [1660]Smedberg，Niklas和 DanielWright， 
 “战争机器中的渲染技术2”，游戏开发者大会，2009年3月。引 
用于p。462 [1661]Smith，Alvy Ray，计算机图形学数字过滤教 
程，技术备忘录27，修订于3月。1983年。引用p。136[1662] 
Smith，Alvy Ray和James F.Blinn， “BlueScreenMatting”， 
SIGGRAPH'96：第23届计算机图形和交互技术年会论文集，ACM， 
第259-268页，1996年8月。引用p。159,160[1663]Smith， 
Alvy Ray，梦想的东西“  ”，计算机图形世界，第一卷。21，pp.27-29， 
1998年7月。引用于p。10421138参考书目[1664]Smith，Ashley 
Vaughan和 MathieuEinig， “基于物理的移动延迟着色”，载于 
Wolfgang Engel，编辑，GPU Pro7，CRC 出版社，第187-198 
页，2016年。903[1665]Smith，BruceG.， “随机粗糙表面的几 
----------------------- Page 1348-----------------------
何阴影”，IEEE天线和传播交易，第一卷。15，不。5，pp.668-671， 
1967年9月。引用于p。334[1666]Smith，Ryan，“GPUBoost 
3.0：更精细的时钟速度控制， “版权所有”NVIDIAGeForceGTX 
1080和GTX1070创始人版评论：启动FinFET一代，AnandTech“        ， 
2016年7月20 日。引用于第4页。163,789[1667]Smits，Brian 
E.和GaryW. Meyer， “牛顿的颜色：在逼真的图像合成中模拟干 
涉现象”，在KadiBouatouch和Christian Bouville编辑。计算 
机图形学中的照片写实，Springer，pp.185-194,1992。引用于p。 
363[1668]Smits，Brian， “光线追踪的效率问题”，图形工具杂 
志，第一卷。3，不。2，pp.1-14,1998。也在[112]中收集。引用p。 
792,961[1669]Smits，Brian，“WALL-E和Up的反射模型设计”， 
SIGGRAPH电影和游戏制作中的实用基于物理的阴影，2012年8 
月。引用于p。324[1670]Snook，Greg， “使用互锁瓷砖简化地 
形”，MarkDeLoura编辑，GameProgrammingGems2，Charles 
RiverMedia，pp.377-383,2001。引用于p。876[1671]Snyder， 
John，“实时图形的区域光源”，技术报告 MSR-TR-96-11，微软 
研究院，1996年3月。引用于 p。382 [1672]Snyder，John和 
Jed Lengyel， “可见性分类与合成而不分裂图像层分解”， 
SIGGRAPH '98：第25届计算机图形学与交互技术年会论文集， 
ACM，第219-230页，1998年7月。引用于p。532,551[1673] 
Soler，Cyril和 Fran.coisSillion，使用卷积快速计算软阴影纹理“   ”， 
SIGGRAPH '98：第25届计算机图形学和交互技术年会论文集， 
----------------------- Page 1349-----------------------
ACM，第321页 - 1998年7月 -3月。引用于 p。256 [1674] 
Sousa，Tiago， “Adaptive Glare”，Wolfgang Engel，编辑， 
ShaderX3，Charles RiverMedia，第349-355页，2004年。引 
用于第4页。288,527[1675]Sousa，Tiago，“GenericRefraction 
Simulation，”，MattPharr，ed。，GPUGems2，Addison-Wesley， 
pp.295-305,2005。引用于p。628 [1676]Sousa，Tiago， “植 
被程序动画和阴影中的阴影”，在Hubert Nguyen编辑，GPU 
Gems3，Addison-Wesley，第373-385页，2007年。引用于p。 
639 [1677]Sousa，Tiago， “CryENGINE中的抗锯齿方法”， 
SIGGRAPH过滤方法，用于实时抗锯齿课程，2011年8月。引用 
于第6页。145,531[1678]Sousa，Tiago，NickolayKasyan和 
NicolasSchulz， “CryENGINE3图形技术的秘密”，SIGGRAPH 
在3D图形和游戏的实时渲染方面取得进展，2011年8月。引用p。 
145,234,245,252,257,262,505 [1679]Sousa，Tiago，Nickolay 
Kasyan和 NicolasSchulz， “CryENGINE 3：三年的工作回顾， 
 “沃尔夫冈恩格尔编辑，GPUPro3，CRC出版社，第 133-168页， 
2012     年      。      引     用      于      p     。 
139,234,238,245,252,257,542,786,793,932,937 [1680]Sousa， 
Tiago，CarstenWenzel和Chris Raine， “孤岛危机3的渲染技 
术”，游戏开发者大会，3月2013.引用于p。887,889,890,895[1681] 
Sousa，Tiago，NickolayKasyan和 NicolasSchulz，“CryENGINE 
3：图形宝石”，SIGGRAPH在3D图形和游戏的实时渲染方面取 
----------------------- Page 1350-----------------------
得进展，2013年7月。引用p。531,535,539,540,542,604,888,892 
[1682]Sousa，T。和J.Geoffroy， “DOOM：魔鬼在细节中”， 
SIGGRAPH在 3D图形和实时渲染方面取得进展游戏课程，2016 
年 7 月。引用于 p。569,629,883,901参考书目 1139 [1683] 
Spencer，Greg，Peter Shirley，KurtZimmerman 和 Donald 
Greenberg，“数字图像的基于物理的眩光效应”，SIGGRAPH'95： 
第22届计算机图形学和交互技术年会论文集，ACM，第325-334 
页，1995年8月。524 [1684]Stachowiak，Tomasz， “随机屏 
幕 - 空间反思”，SIGGRAPH在游戏课程中实时渲染的进展，2015 
年8月。引用于p。507,508[1685]Stachowiak，Tomasz， “延 
期材料渲染系统”，在线文章，2015年 12月 18日。引用于p。 
907[1686]Stam，Jos， “多重散射作为扩散过程”，在渲染技术 
'95，Springer，pp.41-50，1995年6月。引用于p。634[1687] 
Stam，Jos， “在任意参数值下对Catmull-Clark细分曲面的精确 
评估”，SIGGRAPH'98：第25届计算机图形学和交互技术年会论 
文集，ACM，pp。1998年7月395-404。引用于p。763[1688] 
Stam，Jos， “衍射着色器”，SIGGRAPH'99：第26届计算机图 
形学与交互技术年会论文集，ACM 出版社/ Addison-Wesley 
PublishingCo.，pp.101-110，1999年8月。引用p。361[1689] 
Stam，Jos， “游戏的实时流体动力学”，游戏开发者大会，2003 
年3月。引用于p。649[1690]Stamate，Vlad， “使用球面谐波 
减少光照计算”，Wolfgang Engel编辑，ShaderX3，CharlesRiver 
----------------------- Page 1351-----------------------
Media，第251-262页，2004年。430 [1691]Stamminger，Marc 
和 George Drettakis， “Perspective Shadow Maps”，ACM 
Transactions onGraphics （SIGGRAPH2002），vol。21，不。 
3，pp.557-562，2002年7月。引用于p。241[1692]St-Amour， 
Jean-Fran.cois， “RenderingAssassin's Creed III”，游戏开发 
者大会，2013年 3月。引用于 p。453 [1693] Steed，Paul， 
Animating Real-TimeGameCharacters，CharlesRiverMedia， 
2002。引用于p。88 [1694]Stefanov，Nikolay， “汤姆克兰西 
的分部全球启示”，游戏开发者大会，2016年3月。引用于 p。 
478,483 [1695]Steinicke，FrankSteinicke，GerdBruder和Scott 
Kuhl，“虚拟对象和环境的逼真透视投影”，ACMTransactionson 
Graphics，vol。30，不。5，文章编号。112，2011年 10月。引 
用于p。554[1696]Stemkoski，Lee，“BubbleDemo”，GitHub 
存储库，2013年。引用于p。628[1697]Stengel，Michael，Steve 
Grogorick ，Martin Eisemann 和 Marcus Magnor， “用于 
Gaze-ContingentReal-TimeRendering的自适应图像空间采样”， 
计算机图形论坛，第一卷。35，不。4，pp.129-139,2016。引用 
于 p。932 [1698]Sterna，Wojciech， “实用聚集的景深， “在 
Wolfgang Engel 编辑，GPU Zen ，Black Cat Publishing， 
pp.217-237,2017。引用于 p。535 [1699] Stewart，AJ 和 MS 
Langer，“在漫射照明下实现从阴影中精确恢复形状”，IEEETrans。 
关于模式分析和机器智能，第一卷。19，没有。9，pp.1020-1025， 
----------------------- Page 1352-----------------------
1997年9月。引用于p。450 [1700]Stewart，Jason和Gareth 
Thomas ， “Tiled Rendering Showdown ：Forward ++ vs. 
DeferredRendering，”Game DevelopersConference，2013 
年 3 月。引用 p。896,897,914 [1701] Stewart ，Jason ， 
 “Compute-BasedTiledCulling”，Wolfgang Engel编辑，GPU 
Pro6，CRC出版社，第435-458页，2015年。引用于p。894,896,914 
[1702]Stich，Martin，CarstenWachach和Alexander Keller， 
 “使用分层遮挡剔除和几何着色器的高效且强大的阴影体积”，在 
Hubert Nguyen 编辑，GPU Gems 3，Addison-Wesley ， 
pp.239-256,2007。引用于p。233 1140参考书目[1703]Stiles， 
WS和JM Burch， “1955年国际物理实验室关于色彩匹配的调查 
 （1955年）的苏黎世国际电影委员会的临时报告，”OpticaActa， 
vol 。2，没有。4，pp.168-181,1955。引用于p。273[1704]Stokes， 
Michael，Matthew Anderson ，Srinivasan Chandrasekar 和 
RicardoMotta， “Internet-sRGB的标准默认色彩空间”，版本 
1.10，国际色彩联盟，1996年 11月。引用于p。278[1705]Stone， 
Jonathan， “径向对称反射图”，SIGGRAPH2009会谈，ACM， 
文章编号。2009年8月24 日。引用于p。414 [1706]Stone， 
Maureen，数字彩色野外指南，AK Peters，Ltd。，2003年8月。 
引自p。276[1707]Stone，Maureen， “将颜色表示为三个数字， 
 “IEEE计算机图形和应用，第一卷。25，不。4，pp.78-85，7月/ 
8月。2005年。引用p。272,276[1708]Storsj¨o，Martin，高效 
----------------------- Page 1353-----------------------
三角重新排序，用于提高实时渲染中的顶点缓存利用率，硕士论文， 
信息技术系，技术学院，.A博阿卡德米大学，2008年。引用 p。 
701[1709]故事，Jon和 HolgerGruen， “高质量 Direct3D10.0 
和 10.1加速技术”，游戏开发者大会，2009年3月。引用于p。 
249[1710]故事，Jon，“DirectComputeAcceleratedSeparable 
Filtering”，游戏开发者大会，2011年3月。引用于p。54,518[1711] 
故事，乔恩， “现代游戏引擎的高级几何校正阴影”，游戏开发者 
大会，2016年3月。引用于p。224,261,262[1712]故事，乔恩和 
克里斯怀曼， “HFTS：该部门的混合恐怖追踪阴影， “ACM 
SIGGRAPH2016会谈，ACM，文章编号。2016年7月13日。引 
用于p。261 [1713]施特劳斯，保罗S.， “现实的照明计算机动画 
师模型，“IEEE计算机图形和应用，第一卷。10，不。6，pp.56-64， 
1990年 11月。引用于p。324 [1714]Str¨om，Jacob和Tomas 
Akenine-M'oller， “iPACKMAN：用于移动电话的高质量，低复 
杂度纹理压缩”，图形硬件2006，EurographicsAssociation， 
pp.63-70，July 2005年。引用p。194[1715]Str¨om，Jacob和 
MartinPettersson， “ETC2：使用无效组合的纹理压缩”，图形 
硬件2007，EurographicsAssociation，pp.49-54，2007年8月。 
引用于p。194[1716]Str¨om，J.，P。Wennersten，J。Rasmusson， 
J。Hasselgren，J。Munkberg，P。Clarberg和T.Akenine-M？ 
oller， “统一编码器中的浮点缓冲器压缩建筑， “图形硬件2008， 
Eurographics协会，第 75-84 页，2008年 6 月。引用于 p。 
----------------------- Page 1354-----------------------
1009,1018,1038[1717]Stréom，Jacob，并且PerWennersten， 
 “已经压缩纹理的无损压缩” ，在 ACM SIGGRAPH / 
EUROGRAPHICS高性能图形会议论文集，ACM，第 177-182页， 
2011年8月。引用于p。870 [1718]Str¨om，J.，K.Astratrom， 
和T.Akenine-M'oller， “Immersive LinearAlgebra”，http： 
// immersivemath.com，2015。引用于 p。102,1047 [1719] 
Strothotte，Thomas和StefanSchlechtweg，非真实感计算机图 
形学：建模，渲染和动画，MorganKaufmann，2002年。引用于 
p。652,678 [1720]Strugar，F。， “渲染高度图的连续距离依赖 
细节水平”，图形，GPU和游戏工具杂志，第一卷。14，没有。4， 
pp.57-74,2009。引用于p。876,877 [1721]Sugden，B。和M. 
Iwanicki， “MegaMeshes：建模，渲染和照亮由100亿个多边 
形组成的世界， “游戏开发者大会，2011年 3月。引用于 p。 
483,868,870 参 考 书 目 1141 [1722] Sun ， Bo ， Ravi 
Ramamoorthi，Srinivasa Narasimhan和Shree Nayar， “用于 
实时渲染的实用分析单散射模型”，ACM Transactions on 
Graphics （SIGGRAPH 2005 ）， vol 。 24 ，不。 3 ， 
pp.1040-1049,2005。引用于p。604[1723]Sun，Xin，Qiming 
Hou，Zhong Ren，Kun Zhou 和 Baining Guo， “Radiance 
Transfer Biclustering for Real-Time All-Frequency Biscale 
Rendering，”IEEETransactionsonVisualizationandComputer 
Graphics，vol。17，不。1，pp.64-73,2011。引用于p。[1724] 
----------------------- Page 1355-----------------------
Sutherland，IvanE.，RobertF.Sproull和 RobertF.Schumacker， 
 “十种隐藏表面算法的特征”，计算调查，第一卷。6，不。1，pp.1-55， 
1974年3月。引用于p。1048[1725]Sutter，Herb， “免费午 
餐结束”博士 Dobb的日记，第一卷。30，不。3，2005年3月。 
引用于p。806,815[1726]Svarovsky，Jan，“View-Independent 
Progressive Meshing” ，在 Mark DeLoura 编辑， Game 
ProgrammingGems，CharlesRiverMedia，pp.454-464,2000。 
引用于p。707,711 [1727]Swoboda，Matt， “延迟照明和后处 
理在 PLAYSTATION3”，游戏开发者大会，2009年3月。引用于 
p。893 [1728] Swoboda，Matt， “Ambrange Occlusion in 
Frameranger”，直接发布视频博客，2010年 1月15日。引用于 
p。453 [1729]Szeliski，Richard，计算机视觉：算法与应用， 
Springer，2011年。引用于 p。130,200,543,549,587,661,1048 
[1730] Szirmay-Kalos，L'aszl'o，Barnab'as Asz'odi，Istv'an 
Laz'anyi和 M'aty'asPremecz， “近似使用 DistanceImpostors 
在GPU上进行光线跟踪，“计算机图形论坛，第一卷。24，不。3， 
pp.695-704,2005。引用于p。502[1731]Szirmay-Kalos，L'aszl'o 
和Tam'asUmenhoffer，“GPU上的位移映射 - 最先进的技术”， 
计算机图形论坛，第一卷。27，不。6，pp.1567-1592,2008。引 
用于 p。222,933 [1732] Szirmay-Kalos ，L'aszl'o，Tam'as 
Umenhoffer，GustavoPatow，L'aszl'oSz'ecsi和 MateuSbert， 
 “关于GPU的镜面效果：最新技术”，计算机图形学论坛，第一 
----------------------- Page 1356-----------------------
卷 28，不。6，pp.1586-1617,2009。引用于 p。435 [1733] 
Szirmay-Kalos，L'aszl'o，Tam'as Umenhoffer，Bal'azsT'oth， 
L'aszl'oSz'ecsi和 MateuSbert， “用于实时渲染和游戏的体积环 
境遮挡， “IEEE计算机图形和应用，第一卷。30，不。1， 
pp.70-79,2010。引用于p。459 [1734]Tabellion，Eric和Arnauld 
Lamorlette， “用于计算机生成胶片的近似全局照明系统”，ACM 
图形交易 （SIGGRAPH2004），第一卷。23，不。3，pp.469-476， 
2004年8月。引用于 p。26,491 [1735]Tadamura，Katsumi， 
Xueying Qin，GuofangJiao和 EihachiroNakamae， “使用多 
个阳光深度缓冲器渲染最佳太阳阴影”，计算机图形国际 1999，IEEE 
计算机学会，第 166-173页，1999年6月。引用p。242 [1736] 
Takayama，Kenshi，Alec Jacobson，Ladislav Kavan和 Olga 
Sorkine-Hornung， “基于射线投射修正多边形网格中的小面方向 
的简单方法”，计算机图形技术杂志，第一卷。3，不。4， 
pp.53-63,2014。引用于p。693[1737]Takeshige，Masaya，GP“ U 
体素化的基础知识”，NVIDIAGameWorks博客，2015年 3月 
22日。引用于p。582[1738]Tampieri，Filippo，Newell's“ Method 
for the Plane equation of a Polygon，”，David Kirk编辑， 
GraphicsGemsIII，Academic Press，pp.231-232,1992。引用p。 
685 [1739]Tanner，Christopher C.，ChristopherJ. Migdal和 
MichaelT.Jones， “剪贴图：虚拟Mipmap”，SIGGRAPH'98： 
第 25 届计算机图形学与交互技术年会论文集，ACM ， 
----------------------- Page 1357-----------------------
pp.151-158，1998年7月。引用于p。570,867,8721142参考书 
目[1740]Tarini，Marco，KaiHormann，PaoloCignoni和Claudio 
Montani，“PolyCube-Maps”，ACMTransactionsonGraphics 
 （SIGGRAPH2004），vol。23，不。3，pp.853-860，2004年 
8月。引用于p。171[1741]Tatarchuk，Natalya， “城市环境中 
的艺术家可直接实时降雨渲染”，SIGGRAPH高级实时渲染3D图 
形和游戏课程，2006年8月。引用于p。604 [1742]Tatarchuk， 
Natalya， “具有近似软阴影的动态视差遮挡映射， “SIGGRAPH 
高级实时渲染 3D图形和游戏课程，2006年 8月。引用于 p。 
217,218,222[1743]Tatarchuk，Natalya， “实用视差遮挡映射与 
近似软阴影的详细表面渲染”，SIGGRAPH高级实时渲染3D图形 
和游戏课程，2006 年 8 月。引用于 p。217,218,222 [1744] 
Tatarchuk，Natalya和JeremyShopf， “FireGL的实时医学可视 
化”，SIGGRAPHAMD技术讲座，2007年8月。引用于p。607,753 
[1745]Tatarchuk，Natalya， “GPU上的实时细分”，SIGGRAPH 
高级实时渲染3D图形和游戏课程，2007年8月。引用于p。770 
[1746]Tatarchuk，Natalya，ChristopherOat，Jason L.Mitchell， 
Chris Green，Johan Andersson，Martin Mittring，Shanon 
Drone和 NicoGaloppo，SIGGRAPH高级实时渲染3D图形和游 
戏课程，2007年8月。引用于p。1115[1747]Tatarchuk，Natalya， 
ChrisTchou和JoeVenzon，命运“ ：从神话科幻小说到实时渲染”， 
SIGGRAPH 在 2013 年 7 月的游戏实时渲染方面取得进展。 
----------------------- Page 1358-----------------------
568,569,892[1748]Tatarchuk，Natalya和ShiKaiWang， “创 
造内容以推动命运的投资游戏：统一所有的一个解决方案”， 
SIGGRAPH 制作会议，2014 年 8 月。引用于 p。366 [1749] 
Tatarchuk，Natalya， “Destiny的多线程渲染架构”，游戏开发 
者大会，2015年3月。引用于p。815[1750]Tatarchuk，Natalya 
和ChrisTchou， “DestinyShaderPipeline”，游戏开发者大会， 
2月 -3月。2017年。引用p。128,129,815[1751]Taubin，Gabriel， 
Andr'e Gu'eziec，William Horn，和弗朗西斯拉撒路， “渐进式 
森林分裂压缩”，SIGGRAPH'98：第25届计算机图形和互动技术 
年会论文集，ACM，第 123-132页，1998年7月。引用于p。[1752] 
泰勒，菲利普， “Per-PixelLighting”，驾驶DirectX网站专栏， 
2001年 11月 13日。引用于p。432 [1753]Tector，C。， “从 
零到200MPH的流媒体大规模环境”，游戏开发者大会，2010年 
3月。引用于p。871 [1754]Teixeira，Diogo， “在GPU上烘焙 
法线图 ” ，在 Hubert Nguyen 编辑， GPU Gems 3 ， 
Addison-Wesley，pp.491-512,2007。引用于 p。853 [1755] 
Teller，SethJ.和CarloH.S'equin，“交互式演练的可见性预处理”， 
计算机图形学 （SIGGRAPH'91Proceedings），第一卷。25，不。 
4，pp.61-69，1991年7月。引用于p。837[1756]Teller，Seth 
J.，密集遮蔽多面体环境中的可见性计算，博士论文，伯克利大学计 
算机科学系，1992年。引用于p。837[1757]Teller，Seth和 Pat 
Hanrahan，“用于照明计算的全局可见性算法”，SIGGRAPH'94： 
----------------------- Page 1359-----------------------
第21届计算机图形学和交互技术年会论文集，ACM，第443-450 
页，1994年7月。引用p。837参考书目 1143[1758]Teschner， 
Matthias， “高级计算机图形学：采样”，课程笔记，计算机科学 
系，弗莱堡大学，2016年。引用于p。144,165[1759]Tessman， 
Thant，“在平面上投射阴影”，IrisUniverse，第 16-19页，1989 
年冬季。引用于p。225[1760]Tevs，A.，I。Ihrke和 H.-P.Seidel， 
 “用于快速，准确和可扩展的动态高度场渲染的最大 Mipmap，“参 
见2008年交互式3D图形与游戏研讨会论文集，ACM，第 183-190 
页，2008年。引用于第4页。220 [1761]Thibault，Aaron P.和 
Sean “Zoner”Cavanaugh， “为边疆创造真实的概念艺术”， 
SIGGRAPH 2010 年 7 月游戏课程中的程式化渲染。 
652,661,662,664,678 [1762] Thibieroz，Nicolas， “Deferred 
Shadingwith Multiple RenderTargets”，Wolfgang Engel编 
辑，ShaderX2 ：Introductions＆Tutorials with DirectX 9， 
Wordware ，pp.251-269,2004 。引用 p。882,884 [1763] 
Thibieroz，Nicolas， “通过反向深度剥离在 DirectX10中的稳健 
顺序独立透明度”，在Wolfgang Engel编辑，ShaderX6，Charles 
RiverMedia，第211-226页，2008年。引用于 p。154 [1764] 
Thibieroz，Nicolas， “在 DirectX10中使用多重采样抗锯齿的延 
迟着色”，Wolfgang Engel编辑，ShaderX7，CharlesRiverMedia， 
pp.225-242,2009。引用于p。888 [1765]Thibieroz，Nicolas， 
 “使用每像素链接列表的顺序无关透明度”，Wolfgang Engel编 
----------------------- Page 1360-----------------------
辑，GPU Pro2，AK Peters/ CRC Press，pp.409-431,2011。引 
用于 p。155 [1766]Thibieroz，Nicolas， “DeferredShading 
Optimizations”，游戏开发者大会，2011年 3月。引用于 p。 
886,887,892,900 [1767]Thomas，Gareth， “基于计算的 GPU 
粒子系统”，游戏开发者大会，2014年3月。引用于p。572[1768] 
Thomas，Gareth， “基于平铺的计算机渲染的进步”，游戏开发 
者大会，2015年 3月。引用于 p。803,894,896,900,901 [1769] 
Thomas，SpencerW.，“将一个矩阵分解成简单的变换”，James 
Arvo 编 辑 ， Graphics Gems II ， Academic Press ， 
pp.320-323,1991。在第 72,74[1770]Thurmer，Grit和Charles 
A.W¨uthrich，“计算多边形小平面的顶点法线”，图形工具杂志， 
第一卷。3，不。1，pp.43-46,1998。也在[112]中收集。引用p。 
695 [1771] Timonen ， Ville ， “Line-Sweep Ambient 
Obscurance”，EurographicsSymposiumonRendering，2013 
年 6月。引用于 p。461 [1772]Toisoul，Antoine 和 Abhijeet 
Ghosh， “实际获取和渲染表面反射中的衍射效应”，ACM 
Transactions onGraphics，vol。36，不。5，pp.166：1-166： 
16，2017年 10月。引用于p。361 [1773]Toisoul，Antoine和 
AbhijeetGhosh， “实时表面衍射与低秩分解的实时渲染”，欧洲 
视觉媒体制作会议 （CVMP），2017年 12月。引用于p。361[1774] 
Toksvig，Michael， “MipmappingNormalMaps”，图形工具 
杂志，第一卷。10，不。3，pp.65-71,2005。引用于p。369[1775] 
----------------------- Page 1361-----------------------
Tokuyoshi，Yusuke，“减少和简化阴影抗锯齿”，技术报告，Square 
Enix，2017年4月。引用于p。371[1776]Torborg，J。和JT Kajiya， 
 “护身符：PC的商品实时3D图形”，SIGGRAPH '96：第23届 
计算机图形和交互技术年会论文集，ACM，第353-363页，1996 
年8月。引用于p。5511144参考书目[1777]Torchelsen，Rafael 
P.，Jo.ao LDComba和 RuiBastos， “实用几何计算机游戏中渲 
染地形的剪贴画”，载于Wolfgang Engel，编辑，ShaderX6， 
CharlesRiverMedia，第 103页-114,2008。引用于p。612，873 
[1778]T¨orok，Bal'azs和TimGreen， “巫师3：狂野狩猎的渲染 
特征”，ACMSIGGRAPH2015会谈，ACM，文章编号。2015年 
8月 7 日。引用于p。366,420,889 [1779]Torrance，K。和 E. 
Sparrow， “粗糙表面的非镜面反射理论”，美国光学学会杂志， 
第一卷。57，不。967，pp.1105-1114，1967年9月。引用于p。 
314,334[1780]Toth，Robert， “通过丢弃过滤器龙头来避免纹理 
接缝”，计算机图形技术杂志，第一卷。2，没有。2，pp.91-104,2013。 
引用于p。191[1781]Toth，Robert，Jon Hasselgren和Tomas 
Akenine-M'oller，“消费者头戴式显示器远距离视线差异的感知”， 
第7届高性能图形会议论文集，ACM，pp.61-66，2015年8月。 
引用于 p。934 [1782] Toth，Robert，Jim Nilsson和 Tomas 
Akenine-M'oller， “渲染虚拟现实的投影方法的比较”，2016年 
高性能图形，EurographicsAssociation，pp.163-171，2016年 
6月。在第 930[1783]Tran，Ray，“FacettedShadowMapping 
----------------------- Page 1362-----------------------
for Large Dynamic Game Environments”，Wolfgang Engel 
编辑，ShaderX7，Charles RiverMedia，第363-371页，2009 
年。[1784]Trapp，Matthias和J¨urgenD'ollner， “实时着色器 
程序的自动组合”，在 Eurographics 2007-Short Papers， 
EurographicsAssociation，pp.53-56，2007年9月。引用于p 。 
128 [1785] Trebilco ，Damian ， “Light-Indexed Deferred 
Rendering”，Wolfgang Engel编辑，ShaderX7，CharlesRiver 
Media，第243-258页，2009年。893 [1786]Treglia，Dante， 
ed。，GameProgrammingGems3，CharlesRiverMedia，2002。 
Cited on p。1089 [1787] Trop ，Oren，Ayellet Tal 和 Ilan 
Shimshoni， “快速三角形到三角交叉口碰撞检测测试”，计算机 
动画和虚拟世界，第一卷。17，不。5，pp.527-535,2006。引用 
于p。974 [1788]特罗布里奇，TS，和KPReitz， “用于射线反射 
的粗糙表面的平均不规则性表示”，美国光学学会期刊，第一卷。 
65，不。5，pp.531-536，1975年5月。引用于p。340[1789]Trudel， 
N。， “为DeusEx改善几何剔除：人类划分”，游戏开发者大会， 
2016年3月。引用于p。850[1790]Tuft，David， “基于平面的 
深度偏差百分比更近的过滤”，游戏开发者，第一卷。17，不。5， 
pp.35-38，2010年5月。引用于p。249,250[1791]Tuft，David， 
 “级联阴影地图”，Windows开发中心：DirectX图形和游戏技术 
文章，2011年。引用于p。244,245,247,265[1792]Tuft，David， 
 “改进阴影深度图的常用技术”，Windows开发中心：DirectX图 
----------------------- Page 1363-----------------------
形和游戏技术文章，2011年。236,239,240,265[1793]Turkowski， 
Ken，用于常见重新采样任务的过滤器“            ”，载于AndrewS.Glassner 
编辑，GraphicsGems，Academic Press，pp.147-165,1990。引 
用于 p。136 [1794] Turkowski ，Ken， “Surface-Normal 
Transformations的属性”，AndrewS.Glassner编辑，Graphics 
Gems ，Academic Press ， pp.539-547,1990 。 68 [1795] 
Turkowski，Ken， “Gaussian的增量计算”，在 HubertNguyen 
编辑，GPU Gems 3，Addison-Wesley，pp.877-890,2007。引 
用于p。515[1796]Ulrich，Thatcher，“LooseOctrees”，Mark 
DeLoura 编辑，Game Programming Gems ，Charles River 
Media，pp.444-453,2000。826参考书目 1145[1797]乌尔里希， 
撒切尔，“渲染大规模地形使用分块水平的细节控制，”SIGGRAPH 
超大尺寸它！2002年7月，扩展到大规模虚拟世界课程。引用第2 
页。874,875 [1798] Uludag，Yasin ， “Hi-Z Screen-Space 
Tracing”，载于Wolfgang Engel，编辑，GPU Pro5，CRC出版 
社，第 149-192页，2014年。507[1799]Umenhoffer，Tam'as， 
L'azl'oSzirmay-Kalos和G'aborSzij'art'o， “球形广告牌及其在 
渲染爆炸中的应用”，图形界面2006，加拿大人机通信Society， 
pp.57-63,2006。引用于p。559 [1800]Umenhoffer，Tam'as， 
L'aszl'oSzirmay-Kalos和G'abor Sz'.j'art'o， “渲染体积数据的 
球形广告牌”，Wolfgang Engel编辑，ShaderX5，CharlesRiver 
Media，第275-285页，2006年。引用第2页。559[1801]Unity 
----------------------- Page 1364-----------------------
用户手册，UnityTechnologies，2017年。引用于p。287[1802] 
虚幻引擎 4 文档， Epic Games ，2017 年。引用于 p。 
114,126,128,129,262,287,364,611,644,920,923,932,934,939 
[1803]Upchurch，Paul和 Mathieu Desbrun， “提高透视渲染 
的精度”，图形工具杂志，第一卷。16，不。1，pp.40-56,2012。 
引用于p。101[1804]Upstill，S。，RenderManCompanion： 
程序员现实计算机图形学指南，Addison-Wesley，1990年。引用 
于p。[1805]Vaidyanathan，K.，M。Salvi，R。Toth，T。Foley， 
T。Akenine-M¨oller，J。Nilsson，J。Munkberg，J。Hasselgren， 
M。Sugihara，P。Clarberg，TJanczak和A. Lefohn， “Coarse 
PixelShading”，2014年高性能图形，EurographicsAssociation， 
第 9-18 页， 2014 年 6 月。引用于 p。924,1013 [1806] 
Vaidyanathan，Karthik，Jacob Munkberg，PetrikClarberg和 
MarcoSalvi，“LayeredLightFieldReconstructionfor Defocus 
Blur”，ACMTransactionsonGraphics，vol。34，不。2，pp.23： 
1-23：12，2015年2月。引用于p。536[1807]Vaidyanathan， 
KTAkenine-M'oller和 M.Salvi，“水密光线穿越精度降低”，2016 
年高性能图形，EurographicsAssociation，第33-40页，2016 
年6月。引用于p。1039[1808]Vainio，Matt， “inFAMOUS的 
视觉效果：第二个儿子”，游戏开发者大会，2014年3月。引用于 
p。572[1809]Valient，Michal， “延迟渲染杀戮地带2”，发展 
会议，2007年7月。引用于p。882,885,886,887[1810]Valient， 
----------------------- Page 1365-----------------------
Michal，Cascaded“ ShadowMaps的稳定渲染”，载于Wolfgang 
Engel，编辑，ShaderX6，CharlesRiverMedia，第231-238页， 
2008年。239,245,247 [1811]Valient，Michal， “Shadows + 
Games ：Practical Considerations ” ，SIGGRAPH Efficient 
Real-TimeShadows课程，2012年8月。引用于p。245,246,252 
[1812]Valient，Michal， “采取杀戮地带：影子下降图像质量进 
入下一代” ，游戏开发者大会，3 月 2014.引用于 p。 
148,235,245,490,506,507,509,523,608,609 [1813]Van Verth， 
Jim， “用 RGB做数学（和A），”游戏开发者大会，2015年3 
月。引用p。151,208[1814]Vaxman，Amir，MarcelCampen， 
Olga Diamanti，Daniele Panozzo，David Bommes，Klaus 
Hildebrandt和 MirelaBen-Chen， “定向场合成，设计和处理”， 
计算机图形学论坛，第一卷。35，不。2，pp.545-572,2016。引 
用于p。672 [1815]Veach，Eric， “用于光传输模拟的鲁棒蒙特 
卡罗方法”，博士论文，斯坦福大学，1997年 12月。引用于p。 
445 1146 参考书目 [1816] Venkataraman ，S。， “Fermi 
AsynchronousTextureTransfers，”，PatrickCozzi和Christophe 
Riccio，eds。，OpenGLInsights，CRCPress，pp.415-430,2012。 
引用于p。1034[1817]Villanueva，AlbertoJaspe，FabioMarton 
和 EnricoGobbetti，SSVDAGs“ ：Symmetry-AwareSparseVoxel 
DAGs”，摘自第20届ACMSIGGRAPH交互式3D图形和游戏研 
讨会，ACM，第7-14页，2016年。引用于第4页。586 [1818] 
----------------------- Page 1366-----------------------
虚拟地形项目，http：//www.vterrain.org。引用p。877 [1819] 
Vlachos，Alex，J¨orgPeters，Chas Boyd和Jason L.Mitchell， 
 “曲线 PN三角形”，2001年 Symposings on Interactive 3D 
Graphics，ACM，pp.159-166,2001。引用在第744,745,746[1820] 
Vlachos，Alex和John Isidoro，“SmoothC2Quaternion-Based 
FlythroughPaths”，MarkDeLoura编辑，GameProgramming 
Gems2，CharlesRiverMedia，pp.220-227,2001。引用p。102 
[1821]Vlachos，Alex， “Orange Box中的后期处理”，游戏开 
发者大会，2008年2月。引用于 p。288,538 [1822]Vlachos， 
Alex， “在左4死2中渲染创伤”游戏开发者大会，2010年3月。 
引用于p。366 [1823]Vlachos，Alex， “高级VR渲染”，游戏 
开 发 者 大 会 ， 2015 年 3 月 。 引 用 于 p 。 
371,628,922,925,926,927,933,934,939,940,1010     [1824] 
Vlachos，Alex， “高级VR渲染性能”，游戏开发者大会，2016 
年3月。引用于p。784,805,928,930,931,936,937,938,940[1825] 
Voorhies，Douglas， “Space-FillingCurvesandaMeasureof 
Coherence”，JamesArvo编辑，GraphicsGemsII，Academic 
Press， pp.26-30,1991。引用于p。1018[1826]Vulkan概述， 
Khronos集团，2016年2月。引用于p。806[1827]Walbourn， 
Chuck，ed。，SIGGRAPHDirect3D10课程入门，2007年8月。 
引用于p。798[1828]Wald，Ingo，William R.Mark，JohannesG¨ 
unther，Solomon Boulos，Thiago Ize，Warren Hunt，Steven 
----------------------- Page 1367-----------------------
G. Parker和 PeterShirley， “光线跟踪动画场景的最新进展，” 
计算机图形学论坛，第一卷。28，不。6，pp.1691-1722,2009。 
引用于p。953[1829]Wald，Ingo，SvenWoop，CarstenBenthin， 
Gregory S.Johnsson和 Manfred Ernst， “Embree：高效CPU 
光线跟踪的内核框架”，ACMTransactions onGraphics，vol。 
33，不。4，pp.143：1-143：8,2014。引用于p。452,821 [1830] 
Walker，R。和J. Snoeyink， “使用多边形的CSG表示进行实际 
的多边形测试”，在ACM SIGGRAPH '97Visual Proceedings， 
ACM，p。1992年8月152日。引用于p。967[1831]Wallace， 
Evan，“在WebGL中渲染实时焦散”，中型博客，2016年 1月7 
日。引用于p。631[1832]Walter，Bruce，SebastianFernandez， 
Adam Arbree，Kavita Bala，Michael Donikian和 Donald P. 
Greenberg， “Lightcuts：一种可扩展的照明方法， “ACM 
TransactionsonGraphics，vol。24，不。3，pp.1098-1107,2005。 
引用于 p。431,901 [1833] Walter ，Bruce ，Stephen R. 
Marschner，HongsongLi和 KennethE.Torrance， “通过粗糙 
表面折射的 Microfacet模型”，RenderingTechniques 2007， 
EurographicsAssociation，pp.195-206，2007年6月。引用p。 
334,337,339,340,369,419[1834]Walton，Patrick，“Pathfinder， 
Rust中基于GPU的快速字体光栅化器”，pcwalton博客，2017 
年2月 14日。引用于p。676[1835]Wan，Liang，Tien-TsinWong 
和 Chi-Sing Leung， “Isocube：利用Cubemap硬件”，IEEE 
----------------------- Page 1368-----------------------
可视化和计算机图形学，第一卷。13，不。4，pp.720-731，2007 
年 7月。引用于 p。412参考书目 1147 [1836]Wan，Liang， 
Tien-TsinWong，Chi-SingLeung和Chi-WingFu， “Isocube： 
具有均匀分布和同等重要特征的立方体图， “在Wolfgang Engel 
编辑，ShaderX6，CharlesRiverMedia，第83-92页，2008年。 
引用于第4页。412 [1837]Wang，Beibei和 HuwBowles， “一 
个强大而灵活的实时闪光效应”，在 “Eurographics研讨会论文集： 
实验性思想与实现”，EurographicsAssociation，pp.49-54,2016。 
在第 372 [1838]Wang，Jiaping，PeiranRen，MinminGong， 
JohnSnyder和 BainingGuo，“动态，空间变化反射的全频渲染”， 
ACMTransactionsonGraphics，vol。28，不。5，pp.133：1-133： 
10,2009。引用于p。397,398,466,472 [1839]Wang，Niniane， 
 “现实和快速的云渲染”，图形工具杂志，第一卷。9，不。3， 
pp.21-40,2004。引用于p。556[1840]Wang，Niniane， “让那 
里有云！”游戏开发者，第一卷。11，不。1，pp.34-39，2004 
年 1月。引用于p。556 [1841]Wang，Rui，RenNg，DavidP. 
Luebke和GregHumphreys， “环境地图渲染的高效小波旋转”， 
第 17届 Eurographics协会研讨会，EurographicsAssociation， 
第 173-182页，2006年。引用次数页。[1842]Wang，R.，X。Yang， 
Y。Yuan，Yazhen，W。Chen，K。Bala和 H.Bao， “Automatic 
ShaderSimplification UsingSurfaceSignalApproximation，” 
ACMTransactionsonGraphics，vol。33，不。6，pp.226：1-226： 
----------------------- Page 1369-----------------------
11,2014。引用于p。853[1843]Wang，R.，B。Yu，K。Marco， 
T。Hu，D。Gutierrez和 H.Bao， “Real-TimeRenderingona 
Power Budget”，ACM Transactions on Graphics，vol。335 
没有。4，pp.111：1-111：11,2016。引用于p。866[1844]Wang， 
X.，X。Tong，S。Lin，S。Hu，B。Guo和 H.-Y.Shum， “广义 
位移图，“在第 15届 Eurographics协会研讨会上，Eurographics 
Association，pp.227-233，2004年6月。引用于p。219[1845] 
Wang，Yulan和Steven Molnar， “第二深度阴影映射”，技术 
报告TR94-019，北卡罗来纳大学教堂山分校计算机科学系，1994 
年。238 [1846]Wanger，Leonard， “影子质量对计算机生成图 
像中空间关系感知的影响”，载于 1992年交互式3D图形研讨会论 
文集，ACM，第39-42页，1992年。引用于p 。225,611[1847] 
Warren，Joe和 HenrikWeimer，几何设计的细分方法：构造方 
法 ， Morgan Kaufmann ， 2001 年 。 引 用 于 p 。 
718,754,756,760,761,781 [1848]Wasson，Ben， “Maxwell的 
动态超分辨率探索”，技术报告网站，2014年9月30 日。引用于 
p。139[1849]Watson，Benjamin和 DavidLuebke， “终极展 
示：所有像素将来自哪里？”计算机，第一卷。38，不。8，pp.54-61， 
2005年8月。引用于p。1，808,817[1850]Watt，Alan和 Fabio 
Policarpo，可编程图形硬件的高级游戏开发，AK Peters，Ltd.， 
2005。引用于 p.1998。220,222 [1851]van Waveren，JMP， 
 “Real-TimeTextureStreaming＆Decompression，”Technical 
----------------------- Page 1370-----------------------
Report，Id Software，2006年 11月。引用于 p。870 [1852] 
vanWaveren，JMP和IgnacioCasta.no，Real-Time“ YCoCg-DXT 
Decompression”，Technical Report，IdSoftware，2007年9 
月。引用于 p。198 [1853] van Waveren ，JMP 和 Ignacio 
Casta.no，“实时法线贴图 DXT压缩”，技术报告，Id软件，2008 
年2月。引用于p。198[1854]vanWaveren，JMP， “idTech5 
Challenges， “SIGGRAPH Beyond ProgrammableShading课 
程，2009年8月。引用于p。812,869 1148参考书目[1855]van 
Waveren，JMP和 E.Hart， “使用虚拟纹理处理大量纹理数据”， 
GPU技术大会 （GTC），2010年9月。引用于p。868,870[1856] 
vanWaveren，JMP，“软件虚拟纹理”，技术报告，Id软件，2012 
年2月。引用于p。868[1857]vanWaveren，JMP， “消费者硬 
件虚拟现实的异步时间扭曲”，第22届ACM虚拟现实软件与技术 
会议论文集，ACM，第37-46页，2016年 11月。引用次数页。 
936,937[1858]Webb，Matthew，EmilPraun，Adam Finkelstein 
和 HuguesHoppe， “硬件孵化中的精细音调控制”，第二届非真 
实动画和渲染国际研讨会论文集，ACM，第53页 -58，2002年 
6月。引用于p。671 [1859]Weber，Marco和 PeterQuayle， 
 “后处理对移动设备的影响”，载于Wolfgang Engel，编辑，GPU 
Pro2，AK Peters/CRC出版社，第291-305页，2011年。527[1860] 
Wei，Li-Yi， “Tile-BasedTextureMapping”，MattPharr编辑， 
GPUGems2，Addison-Wesley，pp.189-199,2005。引用于p。 
----------------------- Page 1371-----------------------
175[1861]Wei，Li-Yi，SylvainLefebvre，Vivek Kwatra和Greg 
Turk， “基于实例的纹理合成的最先进技术”，在2009年的 
Eurographics上 - 最先进的报告，EurographicsAssociation， 
pp.93- 117,2009。引用于p。200 [1862]Weidlich，Andrea和 
AlexanderWilkie，“Arbitrarily LayeredMicro-FacetSurfaces”， 
在GRAPHITE 2007，ACM，pp.171-178,2007。引用于p。364 
[1863]Weidlich，Andrea和AlexanderWilkie，SIGGRAPHAsia 
Thinking inLayers：Modelingwith LayeredMaterialscourse， 
2011年8月。引用p。364[1864]Weier，M.，M。Stengel，T。 
Roth，P。Didyk，E。Eisemann，M。Eisemann，S。Grogorick， 
A。Hinkenjann，E。Kruijff，M。Magnor，K。Myszkowski，and 
P.Slusallek， “Perception-DrivenAccelerated Rendering”， 
计算机图形论坛，第一卷。36，不。2，pp.611-643,2017。引用 
于p。587,940[1865]Weiskopf，D。和T. Ertl， “基于双深度层 
的阴影映射”，Eurographics2003简短介绍，2003年9月。引 
用于p。238 [1866]威尔士，特里， “具有偏移限制的视差映射： 
不均匀表面的每像素近似”，技术报告，Infiscape公司，2004年 
1月 18日。也收集在[429]中。引用p。215,216 [1867]Welzl， 
Emo， “最小封闭盘 （球和椭圆体）”，在 H.Maurer编辑，新结 
果和计算机科学新趋势，LNCS555，Springer，pp.359-370,1991 。 
引用p。950 [1868]Wennersten，Per和JacobStr¨om， “基于 
表格的Alpha压缩”，计算机图形学论坛，第一卷。28，不。2， 
----------------------- Page 1372-----------------------
pp.687-695,2009。引用于p。[1869]Wenzel，Carsten， “孤岛 
惊魂与DirectX”，游戏开发者大会，2005年3月。引用于p。528,799 
[1870]Wenzel，Carsten，“游戏中的实时大气效应”，SIGGRAPH 
高级实时渲染3D图形和游戏课程，2006年8月。引用于p。559 
[1871]Wenzel，Carsten， “重新审视游戏中的实时大气效应”， 
游戏开发者大会，2007年3月。引用于p。551,556,601,602,614 
[1872]Weronko，S。和S.Andreason， “1886年实时转型”， 
ACM SIGGRAPH 2015会谈，ACM，文章编号。2015年8月8 
日。引用于p。91 [1873]威斯汀，Stephen H.，HongsongLi和 
Kenneth E. Torrance， “BRDF模型的实地指南， “研究报告 
PCG-04-01，康奈尔大学计算机图形学程序，2004年 1月。引用 
于p。329参考书目 1149[1874]威斯汀，StephenH.，Hongsong 
Li和 KennethE.Torrance， “四种BRDF模型的比较”，研究报 
告PCG-04-02，康奈尔大学计算机图形学程序，2004年4月。被 
引在第 329 [1875] Wetzstein，Gordon， “Focus Cues and 
Computational Near-Eye Displays with Focus Cues ， ” 
SIGGRAPH视觉感知应用于虚拟现实课程，2017年8月。引用于 
p。549,923[1876]Whatley，David， “走向虚拟植物学中的照片 
写实”，载于 MattPharr，编辑，GPUGems2，Addison-Wesley， 
pp.7-45,2005。引用于p。207,858[1877]White，John和Colin 
Barr'e-Brisebois， “更多表演！ “战地3”中的五个渲染理念和极 
品飞车：奔跑，“SIGGRAPH在游戏中实时渲染的进展，2011年8 
----------------------- Page 1373-----------------------
月。引用于第4页。527,804,896,898,904[1878]Whiting，Nick， 
 “整合OculusRift进入虚幻引擎4”，Gamasutra，2013年6月 
11日。引用于p。934[1879]惠特利，布兰登， “命运粒子架构”， 
SIGGRAPH在游戏中实时渲染的进展，2017年8月。引用于p。 
571[1880]Whittinghill，David， “NasumVirtualis：减少头部 
VR模拟器疾病的简单技术”，游戏开发者大会，2015年3月。引 
用于p。920 [1881]Widmark，M。， “战地3中的地形：现代， 
完整和可扩展的系统”，游戏开发者大会，2012年3月。引用于p。 
869,878 [1882]Wiesendanger，Tobias， “Stingray Renderer 
Walkthrough”，Autodesk Stingray博客，2017年2月 1日。 
引用于p。549,803,814 [1883]Wihlidal，Graham， “通过计算 
优化图形管道”，游戏开发者大会，2016年 3月。引用于 p。 
54,798,834,83​ ​ 7,840,848,849,851,908,986 [1884]Wihlidal， 
Graham， “用计算优化图形管道”，Wolfgang Engel编辑，GPU 
Zen，BlackCat Publishing，pp 。引用次数为277-320,2017。 
54,702,784,798,812,834,83 ​  ​  7,840,848,850,851,908,986 
[1885]Wihlidal，Graham， “战地1中的4K棋盘和Andromeda 
质量效应”，游戏开发者大会，2月-mar。2017年。引用 p。 
143,805,906,1042 [1886] Wiley ， Abe 和 Thorsten 
Scheuermann， “Whiteout的艺术与技术”，SIGGRAPHAMD 
技术讲座，2007年8月。引用于p。427 [1887]Williams，Amy， 
Steve Barrus，R。KeithMorley和 PeterShirley， “一种高效且 
----------------------- Page 1374-----------------------
稳健的 Ray-Box交叉算法”，图形工具杂志，第一卷。10，不。1， 
pp。49-54,2005。引用于p。961[1888]Williams，Lance， “在 
曲面上投射弯曲的阴影”，计算机图形学（SIGGRAPH '78 
Proceedings），第一卷。12，不。3，pp.270-274，1978年8 
月。引用于 p。234 [1889] Williams，Lance， “Pyramidal 
Parametrics，”ComputerGraphics，vol。7，不。3，pp.1-11， 
1983年7月。引用于p。183,185,408[1890]Willmott，Andrew， 
 “快速简化多属性网格”，参见ACMSIGGRAPH高性能图形研讨 
会论文集，ACM，第 151-158页，2011年8月。引用于p 。710 
[1891]Wilson，Timothy， “VR的高性能立体渲染”，圣地亚哥 
虚拟现实聚会，2015年1月20日。引用于p。927[1892]Wimmer， 
Michael，Peter Wonka 和 Francois Sillion， “Point-Based 
Impostors for Real-Time Visualization ” ， Rendering 
Techniques2001，Springer，pp.163-176，June2001.引用于p。 
5611150参考书目[1893]Wimmer，Michael，DanielScherzer 
和 Werner Purgathofer， “光空间透视阴影地图”，第15届 
Eurographics协会会议论文集，EurographicsAssociation，第 
143-151页，2004年6月。引用次数页。241 [1894]Wimmer， 
Michael和Jir'。Bittner，“硬件遮挡查询变得有用”，在 MattPharr 
编辑，GPUGems2，Addison-Wesley，pp.91-108,2005。引用 
于p。844 [1895]Wimmer，Michael和 DanielScherzer， “使 
用光空间透视阴影图进行稳健阴影映射”，载于Wolfgang Engel， 
----------------------- Page 1375-----------------------
编辑，ShaderX4，Charles RiverMedia，第313-330页，2005 
年。241 [1896]Winnem¨oller，Holger， “XDoG：高级图像样 
式与高斯差异的高斯，”在ACMSIGGRAPH/ Eurographics非真 
实感动画和渲染研讨会上，ACM，pp。147-156，2011年8月。 
引用于p。665[1897]Wloka，Matthias， “批处理，批处理，批 
处理：它真正意味着什么？”游戏开发者大会，2003年3月。引用 
于p。796[1898]Wolff，LawrenceB.， “光学介电表面的漫反射 
模型”，美国光学学会杂志，第一卷。11，不。11，pp.2956-2968， 
1994年 11月。引用于p。353[1899]Wolff，LawrenceB.，Shree 
K.Nayar和 MichaelOren， “改进的计算机视觉漫反射模型”， 
国际计算机视觉杂志，第一卷。30，不。1，pp.55-71,1998。引用 
于 p。354 [1900]Woo，Andrew， “影子深度图重访”，载于 
DavidKirk，编辑，图形宝石III，学术出版社，第338-342页，1992 
年。238 [1901] Woo ，Andrew ，Andrew Pearce 和 Marc 
Ouellette， “这真的不是渲染错误，你看......” “IEEE计算机图形 
和应用，第一卷。16，不。5，pp.21-25，1996年9月。引用于p。 
688[1902]Woo，Andrew和 PierrePoulin，ShadowAlgorithms 
DataMiner，AK Peters/CRCPress，2011。引用于p。223,265 
[1903]Woodland，Ryan， “填补空白 - 使用拼接和剥皮的高级 
动画”，MarkDeLoura编辑，GameProgrammingGems，Charles 
RiverMedia，第476-483页，2000年。84,85[1904]Woodland， 
Ryan， “使用纹理坐标生成的高级纹理”，MarkDe-Loura编辑， 
----------------------- Page 1376-----------------------
Game Programming Gems ， Charles River Media ， 
pp.549-554,2000 。 200,221 [1905] Woop ， Sven ， J ¨ 
orgSchmittler和 PhilippSlusallek， “RPU：用于实时光线跟踪 
的可编程光线处理单元”，ACMTransactionsonGraphics，vol。 
24，不。3，pp.434-444，2005年8月。引用于p。1039[1906] 
Woop，Sven，CarstenBenthin和 IngoWald， “水密雷/三角交 
叉口”，计算机图形技术杂志，第一卷。2，没有。1，pp.65-82， 
2013年6月。引用于p。962[1907]Worley，Steven， “细胞纹 
理基础功能”，SIGGRAPH'96：第23届计算机图形学和交互技术 
年会论文集，ACM，第291-294页，1996年。引用于第9页。620 
[1908]Wrenninge，Magnus，ProductionVolume Rendering： 
Designand Implementation，AK Peters/ CRC Press，2012年 
9月。引用于p。582,594,610[1909]Wrenninge，Magnus，Chris 
Kulla和Viktor Lundqvist， “Oz：TheGreatandvolumetric”， 
参见ACM SIGGRAPH 2013会谈，ACM，文章编号。2013年7 
月46 日。引用于p。621[1910]Wright，Daniel， “带有签名距 
离场的动态遮挡”，SIGGRAPH在2015年8月的游戏课程中实时 
渲染方面取得了进展。454，467 [1911]Wronski，Bartlomiej， 
 “刺客信条：黑旗 - 下一代图形之路”，游戏开发者大会，2014 
年3月。引用于p。32,218,478,571,572,801参考书目1151[1912] 
Wronski ， Bartlomiej ， “Temporal Supersampling and 
Antialiasing”，BartWronski博客，2014年3月15日。引用于 
----------------------- Page 1377-----------------------
p。143,540[1913]Wronski，Bartlomiej， “GDC跟进：屏幕空 
间反思过滤和向上采样”，BartWronski博客，2014年 3月23 
日。引用于p。509 [1914]Wronski，Bartlomiej， “GCN-延迟 
隐藏和波浪占用的两种方式”，BartWronski博客，2014年3月 
27 日。引用于p。32,801,1005 [1915]Wronski，Bartlomiej， 
 “BokehDepthofField-GoingInsane！第1部分，Bart“ Wronski 
博客，2014 年 4 月 7 日。引用于p。531 [1916] Wronski， 
Bartlomiej，“TemporalSupersamplingpt。2-SSAO示范， “Bart 
Wronski博客，2014年4月27 日。引用p。462 [1917]Wronski， 
Bartlomiej，“体积雾：基于统一计算着色器的大气散射解决方案”， 
SIGGRAPH在游戏中实时渲染的进展，2014年8月。引用于p。 
610,611[1918]Wronski，Bartlomiej，“设计下一代后效应管道”， 
BartWronski博客，2014年12月9日。引用于p。514,520,527,543 
[1919]Wronski，Bartlomiej， “Anamorphic Lens Flaresand 
Visual Effects”，BartWronski博客，2015年3月9 日。引用于 
p。526 [1920]Wronski，Bartlomiej， “Fixing Screen-Space 
DeferredDecals”，BartWronski博客，2015年3月12日。引 
用于 p。889,890 [1921] Wronski，Bartlomiej， “本地化的 
Tonemapping - 全球曝光和全球音频运营商足够用于视频游戏 
吗？”BartWronski博客，2016年8月29日。引用于p。286[1922] 
Wronski，Bartlomiej， “剔除那个锥体！针对平铺和集群照明的 
改进的锥/聚光灯可见性测试， “BartWronski博客，2017年4月 
----------------------- Page 1378-----------------------
13日。引用于p。901[1923]Wronski，Bartlomiej， “可分离的 
磁盘般的景深”，BartWronski博客，2017年8月6 日。引用于 
p。518[1924]Wu，Kui和CemYuksel，“实时光纤级布料渲染”， 
交互式3D图形和游戏研讨会，2017年3月。引用于p。359[1925] 
Wu，Kui，NghiaTruong，CemYuksel和 RamaHoetzlein，“GPU 
上稀疏体积的快速流体模拟”，计算机图形学论坛，第一卷。37， 
不。1，pp.157-167,2018。引用于 p。579 [1926]Wu，Kui和 
CemYuksel， “带有光纤级细节的实时布料渲染”，IEEE可视化和 
计算机图形学的交易，出现。引用p。359[1927]Wyman，Chris， 
 “附近几何的交互式图像空间折射， “在GRAPHITE2005，ACM， 
pp.205-211，2005年 11月。引用于p。630,632[1928]Wyman， 
Chris，“使用图像空间技术的交互式折射和焦散”，载于Wolfgang 
Engel，编辑，ShaderX5，CharlesRiverMedia，第359-371页， 
2006年。632 [1929]Wyman，Chris， “Hierarchical Caustic 
Maps”，“2008年交互式3D图形与游戏研讨会论文集”，ACM， 
第 163-172页，2008年2月。引用于p。632 [1930]Wyman， 
C.，R。Hoetzlein 和 A. Lefohn， “Frustum-Traced Raster 
Shadows：RevisitingIrregularZ-Buffers”，第19届交互式3D 
图形与游戏研讨会论文集，ACM，第 15页-23，2月 -3月2015. 
引用于p。261,1001 [1931]Wyman，Chris， “探索和扩展OIT 
算法的连续性”， “高性能图形学会论文集”，Eurographics 
Association，第 1-11页，2016年6月。引用于p。156，159,165 
----------------------- Page 1379-----------------------
[1932] Wyman，Chris，Rama Hoetzlein和 Aaron Lefohn， 
 “Frustum-Traced Irregular Z-Buffers ： Fast ， Sub-pixel 
Accurate HardShadows，”IEEETransactionsonVisualization 
and ComputerGraphics，vol。22，不。10，pp.2249-2261， 
2016年 10月。引用于p。261 1152参考书目[1933]Wyman， 
Chris和 MorganMcGuire， “HashedAlphaTesting”，交互式 
3D图形和游戏研讨会，2017年3月。引用于p。206,208,642[1934] 
Wyszecki，G¨unther和WSStiles，ColorScience：Conceptsand 
Methods，Quantitative Dataand Formulas，Second Edition， 
JohnWiley＆Sons，Inc.，2000。276,291 [1935]Xia，Julie C.， 
Jihad El-Sana和AmitabhVarshney， “基于自适应实时细节的多 
边形物体渲染” ，IEEE Transactions on Visualization and 
ComputerGraphics，vol。3，不。2，pp.171-183，1997年6 
月。引用p。772[1936]Xiao，Xiangyun，ShuaiZhang和Xubo 
Yang，“用于大规模颗粒流体的实时高质量表面渲染”，交互式3D 
图形和游戏研讨会，2017年3月。引用p。572,753[1937]谢，冯 
和Jon Lanz， “梦工厂动画中基于物理的阴影”，SIGGRAPH理 
论和实践中的基于物理的阴影，2017 年 8 月。引用于 p。 
336,359,364[1938]Xu，Ke， “Uncharted4 中的时间抗锯齿”， 
SIGGRAPH在游戏中实时渲染的进展，2016年7月。引用于p。 
142,143,144,492[1939]Xu，Kun，Yun-TaoJia，HongHongFu， 
Shimin Hu和Chiew-LanTai， “全频预计算辐射传递的球面分段 
----------------------- Page 1380-----------------------
常数基函数”，IEEE可视化交易和计算机图形学，第一卷。14，没 
有。2，pp.454-467，3月 -4月。2008年。引用p。402 [1940] 
Xu，Kun，Sun-Lun Sun，Zhao Dong，Dan-Yong Zhao， 
Run-DongWu，and Shi-Min Hu， “Anisotropic Spherical 
Gaussians，”ACMTransactionsonGraphics，vol。32，不。6， 
pp.209：1-209：11,2013。引用于p。398,498[1941]Yan，Ling-Qi 
和 Hasan，Milos，Wenzel Jakob，Jason Lawrence，Steve 
Marschner和 RaviRamamoorthi， “在高分辨率法线照射镜面上 
渲染闪光”，ACM图形交易 （SIGGRAPH）2014），第一卷。33， 
不。4，pp.116：1-116：9，2014年7月。引用于p。372[1942] 
Yan ，Ling-Qi ，Milos Hasan ，Steve Marschner 和 Ravi 
Ramamoorthi，“高效渲染镜面微结构的位置 - 正态分布”，ACM 
图形交易 （SIGGRAPH2016），第一卷。35，不。4，pp.56：1-56： 
9，2016年7月。引用于p。372[1943]Yang，Baoguang，Zhao 
Dong，Jiejie Feng，Hans-PeterSeidel，和Jan Kautz，“Variance 
SoftShadowMapping”，计算机图形论坛，第一卷。29，不。7， 
pp.2127-2134,2010。引用于p。257,259[1944]Yang，Lei，Pedro 
V.Sander和Jason Lawrence，“Geometry-AwareFramebuffer 
Level of details”，第 19 届 Eurographics 研讨会论文集， 
EurographicsAssociation，pp.1183-1188，2008年6月。引用 
p。520[1945]Yang，L.，Y.-C。Tse，P。Sander，J。Lawrence， 
D。Nehab，H。Hoppe和C.Wilkins，“Image-SpaceBidirectional 
----------------------- Page 1381-----------------------
Scene Reprojection，”ACMTransactions onGraphics，vol。 
30，不。6，pp.150：1-150：10,2011。引用p。523[1946]Yang， 
L。和 H.Bowles，使用双向迭代重投影加速渲染管道“            ”，SIGGRAPH 
在游戏中实时渲染方面取得进展，2012年8月。523[1947]Ylitie， 
Henri，Tero Karras和SamuliLaine， “通过压缩宽 BVH在GPU 
上进行高效的非相干光线遍历”，高性能图形，2017年7月。511 
[1948]Yoon，Sung-Eui，PeterLindstrom，Valerio Pascucci和 
DineshManocha， “Cache-Oblivious MeshLayouts”，ACM 
TransactionsonGraphics，vol。24，不。3，pp.886-893，2005 
年 7 月。引用于 p。828 [1949] Yoon，Sung-Eui 和 Dinesh 
Manocha，“缓存高效的边界体积层次布局”，计算机图形学论坛， 
第一卷。25，不。3，pp.853-857,2006。引用于p。828参考书 
目 1153 [1950] Yoon ，Sung-Eui ，Sean Curtis 和 Dinesh 
Manocha， “使用选择性重组的光线跟踪动态场景”，第18届 
Eurographics协会研讨会，EurographicsAssociation，pp.73-84， 
2007年 6月。引用页。821 [1951]Yoshida，Akiko，Matthias 
Ihrke，RafalMantiuk和 Hans-PeterSeidel，“眩光幻觉的亮度，” 
第五届图形与可视化应用感知研讨会，ACM，第83-90页，2008 
年8月。引用于第4页。524[1952]Yu，X.，R。Wang和J.Yu， 
 “通过动态光场生成和过滤的实时景深渲染”，计算机图形论坛， 
第一卷。29，不。7，pp.2009-2107,2010。引用于p。523[1953] 
Yuksel，Cem和John Keyser， “DeepOpacity Maps”，计算 
----------------------- Page 1382-----------------------
机图形学论坛，第一卷。27，不。2，pp.675-680,2008。引用于p。 
257,645,646 [1954]Yuksel，Cem和 SaraTariq，SIGGRAPH高 
级技术在实时头发渲染和模拟课程，2010年 7月。引用于 p。 
45,642,646,649 [1955]Yuksel，Cem， “MeshColorTextures”， 
高性能图形 2017，EurographicsAssociation，pp.17：1-17： 
11,2017。引用于p。191[1956]Yusov，E。， “使用 DirectX11 
进行实时可变形地形渲染”，载于Wolfgang Engel，编辑， 
ShaderX3，CharlesRiverMedia，第13-39页，2004年。879[1957] 
Yusov，Egor， “室外光散射”，游戏开发者大会，2013年3月。 
引用于p。615[1958]Yusov，Egor， “使用极线采样和 1D最小/ 
最大二叉树的光散射效果的实际实现”，游戏开发者大会，2013年 
3月。引用于p。608 [1959]Yusov，Egor， “使用预先计算的照 
明对现实的积云进行高性能渲染”，参见Eurographics/ ACM 
SIGGRAPH高性能图形研讨会论文集，EurographicsAssociation， 
pp.127-136，2014年8月。引用p。617,618 [1960]Zakarin， 
约旦， “丛林书如何让它的动物看起来如此真实，具有开创性的视 
觉特效，”Inverse.com，2016年4月15日。引用于p。1042[1961] 
Zarge，Jonathan和 RichardHuddy， “用ATI开发人员性能工具 
和优化技术挤出游戏性能”，游戏开发人员大会，2006年3月。引 
用p。713,786,787[1962]Zhang，Fan，HanqiuSun，LeileiXu 
和 Kit-LunLee，用于大规模虚拟环境的并行分裂阴影贴图“           ”，2006 
年 ACM 国际虚拟现实连续体会议论文集及其应用，ACM， 
----------------------- Page 1383-----------------------
pp.311-318，2006年6月。引用于p。242,244 [1963]Zhang， 
Fan，HanqiuSun和Oskari Nyman， “可编程GPU上的并行分 
裂阴影图 ” ， Hubert Nguyen 编辑， GPU Gems 3 ， 
Addison-Wesley，第203-237页，2007年。引用p。242,243,244 
[1964]Zhang，Fan，AlexanderZaprjagaev和Allan Bentham， 
 “PracticalCascadedShadowMaps”，Wolfgang Engel，编辑， 
ShaderX7，CharlesRiverMedia，pp.305-329,2009。引用于p。 
242,245[1965]Zhang，Hansong，有效遮挡剔除任意模型的交互 
显示，博士论文，计算机科学系，北卡罗来纳大学教堂山分校，1998 
年7月。引用p。843[1966]Zhang，Long，QianSun，Ying He， 
 “Splatting Lines：一种有效的3D表面和体积说明方法”，ACM 
SIGGRAPH交互式3D图形和游戏研讨会第18次会议记录，ACM， 
pp.135-142，2014年3月。引用于p。6651154参考书目[1967] 
Zhao，Guangyuan和XianmingSun，使“用Henyey-Greensterin 
进行蒙特卡罗辐射传输模拟的误差分析”，电磁学研究会，2010年 
3月。引用于p。598[1968]Zhdan，Dmitry， “TiledShading： 
LightCulling - 达到光速， “游戏开发者大会，2016年3月。引 
用于p。894[1969]Zhou，Kun，Yaohua Hu，StephenLin，Baining 
Guo和 Heung-YeungShum， “预先计算的动态场景阴影场”， 
ACM 图形交易（SIGGRAPH 2005），第一卷。24，不。3， 
pp.1196-1201,2005。引用于p。466 [1970]Zhukov，Sergei， 
Andrei Iones和GrigorijKronin， “环境光照明模型”，渲染技术 
----------------------- Page 1384-----------------------
'98，Springer，第45-56页，1998年6月至7月。引用于 p。 
449,454,457 [1971]Zink，Jason，MattPettineo和Jack Hoxley， 
实际渲染和计算与 Direct3D11，CRC出版社，2011年。引用于p。 
47,54,90,518,519,520,568,795,813,814,914 [1972] Zinke ， 
Arno，CemYuksel，WeberAndreas和John Keyser， “头发中 
快速多重散射的双散射近似”，ACM图形交易 SIGGRAPH（             2008）， 
第一卷。27，没有。3，pp.1-10,2008。引用于p。645[1973]Zioma， 
Renaldas，“使用 LightBuffers进行更好的几何配料”，Wolfgang 
Engel编辑，ShaderX4，CharlesRiverMedia，第5-16页，2005 
年。893 [1974]Zirr，Tobias和Anton Kaplanyan， “程序多尺 
度材料的实时渲染”，交互式3D图形和游戏研讨会，2016年2月。 
引用于p。372 [1975]Zorin，Denis，PeterSchr¨oder和Wim 
Sweldens， “插入任意拓扑的网格细分”，SIGGRAPH'96：第23 
届计算机图形学和交互技术年会论文集，ACM，第189页-192， 
1996年8月。引用于p。761 [1976]Zorin，Denis，固定细分和 
多分辨率表面表示，博士论文，CS-TR-97-32，加州理工学院，1997 
年。引用于p。759,761 [1977]Zorin，Denis，PeterSchr¨oder， 
Tony DeRose，Leif Kobbelt，Adi Levin和 Wim Sweldens， 
SIGGRAPH 建模与动画细分课程， 2000 年 7 月。 
756,760,761,762,781[1978]Zou，Ming，TaoJu和NathanCarr， 
 “一种三角形多边形三角形算法”，计算机图形学论坛，第一卷。 
32，不。5，pp.157-166,2013。引用于p。685索引对于具有多 
----------------------- Page 1385-----------------------
个页面引用的索引术语，斜体页面 （或范围）表示最重要的引用。1 
环，759,7602.5尺寸，5313D打印，578,683,6933dfx交互式， 
37A缓冲，见缓冲AABB，822,944,946,974,976创作，949正投 
影，93AABB/物体交叉，参见交叉口测试，AABB/AABB学院颜 
色编码系统，参见ACES加速算法，14,682,817-879，19时钟门 
控，1028时钟速率，789CLOD，参见详细程度，连续闭合模型， 
693云，257,556,563-564,598,613,616-620,622-623聚类延迟着 
色，904聚类前向着色，904,907,908,914聚类阴影，898-905Cn- 
连续性，728代码优化，参见优化，代码CodeAnalyst，792相干 
帧到帧，866长度，362空间，837时间，866碰撞检测，14颜色， 
8,272-290环境，392缓冲，见缓冲，颜色分级，289-290匹配， 
272-274模式，1009深色，1010高颜色，1009-1010真彩色， 
1009-1010感知，278索引 1159颜色外观模型，278颜色空间 
ACEScg，278Adob​ ​ e1998,277DCI-P3,277ICTCP，276,287 
Rec。2020,277,281Rec。709,277,281sRGB，277,281工作，278 
种颜色匹配功能， 48 diffuse term, 306 diffusion, 634 
normal-map, 635 screen-space, 636–638 texture-space, 635 
digital differential analyzer, 506 digital visual interface, 1011 
dihedralangle,654,660,695dimension reduction,955direct 
memory access, see DMA Direct3D, 21n DirectCompute, 40 
directed acyclic graph, 586, 829 direction, principal, 672 
directional occlusion, 465 dynamic, 467–468 precomputed, 
----------------------- Page 1386-----------------------
466 shading,468–472 DirectX,38–41 DirectX11,813 DirectX 
12, 814 discrete geometry LOD, see level of detail, discrete 
geometry discrete ordinate methods, 493 discrete oriented 
polytope,seek-DOPdiscretizedsignal, 131DisneyInfinity3.0, 
372 displaced subdivision, see surfaces, subdivision, 
displaced Index 1161 displacement mapping, 167, 219, 765, 
770 display encoding, 160– 165 engine, 1011 flare, 285 
head-mounted, 916 interface, 1011 list, 812 primary, 276 
varifocal,923displayrate,1display-referred,283DisplayPort, 
1011 distance field, 677 distortion, lens, 921 distribution of 
normals, see NDF distribution of visible normals, 333 
dithering, 1010 DLAA,see antialiasing, directionally localized 
DMA, 1034 Dolby Vision, 282 DOM, see discrete ordinate 
methodsdomain,719rectangular,736triangular,740domain 
shader, 44 DOOM (2016), 246, 540, 629, 823, 869, 883, 901 
dot product, 7 dots per inch, 817 double buffer, see buffer, 
doubledownsampling,136,518,525DRAM,791drawcall,35 
Dreams,577, 1045driver,seegraphicsdriverdual paraboloid 
mapping, see environment mapping, parabolic dual 
source-color blending, 53 dueling frusta, 242 Dust 514, 493 
DVI,1011DXR,1044DXTC,see undertexturing, compression 
dynamic buffer, 793 dynamic super resolution, 139 EAC, 194 
----------------------- Page 1387-----------------------
earclipping,685early-zculling,see undercullingedge,654– 
656, see also line border, 654 boundary, 654, 661, 692, 709 
bridge, 686 collapse, see under simplification contour, 654– 
656crease,654,695,709,747detection,661,663feature,654 
function, 994–996 hard,654join, 686 keyholed,686 material, 
654 preservation, 695 ridge, 654, 660 silhouette, 654–655 
stitching, 689 suggestive contour, 655 valley, 654, 660 
effective surface, 350electrical opticaltransfer function, 161, 
283 EM, see environment mapping energy efficiency, 1024 
Enlighten, 482 enveloping, see transform, vertex blending 
environment mapping, 404 – 433 cubic, 410 – 412, 425 
irradiance, 424–433 latitude-longitude, 406–408 localized, 
499–502octahedral,413 parabolic,413 prefiltered,415–420, 
471, 502, 503 sphere, 408–410 EOTF, see electrical optical 
transfer function EQAA, see antialiasing, enhanced quality 
Ericsson texture compression, see texturing, compression, 
ETC ESM, see shadow, map, exponential ETC, see under 
texturing, compression Euler angles, 59, 70, 73, 82 Euler 
transform, see transform, Euler Euler-Mascheroni constant, 
802 Euler-Poincar′e formula, 699, 706 EVS, see exact visible 
set EVSM, see shadow, map, exponential EWA, 189 exact 
visibleset,831executionunit,1003exitance,442,474explicit 
----------------------- Page 1388-----------------------
surface, see surfaces, explicit exposure, 285, 288 – 289 
extraordinary vertex, 758 eye space, 15 eye-dome lighting, 
575faceter, 682fairness, 761 1162Indexfallofffunction, 114, 
381fan, seetriangle,fan FarCry,453,476 FarCry 3,478,481 
FarCry4,420,481far plane,93,99,981Feline,189fence,938 
FIFA, 616 FIFO, 808, 809, 1023 fill rate, 788 film frame rate, 
536filter, 130–137,515bilateral,462, 518–520box, 134,165, 
517, 518 bright-pass, 527 cross bilateral, see filter, joint 
bilateral disk, 518 edge-preserving, 520 Gaussian, 136, 189, 
515, 517, 572, 665 joint bilateral, 249, 519 kernel, 517 
low-pass, 135, 136 nearest neighbor, 134 rotation-invariant, 
515 running-average, 523 separable, 516, 517, 520, 532 sinc, 
135–136, 515 steerable, 525 support, 517tent, 134triangle, 
134 fin, 646, 668 Final Fantasy XV, 620 fireflies, see under 
aliasing Firewatch, 104 first principal direction, 672 
fixed-function pipeline, 27 fixed-view effects, 546–547 flat 
shading, 120 FLIPQUAD, 146 floor, 769 flow control, 36 
dynamic, 36 static, 36 flush, 1005 FMA, 1026, 1033fog, 598, 
600–602, 608 force feedback, 14 form factor, 442 forward 
mapping, 531 forward shading, 883 forward+ shading, see 
tiled, forward shading Forza Horizon 2, 141, 899 Forza 
Motorsport7, 2,412 foveated rendering,931–932 FPS, 1,13, 
----------------------- Page 1389-----------------------
789, 817 fragment, 22, 49 fragment shader, 23, 49, 125, see 
also pixel shader frame rate, 1, 808 constant, 865 
frame-to-frame coherence, 866 framebuffer, 25 frames per 
second, 13 FreeSync, 1011 FreeType, 676 Fresnel effect, 319 
Fresnelequations,316Fresnelreflectance,316–327,330,331, 
348, 351, 405, 420, 421, 426, 498, 626, 631, 632, 643, 892 
Schlick approximation, 320, 321, 326, 347, 351, 598 front 
buffer, see buffer, front front plane, 93n Frostbite game 
engine, 111, 113, 115, 116,287, 290, 312, 325, 616, 804, 811, 
851, 878, 890, 893, 903 froxel, 611 frustum, 11, 17–18, 981 
plane extraction, 983 – 984 tracing, 261 frustum/object 
intersection, see specific objects under intersection testing 
FSAA,seeantialiasing,full-scenefull screenpass,514fur,640 
–641, 646–649 FX Composer, 44 FXAA, see antialiasing, fast 
approximate G-sync, 1011 G1-continuity, see continuity 
gamma correction, 160–165, 184gamut, 276, 323 sRGB, 323 
gas, ideal, 297 gather operation, 532 Gauss map, 667 
Gaussian, anisotropic spherical, 398, 498 GBAA, see 
antialiasing, geometry buffer GCN, see under hardware 
genus, 699 geodesic curve, 81 geometric mean, 864 
geometry clipmap, 872 – 873 patch, 775 Index 1163 
processing,seeunderpipelineshader,18–19,47–48, 647,668, 
----------------------- Page 1390-----------------------
677, 702, 786, 798 stage, see pipeline, geometry processing 
geomorph LOD, see level of detail, geomorph GigaThread 
engine, 1032 gimbal lock, 73 glare effects, 524 global 
illumination,315,438glPolygonOffset,236,657,673GLSL,35, 
39gluLookAt,67gluPerspective,99Gn-continuity,728gobo, 
173, 221, 230, 434 golden thread, 547 Gooch shading, 103, 
663 Gouraud shading, 118 GPA, 785 GPU, 13, 29, see also 
hardwarecomputing,54GPU Boost,789GPU PerfStudio,785 
GPUView, 785 gradient of pixel, 51, 185 graftals, 672 Grand 
Theft Auto V, 525 graphics driver, 786, 793, 1012 graphics 
processing unit, see GPU grayscale, conversion to, 278 great 
arc, 81 great circle, 81 green-screening, 160GRID2, 258 GTX 
1080,see under hardwareguard-band clipping, 998 H-basis, 
404 hair, 257, 640–646, 649 half vector, 336 half-edge, 692 
Half-Life 2, 402, 403, 476, 478, 499 Half-Life 2 basis, 403 
half-space, 6, 946 halo, 524 Halo 3, 475 haloing, 675 Halton 
sequence, 144 hard realtime, 865 hardwareGameCube, 867 
GCN, 1035–1039 GeForce 256, 29 GeForce3, 38 GTX 1080, 
1029–1035Maliarchitecture, 1020,1024–1029NVIDIAPascal, 
1029 – 1035 Pixel-Planes, 8n, 1026 PixelFlow, 1022 
PLAYSTATION, 936 PLAYSTATION 3, 39, 700 PLAYSTATION4, 
867, 1007, 1035Pomegranate, 1022Talisman, 189,551Vega, 
----------------------- Page 1391-----------------------
1035–1039Voodoo 1, 1Wii, 27, 39Xbox, 1035Xbox 360, 39 
Xbox One, 867 harmonicseries,802 Hausdorffdistance, 708, 
875 H-basis, 475 HBM2, 1034, 1038 HDMI, 1011 HDR, 193, 
271, 281–283, 405 display, 1011 HDR10, 281 head, 70, 72 
heads-up display, 561, 917, 932, 933 heat diffusion, 535 
heightfield, 564–566, see also bump mapping terrain, 877 
Hellgate: London, 609 Helmholtz reciprocity, 312, 351 
hemisphere lighting, 431 hemispherical basis, see basis, 
hemispherical        hemispherical       harmonics,        404 
Henyey-Greenstein phase function, 598–599, 620 Hermite 
curves, see curves, Hermite Hermite interpolation, see 
interpolation, Hermite Hertz, 13 hidden line removal, 668– 
669hiddenlinerendering,seeline,hiddenhierarchicalimage 
caching, see impostor hierarchical spatial data structure, see 
spatial data structure hierarchical view frustum culling, see 
culling, hierarchicalview frustum hierarchicalz-buffering, see 
under culling high color mode, see color, mode, high color 
high dynamic range, see HDR high-definition multimedia 
interface, 1011 High-Level Shading Language, see HLSL 
highlight, 119 highlight selection, 673 histogram, 245 1164 
Index histogram renormalization, 196 hither, 93n HiZ, 252, 
1015, 1038 HLG,281 HLSL,35, 39 homogeneous notation,6, 
----------------------- Page 1392-----------------------
58, 62, 173 homogenization, 62, 92 horizon angle, 460 
horizon mapping, 460, 466 hourglass, 684 HRAA, see 
antialiasing, hybrid reconstruction HTCVive, see Vive HTILE, 
1038 HUD, 561, 917, 932, 933 hue, 276 hull shader, 44 Hunt 
effect, 285 Huygens-Fresnel principle, 360 Hybrid 
Log-Gamma,see HLGhysteresis,861 HZBculling,seeculling, 
hierarchical z-buffering IBR, see image-based rendering 
illuminant D65, 270, 274 image geometry, 566, 876 
processing, 513– 522, 665 pyramid, 846, 847 state, 283 
image-based lighting, 406, 414 – 424, 435 image-based 
rendering, 269, 545 immediate context, 813 implicit surface, 
seesurfaces,implicitimportancesampling,385,445,451, 503 
impostor, 561–564,866 depth sprite, 564–565 layereddepth 
image, 565 index buffer, 702–705 index of refraction, 298 
complex, 298 indirect draw command, 851 inFAMOUS 
Second Son, 91, 572 inflection, 728 inner product, 398 input 
assembler,42 insidetest,996instance, 15,829instancing,42, 
797 instruction set architecture, 35 instruction-level 
parallelism, 1003 Instruments, 785, 792 integral double 
product, 464, 470 triple product, 470 intensity, 269 
interactivity,1interface,seehardwareinterference,seeunder 
light interleaved sampling, 145 intermediate language, 35 
----------------------- Page 1393-----------------------
interpolation, 781, 998–1001 barycentric, 963 bicubic, 178 
bilinear, 178–180, 182,735–736 centroid, 141 Hermite,729– 
732 linear,720 perspective-correct,22,49, 1000quadrilinear, 
189 repeated, 740 bilinear, 736 linear, 720–722 trilinear, 186 
interpupillary distance, 923 intersection testing, 941– 991 
AABB/AABB, 978–979 box/plane, 970–972 box/ray,959–962 
ray slope, 961–962 slabs method, 959–961 BV/BV,976–981 
convex polyhedron/ray, 961 crossings test, 967 – 970 
dimensionreduction,955frustum,981–987frustum/box,986 
– 987 frustum/ray, 961 frustum/sphere, 984 – 986 
hardware-accelerated,942–943 intervaloverlap method,972 
–974 k-DOP/k-DOP, 979–980 k-DOP/ray, 961 line/line, 987– 
990 OBB/OBB, 980–981 picking, 942 plane/box, 970–972 
plane/ray, 966 plane/sphere, 970 polygon/ray, 966 – 970 
polyhedron/polyhedron,987 ray/box,959–961 rejectiontest, 
948 rulesofthumb, 954–955 separating axis, 946 separating 
axis test, 947, 974, 979, 980, 986–987 sphere/box, 977–978 
sphere/ray, 955–959 Index 1165 sphere/sphere, 976–977 
three planes,990triangle/box,974–975triangle/ray,962–966 
triangle/triangle,972–974intervaloverlapmethod,seeunder 
intersection testing  intrinsic functions,  36 inverse 
displacement mapping, see texturing, parallax occlusion 
----------------------- Page 1394-----------------------
mappinginversez, 100IOR,seeindexofrefractionirradiance, 
268, 294, 425 precomputed, 474 spherical harmonics, 475 
volume, 487 irradiance mapping, see environment mapping, 
irradiance irregular vertex, 758 isocube, 412 isosurface, 584, 
682, 753 isotropic scaling, 62 Jzazbz, 276jaggies, see under 
aliasingjittering, see under antialiasingjoint, 720, 726, 728, 
731Jordan curvetheorem, 967judder, 935Just Cause 2, 114, 
882 Just Cause 3, 883, 899, 900 k-ary tree, 820 k-dtree, see 
under spatial data structure k-DOP, 945–946, 961, 976, 990 
creation,949 KentuckyRouteZero, 121Killzone:Shadow Fall, 
116, 523 Killzone 2, 885 Kite, 493 Kochanek-Bartels curves, 
see curves, Kochanek-Bartels LAB, 276 Lambertian shading, 
see BRDF, Lambertian The Last of Us, 476 late depth test, 
1016latelatching,938 latency,1,30,791,807–810,920–921, 
935, 1004–1006, 1013 occlusion query, 845 Latin hypercube 
sampling, 143 latitude, 407, 944 layered depth image, see 
under impostor LCD, 676 LDI, see impostor, layered depth 
imageLEANmapping,370left-handed,seeundercoordinate 
system lens flare, 524–526 level of detail, 44, 580, 706, 717, 
807, 852–866 alpha, 857–858 bias, 186, see also texturing 
blend,856continuous,706,859,860discretegeometry,854– 
856 fractional tessellation, 768 generation, 853 geomorph, 
----------------------- Page 1395-----------------------
859–860 hysteresis, 861 PNtriangle, 747 popping, 710, 854, 
856, 858 projected area-based, 861–864 range-based, 860– 
861 selection, 853, 860–864 simplification, 710 subdivision 
surface, 756 switching, 853, 854–860 time-critical, 865–866 
levelset, 583 LIDAR, 573 lightambient, 391–392attenuation 
mask, 230 baking, 798 bandwidth, 362 bleeding, 255 field, 
269 interference constructive, 296, 298 destructive, 296 
thin-film, 361–363 inverse-squareattenuation, 111leak,238, 
255,256map,484 meter,271monochromatic,293polarized, 
linearly,293polychromatic,293prepass,892 probe,414,490, 
901 propagationvolumes, 493 cascaded, 494 scattering, see 
scattering shafts, 602, 604, 608, 631 source, 106–117, 798 
area, 116– 117, 224, 228, 377– 391 card, 387, 388, 427 
directional, 109– 110 1166 Index light (continued) source 
(continued) disk, 379, 381, 388, 430, 435 fill, 431 omni, see 
light,source, pointplanar,388point,111–114polygonal,389 
punctual,110–116spherical,381–384,386,387,430spot,114 
– 115 tube, 387 volume, 224 transport linearity, 438, 479 
meshless, 484 modular, 484 notation, 439–440 unpolarized, 
294velocity, phase,294visible, 268 lightmap,227 light-field 
rendering, 549 lightcuts,431 lighting probe,490 limit curve, 
754,756surface,760line,19,673–675,seealsoedgehaloing, 
----------------------- Page 1396-----------------------
675 hidden,674–675 integralconvolution, 538triangle edge 
rendering, 673– 674 line/line intersection, see intersection 
testing, line/linelinearblendskinning,84 linearinterpolation, 
720 linear speedup, 810 linear transform, see transform, 
linear linearlytransformed cosines, 390 LiSPSM, see shadow, 
map,lightspaceperspectiveLittleBigPlanet,488 loadbalance, 
1023 lobe anisotropic, 422–424 asymmetric, 422–424 local 
frame, 343 local illumination, 315 local lighting model, 438 
LOD,seelevelofdetaillog,8longitude,407,944lookuptable, 
173 loop, 686 Loop subdivision, see surfaces, subdivision, 
Loop loose octree, see under spatial data structure lossy 
compression, 194LostPlanet,647lozenge,946 LPV,seelight, 
propagationvolumes Lumberyard,740, 1044Lumigraph,549 
luminance, 197,271,273, 278 LUT,see lookuptable LUV,276 
M¨obiusstrips,693Machbanding,1010macroscale,208,367 
magnification, see under texturing main axes, 8 Mali, see 
hardware, Mali architecture manifold, 694 Mantle, 40 
marching cubes, 583, 683, 753 marching tetrahedra, 753 
mask, 759 masked hierarchical depth buffer, 849 masking 
function, 333 perceptual, 278 masking-shadowing function, 
334,335material,125glossy,382–386instance,126template, 
126matrix,seealsotransformadjoint,68changeofbasis,63, 
----------------------- Page 1397-----------------------
67, 75 column-major, 60 determinant, 63 orientation, 60, 70 
orthogonal,69,72,80rotation,70row-major,60,95trace,61, 
80 transpose, 7, 63 matte, 159 mean width, 954 media, 310 
mediatedreality,917mediumabsorptive,298homogeneous, 
298 megatexture, 867 memory allocation, 793 architecture, 
1006– 1007 Index 1167 bandwidth, 1006 controller, 1038 
dynamic randomaccess,791 hierarchy,791optimization, see 
optimization, memory UMA, 1007 unified, 1007 wall, 791 
merging of pixels, 24–25 merging stage, 24–25, 53 mesh 
cache-oblivious,  700 – 701  parameterization,  173 
segmentation, 683 smoothing, 694–696 solidity, 693–694 
triangle, 691, 699–701 universal, 700–701 Meshlab,695, 716 
mesoscale, 208–209, 367 message-passing architecture, see 
multiprocessing, message-passing metaball, 48, 683, 751 
Metal,40, 814 metal,323 MetalGear SolidV: GroundZeroes, 
289 metamericfailure, 280 metamers, 273 microfacets, 331– 
336 microgeometry, 304, 327–330 masking, 328 shadowing, 
328 micropolygon, 26 microscale, 208, 367 Mie scattering, 
see scattering, Mie Minecraft, 579, 842 minification, see 
under texturing mipmap chain, 184 mipmapping, see under 
texturing, minification mirror transform, see transform, 
reflection Mirror’s Edge Catalyst, 616 mixed reality, 917 
----------------------- Page 1398-----------------------
MLAA, see antialiasing, morphological MMU, 1024 model 
space, 15 modeler,682–683 solid, 682 surface, 683 modified 
butterfly subdivision, see surfaces, subdivision modified 
Gram-Schmidt, 344 Monte Carlo integration, 385, 418, 419, 
423, 444, 451, 459, 507 noise,445, 511 Moore’s Law, 1042 
morph targets, see under transform morphing, see under 
transform Morton sequence, 1018 mosaicing, see texturing, 
tiling motionblur,536–542,835 MPEG-4,712MRT,50MSAA, 
seeantialiasing, multisamplingmulti-view,928multicore,806 
multiprocessing, 805–814, 1023 dynamic assignment, 810 
message-passing, 806 parallel, 809–810 pipeline, 806–809 
static assignment, 810 symmetric, 806 task, 811 – 812 
task-based, 806 multiprocessor, 1003 shared memory, 806, 
1003streaming,seestreaming,multiprocessormultisampling, 
seeunderantialiasingmultitexturing,seetexturing multumin 
parvo, 183 N-patch, see surfaces, PN triangle N-rooks 
sampling, 143 nailboard, see impostor, depth sprite 
nanogeometry,359 NDF,332, 337–346,367,498 anisotropic, 
343–346Beckmann,338Blinn-Phong,339,340filtering, 367– 
372 generalized Trowbridge-Reitz, see NDF, GTR GGX, 340– 
342, 369 GTR, 342 isotropic, 338–343 shape-invariance, 339 
Trowbridge-Reitz, see NDF,GGX near plane, 93, 99, 862, 981 
----------------------- Page 1399-----------------------
nearest neighbor, see under filter and texturing, 
magnification and texturing, minification Need for Speed, 
616 Newell’sformula, 685 node,819–821 internal,819 leaf, 
819 root, 819 node hierarchy, 828 noise, 872 noise function, 
seetexturing, noise 1168Indexnon-photorealisticrendering, 
651–673 noncommutativity, 65, 77 normal cone, 833–835 
incidence,317map,seeunderbumpmappingtransform, see 
transform, normal normal distribution function, see NDF 
normal-masking independence, 334 normalized device 
coordinates, 19, 94, 98, 100 NPR, see non-photorealistic 
rendering NSight,785 NURBS,781 NVIDIA Pascal,see under 
hardware Nyquist limit, see under sampling OBB, 945, 946, 
976 OBB/object intersection, see specific objects under 
intersection testing object-based shading, 908 – 912 
obscurance,449, 450, 454, 457 volumetric, 459 occluder, 844 
occluding power,844 occlusion culling, seeculling, occlusion 
occupancy, 32, 127,801, 886, 898, 1005occupancy function, 
459 octahedral mapping, 413 octave, 198 octree, see under 
spatialdatastructureoctreetexture, 190OculusRift,915,916, 
923, 935 OETF, see optical electric transfer function Okami, 
653opacity, 149Open3DGC, 712OpenCL, 54OpenCTM, 712 
OpenGL, 39–41 extensions, 40 OpenGL ES,41, 194 OpenGL 
----------------------- Page 1400-----------------------
Shading Language, 35 OpenSubdiv, 777–779 optical electric 
transfer function, 161 optics geometrical, 303 physical, 359 
wave, 359optimizationapplication stage,790–793code, 790 
– 793 geometry processing, 798– 800 lighting, 798– 800 
memory, 791–793 merging, 805 mobile, 814 pipeline, 783– 
815 pixelprocessing,800–804 pixelshader,803 rasterization, 
800The Orange Box,288The Order: 1886,91, 357,365, 370, 
477, 498, 896 ordinary vertex, 758 Oren and Nayar model, 
354 orientation, see under polygon oriented bounding box, 
see OBB orienting the camera, 67 over operator, 150–151, 
856 overblurring, 186 overclock, 787 overdraw, see under 
pixel packed pixel format, 1010 padding, 792 painter’s 
algorithm, 551, 824 painterly rendering, 652 pan, 538 
parabola,721 parabolicmapping,413 parallax,548mapping, 
167,214–220occlusionmapping,seeundertexturing parallel 
architectures, 1020 graphics, 1019 processing, see 
multiprocessing,  parallel  projection,  see  projection, 
orthographic parallelism, 810 spatial, 806 temporal, 806 
parametriccurves,seecurves,parametricparametricsurfaces, 
see surfaces, parametricparticipating media,310absorption, 
590extinction, 590, 593, 595, 610, 616, 624, 639, 643 optical 
depth, 593, 595 phase function, 590, 623, 626, 638, 644 
----------------------- Page 1401-----------------------
geometric, see scattering, geometric Mie,see scattering, Mie 
Rayleigh, see scattering, Rayleigh particle soft, 558– 559 
system, 567–572 Pascal, see hardware, NVIDIA Pascal patch, 
736pathtracing,26,444, 510,1043,1044Index1169PCF,see 
percentage-closer filtering PCI Express, 1006 Pearl Harbor, 
446 pen and ink, 652 pending buffer, 1013 penumbra, see 
under shadow per-triangle operations, 14 per-vertex 
operations, 14 percentage-closer filtering, 247– 250, 849 
perceptualquantizer,see PQperformancemeasurement,788 
– 790 perp dot product, 6, 987, 989 persistence, 935 
perspective division, 19 projection, see projection, 
perspective warping, 241 perspective-correct interpolation, 
seeinterpolationPeterPanning,238Phonglightingequation, 
see BRDF,Phong Phongshading, 118Phongtessellation, see 
undersurfacesphotogrammetry,573,682photometriccurve, 
271, 273, 278 photometry, 271 photopic, 271 photorealistic 
rendering, 545, 651 PhyreEngine, 893 pick window, see 
intersectiontesting, picking picking, 942, 943, 957 piecewise 
B′ezier curves, see curves, piecewise ping-pong buffers, 520, 
525 pipeline, 11–27, 783–815 application stage, 12, 13–14, 
783 fixed-function, 27 flush, 1005 functional stages, 13 
geometry processing, 12, 14–21, 783 parallelism, 1003 pixel 
----------------------- Page 1402-----------------------
processing, 12,22–25,783 rasterization, 12,21–22,783,993– 
998 software, 806 speedup, 12 stage, 12–13 Pirates of the 
Caribbean, 454 pitch, 70, 72 PIX, 785 pixel, 21 local storage, 
1027 overdraw, 701, 801 processing, see under pipeline 
shader, 23, 49 – 52 synchronization, 156 Pixel-Planes, see 
under hardware pixelation, 178 PixelFlow, 1022 pixels per 
inch, 817 pixels per second, 788 plane, 6 axis-aligned, 8 
coordinate, 8 plane masking, 836 plane/object intersection, 
see specific objects under intersectiontesting PLAYSTATION, 
see under hardware point cloud, 572 – 578, 683 point 
rendering, 572 – 578 point-based visibility, 842 pointer 
indirection, 792 Poisson disk, 249 Pok ′ emon GO, 917 
polycube maps, 171 polygon bowtie, 684 consolidation, 691 
contour, 686 convex, 685 edge cracking, see cracking, 
polygon edge edge stitching, 689 hourglass, 684 loop, 686 
merging, 691 mesh, 691 orientation, 691–693 sorting, 824 
soup, 691 star-shaped, 686 T-vertex, 689 – 690 
polygon-alignedBSPtree, seespatialdatastructure, BSPtree 
polygonal techniques, 853 polygonalization, 583, 683 
polymorphengine, 1031polypostor,562 POM,217 popping, 
see under levelofdetail port, 1006portalculling,seeculling, 
portalpose,921,924,938post-processing,514posterization, 
----------------------- Page 1403-----------------------
652, 1010 potentiallyvisible set, 831 powerform, 724 power 
gating, 1028 PowerTune, 789 PowerVR, 196 PQ, 281 1170 
Indexpre-lighting,892 pre-ordertraversal,835precision,712 
–715 color, 186, 1010depth, 236 floating point, 713 mobile, 
814 subpixel, 689 precomputed radiance transfer, 471, 478, 
479, 481 local deformable, 481 predictive rendering, 280 
prefilter, 414 primitive generator, 44 primitive shader, 1037 
Prince of Persia, 658 principal component analysis, 480, 484 
probability, geometric, 953–954 procedural modeling, 222, 
672, 682 procedural texturing, see texturing, procedural 
processor pixel, see pixel, shader vertex, see vertex, shader 
progressive refinement, 510, 547 projection, 16–18, 92–102 
3D polygon to 2D, 966 3D triangle to 2D, 962 bounding 
volume,861–864cylindrical,172orthographic,17–18,59,93– 
95 parallel, see projection, orthographic perspective, 17, 59, 
96–102, 1014 planar, 172spherical, 172 projectivetexturing, 
see texturing, projective proxy object, 819 PRT, see 
precomputed radiance transfer PSM, see shadow, map, 
perspective Ptex, 191 purple fringing, 628 purple line, 274 
PVRTC,seeundertexturing,compression PVS,see potentially 
visible set PxrSurface,343, 359, 363, 364QEM, 708 quad, 51, 
801,994quadovershading,787,853,863,910,994quadratic 
----------------------- Page 1404-----------------------
curve, see curves, quadratic quadratic equation, 957 quadric 
error metric, 708 quadtree, see under spatial data structure 
Quake, 37,474 Quake II,474 Quake III, 37,402 quantization, 
scalar, 714 Quantum Break, 496 quartic curve, see curves, 
quartic quaternion, 72, 76–84 addition, 77 conjugate, 77, 78 
definition,76dual,87identity,77imaginaryunits,76inverse, 
77 lawsof multiplication,78 logarithm,78 matrixconversion, 
79–81 multiplication,77 norm,77, 78 power,78 slerp,81–83 
spherical linearinterpolation,81–82 spline interpolation,82– 
83 transforms, 79–84 unit, 78, 79 Quickhull, 950 Quincunx, 
see antialiasing, Quincunx quintic curve, 181 radiance, 269– 
270,273,425distribution,269incoming,315radiantexitance, 
seeexitanceflux, 268intensity,269 radiometry,267 radiosity, 
442–443 normal mapping, 402–404 progressive,483 RAGE, 
867 Rainbow Six Siege, 887 range-based fog, see fog raster 
engine, 1031 raster operation, see ROP rasterization, see 
under pipeline conservative, 22, 139, 259, 582, 1001 inner, 
1001 outer, 1001 overestimated, 1001 underestimated, 1001 
rasterizer order view, 52, 139, 156 rasterizer stage, see 
pipeline, rasterization Ratatouille, 638 rational linear 
interpolation, 720 Index 1171 ray, 943– 944 casting, 443 
function,437 marching,199,216–220,262,566,570,594,607, 
----------------------- Page 1405-----------------------
608, 614, 616, 618, 620–622, 639, 642, 648, 752, 753, 1048 
tracing, 26,259,261,443–445, 530,586,802,953, 1006,1044 
–1047architecture, 1039isosurface,584voxel, 580ray/object 
intersection, see specific objects under intersection testing 
Rayleigh scattering, see scattering, Rayleigh reciprocity, 312 
reconstruction, 131, 133–136 reduce, 245, 896 reflectance 
anisotropic,328directional-hemispherical,313equation,311, 
437 hemispherical-directional, 313 isotropic, 328 spectral, 
279reflectancelobe,seeunderBRDFreflection,314,315,623, 
626, 630 environment mapping, 413 equation, see 
reflectance, equation external, 317 internal, 317, 325 total, 
326lawof,504mapping,405 planar,504–505,839probe,499 
localized, 500 proxy, 500 screen-space, 505–509 transform, 
see transform, reflection refraction, 149, 302, 626–630, 631– 
633, 638, 639 image-space, 630 refractive index, 298 refresh 
rate, 1vertical, 1011registercombiners, 38 registerpressure, 
127,801,904,1005regularvertex,758relieftexturemapping, 
see texturing, relief relighting, 547 render target, 50 
RenderDoc,785renderingequation,437–438 spectrum, 545– 
546 state, 794 RenderMan, 37, 39 repeated linear 
interpolation,see interpolation, repeated, linear reprojection, 
143, 522 – 523, 936 resampling, 136 – 137 resolve, 142 
----------------------- Page 1406-----------------------
retopology,712 retrace,vertical, 25, 1012retroreflection,330 
reverse mapping, 532 reversed z, 100 Reyes, 908–912 RGB, 
176color cube, 275 color mode, see color, mode,true color 
tograyscale,278RGBA,150,159,1010texture, 176RGSS,see 
antialiasing, rotated grid right-hand rule, 692 right-handed, 
92 rigid-body transform, see transform, rigid-body ringing, 
256, 401, 428, 570 roll, 70, 72 ROP, 24, 25, 1010, 1032–1033 
roping, 165 rotation, see under transform roughness, 304 
ROV, see rasterizer order view RSM, see shadow, map, 
reflective S3TC, 192 saccade, 931 SAH, see surface area 
heuristic sample, 22 sampling, 130 – 137, 143, see also 
antialiasing band-limited signal, 133 centroid, 141 
continuous signal, 131 discretized signal, 131 Nyquist limit, 
133, 182, 186pattern, 143stochastic, 145, 149stratified, 144 
theorem, 133 SAT, see intersection testing, separating axis 
test saturation, 276 SBRDF, 310 scalable link interface, 1013 
scaling, see under transform scan conversion, 21 scanline 
interleave, 1013scatteroperation, 531 1172Indexscattering, 
297,589–599backward,597,598,599forward, 597,598,599, 
607, 638 geometric, 596, 599 Mie, 298, 596, 597–599, 614, 
620 multiple,607,615,616,621–622,633,643–646 Rayleigh, 
298, 596–597, 613, 614 single, 589, 592, 610, 614, 618, 633, 
----------------------- Page 1407-----------------------
638 subsurface, see subsurface scattering Tyndall, 298 scene 
graph, see under spatial data structure scene-referred, 283 
Schlick phase function, 599 scoreboard, 1031 scotopic, 271 
screencoordinates,20mapping,20spacecoverage,772,862 
scRGB, 282 SDR, 281 SDSM, see shadow, map, sample 
distribution second-order equation, 957 sectioning, 19 
segmentation, 683 semiconductor, 324 separating axis test, 
see under intersection testing separating hyperplane 
theorem, 946 SGIalgorithm, seetriangle, strip shadetree, 37 
shader cores, 30 storage bufferobject, see unorderedaccess 
view unified, see unified shader architecture Shader Model, 
38 Shadertoy, 199,222, 753, 1048shading, 16clustered, see 
clustered shading deferred, see deferred shading equation, 
16flat, 120forward,883Gouraud,118hard,652language,35 
model, 103–106 Lambertian, 109 Phong, 118 pixel, 23, see 
also pixel shader tiled, see tiled, shading toon, 652– 654 
vertex, see vertex, shader shadow, 223 – 265 acne, 236 
anti-shadow, 227 buffer, 234 contact hardening, 251 on 
curvedsurfaces,229–230depthmap,234hard,223map,230, 
234–252, 594, 604 adaptive volumetric, 258 bias, 236–239 
cascaded,242–247convolution,255deep,257–259,638dual, 
238 exponential, 256–257 filtered, 252–257 imperfect, 492 
----------------------- Page 1408-----------------------
irregular, 259–264 light space perspective, 241 minmax, 252 
moment, 256 omnidirectional, 234 opacity, 257, 612 
parallel-split,242 perspective,241 reflective,491,493 sample 
distribution, 245 second-depth, 238 sparse, 246, 263 
translucent, 639 trapezoidal, 241 variance, 252 – 255 
volumetric, 644 penumbra, 224, 228 percentage-closer soft, 
250–252 planar,225–229 soft, 228–229 projection, 225–227 
screen-space, 262 soft, 224–225, 227–229, 247–252, 442 
umbra, 224 volume, 230–233 shadowing-masking function, 
see masking-shadowing function shape blending, see 
transform, morphtargetssharedmemorymultiprocessor,see 
multiprocessor, shared memory shear, see under transform 
shell, 646 shell mapping, 220, 659 shortest arc, 81 shower 
door effect, 670 Shrek 2,491 signed distance field, 454, 579, 
677 Index 1173signed distance function, 577, 750 spherical, 
466 silhouette,765,773loop,667SIMD,31,1003,1005,1035 
SIMD lane, 31, 1002 simplification, 706 – 712, 853 cost 
function, 707–709edgecollapse,706–708 levelofdetail,710 
optimal placement, 707 reversibility, 706 SIMT, 1002 
simulation sickness, 920 single buffer, see buffer, single 
skeleton-subspace deformation, see transform, vertex 
blending skinning, see transform, vertex blending sky, see 
----------------------- Page 1409-----------------------
atmosphere and clouds skybox, 547–549, 556,628, 632 slab, 
945 slerp, see under quaternion SLI, 1013 slicemap, 581 
SMAA, see antialiasing, subpixel morphological small batch 
problem, 796 smart composition, 1028 Smith masking 
function, 334, 335, 339, 341–343, 355, 358 smoothstep, 115, 
181 SMOOTHVISION, 145 SMP, 806 Snell’s law, 302, 326 
softbox, 388, 434 software pipelining, see multiprocessing 
solid, 693 solid angle, 268 differential, 311 sort, 822 space, 
1020 sort-everywhere, 1022 sort-first, 1020 sort-last, 1020, 
1033 fragment, 1021 image, 1021, 1022 sort-middle, 1020, 
1024 space subdivision, 819 space-filling curve, 1018 
spacewarp, 935, 937 sparse texture, see texturing, sparse 
sparsevoxel octree,494, 579 spatial data structure, 818–830 
aspectgraph,831 boundingvolume hierarchy,510,819–821, 
942 BSP tree, 819, 822 – 824 axis-aligned, 822 – 823 
polygon-aligned, 823 – 824 cache-aware, 827 – 828 
cache-oblivious, 827–828 hierarchical, 818 irregular, 819 k-d 
tree, 822–823 loose octree, 826–827 octree, 819, 824–827, 
846quadtree,825,874 restricted,774,877 regular,819scene 
graph,828–830,840,861 LOD,861spatiallocality,791spatial 
relationship, 438 spatialization, 830 SPD, see spectral power 
distribution spectral power distribution, 270, 272 spectrum, 
----------------------- Page 1410-----------------------
268, 274 specular highlight, 119 lobe, see under BRDFterm, 
306sphere,682formula,944,956 mapping,seeenvironment 
mapping, sphere sphere/object intersection, see specific 
objects under intersection testing spherical basis, see basis, 
spherical coordinates, 407, 944 function, 392–404 Gaussian, 
see basis, spherical, Gaussian harmonics, 398–401, 427–431, 
456, 480, 488 gradients, 488 linear interpolation, see under 
quaternion SPIR-V, 40 splat, 573– 574 spline curves, see 
curves, spline spline surfaces, see surfaces, spline split and 
dice, 774–775 Split/Second, 898 Spore, 678, 710 sprite, 531, 
550– 551, see also impostor layered, 550– 551 SRAA, see 
antialiasing,subpixel reconstructionsRGB, 161,162,165,196, 
322, 323 SSBO, see unordered access view SSE, 977–979 
stage stalling, 809 starving, 12, 809 1174 Index stalling, 809 
standarddynamicrange,seeSDRStarOcean4, 286StarWars 
Battlefront, 647 star-shaped polygon, 686 Starcraft II, 459 
starving, see under stage state changes, 794 sorting, 807 
static buffer, 794 stationary subdivision, see surfaces, 
subdivision, stationary stencil, 759 stencil buffer, see buffer, 
stencil steradian, 268, 269 stereo rendering, 927–931 stereo 
vision, 922–924 stereopsis, 922 Stevens effect, 285 stitching, 
689 stream output, 19,48–49, 571, 705 streaming, 871–872 
----------------------- Page 1411-----------------------
multiprocessor, 1003, 1029 texture, see texturing, streaming 
stride, 702 strip, see triangle, strip stroke, 672 stylized 
rendering, see non-photorealistic rendering subdivision 
curves, see curves, subdivision subdivision surfaces, see 
surfaces, subdivision subpixel addressing, 689 subsurface 
albedo, 348–349 subsurface scattering, 305–307, 445, 607 
global, 306, 632–640 local, 306, 347–355 subtexture, see 
texturing summed-area table, see under texturing, 
minification superscalar, 14 supershader, 128 surface area 
heuristic, 953 surface extraction, 583 surfaces acne, 236 
B-spline,749,762 B′ezier patch,735–738 B′eziertriangle, 740 
–741, 745 biquadratic, 736 continuity, 741–742 explicit, 944 
sphere,944triangle,944,963implicit,749–753,944blending, 
751derivatives,751sphere,956 NURBS,781 parametric,171, 
734–747 Phongtessellation, 735, 740, 748–749 PNtriangle, 
46, 735, 740, 744–747, 748, 749 spline, 689, 761 subdivision, 
756–767 adaptive quadtree, 718, 779–780 approximating, 
758 Catmull-Clark, 761– 763 displaced, 765– 766 feature 
adaptive, 777–779 limit position, 760 limit surface, 760 limit 
tangents, 760 Loop, 758– 761, 763, 765– 767 mask, 759 
modified butterfly, 761 stationary, 756 stencil, 759 tensor 
product, 735 tessellation, 735 surfel, 573 surround, 285 
----------------------- Page 1412-----------------------
SVBRDF, 310 swap buffer, see buffer, swap swizzling, 1018 
synchronizationwith monitor,790, 1012,1013TAM, seetonal 
art map tangent frame, 209 map, 344 patch, 775 space, see 
under basis vector, 209, 729 TBN, 209 Team Fortress 2, 654, 
677, 678, 940 tearing, 1012 technical illustration, 651, 673 
temporalaliasing,seealiasing,temporalcoherence,866delay, 
1locality,791temporary register,36tensor productsurfaces, 
735terrain chunked LOD,874–877tessellation, 683–690,767 
–780, 853 adaptive, 770–775 control shader, 44 Index 1175 
domainshader,44evaluationshader,44factors,45fractional, 
768–770, 860 hullshader,44 levels,45 stage, 18,44–46, 677 
surface, 735 tessellator, 44 uniform, 767 tetrahedralization, 
489 texel, 169Texram, 189text, 675–677, 725 texture array, 
191atlas, 190bandwidth, 1006cache,seecachecoordinates, 
169cube map,190dependent read,38, 177,220,406 matrix, 
174n, 410 periodicity, 175 space, 169 volume, 189– 190 
volumetric,  646  texture  processing  cluster,  1031 
texture-space shading, 910 texturing, 23, 167–222 albedo 
color map,201alpha mapping,176,202–208, 551animation, 
200, 203 bindless, 192 border, 174 cellular, 199 charts, 485 
clamp, 174 clipmap, 867 compression, 192– 198, 486, 503 
ASTC, 196, 1029 BC, 192–193 DXTC, 192–193 EAC, 194 ETC, 
----------------------- Page 1413-----------------------
194–195, 1029lossy, 194normal, 195 PVRTC, 195–196S3TC, 
192corresponderfunction, 169,174–175decaling,202detail, 
180diffuse color map, 201 distortion, 687–688 image, 176– 
198 image size, 177 level of detail bias, 186 light mapping, 
484 magnification, 177, 178–181 bilinear interpolation, 178 
cubic convolution, 178 nearest neighbor, 178 minification, 
177, 182 – 189 anisotropic filtering, 187 – 188 bilinear 
interpolation, 182 Elliptical Weighted Average, 189 level of 
detail, 185 mipmapping, 183– 186 nearest neighbor, 182 
quadrilinear interpolation, 189 summed-area table, 186–188 
trilinear interpolation, 186 mipmapping, 485 mirror, 174 
mirror once, 175 noise, 198, 549 one-dimensional, 173 
parallax occlusion mapping, 167, 216–220 parameterization, 
485, 486 pipeline, 169–176 procedural, 198–200 projective, 
221,688projectorfunction, 169–174relief,216–220,222,565 
–566, 630, 646, 853, 854 repeat, 174 seams, 486 shells, 485 
sparse, 246, 263, 867–871 streaming, 870–871 subtexture, 
184 swizzling, 1018 texture coordinates, 169 tiling, 795 
transcoding, 870–871 value transform function, 169 vertex, 
43, 186virtual, 867–871 wrap, 174 TFAN, 712 That Dragon, 
Cancer, 121 thin-film interference, see light, interference, 
thin-filmthreaddivergence,32,260group,54,518shader,31 
----------------------- Page 1414-----------------------
thread-level parallelism, 1003 1176 IndexThreading Building 
Blocks,812 three plane intersection, see intersectiontesting, 
three planes three-dimensional printing, see 3D printing 
three.js, 41, 50, 189, 407, 485, 568, 628, 1048 thresholding, 
656 throughput, 30, 783, 808 tile, 995 local storage, 156 
screen, 1007, 1021 table, 1008 texture, 795 tiled caching, 
1033 deferred shading, 894, 896, 904, 914 forward shading, 
895 – 896, 903, 904, 914 rasterization, see pipeline, 
rasterization shading, 893–898 triangle traversal, 996 tiling, 
795 time-critical rendering, 865 timer query, 785 timewarp, 
935–937timing,955TIN,705,877Toksvig mapping,369Tom 
Clancy’s The Division, 478 Tomb Raider (2013), 114, 116 
Tomorrow Children, The, 496, 497 tonal art map, 671 tone 
mapping,283–289global, 285 local,285toon rendering,see 
shading,  toon  top-left  rule,  995  topology,  712 
Torrance-Sparrow model, 334 tracking, 916, 921 transaction 
elimination, 1028 transcoding, see under texturing transfer 
function, 161,478volume, 605transform, 57,seealso matrix 
affine, 58, 68 angle-preserving, 66 concatenation of, 65–66 
constraining, 73 decomposition, 73 – 74 Euler, 70 – 73 
extracting parameters, 72–73 gimbal lock, 73 feedback, 49 
inverse, 59, 61–64, 66, 69, 75 adjoint method, 69 Cramer’s 
----------------------- Page 1415-----------------------
rule, 69, 964 Gaussian elimination, 69 LU decomposition, 69 
length-preserving, 66 linear, 57– 58 mirror, see transform, 
reflectionmodel, 15–16morphtargets, 89–91 morphing,87– 
91 normal, 68 – 69 orthographic, see under projection 
perspective, see under projection quaternion, 80 reflection, 
63, 692, 832 rigid-body, 60, 66–67, 74, 84 rotation, 60–61 
aboutanarbitraryaxis,74–76from onevectorto another,83 
–84aroundapoint,61scaling,62–63anisotropic,62isotropic, 
62 nonuniform, 62 uniform, 62 shear, 63–64 translation, 59 
vertex blending, 84 – 87, 90, 102, 1006 view, 15 – 16 
volume-preserving, 64translation, 59transparency, 148–160 
order-independent, 154–159 screen-door, 149, 858 sorting, 
152, 823 stochastic, 149 weighted average, 156 – 158 
weighted sum, 157 transparency adaptive antialiasing, 207 
tree balanced, 820 binary, 820 k-ary tree, 820 trees (forest), 
202,559–560trianglefan,686,696–697formula,944,963list, 
696 indexed, 703 setup, 22, 997–998 sorting, 152–153,802– 
803 soup, 691 strip, 697–699 indexed, 703 sequential, 698 
traversal, 22, 996–997 tiled, 996 Index 1177 triangle/object 
intersection, see specific objects under intersection testing 
triangulated irregular network, 705, 877 triangulation, 683– 
686 Delaunay, 684 trilight, 432 trilinear interpolation, 186 
----------------------- Page 1416-----------------------
triple buffer,1013tristimulusvalues,273truecolormode,see 
color, mode, true color TSM, see shadow, map, trapezoidal 
turbulence, 198 T-vertex, see under polygon TXAA, 142 
Tyndall scattering, 298 UAV, see unordered access view 
ubershader, 128 UBO, 795 UMA, see unified memory 
architecture umbra, 224 Uncharted 2, 286, 357 Uncharted 3, 
879 Uncharted 4, 290, 356–359, 492 Uncharted: Drake’s 
Fortune, 893 under operator, 153 underclock, 787 unified 
memory architecture, 1007 unified shader architecture, 35, 
786uniformbufferobject,795uniformtessellation,767Unity 
engine, 128, 287, 476, 482, 489, 740, 930 unordered access 
view, 51–52,87, 155, 192,896, 1016Unreal Engine, 104, 113, 
114,116,126,128–130,143,287,325,364,383,493,495, 556, 
572, 611, 740, 899, 930, 1048 up direction, 70 upsampling, 
136 valence, 699, 758 Valgrind, 792 van Emde Boas layout, 
827–828 VAO, 703 variance mapping, 370 VDC, see video 
display controller vector irradiance, 379– 380, 389 vector 
norm,7Vega, see under hardwarevergence, 923, 932vertex 
array,seevertex, bufferarrayobject,703 blending,see under 
transform buffer, 701– 705, 793 cache, see cache, vertex 
clustering, 709 compression, 712–715 correspondence, 87 
pulling, 703 shader, 15–16,42–43 animation, 43 effects, 43 
----------------------- Page 1417-----------------------
skinning, 87 stream, 702 vertical refresh rate, 1011 vertical 
retrace, see retrace, vertical vertical synchronization, see 
synchronization with monitorvertices per second, 788 VGA, 
1011videodisplaycontroller,1011videographicsarray,1011 
video memory, 1006, 1011view frustum culling, see culling, 
viewfrustumviewspace,15,26viewtransform,seetransform, 
view view-independent progressive meshing, 706 VIPM, 706 
virtual point light, 491 virtual reality, 523, 912, 915– 940 
compositor, 924 optics, 921–922 visibility buffer, see buffer, 
visibility cone, 470, 471 function, 446 test, 843 visual 
appearance, 103 Vive, 915, 916, 917, 922, 925, 934 von 
Mises-Fisherdistribution, 397Von Neumann bottleneck, 791 
voxel, 578–586voxelization, 580–582,610–612,974VPL, see 
virtual pointlightVSM, see shadow, map,variance vsync, see 
synchronization with monitor VTune, 792 Vulkan, 40, 814 
Wang tiles, 175 Ward model, 314 warp, 31 watercolor, 652, 
665 watertight model, 693 watt, 268 wave electromagnetic, 
293 transverse, 293 wavefront, 31, 1035 1178 Index 
wavelength, 267, 293wavelets, 199WebGL, 41, 50, 122, 125, 
129,189,201,208,407,485, 568,628,631,713,796,805,829, 
1048 welding vertices, 691 white point, 274 Wii, see under 
hardware winding direction, 692 winding number, 968 
----------------------- Page 1418-----------------------
window coordinates,20wireframe, 674,675TheWitcher 3,2, 
263, 420, 526, 534, 873, 1049 world space, 15 wrap, see 
texturing, repeat wrap lighting, 382, 633 Xbox, see under 
hardwareXR,915Y’CbCr,892yaw,70nYCoCg, 197–198,804 
–805 yon, 93n z-buffer, see under buffer z-fighting, 1014 
z-prepass,803,881,882,901,1016z-pyramid,846Zaxxon, 17 
zmax-culling, seeculling,zmaxzmin-culling, seeculling,zmin 
zonal harmonics,401,428,430,470 